(()=>{var e,r,t=globalThis,n={},o={},i=t.parcelRequire5b70;null==i&&((i=function(e){if(e in n)return n[e].exports;if(e in o){var r=o[e];delete o[e];var t={id:e,exports:{}};return n[e]=t,r.call(t.exports,t,t.exports),t.exports}var i=Error("Cannot find module '"+e+"'");throw i.code="MODULE_NOT_FOUND",i}).register=function(e,r){o[e]=r},t.parcelRequire5b70=i),i.register,importScripts("./generateMeshBVH.worker.cd4b9fc6.js");var s=i("e06gU"),a=i("gbfhP"),u=i("2lzJi"),f=i("271LZ"),l=i("lxFhA"),p=i("6Y4FX"),c=i("i1Cyt");let g=!1,h=0;var d={},B={};B=function(e,r,t){if(r===self.location.origin)return e;var n=t?"import "+JSON.stringify(e)+";":"importScripts("+JSON.stringify(e)+");";return URL.createObjectURL(new Blob([n],{type:"application/javascript"}))};var w={};e=function(e){var r=w[e];return r||(r=function(){try{throw Error()}catch(r){var e=(""+r.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^)\n]+/g);if(e)return(""+e[2]).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/.+)\/[^/]+$/,"$1")+"/"}return"/"}(),w[e]=r),r},r=function(e){var r=(""+e).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^/]+/);if(!r)throw Error("Origin not found");return r[0]};let m=e("512E4")+"parallelMeshBVH.worker.22cf4bb0.js";d=B(m,r(m),!1);let b=new class{get workerCount(){return this.workers.length}constructor(e){this.workers=[],this._getWorker=e}setWorkerCount(e){let r=this.workers;for(;r.length<e;)r.push(this._getWorker());for(;r.length>e;)r.pop().terminate()}runSubTask(e,r,t){return new Promise((n,o)=>{let i=this.workers[e];if(i.isRunning)throw Error(`${this.name}: Worker ${e} is already running.`);i.isRunning=!0,i.postMessage(r),i.onerror=e=>{i.isRunning=!1,o(e)},i.onmessage=e=>{"progress"===e.data.type?t&&t(e.data.progress):(t&&t(1),i.isRunning=!1,n(e.data))}})}}(()=>new Worker(d));function k(e){let r=0;return function(t){e(t-r),r=t}}function y(e){e=Math.min(e,1);let r=performance.now();r-h>=10&&1!==e&&(postMessage({error:null,progress:e,type:"progress"}),h=r)}function E(e,r){let t=new s.BufferGeometry;return e&&(t.index=new s.BufferAttribute(e,1,!1)),t.setAttribute("position",new s.BufferAttribute(r,3)),t}onmessage=async({data:e})=>{if(g)throw Error("Worker is already running a task.");let{operation:r}=e;if("BUILD_BVH"===r){g=!0;let{maxWorkerCount:r,index:t,position:n,options:o}=e;b.setWorkerCount((0,s.MathUtils).floorPowerOfTwo(r));let i=E(t,n),l=o.indirect?(0,p.getFullGeometryRange)(i):(0,p.getRootIndexRanges)(i),h=o.indirect?(0,u.generateIndirectBuffer)(i,!0):null,d=(0,p.getTriCount)(i),B=new Float32Array(new SharedArrayBuffer(24*d)),w=[];for(let e=0,r=b.workerCount;e<r;e++){let o=Math.ceil(d/r),i=e*o,s=Math.min(o,d-i);w.push(b.runSubTask(e,{operation:"BUILD_TRIANGLE_BOUNDS",offset:i,count:s,index:t,position:n,triangleBounds:B}))}await Promise.all(w);let m={_indirectBuffer:h,geometry:i},T=0,x={...c.DEFAULT_OPTIONS,...o,verbose:!1,maxDepth:Math.round(Math.log2(b.workerCount)),onProgress:o.includedProgressCallback?k(e=>{y(T+=.1*e)}):null},_=[];for(let e=0,r=l.length;e<r;e++){let r=[],i=l[e],s=(0,u.buildTree)(m,B,i.offset,i.count,x),p=function(e){let r=[];return function e(t,n=0){t.depth=n,r.push(t),t.count||(e(t.left,n+1),e(t.right,n+1))}(e),r}(s),g=0,d=0,w=0;for(let e=0,i=p.length;e<i;e++){let i=p[e];if(i.count){let e={...c.DEFAULT_OPTIONS,...o};e.maxDepth=e.maxDepth-i.depth;let s=b.runSubTask(w++,{operation:"BUILD_SUBTREE",offset:i.offset,count:i.count,indirectBuffer:h,index:t,position:n,triangleBounds:B,options:e},k(e=>{y(T+=.9*e/w)})).then(e=>{let r=e.buffer;i.buffer=r,g+=r.byteLength});r.push(s)}else d++}await Promise.all(r);let E=new(o.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer)(g+d*a.BYTES_PER_NODE);(0,f.populateBuffer)(0,s,E),_.push(E)}postMessage({error:null,serialized:{roots:_,index:t,indirectBuffer:h},position:n,progress:1}),g=!1}else if("BUILD_SUBTREE"===r){let{offset:r,count:t,indirectBuffer:n,index:o,position:i,triangleBounds:s,options:l}=e,p={_indirectBuffer:n,geometry:E(o,i)},g={...c.DEFAULT_OPTIONS,...l,onProgress:l.includedProgressCallback?y:null},h=(0,u.buildTree)(p,s,r,t,g),d=(0,f.countNodes)(h),B=new ArrayBuffer(a.BYTES_PER_NODE*d);(0,f.populateBuffer)(0,h,B),postMessage({type:"result",buffer:B,progress:1},[B])}else if("BUILD_TRIANGLE_BOUNDS"===r){let{index:r,position:t,triangleBounds:n,offset:o,count:i}=e,s=E(r,t);(0,l.computeTriangleBounds)(s,n,o,i),postMessage({type:"result"})}}})();
//# sourceMappingURL=parallelMeshBVH.worker.22cf4bb0.js.map
