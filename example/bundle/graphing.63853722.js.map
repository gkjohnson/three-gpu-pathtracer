{"mappings":"IK4BI,EAAQ,EAAO,EAAU,EACzB,EAEA,EAAQ,E,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,e,I,G,I,E,E,QJ7BL,OAAM,UAAqB,EAAA,cAAa,CAE9C,IAAI,YAAa,CAAC,CAAG,CAEpB,KAAK,CAAC,YAAc,CAAA,EACpB,IAAI,CAAC,aAAa,CAAE,CAEnB,KAAM,eAEP,EAED,CAEA,YAAa,CAAM,CAAG,CAIrB,IAAM,IAAM,KAFZ,KAAK,CAAE,GAEY,IAAI,CAAC,QAAQ,CAE/B,OAAO,cAAc,CAAE,IAAI,CAAE,EAAK,CAEjC,MAEC,OAAO,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,KAAK,AAElC,EAEA,IAAK,CAAC,EAEL,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,KAAK,CAAG,CAE9B,CAED,EAIF,CAGA,UAAW,CAAI,CAAE,CAAiB,CAAG,CAEpC,GAAK,MAAA,EAEJ,CAAA,GAAK,KAAQ,IAAI,CAAC,OAAO,CAIxB,OAFA,OAAO,IAAI,CAAC,OAAO,CAAE,EAAM,CAC3B,IAAI,CAAC,WAAW,CAAG,CAAA,EACZ,CAAA,CAER,MAIA,GAAK,IAAI,CAAC,OAAO,CAAE,EAAM,GAAK,EAI7B,OAFA,IAAI,CAAC,OAAO,CAAE,EAAM,CAAG,EACvB,IAAI,CAAC,WAAW,CAAG,CAAA,EACZ,CAAA,EAMT,MAAO,CAAA,CAER,CAED,C,G,E,Q,S,C,C,C,E,E,E,O,C,gB,I,GCtEO,IAAM,EAA0B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqGxC,C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","sources":["<anon>","src/materials/MaterialBase.js","src/shader/bsdf/ggx_functions.glsl.js","src/shader/common/math_functions.glsl.js","src/shader/common/util_functions.glsl.js","example/graphing.js","src/materials/debug/GraphMaterial.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5b70\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5b70\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"9fZ6X\", function(module, exports) {\n\n$parcel$export(module.exports, \"MaterialBase\", () => $6bd4eb2914ee2835$export$f1ac3a587b6cbb5d);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $6bd4eb2914ee2835$export$f1ac3a587b6cbb5d extends (0, $ilwiq.ShaderMaterial) {\n    set needsUpdate(v) {\n        super.needsUpdate = true;\n        this.dispatchEvent({\n            type: \"recompilation\"\n        });\n    }\n    constructor(shader){\n        super(shader);\n        for(const key in this.uniforms)Object.defineProperty(this, key, {\n            get () {\n                return this.uniforms[key].value;\n            },\n            set (v) {\n                this.uniforms[key].value = v;\n            }\n        });\n    }\n    // sets the given named define value and sets \"needsUpdate\" to true if it's different\n    setDefine(name, value) {\n        if (value === undefined || value === null) {\n            if (name in this.defines) {\n                delete this.defines[name];\n                this.needsUpdate = true;\n                return true;\n            }\n        } else if (this.defines[name] !== value) {\n            this.defines[name] = value;\n            this.needsUpdate = true;\n            return true;\n        }\n        return false;\n    }\n}\n\n});\n\nparcelRegister(\"8keuf\", function(module, exports) {\n\n$parcel$export(module.exports, \"ggx_functions\", () => $60fb6dc3c6495c33$export$4c711108e2e8ef5e);\nconst $60fb6dc3c6495c33$export$4c711108e2e8ef5e = /* glsl */ `\n\n\t// The GGX functions provide sampling and distribution information for normals as output so\n\t// in order to get probability of scatter direction the half vector must be computed and provided.\n\t// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\t// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n\t// [2] http://jcgt.org/published/0007/04/01/\n\t// [4] http://jcgt.org/published/0003/02/03/\n\n\t// trowbridge-reitz === GGX === GTR\n\n\tvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\n\n\t\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t\t// function below, as well\n\n\t\t// Implementation from reference [1]\n\t\t// stretch view\n\t\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\n\n\t\t// orthonormal basis\n\t\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\n\t\tvec3 T2 = cross( T1, V );\n\n\t\t// sample point with polar coordinates (r, phi)\n\t\tfloat a = 1.0 / ( 1.0 + V.z );\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\n\t\tfloat P1 = r * cos( phi );\n\t\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\n\n\t\t// compute normal\n\t\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\n\n\t\t// unstretch\n\t\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\n\n\t\treturn N;\n\n\t}\n\n\t// Below are PDF and related functions for use in a Monte Carlo path tracer\n\t// as specified in Appendix B of the following paper\n\t// See equation (34) from reference [0]\n\tfloat ggxLamda( float theta, float roughness ) {\n\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = tanTheta * tanTheta;\n\t\tfloat alpha2 = roughness * roughness;\n\n\t\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\n\t\treturn numerator / 2.0;\n\n\t}\n\n\t// See equation (34) from reference [0]\n\tfloat ggxShadowMaskG1( float theta, float roughness ) {\n\n\t\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n\t}\n\n\t// See equation (125) from reference [4]\n\tfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat scatterTheta = acos( wo.z );\n\t\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n\t}\n\n\t// See equation (33) from reference [0]\n\tfloat ggxDistribution( vec3 halfVector, float roughness ) {\n\n\t\tfloat a2 = roughness * roughness;\n\t\ta2 = max( EPSILON, a2 );\n\t\tfloat cosTheta = halfVector.z;\n\t\tfloat cosTheta4 = pow( cosTheta, 4.0 );\n\n\t\tif ( cosTheta == 0.0 ) return 0.0;\n\n\t\tfloat theta = acosSafe( halfVector.z );\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = pow( tanTheta, 2.0 );\n\n\t\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\n\t\treturn ( a2 / denom );\n\n\t}\n\n\t// See equation (3) from reference [2]\n\tfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat D = ggxDistribution( halfVector, roughness );\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\t\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\n\n\t}\n\n`;\n\n});\n\nparcelRegister(\"fYvb1\", function(module, exports) {\n\n$parcel$export(module.exports, \"math_functions\", () => $ba14a4aaa0cde19b$export$98323a006d35be35);\nconst $ba14a4aaa0cde19b$export$98323a006d35be35 = /* glsl */ `\n\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\n\t// For more information see: https://github.com/gkjohnson/three-gpu-pathtracer/pull/171#issuecomment-1152275248\n\tfloat acosApprox( float x ) {\n\n\t\tx = clamp( x, -1.0, 1.0 );\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\n\n\t}\n\n\t// An acos with input values bound to the range [-1, 1].\n\tfloat acosSafe( float x ) {\n\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\n\n\t}\n\n\tfloat saturateCos( float val ) {\n\n\t\treturn clamp( val, 0.001, 1.0 );\n\n\t}\n\n\tfloat square( float t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 square( vec2 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec3 square( vec3 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec4 square( vec4 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 rotateVector( vec2 v, float t ) {\n\n\t\tfloat ac = cos( t );\n\t\tfloat as = sin( t );\n\t\treturn vec2(\n\t\t\tv.x * ac - v.y * as,\n\t\t\tv.x * as + v.y * ac\n\t\t);\n\n\t}\n\n\t// forms a basis with the normal vector as Z\n\tmat3 getBasisFromNormal( vec3 normal ) {\n\n\t\tvec3 other;\n\t\tif ( abs( normal.x ) > 0.5 ) {\n\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\n\n\t\t} else {\n\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\n\n\t\t}\n\n\t\tvec3 ortho = normalize( cross( normal, other ) );\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\n\t\treturn mat3( ortho2, ortho, normal );\n\n\t}\n\n`;\n\n});\n\nparcelRegister(\"dUUQZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"util_functions\", () => $a21c9b4177584031$export$fe1d788deccfbee3);\nconst $a21c9b4177584031$export$fe1d788deccfbee3 = /* glsl */ `\n\n\t// TODO: possibly this should be renamed something related to material or path tracing logic\n\n\t#ifndef RAY_OFFSET\n\t#define RAY_OFFSET 1e-4\n\t#endif\n\n\t// adjust the hit point by the surface normal by a factor of some offset and the\n\t// maximum component-wise value of the current point to accommodate floating point\n\t// error as values increase.\n\tvec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {\n\n\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\tvec3 absPoint = abs( point );\n\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\treturn point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;\n\n\t}\n\n\t// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\n\tvec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {\n\n\t\tvec3 ot = - log( attColor ) / attDist;\n\t\treturn exp( - ot * dist );\n\n\t}\n\n\tvec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {\n\n\t\t// get the half vector - assuming if the light incident vector is on the other side\n\t\t// of the that it's transmissive.\n\t\tvec3 h;\n\t\tif ( wi.z > 0.0 ) {\n\n\t\t\th = normalize( wi + wo );\n\n\t\t} else {\n\n\t\t\t// Scale by the ior ratio to retrieve the appropriate half vector\n\t\t\t// From Section 2.2 on computing the transmission half vector:\n\t\t\t// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\n\t\t\th = normalize( wi + wo * eta );\n\n\t\t}\n\n\t\th *= sign( h.z );\n\t\treturn h;\n\n\t}\n\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\n\n\t\treturn normalize( a + b );\n\n\t}\n\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\n\t// we find a ray like that we ignore it to avoid artifacts.\n\t// This function returns if the direction is on the same side of both planes.\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\n\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\n\n\t}\n\n\t// ray sampling x and z are swapped to align with expected background view\n\tvec2 equirectDirectionToUv( vec3 direction ) {\n\n\t\t// from Spherical.setFromCartesianCoords\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\n\t\tuv /= vec2( 2.0 * PI, PI );\n\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\n\t\tuv.x += 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\t\treturn uv;\n\n\t}\n\n\tvec3 equirectUvToDirection( vec2 uv ) {\n\n\t\t// undo above adjustments\n\t\tuv.x -= 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\n\t\t// from Vector3.setFromSphericalCoords\n\t\tfloat theta = uv.x * 2.0 * PI;\n\t\tfloat phi = uv.y * PI;\n\n\t\tfloat sinPhi = sin( phi );\n\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\n\n\t}\n\n\t// power heuristic for multiple importance sampling\n\tfloat misHeuristic( float a, float b ) {\n\n\t\tfloat aa = a * a;\n\t\tfloat bb = b * b;\n\t\treturn aa / ( aa + bb );\n\n\t}\n\n\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\n\t// erichlof/THREE.js-PathTracing-Renderer/\n\tfloat tentFilter( float x ) {\n\n\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\n\n\t}\n`;\n\n});\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $jiuw3 = parcelRequire(\"jiuw3\");\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $9fZ6X = parcelRequire(\"9fZ6X\");\nclass $162adcf1224d60ef$export$8af0c82d10044f6a extends (0, $9fZ6X.MaterialBase) {\n    get graphFunctionSnippet() {\n        return this._graphFunctionSnippet;\n    }\n    set graphFunctionSnippet(v) {\n        this._graphFunctionSnippet = v;\n    }\n    constructor(parameters){\n        super({\n            blending: (0, $ilwiq.NoBlending),\n            transparent: false,\n            depthWrite: false,\n            depthTest: false,\n            defines: {\n                USE_SLIDER: 0\n            },\n            uniforms: {\n                dim: {\n                    value: true\n                },\n                thickness: {\n                    value: 1\n                },\n                graphCount: {\n                    value: 4\n                },\n                graphDisplay: {\n                    value: new (0, $ilwiq.Vector4)(1.0, 1.0, 1.0, 1.0)\n                },\n                overlay: {\n                    value: true\n                },\n                xRange: {\n                    value: new (0, $ilwiq.Vector2)(-2, 2.0)\n                },\n                yRange: {\n                    value: new (0, $ilwiq.Vector2)(-2, 2.0)\n                },\n                colors: {\n                    value: [\n                        new (0, $ilwiq.Color)(0xe91e63).convertSRGBToLinear(),\n                        new (0, $ilwiq.Color)(0x4caf50).convertSRGBToLinear(),\n                        new (0, $ilwiq.Color)(0x03a9f4).convertSRGBToLinear(),\n                        new (0, $ilwiq.Color)(0xffc107).convertSRGBToLinear()\n                    ]\n                }\n            },\n            vertexShader: /* glsl */ `\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n            fragmentShader: /* glsl */ `\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform bool overlay;\n\t\t\t\tuniform bool dim;\n\t\t\t\tuniform bvec4 graphDisplay;\n\t\t\t\tuniform float graphCount;\n\t\t\t\tuniform float thickness;\n\t\t\t\tuniform vec2 xRange;\n\t\t\t\tuniform vec2 yRange;\n\t\t\t\tuniform vec3 colors[ 4 ];\n\n\t\t\t\t__FUNCTION_CONTENT__\n\n\t\t\t\tfloat map( float _min, float _max, float v ) {\n\n\t\t\t\t\tfloat len = _max - _min;\n\t\t\t\t\treturn _min + len * v;\n\n\t\t\t\t}\n\n\t\t\t\tvec3 getBackground( vec2 point, float steepness ) {\n\n\t\t\t\t\tvec2 pw = fwidth( point );\n\t\t\t\t\tvec2 halfWidth = pw * 0.5;\n\n\t\t\t\t\t// x, y axes\n\t\t\t\t\tvec2 distToZero = smoothstep(\n\t\t\t\t\t\t- halfWidth * 0.5,\n\t\t\t\t\t\thalfWidth * 0.5,\n\t\t\t\t\t\tabs( point.xy ) - pw\n\t\t\t\t\t);\n\n\t\t\t\t\t// 1 unit markers\n\t\t\t\t\tvec2 temp;\n\t\t\t\t\tvec2 modAxis = abs( modf( point + vec2( 0.5 ), temp ) ) - 0.5;\n\t\t\t\t\tvec2 distToAxis = smoothstep(\n\t\t\t\t\t\t- halfWidth,\n\t\t\t\t\t\thalfWidth,\n\t\t\t\t\t\tabs( modAxis.xy ) - pw * 0.5\n\t\t\t\t\t);\n\n\t\t\t\t\t// if we're at a chart boundary then remove the artifacts\n\t\t\t\t\tif ( abs( pw.y ) > steepness * 0.5 ) {\n\n\t\t\t\t\t\tdistToZero.y = 1.0;\n\t\t\t\t\t\tdistToAxis.y = 1.0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// mix colors into a background color\n\t\t\t\t\tfloat axisIntensity = 1.0 - min( distToZero.x, distToZero.y );\n\t\t\t\t\tfloat markerIntensity = 1.0 - min( distToAxis.x, distToAxis.y );\n\n\t\t\t\t\tvec3 markerColor = mix( vec3( 0.005 ), vec3( 0.05 ), markerIntensity );\n\t\t\t\t\tvec3 backgroundColor = mix( markerColor, vec3( 0.2 ), axisIntensity );\n\t\t\t\t\treturn backgroundColor;\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// from uniforms\n\t\t\t\t\tfloat sectionCount = overlay ? 1.0 : graphCount;\n\t\t\t\t\tfloat yWidth = abs( yRange.y - yRange.x );\n\n\t\t\t\t\t// separate into sections\n\t\t\t\t\tfloat _section;\n\t\t\t\t\tfloat sectionY = modf( sectionCount * vUv.y, _section );\n\t\t\t\t\tint section = int( sectionCount - _section - 1.0 );\n\n\t\t\t\t\t// get the current point\n\t\t\t\t\tvec2 point = vec2(\n\t\t\t\t\t\tmap( xRange.x, xRange.y, vUv.x ),\n\t\t\t\t\t\tmap( yRange.x, yRange.y, sectionY )\n\t\t\t\t\t);\n\n\t\t\t\t\t// get the results\n\t\t\t\t\tvec4 result = graphFunction( point.x );\n\t\t\t\t\tvec4 delta = result - vec4( point.y );\n\t\t\t\t\tvec4 halfDdf = fwidth( delta ) * 0.5;\n\t\t\t\t\tif ( fwidth( point.y ) > yWidth * 0.5 ) {\n\n\t\t\t\t\t\thalfDdf = vec4( 0.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// graph display intensity\n\t\t\t\t\tvec4 graph = smoothstep( - halfDdf, halfDdf, abs( delta ) - thickness * halfDdf );\n\n\t\t\t\t\t// initialize the background\n\t\t\t\t\tgl_FragColor.rgb = getBackground( point, yWidth );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\tif ( dim && ( point.x < 0.0 || point.y < 0.0 ) ) {\n\n\t\t\t\t\t\tgraph = mix(\n\t\t\t\t\t\t\tvec4( 1.0 ),\n\t\t\t\t\t\t\tgraph,\n\t\t\t\t\t\t\t0.05\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// color the charts\n\t\t\t\t\tif ( sectionCount > 1.0 ) {\n\n\t\t\t\t\t\tif ( graphDisplay[ section ] ) {\n\n\t\t\t\t\t\t\tgl_FragColor.rgb = mix(\n\t\t\t\t\t\t\t\tcolors[ section ],\n\t\t\t\t\t\t\t\tgl_FragColor.rgb,\n\t\t\t\t\t\t\t\tgraph[ section ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( int i = 0; i < int( graphCount ); i ++ ) {\n\n\t\t\t\t\t\t\tif ( graphDisplay[ i ] ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb = mix(\n\t\t\t\t\t\t\t\t\tcolors[ i ],\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb,\n\t\t\t\t\t\t\t\t\tgraph[ i ]\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t#include <colorspace_fragment>\n\n\t\t\t\t}\n\n\t\t\t`\n        });\n        this._graphFunctionSnippet = /* glsl */ `\n\t\t\tvec4 graphFunctionSnippet( float x ) {\n\n\t\t\t\treturn vec4(\n\t\t\t\t\tsin( x * 3.1415926535 ),\n\t\t\t\t\tcos( x ),\n\t\t\t\t\t0.0,\n\t\t\t\t\t0.0\n\t\t\t\t);\n\n\t\t\t}\n\t\t`;\n        this.setValues(parameters);\n    }\n    onBeforeCompile(shader) {\n        shader.fragmentShader = shader.fragmentShader.replace(\"__FUNCTION_CONTENT__\", this._graphFunctionSnippet);\n        return shader;\n    }\n    customProgramCacheKey() {\n        return this._graphFunctionSnippet;\n    }\n}\n\n\n\nvar $8keuf = parcelRequire(\"8keuf\");\n\nvar $fYvb1 = parcelRequire(\"fYvb1\");\nvar $dUUQZ = parcelRequire(\"dUUQZ\");\nconst $7f018191b657fea8$var$graphFunctionSnippet = /* glsl */ `\n\t#include <common>\n\t${$fYvb1.math_functions}\n\t${$dUUQZ.util_functions}\n\t${$8keuf.ggx_functions}\n\n\tvec4 graphFunction( float x ) {\n\n\t\tvec3 wi = normalize( vec3( 1.0, 1.0, 1.0 ) );\n\t\tvec3 halfVec = vec3( 0.0, 0.0, 1.0 );\n\t\tfloat theta = dot( wi, halfVec );\n\n\t\treturn vec4(\n\t\t\tggxPDF( wi, halfVec, x ),\n\t\t\tggxDistribution( halfVec, x ),\n\t\t\tggxShadowMaskG1( theta, x ),\n\t\t\tggxLamda( theta, x )\n\t\t);\n\n\t}\n`;\nlet $7f018191b657fea8$var$camera, $7f018191b657fea8$var$scene, $7f018191b657fea8$var$renderer, $7f018191b657fea8$var$plane;\nlet $7f018191b657fea8$var$cameraCenter;\nlet $7f018191b657fea8$var$zoom = 10;\nlet $7f018191b657fea8$var$dataEl, $7f018191b657fea8$var$dataContainerEl;\nconst $7f018191b657fea8$var$params = {\n    aspect: 1,\n    displayX: true,\n    displayY: true,\n    displayZ: true,\n    displayW: true,\n    reset () {\n        $7f018191b657fea8$var$zoom = 10;\n        $7f018191b657fea8$var$cameraCenter.set(-$7f018191b657fea8$var$zoom * 0.5 + $7f018191b657fea8$var$zoom * 0.05, $7f018191b657fea8$var$getAspect() * $7f018191b657fea8$var$zoom * 0.5 - $7f018191b657fea8$var$zoom * 0.05);\n    }\n};\n$7f018191b657fea8$var$init();\n// init\nasync function $7f018191b657fea8$var$init() {\n    $7f018191b657fea8$var$dataContainerEl = document.getElementById(\"dataContainer\");\n    $7f018191b657fea8$var$dataEl = document.getElementById(\"data\");\n    // renderer init\n    $7f018191b657fea8$var$renderer = new $ilwiq.WebGLRenderer({\n        antialias: true\n    });\n    $7f018191b657fea8$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    $7f018191b657fea8$var$renderer.setClearColor(0x11161C);\n    $7f018191b657fea8$var$renderer.setPixelRatio(window.devicePixelRatio);\n    $7f018191b657fea8$var$renderer.setAnimationLoop($7f018191b657fea8$var$animation);\n    document.body.appendChild($7f018191b657fea8$var$renderer.domElement);\n    // init camera\n    $7f018191b657fea8$var$camera = new $ilwiq.OrthographicCamera();\n    $7f018191b657fea8$var$camera.position.set(0, 0, 1.5);\n    $7f018191b657fea8$var$scene = new $ilwiq.Scene();\n    $7f018191b657fea8$var$cameraCenter = new $ilwiq.Vector2();\n    // image plane\n    $7f018191b657fea8$var$plane = new $ilwiq.Mesh(new $ilwiq.PlaneGeometry(), new (0, $162adcf1224d60ef$export$8af0c82d10044f6a)({\n        side: $ilwiq.DoubleSide,\n        thickness: 1,\n        graphFunctionSnippet: $7f018191b657fea8$var$graphFunctionSnippet\n    }));\n    $7f018191b657fea8$var$plane.scale.setScalar(2.0);\n    $7f018191b657fea8$var$scene.add($7f018191b657fea8$var$plane);\n    $7f018191b657fea8$var$cameraCenter.set(-$7f018191b657fea8$var$zoom * 0.5 + $7f018191b657fea8$var$zoom * 0.05, $7f018191b657fea8$var$getAspect() * $7f018191b657fea8$var$zoom * 0.5 - $7f018191b657fea8$var$zoom * 0.05);\n    const gui = new (0, $jiuw3.default)();\n    gui.add($7f018191b657fea8$var$plane.material, \"dim\");\n    gui.add($7f018191b657fea8$var$plane.material, \"thickness\", 0.5, 10.0);\n    gui.add($7f018191b657fea8$var$params, \"aspect\", 0.1, 2);\n    gui.add($7f018191b657fea8$var$params, \"reset\");\n    const graphFolder = gui.addFolder(\"graphs\");\n    graphFolder.add($7f018191b657fea8$var$params, \"displayX\").name(\"display graph 1\");\n    graphFolder.add($7f018191b657fea8$var$params, \"displayY\").name(\"display graph 2\");\n    graphFolder.add($7f018191b657fea8$var$params, \"displayZ\").name(\"display graph 3\");\n    graphFolder.add($7f018191b657fea8$var$params, \"displayW\").name(\"display graph 4\");\n    let clicked = false;\n    let prevX = -1;\n    let prevY = -1;\n    $7f018191b657fea8$var$renderer.domElement.addEventListener(\"pointerleave\", ()=>{\n        $7f018191b657fea8$var$dataContainerEl.style.visibility = \"hidden\";\n    });\n    $7f018191b657fea8$var$renderer.domElement.addEventListener(\"pointerenter\", ()=>{\n        $7f018191b657fea8$var$dataContainerEl.style.visibility = \"visible\";\n    });\n    $7f018191b657fea8$var$renderer.domElement.addEventListener(\"pointerdown\", (e)=>{\n        clicked = true;\n        prevX = e.clientX;\n        prevY = e.clientY;\n    });\n    $7f018191b657fea8$var$renderer.domElement.addEventListener(\"pointermove\", (e)=>{\n        clicked = clicked && Boolean(e.buttons & 1);\n        if (clicked) {\n            const deltaX = e.clientX - prevX;\n            const deltaY = e.clientY - prevY;\n            prevX = e.clientX;\n            prevY = e.clientY;\n            const xWidth = 1;\n            const yWidth = $7f018191b657fea8$var$getAspect();\n            const graphDeltaX = $7f018191b657fea8$var$zoom * xWidth * deltaX / window.innerWidth;\n            const graphDeltaY = $7f018191b657fea8$var$zoom * yWidth * deltaY / window.innerHeight;\n            $7f018191b657fea8$var$cameraCenter.x += graphDeltaX;\n            $7f018191b657fea8$var$cameraCenter.y += graphDeltaY;\n        }\n        $7f018191b657fea8$var$dataContainerEl.style.left = `${e.clientX}px`;\n        $7f018191b657fea8$var$dataContainerEl.style.top = `${e.clientY}px`;\n        const data = $7f018191b657fea8$var$mouseToGraphValue(e.clientX, e.clientY);\n        $7f018191b657fea8$var$dataEl.innerText = `x: ${data.x.toFixed(3)}\\ny: ${data.y.toFixed(3)}`;\n    });\n    $7f018191b657fea8$var$renderer.domElement.addEventListener(\"wheel\", (e)=>{\n        const mouseX = e.clientX;\n        const mouseY = e.clientY;\n        const xWidth = 1;\n        const yWidth = $7f018191b657fea8$var$getAspect();\n        const centerRelX = mouseX / window.innerWidth - 0.5;\n        const centerRelY = mouseY / window.innerHeight - 0.5;\n        const graphX = $7f018191b657fea8$var$zoom * xWidth * centerRelX;\n        const graphY = $7f018191b657fea8$var$zoom * yWidth * centerRelY;\n        const beforeZoom = $7f018191b657fea8$var$zoom;\n        const delta = Math.pow(0.95, 1.0);\n        if (e.deltaY < 0) $7f018191b657fea8$var$zoom *= delta;\n        else $7f018191b657fea8$var$zoom /= delta;\n        $7f018191b657fea8$var$zoom = Math.max($7f018191b657fea8$var$zoom, 0.1);\n        $7f018191b657fea8$var$zoom = Math.min($7f018191b657fea8$var$zoom, 100);\n        const afterX = graphX * $7f018191b657fea8$var$zoom / beforeZoom;\n        const afterY = graphY * $7f018191b657fea8$var$zoom / beforeZoom;\n        $7f018191b657fea8$var$cameraCenter.x -= graphX - afterX;\n        $7f018191b657fea8$var$cameraCenter.y -= graphY - afterY;\n    });\n    window.addEventListener(\"resize\", ()=>{\n        $7f018191b657fea8$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    });\n}\n// animation\nfunction $7f018191b657fea8$var$animation() {\n    const mat = $7f018191b657fea8$var$plane.material;\n    const xWidth = 1;\n    const yWidth = $7f018191b657fea8$var$getAspect();\n    mat.xRange.set(-$7f018191b657fea8$var$cameraCenter.x - 0.5 * xWidth * $7f018191b657fea8$var$zoom, -$7f018191b657fea8$var$cameraCenter.x + 0.5 * xWidth * $7f018191b657fea8$var$zoom);\n    mat.yRange.set($7f018191b657fea8$var$cameraCenter.y - 0.5 * yWidth * $7f018191b657fea8$var$zoom, $7f018191b657fea8$var$cameraCenter.y + 0.5 * yWidth * $7f018191b657fea8$var$zoom);\n    mat.graphDisplay.set(Number($7f018191b657fea8$var$params.displayX), Number($7f018191b657fea8$var$params.displayY), Number($7f018191b657fea8$var$params.displayZ), Number($7f018191b657fea8$var$params.displayW));\n    $7f018191b657fea8$var$renderer.render($7f018191b657fea8$var$scene, $7f018191b657fea8$var$camera);\n}\nfunction $7f018191b657fea8$var$getAspect() {\n    return $7f018191b657fea8$var$params.aspect * window.innerHeight / window.innerWidth;\n}\nfunction $7f018191b657fea8$var$mouseToGraphValue(x, y) {\n    const xWidth = 1;\n    const yWidth = $7f018191b657fea8$var$getAspect();\n    const centerRelX = x / window.innerWidth - 0.5;\n    const centerRelY = y / window.innerHeight - 0.5;\n    const graphX = $7f018191b657fea8$var$zoom * xWidth * centerRelX - $7f018191b657fea8$var$cameraCenter.x;\n    const graphY = $7f018191b657fea8$var$zoom * yWidth * centerRelY - $7f018191b657fea8$var$cameraCenter.y;\n    return {\n        x: graphX,\n        y: -graphY\n    };\n}\n\n\n//# sourceMappingURL=graphing.63853722.js.map\n","import { ShaderMaterial } from 'three';\n\nexport class MaterialBase extends ShaderMaterial {\n\n\tset needsUpdate( v ) {\n\n\t\tsuper.needsUpdate = true;\n\t\tthis.dispatchEvent( {\n\n\t\t\ttype: 'recompilation',\n\n\t\t} );\n\n\t}\n\n\tconstructor( shader ) {\n\n\t\tsuper( shader );\n\n\t\tfor ( const key in this.uniforms ) {\n\n\t\t\tObject.defineProperty( this, key, {\n\n\t\t\t\tget() {\n\n\t\t\t\t\treturn this.uniforms[ key ].value;\n\n\t\t\t\t},\n\n\t\t\t\tset( v ) {\n\n\t\t\t\t\tthis.uniforms[ key ].value = v;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// sets the given named define value and sets \"needsUpdate\" to true if it's different\n\tsetDefine( name, value = undefined ) {\n\n\t\tif ( value === undefined || value === null ) {\n\n\t\t\tif ( name in this.defines ) {\n\n\t\t\t\tdelete this.defines[ name ];\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.defines[ name ] !== value ) {\n\n\t\t\t\tthis.defines[ name ] = value;\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n}\n","export const ggx_functions = /* glsl */`\n\n\t// The GGX functions provide sampling and distribution information for normals as output so\n\t// in order to get probability of scatter direction the half vector must be computed and provided.\n\t// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\t// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n\t// [2] http://jcgt.org/published/0007/04/01/\n\t// [4] http://jcgt.org/published/0003/02/03/\n\n\t// trowbridge-reitz === GGX === GTR\n\n\tvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\n\n\t\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t\t// function below, as well\n\n\t\t// Implementation from reference [1]\n\t\t// stretch view\n\t\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\n\n\t\t// orthonormal basis\n\t\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\n\t\tvec3 T2 = cross( T1, V );\n\n\t\t// sample point with polar coordinates (r, phi)\n\t\tfloat a = 1.0 / ( 1.0 + V.z );\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\n\t\tfloat P1 = r * cos( phi );\n\t\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\n\n\t\t// compute normal\n\t\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\n\n\t\t// unstretch\n\t\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\n\n\t\treturn N;\n\n\t}\n\n\t// Below are PDF and related functions for use in a Monte Carlo path tracer\n\t// as specified in Appendix B of the following paper\n\t// See equation (34) from reference [0]\n\tfloat ggxLamda( float theta, float roughness ) {\n\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = tanTheta * tanTheta;\n\t\tfloat alpha2 = roughness * roughness;\n\n\t\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\n\t\treturn numerator / 2.0;\n\n\t}\n\n\t// See equation (34) from reference [0]\n\tfloat ggxShadowMaskG1( float theta, float roughness ) {\n\n\t\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n\t}\n\n\t// See equation (125) from reference [4]\n\tfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat scatterTheta = acos( wo.z );\n\t\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n\t}\n\n\t// See equation (33) from reference [0]\n\tfloat ggxDistribution( vec3 halfVector, float roughness ) {\n\n\t\tfloat a2 = roughness * roughness;\n\t\ta2 = max( EPSILON, a2 );\n\t\tfloat cosTheta = halfVector.z;\n\t\tfloat cosTheta4 = pow( cosTheta, 4.0 );\n\n\t\tif ( cosTheta == 0.0 ) return 0.0;\n\n\t\tfloat theta = acosSafe( halfVector.z );\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = pow( tanTheta, 2.0 );\n\n\t\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\n\t\treturn ( a2 / denom );\n\n\t}\n\n\t// See equation (3) from reference [2]\n\tfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat D = ggxDistribution( halfVector, roughness );\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\t\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\n\n\t}\n\n`;\n","export const math_functions = /* glsl */`\n\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\n\t// For more information see: https://github.com/gkjohnson/three-gpu-pathtracer/pull/171#issuecomment-1152275248\n\tfloat acosApprox( float x ) {\n\n\t\tx = clamp( x, -1.0, 1.0 );\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\n\n\t}\n\n\t// An acos with input values bound to the range [-1, 1].\n\tfloat acosSafe( float x ) {\n\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\n\n\t}\n\n\tfloat saturateCos( float val ) {\n\n\t\treturn clamp( val, 0.001, 1.0 );\n\n\t}\n\n\tfloat square( float t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 square( vec2 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec3 square( vec3 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec4 square( vec4 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 rotateVector( vec2 v, float t ) {\n\n\t\tfloat ac = cos( t );\n\t\tfloat as = sin( t );\n\t\treturn vec2(\n\t\t\tv.x * ac - v.y * as,\n\t\t\tv.x * as + v.y * ac\n\t\t);\n\n\t}\n\n\t// forms a basis with the normal vector as Z\n\tmat3 getBasisFromNormal( vec3 normal ) {\n\n\t\tvec3 other;\n\t\tif ( abs( normal.x ) > 0.5 ) {\n\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\n\n\t\t} else {\n\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\n\n\t\t}\n\n\t\tvec3 ortho = normalize( cross( normal, other ) );\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\n\t\treturn mat3( ortho2, ortho, normal );\n\n\t}\n\n`;\n","export const util_functions = /* glsl */`\n\n\t// TODO: possibly this should be renamed something related to material or path tracing logic\n\n\t#ifndef RAY_OFFSET\n\t#define RAY_OFFSET 1e-4\n\t#endif\n\n\t// adjust the hit point by the surface normal by a factor of some offset and the\n\t// maximum component-wise value of the current point to accommodate floating point\n\t// error as values increase.\n\tvec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {\n\n\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\tvec3 absPoint = abs( point );\n\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\treturn point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;\n\n\t}\n\n\t// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\n\tvec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {\n\n\t\tvec3 ot = - log( attColor ) / attDist;\n\t\treturn exp( - ot * dist );\n\n\t}\n\n\tvec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {\n\n\t\t// get the half vector - assuming if the light incident vector is on the other side\n\t\t// of the that it's transmissive.\n\t\tvec3 h;\n\t\tif ( wi.z > 0.0 ) {\n\n\t\t\th = normalize( wi + wo );\n\n\t\t} else {\n\n\t\t\t// Scale by the ior ratio to retrieve the appropriate half vector\n\t\t\t// From Section 2.2 on computing the transmission half vector:\n\t\t\t// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\n\t\t\th = normalize( wi + wo * eta );\n\n\t\t}\n\n\t\th *= sign( h.z );\n\t\treturn h;\n\n\t}\n\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\n\n\t\treturn normalize( a + b );\n\n\t}\n\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\n\t// we find a ray like that we ignore it to avoid artifacts.\n\t// This function returns if the direction is on the same side of both planes.\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\n\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\n\n\t}\n\n\t// ray sampling x and z are swapped to align with expected background view\n\tvec2 equirectDirectionToUv( vec3 direction ) {\n\n\t\t// from Spherical.setFromCartesianCoords\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\n\t\tuv /= vec2( 2.0 * PI, PI );\n\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\n\t\tuv.x += 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\t\treturn uv;\n\n\t}\n\n\tvec3 equirectUvToDirection( vec2 uv ) {\n\n\t\t// undo above adjustments\n\t\tuv.x -= 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\n\t\t// from Vector3.setFromSphericalCoords\n\t\tfloat theta = uv.x * 2.0 * PI;\n\t\tfloat phi = uv.y * PI;\n\n\t\tfloat sinPhi = sin( phi );\n\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\n\n\t}\n\n\t// power heuristic for multiple importance sampling\n\tfloat misHeuristic( float a, float b ) {\n\n\t\tfloat aa = a * a;\n\t\tfloat bb = b * b;\n\t\treturn aa / ( aa + bb );\n\n\t}\n\n\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\n\t// erichlof/THREE.js-PathTracing-Renderer/\n\tfloat tentFilter( float x ) {\n\n\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\n\n\t}\n`;\n","import * as THREE from 'three';\nimport GUI from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport { GraphMaterial } from '../src/materials/debug/GraphMaterial.js';\nimport * as BSDFGLSL from '../src/shader/bsdf/index.js';\nimport * as CommonGLSL from '../src/shader/common/index.js';\n\nconst graphFunctionSnippet = /* glsl */`\n\t#include <common>\n\t${ CommonGLSL.math_functions }\n\t${ CommonGLSL.util_functions }\n\t${ BSDFGLSL.ggx_functions }\n\n\tvec4 graphFunction( float x ) {\n\n\t\tvec3 wi = normalize( vec3( 1.0, 1.0, 1.0 ) );\n\t\tvec3 halfVec = vec3( 0.0, 0.0, 1.0 );\n\t\tfloat theta = dot( wi, halfVec );\n\n\t\treturn vec4(\n\t\t\tggxPDF( wi, halfVec, x ),\n\t\t\tggxDistribution( halfVec, x ),\n\t\t\tggxShadowMaskG1( theta, x ),\n\t\t\tggxLamda( theta, x )\n\t\t);\n\n\t}\n`;\n\nlet camera, scene, renderer, plane;\nlet cameraCenter;\nlet zoom = 10;\nlet dataEl, dataContainerEl;\nconst params = {\n\taspect: 1,\n\tdisplayX: true,\n\tdisplayY: true,\n\tdisplayZ: true,\n\tdisplayW: true,\n\treset() {\n\n\t\tzoom = 10;\n\t\tcameraCenter.set(\n\t\t\t- zoom * 0.5 + zoom * 0.05,\n\t\t\tgetAspect() * zoom * 0.5 - zoom * 0.05,\n\t\t);\n\n\t}\n};\n\ninit();\n\n// init\nasync function init() {\n\n\tdataContainerEl = document.getElementById( 'dataContainer' );\n\tdataEl = document.getElementById( 'data' );\n\n\t// renderer init\n\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setClearColor( 0x11161C );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setAnimationLoop( animation );\n\tdocument.body.appendChild( renderer.domElement );\n\n\t// init camera\n\tcamera = new THREE.OrthographicCamera();\n\tcamera.position.set( 0, 0, 1.5 );\n\n\tscene = new THREE.Scene();\n\n\tcameraCenter = new THREE.Vector2();\n\n\t// image plane\n\tplane = new THREE.Mesh(\n\t\tnew THREE.PlaneGeometry(),\n\t\tnew GraphMaterial( {\n\t\t\tside: THREE.DoubleSide,\n\t\t\tthickness: 1,\n\t\t\tgraphFunctionSnippet,\n\t\t} )\n\t);\n\tplane.scale.setScalar( 2.0 );\n\tscene.add( plane );\n\n\tcameraCenter.set(\n\t\t- zoom * 0.5 + zoom * 0.05,\n\t\tgetAspect() * zoom * 0.5 - zoom * 0.05,\n\t);\n\n\tconst gui = new GUI();\n\tgui.add( plane.material, 'dim' );\n\tgui.add( plane.material, 'thickness', 0.5, 10.0 );\n\tgui.add( params, 'aspect', 0.1, 2 );\n\tgui.add( params, 'reset' );\n\n\tconst graphFolder = gui.addFolder( 'graphs' );\n\tgraphFolder.add( params, 'displayX' ).name( 'display graph 1' );\n\tgraphFolder.add( params, 'displayY' ).name( 'display graph 2' );\n\tgraphFolder.add( params, 'displayZ' ).name( 'display graph 3' );\n\tgraphFolder.add( params, 'displayW' ).name( 'display graph 4' );\n\n\tlet clicked = false;\n\tlet prevX = - 1;\n\tlet prevY = - 1;\n\trenderer.domElement.addEventListener( 'pointerleave', () =>{\n\n\t\tdataContainerEl.style.visibility = 'hidden';\n\n\t} );\n\n\trenderer.domElement.addEventListener( 'pointerenter', () =>{\n\n\t\tdataContainerEl.style.visibility = 'visible';\n\n\t} );\n\n\trenderer.domElement.addEventListener( 'pointerdown', e => {\n\n\t\tclicked = true;\n\t\tprevX = e.clientX;\n\t\tprevY = e.clientY;\n\n\t} );\n\n\trenderer.domElement.addEventListener( 'pointermove', e => {\n\n\t\tclicked = clicked && Boolean( e.buttons & 1 );\n\t\tif ( clicked ) {\n\n\t\t\tconst deltaX = e.clientX - prevX;\n\t\t\tconst deltaY = e.clientY - prevY;\n\n\t\t\tprevX = e.clientX;\n\t\t\tprevY = e.clientY;\n\n\t\t\tconst xWidth = 1;\n\t\t\tconst yWidth = getAspect();\n\n\t\t\tconst graphDeltaX = zoom * xWidth * deltaX / window.innerWidth;\n\t\t\tconst graphDeltaY = zoom * yWidth * deltaY / window.innerHeight;\n\n\t\t\tcameraCenter.x += graphDeltaX;\n\t\t\tcameraCenter.y += graphDeltaY;\n\n\t\t}\n\n\t\tdataContainerEl.style.left = `${ e.clientX }px`;\n\t\tdataContainerEl.style.top = `${ e.clientY }px`;\n\n\t\tconst data = mouseToGraphValue( e.clientX, e.clientY );\n\t\tdataEl.innerText = `x: ${ data.x.toFixed( 3 ) }\\ny: ${ data.y.toFixed( 3 ) }`;\n\n\t} );\n\n\trenderer.domElement.addEventListener( 'wheel', e => {\n\n\t\tconst mouseX = e.clientX;\n\t\tconst mouseY = e.clientY;\n\n\t\tconst xWidth = 1;\n\t\tconst yWidth = getAspect();\n\n\t\tconst centerRelX = ( mouseX / window.innerWidth ) - 0.5;\n\t\tconst centerRelY = ( mouseY / window.innerHeight ) - 0.5;\n\n\t\tconst graphX = zoom * xWidth * centerRelX;\n\t\tconst graphY = zoom * yWidth * centerRelY;\n\n\t\tconst beforeZoom = zoom;\n\t\tconst delta = Math.pow( 0.95, 1.0 );\n\n\t\tif ( e.deltaY < 0 ) {\n\n\t\t\tzoom *= delta;\n\n\t\t} else {\n\n\t\t\tzoom /= delta;\n\n\t\t}\n\n\t\tzoom = Math.max( zoom, 0.1 );\n\t\tzoom = Math.min( zoom, 100 );\n\n\t\tconst afterX = graphX * zoom / beforeZoom;\n\t\tconst afterY = graphY * zoom / beforeZoom;\n\n\t\tcameraCenter.x -= graphX - afterX;\n\t\tcameraCenter.y -= graphY - afterY;\n\n\t} );\n\n\twindow.addEventListener( 'resize', () => {\n\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t} );\n\n}\n\n// animation\nfunction animation() {\n\n\tconst mat = plane.material;\n\tconst xWidth = 1;\n\tconst yWidth = getAspect();\n\n\tmat.xRange.set(\n\t\t- cameraCenter.x - 0.5 * xWidth * zoom,\n\t\t- cameraCenter.x + 0.5 * xWidth * zoom,\n\t);\n\n\tmat.yRange.set(\n\t\tcameraCenter.y - 0.5 * yWidth * zoom,\n\t\tcameraCenter.y + 0.5 * yWidth * zoom,\n\t);\n\n\tmat.graphDisplay.set(\n\t\tNumber( params.displayX ),\n\t\tNumber( params.displayY ),\n\t\tNumber( params.displayZ ),\n\t\tNumber( params.displayW ),\n\t);\n\n\trenderer.render( scene, camera );\n\n}\n\nfunction getAspect() {\n\n\treturn params.aspect * window.innerHeight / window.innerWidth;\n\n}\n\nfunction mouseToGraphValue( x, y ) {\n\n\tconst xWidth = 1;\n\tconst yWidth = getAspect();\n\n\tconst centerRelX = ( x / window.innerWidth ) - 0.5;\n\tconst centerRelY = ( y / window.innerHeight ) - 0.5;\n\n\tconst graphX = zoom * xWidth * centerRelX - cameraCenter.x;\n\tconst graphY = zoom * yWidth * centerRelY - cameraCenter.y;\n\n\treturn { x: graphX, y: - graphY };\n\n}\n","import { NoBlending, Color, Vector2, Vector4 } from 'three';\nimport { MaterialBase } from '../MaterialBase.js';\n\nexport class GraphMaterial extends MaterialBase {\n\n\tget graphFunctionSnippet() {\n\n\t\treturn this._graphFunctionSnippet;\n\n\t}\n\n\tset graphFunctionSnippet( v ) {\n\n\t\tthis._graphFunctionSnippet = v;\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tblending: NoBlending,\n\n\t\t\ttransparent: false,\n\n\t\t\tdepthWrite: false,\n\n\t\t\tdepthTest: false,\n\n\t\t\tdefines: {\n\n\t\t\t\tUSE_SLIDER: 0,\n\n\t\t\t},\n\n\t\t\tuniforms: {\n\n\t\t\t\tdim: { value: true },\n\t\t\t\tthickness: { value: 1 },\n\t\t\t\tgraphCount: { value: 4 },\n\t\t\t\tgraphDisplay: { value: new Vector4( 1.0, 1.0, 1.0, 1.0 ) },\n\t\t\t\toverlay: { value: true },\n\t\t\t\txRange: { value: new Vector2( - 2.0, 2.0 ) },\n\t\t\t\tyRange: { value: new Vector2( - 2.0, 2.0 ) },\n\t\t\t\tcolors: { value: [\n\t\t\t\t\tnew Color( 0xe91e63 ).convertSRGBToLinear(),\n\t\t\t\t\tnew Color( 0x4caf50 ).convertSRGBToLinear(),\n\t\t\t\t\tnew Color( 0x03a9f4 ).convertSRGBToLinear(),\n\t\t\t\t\tnew Color( 0xffc107 ).convertSRGBToLinear(),\n\t\t\t\t] },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform bool overlay;\n\t\t\t\tuniform bool dim;\n\t\t\t\tuniform bvec4 graphDisplay;\n\t\t\t\tuniform float graphCount;\n\t\t\t\tuniform float thickness;\n\t\t\t\tuniform vec2 xRange;\n\t\t\t\tuniform vec2 yRange;\n\t\t\t\tuniform vec3 colors[ 4 ];\n\n\t\t\t\t__FUNCTION_CONTENT__\n\n\t\t\t\tfloat map( float _min, float _max, float v ) {\n\n\t\t\t\t\tfloat len = _max - _min;\n\t\t\t\t\treturn _min + len * v;\n\n\t\t\t\t}\n\n\t\t\t\tvec3 getBackground( vec2 point, float steepness ) {\n\n\t\t\t\t\tvec2 pw = fwidth( point );\n\t\t\t\t\tvec2 halfWidth = pw * 0.5;\n\n\t\t\t\t\t// x, y axes\n\t\t\t\t\tvec2 distToZero = smoothstep(\n\t\t\t\t\t\t- halfWidth * 0.5,\n\t\t\t\t\t\thalfWidth * 0.5,\n\t\t\t\t\t\tabs( point.xy ) - pw\n\t\t\t\t\t);\n\n\t\t\t\t\t// 1 unit markers\n\t\t\t\t\tvec2 temp;\n\t\t\t\t\tvec2 modAxis = abs( modf( point + vec2( 0.5 ), temp ) ) - 0.5;\n\t\t\t\t\tvec2 distToAxis = smoothstep(\n\t\t\t\t\t\t- halfWidth,\n\t\t\t\t\t\thalfWidth,\n\t\t\t\t\t\tabs( modAxis.xy ) - pw * 0.5\n\t\t\t\t\t);\n\n\t\t\t\t\t// if we're at a chart boundary then remove the artifacts\n\t\t\t\t\tif ( abs( pw.y ) > steepness * 0.5 ) {\n\n\t\t\t\t\t\tdistToZero.y = 1.0;\n\t\t\t\t\t\tdistToAxis.y = 1.0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// mix colors into a background color\n\t\t\t\t\tfloat axisIntensity = 1.0 - min( distToZero.x, distToZero.y );\n\t\t\t\t\tfloat markerIntensity = 1.0 - min( distToAxis.x, distToAxis.y );\n\n\t\t\t\t\tvec3 markerColor = mix( vec3( 0.005 ), vec3( 0.05 ), markerIntensity );\n\t\t\t\t\tvec3 backgroundColor = mix( markerColor, vec3( 0.2 ), axisIntensity );\n\t\t\t\t\treturn backgroundColor;\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// from uniforms\n\t\t\t\t\tfloat sectionCount = overlay ? 1.0 : graphCount;\n\t\t\t\t\tfloat yWidth = abs( yRange.y - yRange.x );\n\n\t\t\t\t\t// separate into sections\n\t\t\t\t\tfloat _section;\n\t\t\t\t\tfloat sectionY = modf( sectionCount * vUv.y, _section );\n\t\t\t\t\tint section = int( sectionCount - _section - 1.0 );\n\n\t\t\t\t\t// get the current point\n\t\t\t\t\tvec2 point = vec2(\n\t\t\t\t\t\tmap( xRange.x, xRange.y, vUv.x ),\n\t\t\t\t\t\tmap( yRange.x, yRange.y, sectionY )\n\t\t\t\t\t);\n\n\t\t\t\t\t// get the results\n\t\t\t\t\tvec4 result = graphFunction( point.x );\n\t\t\t\t\tvec4 delta = result - vec4( point.y );\n\t\t\t\t\tvec4 halfDdf = fwidth( delta ) * 0.5;\n\t\t\t\t\tif ( fwidth( point.y ) > yWidth * 0.5 ) {\n\n\t\t\t\t\t\thalfDdf = vec4( 0.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// graph display intensity\n\t\t\t\t\tvec4 graph = smoothstep( - halfDdf, halfDdf, abs( delta ) - thickness * halfDdf );\n\n\t\t\t\t\t// initialize the background\n\t\t\t\t\tgl_FragColor.rgb = getBackground( point, yWidth );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\tif ( dim && ( point.x < 0.0 || point.y < 0.0 ) ) {\n\n\t\t\t\t\t\tgraph = mix(\n\t\t\t\t\t\t\tvec4( 1.0 ),\n\t\t\t\t\t\t\tgraph,\n\t\t\t\t\t\t\t0.05\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// color the charts\n\t\t\t\t\tif ( sectionCount > 1.0 ) {\n\n\t\t\t\t\t\tif ( graphDisplay[ section ] ) {\n\n\t\t\t\t\t\t\tgl_FragColor.rgb = mix(\n\t\t\t\t\t\t\t\tcolors[ section ],\n\t\t\t\t\t\t\t\tgl_FragColor.rgb,\n\t\t\t\t\t\t\t\tgraph[ section ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( int i = 0; i < int( graphCount ); i ++ ) {\n\n\t\t\t\t\t\t\tif ( graphDisplay[ i ] ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb = mix(\n\t\t\t\t\t\t\t\t\tcolors[ i ],\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb,\n\t\t\t\t\t\t\t\t\tgraph[ i ]\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t#include <colorspace_fragment>\n\n\t\t\t\t}\n\n\t\t\t`\n\n\t\t} );\n\n\n\t\tthis._graphFunctionSnippet = /* glsl */`\n\t\t\tvec4 graphFunctionSnippet( float x ) {\n\n\t\t\t\treturn vec4(\n\t\t\t\t\tsin( x * 3.1415926535 ),\n\t\t\t\t\tcos( x ),\n\t\t\t\t\t0.0,\n\t\t\t\t\t0.0\n\t\t\t\t);\n\n\t\t\t}\n\t\t`;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tonBeforeCompile( shader ) {\n\n\t\tshader.fragmentShader = shader.fragmentShader.replace(\n\t\t\t'__FUNCTION_CONTENT__',\n\t\t\tthis._graphFunctionSnippet,\n\t\t);\n\t\treturn shader;\n\n\t}\n\n\tcustomProgramCacheKey() {\n\n\t\treturn this._graphFunctionSnippet;\n\n\t}\n\n}\n"],"names":["$7f018191b657fea8$var$camera","$7f018191b657fea8$var$scene","$7f018191b657fea8$var$renderer","$7f018191b657fea8$var$plane","$7f018191b657fea8$var$cameraCenter","$7f018191b657fea8$var$dataEl","$7f018191b657fea8$var$dataContainerEl","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$6bd4eb2914ee2835$export$f1ac3a587b6cbb5d","$ilwiq","ShaderMaterial","needsUpdate","dispatchEvent","type","constructor","shader","key","uniforms","value","setDefine","name","defines","$60fb6dc3c6495c33$export$4c711108e2e8ef5e","$ba14a4aaa0cde19b$export$98323a006d35be35","$a21c9b4177584031$export$fe1d788deccfbee3","$jiuw3","$9fZ6X","$162adcf1224d60ef$export$8af0c82d10044f6a","MaterialBase","graphFunctionSnippet","_graphFunctionSnippet","parameters","blending","NoBlending","transparent","depthWrite","depthTest","USE_SLIDER","dim","thickness","graphCount","graphDisplay","Vector4","overlay","xRange","Vector2","yRange","colors","Color","convertSRGBToLinear","vertexShader","fragmentShader","setValues","onBeforeCompile","replace","customProgramCacheKey","$8keuf","$fYvb1","$dUUQZ","$7f018191b657fea8$var$graphFunctionSnippet","math_functions","util_functions","ggx_functions","$7f018191b657fea8$var$zoom","$7f018191b657fea8$var$params","aspect","displayX","displayY","displayZ","displayW","reset","$7f018191b657fea8$var$getAspect","$7f018191b657fea8$var$animation","mat","material","yWidth","x","y","Number","render","window","innerHeight","innerWidth","$7f018191b657fea8$var$init","document","getElementById","WebGLRenderer","antialias","setSize","setClearColor","setPixelRatio","devicePixelRatio","setAnimationLoop","body","appendChild","domElement","OrthographicCamera","position","Scene","Mesh","PlaneGeometry","side","DoubleSide","scale","setScalar","add","gui","default","graphFolder","addFolder","clicked","prevX","prevY","addEventListener","style","visibility","clientX","clientY","Boolean","buttons","deltaX","deltaY","graphDeltaX","graphDeltaY","left","top","data","$7f018191b657fea8$var$mouseToGraphValue","centerRelX","centerRelY","innerText","toFixed","mouseX","mouseY","graphX","graphY","beforeZoom","Math","afterX","min","max","afterY"],"version":3,"file":"graphing.63853722.js.map"}