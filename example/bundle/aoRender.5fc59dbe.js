function e(e,t,r,i){Object.defineProperty(e,t,{get:r,set:i,enumerable:!0,configurable:!0})}var t=globalThis,r={},i={},o=t.parcelRequire5b70;null==o&&((o=function(e){if(e in r)return r[e].exports;if(e in i){var t=i[e];delete i[e];var o={id:e,exports:{}};return r[e]=o,t.call(o.exports,o,o.exports),o.exports}var n=Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}).register=function(e,t){i[e]=t},t.parcelRequire5b70=o),(0,o.register)("7ePFa",function(t,r){e(t.exports,"computeMikkTSpaceTangents",()=>n),e(t.exports,"mergeGeometries",()=>l),e(t.exports,"mergeVertices",()=>u),e(t.exports,"toTrianglesDrawMode",()=>a);var i=o("ilwiq");function n(e,t,r=!0){if(!t||!t.isReady)throw Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!e.hasAttribute("position")||!e.hasAttribute("normal")||!e.hasAttribute("uv"))throw Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function o(e){if(e.normalized||e.isInterleavedBufferAttribute){let t=new Float32Array(e.count*e.itemSize);for(let r=0,i=0;r<e.count;r++)t[i++]=e.getX(r),t[i++]=e.getY(r),e.itemSize>2&&(t[i++]=e.getZ(r));return t}return e.array instanceof Float32Array?e.array:new Float32Array(e.array)}let n=e.index?e.toNonIndexed():e,l=t.generateTangents(o(n.attributes.position),o(n.attributes.normal),o(n.attributes.uv));if(r)for(let e=3;e<l.length;e+=4)l[e]*=-1;return n.setAttribute("tangent",new i.BufferAttribute(l,4)),e!==n&&e.copy(n),e}function l(e,t=!1){let r=null!==e[0].index,o=new Set(Object.keys(e[0].attributes)),n=new Set(Object.keys(e[0].morphAttributes)),l={},u={},a=e[0].morphTargetsRelative,f=new i.BufferGeometry,m=0;for(let i=0;i<e.length;++i){let s=e[i],g=0;if(r!==(null!==s.index))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(let e in s.attributes){if(!o.has(e))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+'. All geometries must have compatible attributes; make sure "'+e+'" attribute exists among all geometries, or in none of them.'),null;void 0===l[e]&&(l[e]=[]),l[e].push(s.attributes[e]),g++}if(g!==o.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+". Make sure all geometries have the same number of attributes."),null;if(a!==s.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(let e in s.morphAttributes){if(!n.has(e))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===u[e]&&(u[e]=[]),u[e].push(s.morphAttributes[e])}if(t){let e;if(r)e=s.index.count;else{if(void 0===s.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+". The geometry must have either an index or a position attribute"),null;e=s.attributes.position.count}f.addGroup(m,e,i),m+=e}}if(r){let t=0,r=[];for(let i=0;i<e.length;++i){let o=e[i].index;for(let e=0;e<o.count;++e)r.push(o.getX(e)+t);t+=e[i].attributes.position.count}f.setIndex(r)}for(let e in l){let t=s(l[e]);if(!t)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" attribute."),null;f.setAttribute(e,t)}for(let e in u){let t=u[e][0].length;if(0===t)break;f.morphAttributes=f.morphAttributes||{},f.morphAttributes[e]=[];for(let r=0;r<t;++r){let t=[];for(let i=0;i<u[e].length;++i)t.push(u[e][i][r]);let i=s(t);if(!i)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" morphAttribute."),null;f.morphAttributes[e].push(i)}}return f}function s(e){let t,r,o;let n=-1,l=0;for(let i=0;i<e.length;++i){let s=e[i];if(void 0===t&&(t=s.array.constructor),t!==s.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===r&&(r=s.itemSize),r!==s.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===o&&(o=s.normalized),o!==s.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(-1===n&&(n=s.gpuType),n!==s.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;l+=s.count*r}let s=new t(l),u=new i.BufferAttribute(s,r,o),a=0;for(let t=0;t<e.length;++t){let i=e[t];if(i.isInterleavedBufferAttribute){let e=a/r;for(let t=0,o=i.count;t<o;t++)for(let o=0;o<r;o++){let r=i.getComponent(t,o);u.setComponent(t+e,o,r)}}else s.set(i.array,a);a+=i.count*r}return void 0!==n&&(u.gpuType=n),u}function u(e,t=1e-4){t=Math.max(t,Number.EPSILON);let r={},o=e.getIndex(),n=e.getAttribute("position"),l=o?o.count:n.count,s=0,u=Object.keys(e.attributes),a={},f={},m=[],g=["getX","getY","getZ","getW"],c=["setX","setY","setZ","setW"];for(let t=0,r=u.length;t<r;t++){let r=u[t],o=e.attributes[r];a[r]=new i.BufferAttribute(new o.array.constructor(o.count*o.itemSize),o.itemSize,o.normalized);let n=e.morphAttributes[r];n&&(f[r]=new i.BufferAttribute(new n.array.constructor(n.count*n.itemSize),n.itemSize,n.normalized))}let b=.5*t,h=Math.pow(10,Math.log10(1/t)),d=b*h;for(let t=0;t<l;t++){let i=o?o.getX(t):t,n="";for(let t=0,r=u.length;t<r;t++){let r=u[t],o=e.getAttribute(r),l=o.itemSize;for(let e=0;e<l;e++)n+=`${~~(o[g[e]](i)*h+d)},`}if(n in r)m.push(r[n]);else{for(let t=0,r=u.length;t<r;t++){let r=u[t],o=e.getAttribute(r),n=e.morphAttributes[r],l=o.itemSize,m=a[r],b=f[r];for(let e=0;e<l;e++){let t=g[e],r=c[e];if(m[r](s,o[t](i)),n)for(let e=0,o=n.length;e<o;e++)b[e][r](s,n[e][t](i))}}r[n]=s,m.push(s),s++}}let p=e.clone();for(let t in e.attributes){let e=a[t];if(p.setAttribute(t,new i.BufferAttribute(e.array.slice(0,s*e.itemSize),e.itemSize,e.normalized)),t in f)for(let e=0;e<f[t].length;e++){let r=f[t][e];p.morphAttributes[t][e]=new i.BufferAttribute(r.array.slice(0,s*r.itemSize),r.itemSize,r.normalized)}}return p.setIndex(m),p}function a(e,t){if(t===i.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(t!==i.TriangleFanDrawMode&&t!==i.TriangleStripDrawMode)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),e;{let r=e.getIndex();if(null===r){let t=[],i=e.getAttribute("position");if(void 0===i)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let e=0;e<i.count;e++)t.push(e);e.setIndex(t),r=e.getIndex()}let o=r.count-2,n=[];if(t===i.TriangleFanDrawMode)for(let e=1;e<=o;e++)n.push(r.getX(0)),n.push(r.getX(e)),n.push(r.getX(e+1));else for(let e=0;e<o;e++)e%2==0?(n.push(r.getX(e)),n.push(r.getX(e+1)),n.push(r.getX(e+2))):(n.push(r.getX(e+2)),n.push(r.getX(e+1)),n.push(r.getX(e)));n.length/3!==o&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");let l=e.clone();return l.setIndex(n),l.clearGroups(),l}}});
//# sourceMappingURL=aoRender.5fc59dbe.js.map
