{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,kB,I,G,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,SCeA,IAAM,EAAc,IAAI,EAAA,OAAM,AACvB,OAAM,EAEZ,IAAI,4BAA6B,CAEhC,MAAO,CAAA,CAAS,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,OAAO,CAAC,WAAW,AAE9D,CAEA,IAAI,2BAA4B,CAAC,CAAG,CAEnC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,SAAS,CAAE,cAAe,EAAI,EAAI,EAE7D,CAEA,IAAI,qBAAsB,CAEzB,OAAO,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,mBAAmB,AAErD,CAEA,IAAI,oBAAqB,CAAC,CAAG,CAE5B,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,mBAAmB,CAAG,CAEjD,CAEA,IAAI,SAAU,CAEb,OAAO,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,OAAO,AAEzC,CAEA,IAAI,QAAS,CAAC,CAAG,CAEhB,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,OAAO,CAAG,CAErC,CAEA,IAAI,oBAAqB,CAExB,OAAO,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,kBAAkB,AAEpD,CAEA,IAAI,mBAAoB,CAAC,CAAG,CAE3B,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,kBAAkB,CAAG,CAEhD,CAEA,IAAI,SAAU,CAEb,OAAO,IAAI,CAAC,WAAW,CAAC,OAAO,AAEhC,CAEA,IAAI,QAAS,CAEZ,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,AAE/B,CAEA,IAAI,OAAQ,CAEX,OAAO,IAAI,CAAC,WAAW,CAAC,KAAK,AAE9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","sources":["<anon>","src/core/WebGLPathTracer.js","src/textures/GradientEquirectTexture.js","src/textures/ProceduralEquirectTexture.js","src/materials/fullscreen/ClampedInterpolationMaterial.js","src/utils/CubeToEquirectGenerator.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5b70\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5b70\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"8mHfG\", function(module, exports) {\n\n$parcel$export(module.exports, \"WebGLPathTracer\", () => $6171edc1778f11e8$export$3a05a7fb86d40d58);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $hWj76 = parcelRequire(\"hWj76\");\n\nvar $hWds8 = parcelRequire(\"hWds8\");\n\nvar $RPVlj = parcelRequire(\"RPVlj\");\n\nvar $bHiTZ = parcelRequire(\"bHiTZ\");\n\nvar $9wqOU = parcelRequire(\"9wqOU\");\n\nvar $5rCKZ = parcelRequire(\"5rCKZ\");\n\nvar $5VY8i = parcelRequire(\"5VY8i\");\nfunction $6171edc1778f11e8$var$supportsFloatBlending(renderer) {\n    return renderer.extensions.get(\"EXT_float_blend\");\n}\nconst $6171edc1778f11e8$var$_resolution = new (0, $ilwiq.Vector2)();\nclass $6171edc1778f11e8$export$3a05a7fb86d40d58 {\n    get multipleImportanceSampling() {\n        return Boolean(this._pathTracer.material.defines.FEATURE_MIS);\n    }\n    set multipleImportanceSampling(v) {\n        this._pathTracer.material.setDefine(\"FEATURE_MIS\", v ? 1 : 0);\n    }\n    get transmissiveBounces() {\n        return this._pathTracer.material.transmissiveBounces;\n    }\n    set transmissiveBounces(v) {\n        this._pathTracer.material.transmissiveBounces = v;\n    }\n    get bounces() {\n        return this._pathTracer.material.bounces;\n    }\n    set bounces(v) {\n        this._pathTracer.material.bounces = v;\n    }\n    get filterGlossyFactor() {\n        return this._pathTracer.material.filterGlossyFactor;\n    }\n    set filterGlossyFactor(v) {\n        this._pathTracer.material.filterGlossyFactor = v;\n    }\n    get samples() {\n        return this._pathTracer.samples;\n    }\n    get target() {\n        return this._pathTracer.target;\n    }\n    get tiles() {\n        return this._pathTracer.tiles;\n    }\n    get stableNoise() {\n        return this._pathTracer.stableNoise;\n    }\n    set stableNoise(v) {\n        this._pathTracer.stableNoise = v;\n    }\n    get isCompiling() {\n        return Boolean(this._pathTracer.isCompiling);\n    }\n    constructor(renderer){\n        // members\n        this._renderer = renderer;\n        this._generator = new (0, $hWj76.PathTracingSceneGenerator)();\n        this._pathTracer = new (0, $hWds8.PathTracingRenderer)(renderer);\n        this._queueReset = false;\n        this._clock = new (0, $ilwiq.Clock)();\n        this._compilePromise = null;\n        this._lowResPathTracer = new (0, $hWds8.PathTracingRenderer)(renderer);\n        this._lowResPathTracer.tiles.set(1, 1);\n        this._quad = new (0, $RPVlj.FullScreenQuad)(new (0, $5rCKZ.ClampedInterpolationMaterial)({\n            map: null,\n            transparent: true,\n            blending: (0, $ilwiq.NoBlending),\n            premultipliedAlpha: renderer.getContextAttributes().premultipliedAlpha\n        }));\n        this._materials = null;\n        this._previousEnvironment = null;\n        this._previousBackground = null;\n        this._internalBackground = null;\n        // options\n        this.renderDelay = 100;\n        this.minSamples = 5;\n        this.fadeDuration = 500;\n        this.enablePathTracing = true;\n        this.pausePathTracing = false;\n        this.dynamicLowRes = false;\n        this.lowResScale = 0.25;\n        this.renderScale = 1;\n        this.synchronizeRenderSize = true;\n        this.rasterizeScene = true;\n        this.renderToCanvas = true;\n        this.textureSize = new (0, $ilwiq.Vector2)(1024, 1024);\n        this.rasterizeSceneCallback = (scene, camera)=>{\n            this._renderer.render(scene, camera);\n        };\n        this.renderToCanvasCallback = (target, renderer, quad)=>{\n            const currentAutoClear = renderer.autoClear;\n            renderer.autoClear = false;\n            quad.render(renderer);\n            renderer.autoClear = currentAutoClear;\n        };\n        // initialize the scene so it doesn't fail\n        this.setScene(new (0, $ilwiq.Scene)(), new (0, $ilwiq.PerspectiveCamera)());\n    }\n    setBVHWorker(worker) {\n        this._generator.setBVHWorker(worker);\n    }\n    setScene(scene, camera, options = {}) {\n        scene.updateMatrixWorld(true);\n        camera.updateMatrixWorld();\n        const generator = this._generator;\n        generator.setObjects(scene);\n        if (this._buildAsync) return generator.generateAsync(options.onProgress).then((result)=>{\n            return this._updateFromResults(scene, camera, result);\n        });\n        else {\n            const result = generator.generate();\n            return this._updateFromResults(scene, camera, result);\n        }\n    }\n    setSceneAsync(...args) {\n        this._buildAsync = true;\n        const result = this.setScene(...args);\n        this._buildAsync = false;\n        return result;\n    }\n    setCamera(camera) {\n        this.camera = camera;\n        this.updateCamera();\n    }\n    updateCamera() {\n        const camera = this.camera;\n        camera.updateMatrixWorld();\n        this._pathTracer.setCamera(camera);\n        this._lowResPathTracer.setCamera(camera);\n        this.reset();\n    }\n    updateMaterials() {\n        const material = this._pathTracer.material;\n        const renderer = this._renderer;\n        const materials = this._materials;\n        const textureSize = this.textureSize;\n        // reduce texture sources here - we don't want to do this in the\n        // textures array because we need to pass the textures array into the\n        // material target\n        const textures = (0, $9wqOU.getTextures)(materials);\n        material.textures.setTextures(renderer, textures, textureSize.x, textureSize.y);\n        material.materials.updateFrom(materials, textures);\n        this.reset();\n    }\n    updateLights() {\n        const scene = this.scene;\n        const renderer = this._renderer;\n        const material = this._pathTracer.material;\n        const lights = (0, $9wqOU.getLights)(scene);\n        const iesTextures = (0, $9wqOU.getIesTextures)(lights);\n        material.lights.updateFrom(lights, iesTextures);\n        material.iesProfiles.setTextures(renderer, iesTextures);\n        this.reset();\n    }\n    updateEnvironment() {\n        const scene = this.scene;\n        const material = this._pathTracer.material;\n        if (this._internalBackground) {\n            this._internalBackground.dispose();\n            this._internalBackground = null;\n        }\n        // update scene background\n        material.backgroundBlur = scene.backgroundBlurriness;\n        material.backgroundIntensity = scene.backgroundIntensity ?? 1;\n        material.backgroundRotation.makeRotationFromEuler(scene.backgroundRotation).invert();\n        if (scene.background === null) {\n            material.backgroundMap = null;\n            material.backgroundAlpha = 0;\n        } else if (scene.background.isColor) {\n            this._colorBackground = this._colorBackground || new (0, $bHiTZ.GradientEquirectTexture)(16);\n            const colorBackground = this._colorBackground;\n            if (!colorBackground.topColor.equals(scene.background)) {\n                // set the texture color\n                colorBackground.topColor.set(scene.background);\n                colorBackground.bottomColor.set(scene.background);\n                colorBackground.update();\n            }\n            // assign to material\n            material.backgroundMap = colorBackground;\n            material.backgroundAlpha = 1;\n        } else if (scene.background.isCubeTexture) {\n            if (scene.background !== this._previousBackground) {\n                const background = new (0, $5VY8i.CubeToEquirectGenerator)(this._renderer).generate(scene.background);\n                this._internalBackground = background;\n                material.backgroundMap = background;\n                material.backgroundAlpha = 1;\n            }\n        } else {\n            material.backgroundMap = scene.background;\n            material.backgroundAlpha = 1;\n        }\n        // update scene environment\n        material.environmentIntensity = scene.environment !== null ? scene.environmentIntensity ?? 1 : 0;\n        material.environmentRotation.makeRotationFromEuler(scene.environmentRotation).invert();\n        if (this._previousEnvironment !== scene.environment) {\n            if (scene.environment !== null) {\n                if (scene.environment.isCubeTexture) {\n                    const environment = new (0, $5VY8i.CubeToEquirectGenerator)(this._renderer).generate(scene.environment);\n                    material.envMapInfo.updateFrom(environment);\n                } else // TODO: Consider setting this to the highest supported bit depth by checking for\n                // OES_texture_float_linear or OES_texture_half_float_linear. Requires changes to\n                // the equirect uniform\n                material.envMapInfo.updateFrom(scene.environment);\n            }\n        }\n        this._previousEnvironment = scene.environment;\n        this._previousBackground = scene.background;\n        this.reset();\n    }\n    _updateFromResults(scene, camera, results) {\n        const { materials: materials, geometry: geometry, bvh: bvh, bvhChanged: bvhChanged, needsMaterialIndexUpdate: needsMaterialIndexUpdate } = results;\n        this._materials = materials;\n        const pathTracer = this._pathTracer;\n        const material = pathTracer.material;\n        if (bvhChanged) {\n            material.bvh.updateFrom(bvh);\n            material.attributesArray.updateFrom(geometry.attributes.normal, geometry.attributes.tangent, geometry.attributes.uv, geometry.attributes.color);\n        }\n        if (needsMaterialIndexUpdate) material.materialIndexAttribute.updateFrom(geometry.attributes.materialIndex);\n        // save previously used items\n        this._previousScene = scene;\n        this.scene = scene;\n        this.camera = camera;\n        this.updateCamera();\n        this.updateMaterials();\n        this.updateEnvironment();\n        this.updateLights();\n        return results;\n    }\n    renderSample() {\n        const lowResPathTracer = this._lowResPathTracer;\n        const pathTracer = this._pathTracer;\n        const renderer = this._renderer;\n        const clock = this._clock;\n        const quad = this._quad;\n        this._updateScale();\n        if (this._queueReset) {\n            pathTracer.reset();\n            lowResPathTracer.reset();\n            this._queueReset = false;\n            quad.material.opacity = 0;\n            clock.start();\n        }\n        // render the path tracing sample after enough time has passed\n        const delta = clock.getDelta() * 1e3;\n        const elapsedTime = clock.getElapsedTime() * 1e3;\n        if (!this.pausePathTracing && this.enablePathTracing && this.renderDelay <= elapsedTime && !this.isCompiling) pathTracer.update();\n        // when alpha is enabled we use a manual blending system rather than\n        // rendering with a blend function\n        pathTracer.alpha = pathTracer.material.backgroundAlpha !== 1 || !$6171edc1778f11e8$var$supportsFloatBlending(renderer);\n        lowResPathTracer.alpha = pathTracer.alpha;\n        if (this.renderToCanvas) {\n            const renderer = this._renderer;\n            const minSamples = this.minSamples;\n            if (elapsedTime >= this.renderDelay && this.samples >= this.minSamples) {\n                if (this.fadeDuration !== 0) quad.material.opacity = Math.min(quad.material.opacity + delta / this.fadeDuration, 1);\n                else quad.material.opacity = 1;\n            }\n            // render the fallback if we haven't rendered enough samples, are paused, or are occluded\n            if (!this.enablePathTracing || this.samples < minSamples || quad.material.opacity < 1) {\n                if (this.dynamicLowRes && !this.isCompiling) {\n                    if (lowResPathTracer.samples < 1) {\n                        lowResPathTracer.material = pathTracer.material;\n                        lowResPathTracer.update();\n                    }\n                    const currentOpacity = quad.material.opacity;\n                    quad.material.opacity = 1 - quad.material.opacity;\n                    quad.material.map = lowResPathTracer.target.texture;\n                    quad.render(renderer);\n                    quad.material.opacity = currentOpacity;\n                }\n                if (!this.dynamicLowRes && this.rasterizeScene || this.dynamicLowRes && this.isCompiling) this.rasterizeSceneCallback(this.scene, this.camera);\n            }\n            if (this.enablePathTracing && quad.material.opacity > 0) {\n                if (quad.material.opacity < 1) // use additive blending when the low res texture is rendered so we can fade the\n                // background out while the full res fades in\n                quad.material.blending = this.dynamicLowRes ? (0, $ilwiq.AdditiveBlending) : (0, $ilwiq.NormalBlending);\n                quad.material.map = pathTracer.target.texture;\n                this.renderToCanvasCallback(pathTracer.target, renderer, quad);\n                quad.material.blending = (0, $ilwiq.NoBlending);\n            }\n        }\n    }\n    reset() {\n        this._queueReset = true;\n        this._pathTracer.samples = 0;\n    }\n    dispose() {\n        this._quad.dispose();\n        this._quad.material.dispose();\n        this._pathTracer.dispose();\n    }\n    _updateScale() {\n        // update the path tracer scale if it has changed\n        if (this.synchronizeRenderSize) {\n            this._renderer.getDrawingBufferSize($6171edc1778f11e8$var$_resolution);\n            const w = Math.floor(this.renderScale * $6171edc1778f11e8$var$_resolution.x);\n            const h = Math.floor(this.renderScale * $6171edc1778f11e8$var$_resolution.y);\n            this._pathTracer.getSize($6171edc1778f11e8$var$_resolution);\n            if ($6171edc1778f11e8$var$_resolution.x !== w || $6171edc1778f11e8$var$_resolution.y !== h) {\n                const lowResScale = this.lowResScale;\n                this._pathTracer.setSize(w, h);\n                this._lowResPathTracer.setSize(Math.floor(w * lowResScale), Math.floor(h * lowResScale));\n            }\n        }\n    }\n}\n\n});\nparcelRegister(\"bHiTZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"GradientEquirectTexture\", () => $88425f7125b6e46c$export$38d6a241e670a287);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $dbdMq = parcelRequire(\"dbdMq\");\nconst $88425f7125b6e46c$var$_direction = new (0, $ilwiq.Vector3)();\nclass $88425f7125b6e46c$export$38d6a241e670a287 extends (0, $dbdMq.ProceduralEquirectTexture) {\n    constructor(resolution = 512){\n        super(resolution, resolution);\n        this.topColor = new (0, $ilwiq.Color)().set(0xffffff);\n        this.bottomColor = new (0, $ilwiq.Color)().set(0x000000);\n        this.exponent = 2;\n        this.generationCallback = (polar, uv, coord, color)=>{\n            $88425f7125b6e46c$var$_direction.setFromSpherical(polar);\n            const t = $88425f7125b6e46c$var$_direction.y * 0.5 + 0.5;\n            color.lerpColors(this.bottomColor, this.topColor, t ** this.exponent);\n        };\n    }\n    copy(other) {\n        super.copy(other);\n        this.topColor.copy(other.topColor);\n        this.bottomColor.copy(other.bottomColor);\n        return this;\n    }\n}\n\n});\nparcelRegister(\"dbdMq\", function(module, exports) {\n\n$parcel$export(module.exports, \"ProceduralEquirectTexture\", () => $9986fde00d79bc96$export$ab88b3c5fea10066);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nconst $9986fde00d79bc96$var$_uv = new (0, $ilwiq.Vector2)();\nconst $9986fde00d79bc96$var$_coord = new (0, $ilwiq.Vector2)();\nconst $9986fde00d79bc96$var$_polar = new (0, $ilwiq.Spherical)();\nconst $9986fde00d79bc96$var$_color = new (0, $ilwiq.Color)();\nclass $9986fde00d79bc96$export$ab88b3c5fea10066 extends (0, $ilwiq.DataTexture) {\n    constructor(width = 512, height = 512){\n        super(new Float32Array(width * height * 4), width, height, (0, $ilwiq.RGBAFormat), (0, $ilwiq.FloatType), (0, $ilwiq.EquirectangularReflectionMapping), (0, $ilwiq.RepeatWrapping), (0, $ilwiq.ClampToEdgeWrapping), (0, $ilwiq.LinearFilter), (0, $ilwiq.LinearFilter));\n        this.generationCallback = null;\n    }\n    update() {\n        this.dispose();\n        this.needsUpdate = true;\n        const { data: data, width: width, height: height } = this.image;\n        for(let x = 0; x < width; x++)for(let y = 0; y < height; y++){\n            $9986fde00d79bc96$var$_coord.set(width, height);\n            $9986fde00d79bc96$var$_uv.set(x / width, y / height);\n            $9986fde00d79bc96$var$_uv.x -= 0.5;\n            $9986fde00d79bc96$var$_uv.y = 1.0 - $9986fde00d79bc96$var$_uv.y;\n            $9986fde00d79bc96$var$_polar.theta = $9986fde00d79bc96$var$_uv.x * 2.0 * Math.PI;\n            $9986fde00d79bc96$var$_polar.phi = $9986fde00d79bc96$var$_uv.y * Math.PI;\n            $9986fde00d79bc96$var$_polar.radius = 1.0;\n            this.generationCallback($9986fde00d79bc96$var$_polar, $9986fde00d79bc96$var$_uv, $9986fde00d79bc96$var$_coord, $9986fde00d79bc96$var$_color);\n            const i = y * width + x;\n            const i4 = 4 * i;\n            data[i4 + 0] = $9986fde00d79bc96$var$_color.r;\n            data[i4 + 1] = $9986fde00d79bc96$var$_color.g;\n            data[i4 + 2] = $9986fde00d79bc96$var$_color.b;\n            data[i4 + 3] = 1.0;\n        }\n    }\n    copy(other) {\n        super.copy(other);\n        this.generationCallback = other.generationCallback;\n        return this;\n    }\n}\n\n});\n\n\nparcelRegister(\"5rCKZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"ClampedInterpolationMaterial\", () => $3f6d89af35c8e149$export$41f50d3add172b7d);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $3f6d89af35c8e149$export$41f50d3add172b7d extends (0, $ilwiq.ShaderMaterial) {\n    get map() {\n        return this.uniforms.map.value;\n    }\n    set map(v) {\n        this.uniforms.map.value = v;\n    }\n    get opacity() {\n        return this.uniforms.opacity.value;\n    }\n    set opacity(v) {\n        if (this.uniforms) this.uniforms.opacity.value = v;\n    }\n    constructor(params){\n        super({\n            uniforms: {\n                map: {\n                    value: null\n                },\n                opacity: {\n                    value: 1\n                }\n            },\n            vertexShader: /* glsl */ `\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t`,\n            fragmentShader: /* glsl */ `\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform float opacity;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvec4 clampedTexelFatch( sampler2D map, ivec2 px, int lod ) {\n\n\t\t\t\t\tvec4 res = texelFetch( map, ivec2( px.x, px.y ), 0 );\n\n\t\t\t\t\t#if defined( TONE_MAPPING )\n\n\t\t\t\t\tres.xyz = toneMapping( res.xyz );\n\n\t\t\t\t\t#endif\n\n\t\t\t  \t\treturn linearToOutputTexel( res );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec2 size = vec2( textureSize( map, 0 ) );\n\t\t\t\t\tvec2 pxUv = vUv * size;\n\t\t\t\t\tvec2 pxCurr = floor( pxUv );\n\t\t\t\t\tvec2 pxFrac = fract( pxUv ) - 0.5;\n\t\t\t\t\tvec2 pxOffset;\n\t\t\t\t\tpxOffset.x = pxFrac.x > 0.0 ? 1.0 : - 1.0;\n\t\t\t\t\tpxOffset.y = pxFrac.y > 0.0 ? 1.0 : - 1.0;\n\n\t\t\t\t\tvec2 pxNext = clamp( pxOffset + pxCurr, vec2( 0.0 ), size - 1.0 );\n\t\t\t\t\tvec2 alpha = abs( pxFrac );\n\n\t\t\t\t\tvec4 p1 = mix(\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxCurr.x, pxCurr.y ), 0 ),\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxNext.x, pxCurr.y ), 0 ),\n\t\t\t\t\t\talpha.x\n\t\t\t\t\t);\n\n\t\t\t\t\tvec4 p2 = mix(\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxCurr.x, pxNext.y ), 0 ),\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxNext.x, pxNext.y ), 0 ),\n\t\t\t\t\t\talpha.x\n\t\t\t\t\t);\n\n\t\t\t\t\tgl_FragColor = mix( p1, p2, alpha.y );\n\t\t\t\t\tgl_FragColor.a *= opacity;\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\t\t\t`\n        });\n        this.setValues(params);\n    }\n}\n\n});\n\nparcelRegister(\"5VY8i\", function(module, exports) {\n\n$parcel$export(module.exports, \"CubeToEquirectGenerator\", () => $4520ebc51d692c1e$export$6f8f537b668b4bb1);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $RPVlj = parcelRequire(\"RPVlj\");\n\nvar $dUUQZ = parcelRequire(\"dUUQZ\");\nclass $4520ebc51d692c1e$var$CubeToEquirectMaterial extends (0, $ilwiq.ShaderMaterial) {\n    constructor(){\n        super({\n            uniforms: {\n                envMap: {\n                    value: null\n                },\n                flipEnvMap: {\n                    value: -1\n                }\n            },\n            vertexShader: /* glsl */ `\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}`,\n            fragmentShader: /* glsl */ `\n\t\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n\t\t\t\tuniform samplerCube envMap;\n\t\t\t\tuniform float flipEnvMap;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t\t${$dUUQZ.util_functions}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 rayDirection = equirectUvToDirection( vUv );\n\t\t\t\t\trayDirection.x *= flipEnvMap;\n\t\t\t\t\tgl_FragColor = textureCube( envMap, rayDirection );\n\n\t\t\t\t}`\n        });\n        this.depthWrite = false;\n        this.depthTest = false;\n    }\n}\nclass $4520ebc51d692c1e$export$6f8f537b668b4bb1 {\n    constructor(renderer){\n        this._renderer = renderer;\n        this._quad = new (0, $RPVlj.FullScreenQuad)(new $4520ebc51d692c1e$var$CubeToEquirectMaterial());\n    }\n    generate(source, width = null, height = null) {\n        if (!source.isCubeTexture) throw new Error(\"CubeToEquirectMaterial: Source can only be cube textures.\");\n        const image = source.images[0];\n        const renderer = this._renderer;\n        const quad = this._quad;\n        // determine the dimensions if not provided\n        if (width === null) width = 4 * image.height;\n        if (height === null) height = 2 * image.height;\n        const target = new (0, $ilwiq.WebGLRenderTarget)(width, height, {\n            type: (0, $ilwiq.FloatType),\n            colorSpace: image.colorSpace\n        });\n        // prep the cube map data\n        const imageHeight = image.height;\n        const maxMip = Math.log2(imageHeight) - 2;\n        const texelHeight = 1.0 / imageHeight;\n        const texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 112));\n        quad.material.defines.CUBEUV_MAX_MIP = `${maxMip}.0`;\n        quad.material.defines.CUBEUV_TEXEL_WIDTH = texelWidth;\n        quad.material.defines.CUBEUV_TEXEL_HEIGHT = texelHeight;\n        quad.material.uniforms.envMap.value = source;\n        quad.material.uniforms.flipEnvMap.value = source.isRenderTargetTexture ? 1 : -1;\n        quad.material.needsUpdate = true;\n        // save state and render the contents\n        const currentTarget = renderer.getRenderTarget();\n        const currentAutoClear = renderer.autoClear;\n        renderer.autoClear = true;\n        renderer.setRenderTarget(target);\n        quad.render(renderer);\n        renderer.setRenderTarget(currentTarget);\n        renderer.autoClear = currentAutoClear;\n        // read the data back\n        const buffer = new Uint16Array(width * height * 4);\n        const readBuffer = new Float32Array(width * height * 4);\n        renderer.readRenderTargetPixels(target, 0, 0, width, height, readBuffer);\n        target.dispose();\n        for(let i = 0, l = readBuffer.length; i < l; i++)buffer[i] = (0, $ilwiq.DataUtils).toHalfFloat(readBuffer[i]);\n        // produce the data texture\n        const result = new (0, $ilwiq.DataTexture)(buffer, width, height, (0, $ilwiq.RGBAFormat), (0, $ilwiq.HalfFloatType));\n        result.minFilter = (0, $ilwiq.LinearMipMapLinearFilter);\n        result.magFilter = (0, $ilwiq.LinearFilter);\n        result.wrapS = (0, $ilwiq.RepeatWrapping);\n        result.wrapT = (0, $ilwiq.RepeatWrapping);\n        result.mapping = (0, $ilwiq.EquirectangularReflectionMapping);\n        result.needsUpdate = true;\n        return result;\n    }\n    dispose() {\n        this._quad.dispose();\n    }\n}\n\n});\n\n\n\n//# sourceMappingURL=areaLight.1c24b9b9.js.map\n","import { PerspectiveCamera, Scene, Vector2, Clock, NormalBlending, NoBlending, AdditiveBlending } from 'three';\nimport { PathTracingSceneGenerator } from './PathTracingSceneGenerator.js';\nimport { PathTracingRenderer } from './PathTracingRenderer.js';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { GradientEquirectTexture } from '../textures/GradientEquirectTexture.js';\nimport { getIesTextures, getLights, getTextures } from './utils/sceneUpdateUtils.js';\nimport { ClampedInterpolationMaterial } from '../materials/fullscreen/ClampedInterpolationMaterial.js';\nimport { CubeToEquirectGenerator } from '../utils/CubeToEquirectGenerator.js';\n\nfunction supportsFloatBlending( renderer ) {\n\n\treturn renderer.extensions.get( 'EXT_float_blend' );\n\n}\n\nconst _resolution = new Vector2();\nexport class WebGLPathTracer {\n\n\tget multipleImportanceSampling() {\n\n\t\treturn Boolean( this._pathTracer.material.defines.FEATURE_MIS );\n\n\t}\n\n\tset multipleImportanceSampling( v ) {\n\n\t\tthis._pathTracer.material.setDefine( 'FEATURE_MIS', v ? 1 : 0 );\n\n\t}\n\n\tget transmissiveBounces() {\n\n\t\treturn this._pathTracer.material.transmissiveBounces;\n\n\t}\n\n\tset transmissiveBounces( v ) {\n\n\t\tthis._pathTracer.material.transmissiveBounces = v;\n\n\t}\n\n\tget bounces() {\n\n\t\treturn this._pathTracer.material.bounces;\n\n\t}\n\n\tset bounces( v ) {\n\n\t\tthis._pathTracer.material.bounces = v;\n\n\t}\n\n\tget filterGlossyFactor() {\n\n\t\treturn this._pathTracer.material.filterGlossyFactor;\n\n\t}\n\n\tset filterGlossyFactor( v ) {\n\n\t\tthis._pathTracer.material.filterGlossyFactor = v;\n\n\t}\n\n\tget samples() {\n\n\t\treturn this._pathTracer.samples;\n\n\t}\n\n\tget target() {\n\n\t\treturn this._pathTracer.target;\n\n\t}\n\n\tget tiles() {\n\n\t\treturn this._pathTracer.tiles;\n\n\t}\n\n\tget stableNoise() {\n\n\t\treturn this._pathTracer.stableNoise;\n\n\t}\n\n\tset stableNoise( v ) {\n\n\t\tthis._pathTracer.stableNoise = v;\n\n\t}\n\n\tget isCompiling() {\n\n\t\treturn Boolean( this._pathTracer.isCompiling );\n\n\t}\n\n\tconstructor( renderer ) {\n\n\t\t// members\n\t\tthis._renderer = renderer;\n\t\tthis._generator = new PathTracingSceneGenerator();\n\t\tthis._pathTracer = new PathTracingRenderer( renderer );\n\t\tthis._queueReset = false;\n\t\tthis._clock = new Clock();\n\t\tthis._compilePromise = null;\n\n\t\tthis._lowResPathTracer = new PathTracingRenderer( renderer );\n\t\tthis._lowResPathTracer.tiles.set( 1, 1 );\n\t\tthis._quad = new FullScreenQuad( new ClampedInterpolationMaterial( {\n\t\t\tmap: null,\n\t\t\ttransparent: true,\n\t\t\tblending: NoBlending,\n\n\t\t\tpremultipliedAlpha: renderer.getContextAttributes().premultipliedAlpha,\n\t\t} ) );\n\t\tthis._materials = null;\n\n\t\tthis._previousEnvironment = null;\n\t\tthis._previousBackground = null;\n\t\tthis._internalBackground = null;\n\n\t\t// options\n\t\tthis.renderDelay = 100;\n\t\tthis.minSamples = 5;\n\t\tthis.fadeDuration = 500;\n\t\tthis.enablePathTracing = true;\n\t\tthis.pausePathTracing = false;\n\t\tthis.dynamicLowRes = false;\n\t\tthis.lowResScale = 0.25;\n\t\tthis.renderScale = 1;\n\t\tthis.synchronizeRenderSize = true;\n\t\tthis.rasterizeScene = true;\n\t\tthis.renderToCanvas = true;\n\t\tthis.textureSize = new Vector2( 1024, 1024 );\n\t\tthis.rasterizeSceneCallback = ( scene, camera ) => {\n\n\t\t\tthis._renderer.render( scene, camera );\n\n\t\t};\n\n\t\tthis.renderToCanvasCallback = ( target, renderer, quad ) => {\n\n\t\t\tconst currentAutoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = false;\n\t\t\tquad.render( renderer );\n\t\t\trenderer.autoClear = currentAutoClear;\n\n\t\t};\n\n\t\t// initialize the scene so it doesn't fail\n\t\tthis.setScene( new Scene(), new PerspectiveCamera() );\n\n\t}\n\n\tsetBVHWorker( worker ) {\n\n\t\tthis._generator.setBVHWorker( worker );\n\n\t}\n\n\tsetScene( scene, camera, options = {} ) {\n\n\t\tscene.updateMatrixWorld( true );\n\t\tcamera.updateMatrixWorld();\n\n\t\tconst generator = this._generator;\n\t\tgenerator.setObjects( scene );\n\n\t\tif ( this._buildAsync ) {\n\n\t\t\treturn generator.generateAsync( options.onProgress ).then( result => {\n\n\t\t\t\treturn this._updateFromResults( scene, camera, result );\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tconst result = generator.generate();\n\t\t\treturn this._updateFromResults( scene, camera, result );\n\n\t\t}\n\n\t}\n\n\tsetSceneAsync( ...args ) {\n\n\t\tthis._buildAsync = true;\n\t\tconst result = this.setScene( ...args );\n\t\tthis._buildAsync = false;\n\n\t\treturn result;\n\n\t}\n\n\tsetCamera( camera ) {\n\n\t\tthis.camera = camera;\n\t\tthis.updateCamera();\n\n\t}\n\n\tupdateCamera() {\n\n\t\tconst camera = this.camera;\n\t\tcamera.updateMatrixWorld();\n\n\t\tthis._pathTracer.setCamera( camera );\n\t\tthis._lowResPathTracer.setCamera( camera );\n\t\tthis.reset();\n\n\t}\n\n\tupdateMaterials() {\n\n\t\tconst material = this._pathTracer.material;\n\t\tconst renderer = this._renderer;\n\t\tconst materials = this._materials;\n\t\tconst textureSize = this.textureSize;\n\n\t\t// reduce texture sources here - we don't want to do this in the\n\t\t// textures array because we need to pass the textures array into the\n\t\t// material target\n\t\tconst textures = getTextures( materials );\n\t\tmaterial.textures.setTextures( renderer, textures, textureSize.x, textureSize.y );\n\t\tmaterial.materials.updateFrom( materials, textures );\n\t\tthis.reset();\n\n\t}\n\n\tupdateLights() {\n\n\t\tconst scene = this.scene;\n\t\tconst renderer = this._renderer;\n\t\tconst material = this._pathTracer.material;\n\n\t\tconst lights = getLights( scene );\n\t\tconst iesTextures = getIesTextures( lights );\n\t\tmaterial.lights.updateFrom( lights, iesTextures );\n\t\tmaterial.iesProfiles.setTextures( renderer, iesTextures );\n\t\tthis.reset();\n\n\t}\n\n\tupdateEnvironment() {\n\n\t\tconst scene = this.scene;\n\t\tconst material = this._pathTracer.material;\n\n\t\tif ( this._internalBackground ) {\n\n\t\t\tthis._internalBackground.dispose();\n\t\t\tthis._internalBackground = null;\n\n\t\t}\n\n\t\t// update scene background\n\t\tmaterial.backgroundBlur = scene.backgroundBlurriness;\n\t\tmaterial.backgroundIntensity = scene.backgroundIntensity ?? 1;\n\t\tmaterial.backgroundRotation.makeRotationFromEuler( scene.backgroundRotation ).invert();\n\t\tif ( scene.background === null ) {\n\n\t\t\tmaterial.backgroundMap = null;\n\t\t\tmaterial.backgroundAlpha = 0;\n\n\t\t} else if ( scene.background.isColor ) {\n\n\t\t\tthis._colorBackground = this._colorBackground || new GradientEquirectTexture( 16 );\n\n\t\t\tconst colorBackground = this._colorBackground;\n\t\t\tif ( ! colorBackground.topColor.equals( scene.background ) ) {\n\n\t\t\t\t// set the texture color\n\t\t\t\tcolorBackground.topColor.set( scene.background );\n\t\t\t\tcolorBackground.bottomColor.set( scene.background );\n\t\t\t\tcolorBackground.update();\n\n\t\t\t}\n\n\t\t\t// assign to material\n\t\t\tmaterial.backgroundMap = colorBackground;\n\t\t\tmaterial.backgroundAlpha = 1;\n\n\t\t} else if ( scene.background.isCubeTexture ) {\n\n\t\t\tif ( scene.background !== this._previousBackground ) {\n\n\t\t\t\tconst background = new CubeToEquirectGenerator( this._renderer ).generate( scene.background );\n\t\t\t\tthis._internalBackground = background;\n\t\t\t\tmaterial.backgroundMap = background;\n\t\t\t\tmaterial.backgroundAlpha = 1;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmaterial.backgroundMap = scene.background;\n\t\t\tmaterial.backgroundAlpha = 1;\n\n\t\t}\n\n\t\t// update scene environment\n\t\tmaterial.environmentIntensity = scene.environment !== null ? ( scene.environmentIntensity ?? 1 ) : 0;\n\t\tmaterial.environmentRotation.makeRotationFromEuler( scene.environmentRotation ).invert();\n\t\tif ( this._previousEnvironment !== scene.environment ) {\n\n\t\t\tif ( scene.environment !== null ) {\n\n\t\t\t\tif ( scene.environment.isCubeTexture ) {\n\n\t\t\t\t\tconst environment = new CubeToEquirectGenerator( this._renderer ).generate( scene.environment );\n\t\t\t\t\tmaterial.envMapInfo.updateFrom( environment );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// TODO: Consider setting this to the highest supported bit depth by checking for\n\t\t\t\t\t// OES_texture_float_linear or OES_texture_half_float_linear. Requires changes to\n\t\t\t\t\t// the equirect uniform\n\t\t\t\t\tmaterial.envMapInfo.updateFrom( scene.environment );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._previousEnvironment = scene.environment;\n\t\tthis._previousBackground = scene.background;\n\t\tthis.reset();\n\n\t}\n\n\t_updateFromResults( scene, camera, results ) {\n\n\t\tconst {\n\t\t\tmaterials,\n\t\t\tgeometry,\n\t\t\tbvh,\n\t\t\tbvhChanged,\n\t\t\tneedsMaterialIndexUpdate,\n\t\t} = results;\n\n\t\tthis._materials = materials;\n\n\t\tconst pathTracer = this._pathTracer;\n\t\tconst material = pathTracer.material;\n\n\t\tif ( bvhChanged ) {\n\n\t\t\tmaterial.bvh.updateFrom( bvh );\n\t\t\tmaterial.attributesArray.updateFrom(\n\t\t\t\tgeometry.attributes.normal,\n\t\t\t\tgeometry.attributes.tangent,\n\t\t\t\tgeometry.attributes.uv,\n\t\t\t\tgeometry.attributes.color,\n\t\t\t);\n\n\t\t}\n\n\t\tif ( needsMaterialIndexUpdate ) {\n\n\t\t\tmaterial.materialIndexAttribute.updateFrom( geometry.attributes.materialIndex );\n\n\t\t}\n\n\t\t// save previously used items\n\t\tthis._previousScene = scene;\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t\tthis.updateCamera();\n\t\tthis.updateMaterials();\n\t\tthis.updateEnvironment();\n\t\tthis.updateLights();\n\n\t\treturn results;\n\n\t}\n\n\trenderSample() {\n\n\t\tconst lowResPathTracer = this._lowResPathTracer;\n\t\tconst pathTracer = this._pathTracer;\n\t\tconst renderer = this._renderer;\n\t\tconst clock = this._clock;\n\t\tconst quad = this._quad;\n\n\t\tthis._updateScale();\n\n\t\tif ( this._queueReset ) {\n\n\t\t\tpathTracer.reset();\n\t\t\tlowResPathTracer.reset();\n\t\t\tthis._queueReset = false;\n\n\t\t\tquad.material.opacity = 0;\n\t\t\tclock.start();\n\n\t\t}\n\n\t\t// render the path tracing sample after enough time has passed\n\t\tconst delta = clock.getDelta() * 1e3;\n\t\tconst elapsedTime = clock.getElapsedTime() * 1e3;\n\t\tif ( ! this.pausePathTracing && this.enablePathTracing && this.renderDelay <= elapsedTime && ! this.isCompiling ) {\n\n\t\t\tpathTracer.update();\n\n\t\t}\n\n\t\t// when alpha is enabled we use a manual blending system rather than\n\t\t// rendering with a blend function\n\t\tpathTracer.alpha = pathTracer.material.backgroundAlpha !== 1 || ! supportsFloatBlending( renderer );\n\t\tlowResPathTracer.alpha = pathTracer.alpha;\n\n\t\tif ( this.renderToCanvas ) {\n\n\t\t\tconst renderer = this._renderer;\n\t\t\tconst minSamples = this.minSamples;\n\n\t\t\tif ( elapsedTime >= this.renderDelay && this.samples >= this.minSamples ) {\n\n\t\t\t\tif ( this.fadeDuration !== 0 ) {\n\n\t\t\t\t\tquad.material.opacity = Math.min( quad.material.opacity + delta / this.fadeDuration, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tquad.material.opacity = 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// render the fallback if we haven't rendered enough samples, are paused, or are occluded\n\t\t\tif ( ! this.enablePathTracing || this.samples < minSamples || quad.material.opacity < 1 ) {\n\n\t\t\t\tif ( this.dynamicLowRes && ! this.isCompiling ) {\n\n\t\t\t\t\tif ( lowResPathTracer.samples < 1 ) {\n\n\t\t\t\t\t\tlowResPathTracer.material = pathTracer.material;\n\t\t\t\t\t\tlowResPathTracer.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst currentOpacity = quad.material.opacity;\n\t\t\t\t\tquad.material.opacity = 1 - quad.material.opacity;\n\t\t\t\t\tquad.material.map = lowResPathTracer.target.texture;\n\t\t\t\t\tquad.render( renderer );\n\t\t\t\t\tquad.material.opacity = currentOpacity;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! this.dynamicLowRes && this.rasterizeScene || this.dynamicLowRes && this.isCompiling ) {\n\n\t\t\t\t\tthis.rasterizeSceneCallback( this.scene, this.camera );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif ( this.enablePathTracing && quad.material.opacity > 0 ) {\n\n\t\t\t\tif ( quad.material.opacity < 1 ) {\n\n\t\t\t\t\t// use additive blending when the low res texture is rendered so we can fade the\n\t\t\t\t\t// background out while the full res fades in\n\t\t\t\t\tquad.material.blending = this.dynamicLowRes ? AdditiveBlending : NormalBlending;\n\n\t\t\t\t}\n\n\t\t\t\tquad.material.map = pathTracer.target.texture;\n\t\t\t\tthis.renderToCanvasCallback( pathTracer.target, renderer, quad );\n\t\t\t\tquad.material.blending = NoBlending;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treset() {\n\n\t\tthis._queueReset = true;\n\t\tthis._pathTracer.samples = 0;\n\n\t}\n\n\tdispose() {\n\n\t\tthis._quad.dispose();\n\t\tthis._quad.material.dispose();\n\t\tthis._pathTracer.dispose();\n\n\t}\n\n\t_updateScale() {\n\n\t\t// update the path tracer scale if it has changed\n\t\tif ( this.synchronizeRenderSize ) {\n\n\t\t\tthis._renderer.getDrawingBufferSize( _resolution );\n\n\t\t\tconst w = Math.floor( this.renderScale * _resolution.x );\n\t\t\tconst h = Math.floor( this.renderScale * _resolution.y );\n\n\t\t\tthis._pathTracer.getSize( _resolution );\n\t\t\tif ( _resolution.x !== w || _resolution.y !== h ) {\n\n\t\t\t\tconst lowResScale = this.lowResScale;\n\t\t\t\tthis._pathTracer.setSize( w, h );\n\t\t\t\tthis._lowResPathTracer.setSize( Math.floor( w * lowResScale ), Math.floor( h * lowResScale ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","import { Color, Vector3 } from 'three';\nimport { ProceduralEquirectTexture } from './ProceduralEquirectTexture.js';\n\nconst _direction = new Vector3();\nexport class GradientEquirectTexture extends ProceduralEquirectTexture {\n\n\tconstructor( resolution = 512 ) {\n\n\t\tsuper( resolution, resolution );\n\n\t\tthis.topColor = new Color().set( 0xffffff );\n\t\tthis.bottomColor = new Color().set( 0x000000 );\n\t\tthis.exponent = 2;\n\t\tthis.generationCallback = ( polar, uv, coord, color ) => {\n\n\t\t\t_direction.setFromSpherical( polar );\n\n\t\t\tconst t = _direction.y * 0.5 + 0.5;\n\t\t\tcolor.lerpColors( this.bottomColor, this.topColor, t ** this.exponent );\n\n\t\t};\n\n\t}\n\n\tcopy( other ) {\n\n\t\tsuper.copy( other );\n\n\t\tthis.topColor.copy( other.topColor );\n\t\tthis.bottomColor.copy( other.bottomColor );\n\t\treturn this;\n\n\t}\n\n}\n","import {\n\tClampToEdgeWrapping,\n\tColor,\n\tDataTexture,\n\tEquirectangularReflectionMapping,\n\tLinearFilter,\n\tRepeatWrapping,\n\tRGBAFormat,\n\tSpherical,\n\tVector2,\n\tFloatType\n} from 'three';\n\nconst _uv = new Vector2();\nconst _coord = new Vector2();\nconst _polar = new Spherical();\nconst _color = new Color();\nexport class ProceduralEquirectTexture extends DataTexture {\n\n\tconstructor( width = 512, height = 512 ) {\n\n\t\tsuper(\n\t\t\tnew Float32Array( width * height * 4 ),\n\t\t\twidth, height, RGBAFormat, FloatType, EquirectangularReflectionMapping,\n\t\t\tRepeatWrapping, ClampToEdgeWrapping, LinearFilter, LinearFilter,\n\t\t);\n\n\t\tthis.generationCallback = null;\n\n\t}\n\n\tupdate() {\n\n\t\tthis.dispose();\n\t\tthis.needsUpdate = true;\n\n\t\tconst { data, width, height } = this.image;\n\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\t\t_coord.set( width, height );\n\n\t\t\t\t_uv.set( x / width, y / height );\n\t\t\t\t_uv.x -= 0.5;\n\t\t\t\t_uv.y = 1.0 - _uv.y;\n\n\t\t\t\t_polar.theta = _uv.x * 2.0 * Math.PI;\n\t\t\t\t_polar.phi = _uv.y * Math.PI;\n\t\t\t\t_polar.radius = 1.0;\n\n\t\t\t\tthis.generationCallback( _polar, _uv, _coord, _color );\n\n\t\t\t\tconst i = y * width + x;\n\t\t\t\tconst i4 = 4 * i;\n\t\t\t\tdata[ i4 + 0 ] = ( _color.r );\n\t\t\t\tdata[ i4 + 1 ] = ( _color.g );\n\t\t\t\tdata[ i4 + 2 ] = ( _color.b );\n\t\t\t\tdata[ i4 + 3 ] = ( 1.0 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( other ) {\n\n\t\tsuper.copy( other );\n\t\tthis.generationCallback = other.generationCallback;\n\t\treturn this;\n\n\t}\n\n}\n","import { ShaderMaterial } from 'three';\n\n// Material that tone maps a texture before performing interpolation to prevent\n// unexpected high values during texture stretching interpolation.\n// Emulates browser image stretching\nexport class ClampedInterpolationMaterial extends ShaderMaterial {\n\n\tget map() {\n\n\t\treturn this.uniforms.map.value;\n\n\t}\n\n\tset map( v ) {\n\n\t\tthis.uniforms.map.value = v;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.uniforms.opacity.value;\n\n\t}\n\n\tset opacity( v ) {\n\n\t\tif ( this.uniforms ) {\n\n\t\t\tthis.uniforms.opacity.value = v;\n\n\t\t}\n\n\t}\n\n\tconstructor( params ) {\n\n\t\tsuper( {\n\t\t\tuniforms: {\n\n\t\t\t\tmap: { value: null },\n\t\t\t\topacity: { value: 1 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform float opacity;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvec4 clampedTexelFatch( sampler2D map, ivec2 px, int lod ) {\n\n\t\t\t\t\tvec4 res = texelFetch( map, ivec2( px.x, px.y ), 0 );\n\n\t\t\t\t\t#if defined( TONE_MAPPING )\n\n\t\t\t\t\tres.xyz = toneMapping( res.xyz );\n\n\t\t\t\t\t#endif\n\n\t\t\t  \t\treturn linearToOutputTexel( res );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec2 size = vec2( textureSize( map, 0 ) );\n\t\t\t\t\tvec2 pxUv = vUv * size;\n\t\t\t\t\tvec2 pxCurr = floor( pxUv );\n\t\t\t\t\tvec2 pxFrac = fract( pxUv ) - 0.5;\n\t\t\t\t\tvec2 pxOffset;\n\t\t\t\t\tpxOffset.x = pxFrac.x > 0.0 ? 1.0 : - 1.0;\n\t\t\t\t\tpxOffset.y = pxFrac.y > 0.0 ? 1.0 : - 1.0;\n\n\t\t\t\t\tvec2 pxNext = clamp( pxOffset + pxCurr, vec2( 0.0 ), size - 1.0 );\n\t\t\t\t\tvec2 alpha = abs( pxFrac );\n\n\t\t\t\t\tvec4 p1 = mix(\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxCurr.x, pxCurr.y ), 0 ),\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxNext.x, pxCurr.y ), 0 ),\n\t\t\t\t\t\talpha.x\n\t\t\t\t\t);\n\n\t\t\t\t\tvec4 p2 = mix(\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxCurr.x, pxNext.y ), 0 ),\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxNext.x, pxNext.y ), 0 ),\n\t\t\t\t\t\talpha.x\n\t\t\t\t\t);\n\n\t\t\t\t\tgl_FragColor = mix( p1, p2, alpha.y );\n\t\t\t\t\tgl_FragColor.a *= opacity;\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\t\t\t`\n\t\t} );\n\n\t\tthis.setValues( params );\n\n\t}\n\n}\n","import {\n\tDataTexture,\n\tDataUtils,\n\tEquirectangularReflectionMapping,\n\tFloatType,\n\tHalfFloatType,\n\tLinearFilter,\n\tLinearMipMapLinearFilter,\n\tRGBAFormat,\n\tRepeatWrapping,\n\tShaderMaterial,\n\tWebGLRenderTarget,\n} from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport * as CommonGLSL from '../shader/common/index.js';\n\nclass CubeToEquirectMaterial extends ShaderMaterial {\n\n\tconstructor() {\n\n\t\tsuper( {\n\n\t\t\tuniforms: {\n\n\t\t\t\tenvMap: { value: null },\n\t\t\t\tflipEnvMap: { value: - 1 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n\t\t\t\tuniform samplerCube envMap;\n\t\t\t\tuniform float flipEnvMap;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t\t${ CommonGLSL.util_functions }\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 rayDirection = equirectUvToDirection( vUv );\n\t\t\t\t\trayDirection.x *= flipEnvMap;\n\t\t\t\t\tgl_FragColor = textureCube( envMap, rayDirection );\n\n\t\t\t\t}`\n\t\t} );\n\n\t\tthis.depthWrite = false;\n\t\tthis.depthTest = false;\n\n\t}\n\n}\n\nexport class CubeToEquirectGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._quad = new FullScreenQuad( new CubeToEquirectMaterial() );\n\n\t}\n\n\tgenerate( source, width = null, height = null ) {\n\n\t\tif ( ! source.isCubeTexture ) {\n\n\t\t\tthrow new Error( 'CubeToEquirectMaterial: Source can only be cube textures.' );\n\n\t\t}\n\n\t\tconst image = source.images[ 0 ];\n\t\tconst renderer = this._renderer;\n\t\tconst quad = this._quad;\n\n\t\t// determine the dimensions if not provided\n\t\tif ( width === null ) {\n\n\t\t\twidth = 4 * image.height;\n\n\t\t}\n\n\t\tif ( height === null ) {\n\n\t\t\theight = 2 * image.height;\n\n\t\t}\n\n\t\tconst target = new WebGLRenderTarget( width, height, {\n\t\t\ttype: FloatType,\n\t\t\tcolorSpace: image.colorSpace,\n\t\t} );\n\n\t\t// prep the cube map data\n\t\tconst imageHeight = image.height;\n\t\tconst maxMip = Math.log2( imageHeight ) - 2;\n\t\tconst texelHeight = 1.0 / imageHeight;\n\t\tconst texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );\n\n\t\tquad.material.defines.CUBEUV_MAX_MIP = `${ maxMip }.0`;\n\t\tquad.material.defines.CUBEUV_TEXEL_WIDTH = texelWidth;\n\t\tquad.material.defines.CUBEUV_TEXEL_HEIGHT = texelHeight;\n\t\tquad.material.uniforms.envMap.value = source;\n\t\tquad.material.uniforms.flipEnvMap.value = source.isRenderTargetTexture ? 1 : - 1;\n\t\tquad.material.needsUpdate = true;\n\n\t\t// save state and render the contents\n\t\tconst currentTarget = renderer.getRenderTarget();\n\t\tconst currentAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = true;\n\t\trenderer.setRenderTarget( target );\n\t\tquad.render( renderer );\n\t\trenderer.setRenderTarget( currentTarget );\n\t\trenderer.autoClear = currentAutoClear;\n\n\t\t// read the data back\n\t\tconst buffer = new Uint16Array( width * height * 4 );\n\t\tconst readBuffer = new Float32Array( width * height * 4 );\n\t\trenderer.readRenderTargetPixels( target, 0, 0, width, height, readBuffer );\n\t\ttarget.dispose();\n\n\t\tfor ( let i = 0, l = readBuffer.length; i < l; i ++ ) {\n\n\t\t\tbuffer[ i ] = DataUtils.toHalfFloat( readBuffer[ i ] );\n\n\t\t}\n\n\t\t// produce the data texture\n\t\tconst result = new DataTexture( buffer, width, height, RGBAFormat, HalfFloatType );\n\t\tresult.minFilter = LinearMipMapLinearFilter;\n\t\tresult.magFilter = LinearFilter;\n\t\tresult.wrapS = RepeatWrapping;\n\t\tresult.wrapT = RepeatWrapping;\n\t\tresult.mapping = EquirectangularReflectionMapping;\n\t\tresult.needsUpdate = true;\n\n\t\treturn result;\n\n\t}\n\n\tdispose() {\n\n\t\tthis._quad.dispose();\n\n\t}\n\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$6171edc1778f11e8$export$3a05a7fb86d40d58","$ilwiq","$hWj76","$hWds8","$RPVlj","$bHiTZ","$9wqOU","$5rCKZ","$5VY8i","$6171edc1778f11e8$var$_resolution","Vector2","multipleImportanceSampling","Boolean","_pathTracer","material","defines","FEATURE_MIS","setDefine","transmissiveBounces","bounces","filterGlossyFactor","samples","target","tiles","stableNoise","isCompiling","constructor","renderer","_renderer","_generator","PathTracingSceneGenerator","PathTracingRenderer","_queueReset","_clock","Clock","_compilePromise","_lowResPathTracer","_quad","FullScreenQuad","ClampedInterpolationMaterial","map","transparent","blending","NoBlending","premultipliedAlpha","getContextAttributes","_materials","_previousEnvironment","_previousBackground","_internalBackground","renderDelay","minSamples","fadeDuration","enablePathTracing","pausePathTracing","dynamicLowRes","lowResScale","renderScale","synchronizeRenderSize","rasterizeScene","renderToCanvas","textureSize","rasterizeSceneCallback","scene","camera","render","renderToCanvasCallback","quad","currentAutoClear","autoClear","setScene","Scene","PerspectiveCamera","setBVHWorker","worker","options","updateMatrixWorld","generator","setObjects","_buildAsync","generateAsync","onProgress","then","result","_updateFromResults","generate","setSceneAsync","args","setCamera","updateCamera","reset","updateMaterials","materials","textures","getTextures","setTextures","x","y","updateFrom","updateLights","lights","getLights","iesTextures","getIesTextures","iesProfiles","updateEnvironment","dispose","backgroundBlur","backgroundBlurriness","backgroundIntensity","backgroundRotation","makeRotationFromEuler","invert","background","backgroundMap","backgroundAlpha","isColor","_colorBackground","GradientEquirectTexture","colorBackground","topColor","equals","bottomColor","update","isCubeTexture","CubeToEquirectGenerator","environmentIntensity","environment","environmentRotation","envMapInfo","results","geometry","bvh","bvhChanged","needsMaterialIndexUpdate","pathTracer","attributesArray","attributes","normal","tangent","uv","color","materialIndexAttribute","materialIndex","_previousScene","renderSample","lowResPathTracer","clock","_updateScale","opacity","start","delta","getDelta","elapsedTime","getElapsedTime","alpha","extensions","Math","min","currentOpacity","texture","AdditiveBlending","NormalBlending","getDrawingBufferSize","w","floor","h","getSize","setSize","$88425f7125b6e46c$export$38d6a241e670a287","$dbdMq","$88425f7125b6e46c$var$_direction","Vector3","ProceduralEquirectTexture","resolution","Color","exponent","generationCallback","polar","coord","setFromSpherical","t","lerpColors","copy","other","$9986fde00d79bc96$export$ab88b3c5fea10066","$9986fde00d79bc96$var$_uv","$9986fde00d79bc96$var$_coord","$9986fde00d79bc96$var$_polar","Spherical","$9986fde00d79bc96$var$_color","DataTexture","width","height","Float32Array","RGBAFormat","FloatType","EquirectangularReflectionMapping","RepeatWrapping","ClampToEdgeWrapping","LinearFilter","needsUpdate","data","image","theta","PI","phi","radius","i4","r","g","b","$3f6d89af35c8e149$export$41f50d3add172b7d","ShaderMaterial","uniforms","value","params","vertexShader","fragmentShader","setValues","$4520ebc51d692c1e$export$6f8f537b668b4bb1","$dUUQZ","$4520ebc51d692c1e$var$CubeToEquirectMaterial","envMap","flipEnvMap","util_functions","depthWrite","depthTest","source","images","WebGLRenderTarget","type","colorSpace","imageHeight","maxMip","log2","CUBEUV_MAX_MIP","CUBEUV_TEXEL_WIDTH","max","pow","CUBEUV_TEXEL_HEIGHT","isRenderTargetTexture","currentTarget","getRenderTarget","setRenderTarget","buffer","Uint16Array","readBuffer","readRenderTargetPixels","i","l","length","DataUtils","toHalfFloat","HalfFloatType","minFilter","LinearMipMapLinearFilter","magFilter","wrapS","wrapT","mapping"],"version":3,"file":"areaLight.1c24b9b9.js.map"}