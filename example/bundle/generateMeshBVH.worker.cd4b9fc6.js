(()=>{function t(t,e,r,n){Object.defineProperty(t,e,{get:r,set:n,enumerable:!0,configurable:!0})}var e=globalThis,r={},n={},i=e.parcelRequire5b70;null==i&&((i=function(t){if(t in r)return r[t].exports;if(t in n){var e=n[t];delete n[t];var i={id:t,exports:{}};return r[t]=i,e.call(i.exports,i,i.exports),i.exports}var s=Error("Cannot find module '"+t+"'");throw s.code="MODULE_NOT_FOUND",s}).register=function(t,e){n[t]=e},e.parcelRequire5b70=i);var s=i.register;s("e06gU",function(e,r){let n;t(e.exports,"FrontSide",()=>i),t(e.exports,"BackSide",()=>s),t(e.exports,"DoubleSide",()=>a),t(e.exports,"MathUtils",()=>S),t(e.exports,"Vector2",()=>A),t(e.exports,"Vector3",()=>H),t(e.exports,"Box3",()=>Y),t(e.exports,"Sphere",()=>td),t(e.exports,"Matrix4",()=>tp),t(e.exports,"Triangle",()=>tK),t(e.exports,"BufferAttribute",()=>t7),t(e.exports,"BufferGeometry",()=>el),t(e.exports,"Plane",()=>em),t(e.exports,"Line3",()=>rC);let i=0,s=1,a=2,o="srgb",l="srgb-linear",h="display-p3-linear",u="linear",c="srgb",d="rec709";class p{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});let r=this._listeners;void 0===r[t]&&(r[t]=[]),-1===r[t].indexOf(e)&&r[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;let r=this._listeners;return void 0!==r[t]&&-1!==r[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;let r=this._listeners[t];if(void 0!==r){let t=r.indexOf(e);-1!==t&&r.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;let e=this._listeners[t.type];if(void 0!==e){t.target=this;let r=e.slice(0);for(let e=0,n=r.length;e<n;e++)r[e].call(this,t);t.target=null}}}let m=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"],f=1234567,g=Math.PI/180,x=180/Math.PI;function y(){let t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,r=4294967295*Math.random()|0,n=4294967295*Math.random()|0;return(m[255&t]+m[t>>8&255]+m[t>>16&255]+m[t>>24&255]+"-"+m[255&e]+m[e>>8&255]+"-"+m[e>>16&15|64]+m[e>>24&255]+"-"+m[63&r|128]+m[r>>8&255]+"-"+m[r>>16&255]+m[r>>24&255]+m[255&n]+m[n>>8&255]+m[n>>16&255]+m[n>>24&255]).toLowerCase()}function _(t,e,r){return Math.max(e,Math.min(r,t))}function v(t,e){return(t%e+e)%e}function b(t,e,r){return(1-r)*t+r*e}function w(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return t/4294967295;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int32Array:return Math.max(t/2147483647,-1);case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw Error("Invalid component type.")}}function M(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return Math.round(4294967295*t);case Uint16Array:return Math.round(65535*t);case Uint8Array:return Math.round(255*t);case Int32Array:return Math.round(2147483647*t);case Int16Array:return Math.round(32767*t);case Int8Array:return Math.round(127*t);default:throw Error("Invalid component type.")}}let S={DEG2RAD:g,RAD2DEG:x,generateUUID:y,clamp:_,euclideanModulo:v,mapLinear:function(t,e,r,n,i){return n+(t-e)*(i-n)/(r-e)},inverseLerp:function(t,e,r){return t!==e?(r-t)/(e-t):0},lerp:b,damp:function(t,e,r,n){return b(t,e,1-Math.exp(-r*n))},pingpong:function(t,e=1){return e-Math.abs(v(t,2*e)-e)},smoothstep:function(t,e,r){return t<=e?0:t>=r?1:(t=(t-e)/(r-e))*t*(3-2*t)},smootherstep:function(t,e,r){return t<=e?0:t>=r?1:(t=(t-e)/(r-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){void 0!==t&&(f=t);let e=f+=1831565813;return e=Math.imul(e^e>>>15,1|e),(((e^=e+Math.imul(e^e>>>7,61|e))^e>>>14)>>>0)/4294967296},degToRad:function(t){return t*g},radToDeg:function(t){return t*x},isPowerOfTwo:function(t){return(t&t-1)==0&&0!==t},ceilPowerOfTwo:function(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))},floorPowerOfTwo:function(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))},setQuaternionFromProperEuler:function(t,e,r,n,i){let s=Math.cos,a=Math.sin,o=s(r/2),l=a(r/2),h=s((e+n)/2),u=a((e+n)/2),c=s((e-n)/2),d=a((e-n)/2),p=s((n-e)/2),m=a((n-e)/2);switch(i){case"XYX":t.set(o*u,l*c,l*d,o*h);break;case"YZY":t.set(l*d,o*u,l*c,o*h);break;case"ZXZ":t.set(l*c,l*d,o*u,o*h);break;case"XZX":t.set(o*u,l*m,l*p,o*h);break;case"YXY":t.set(l*p,o*u,l*m,o*h);break;case"ZYZ":t.set(l*m,l*p,o*u,o*h);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}},normalize:M,denormalize:w};class A{constructor(t=0,e=0){A.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){let e=this.x,r=this.y,n=t.elements;return this.x=n[0]*e+n[3]*r+n[6],this.y=n[1]*e+n[4]*r+n[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){let r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(t,Math.min(e,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){let e=Math.sqrt(this.lengthSq()*t.lengthSq());return 0===e?Math.PI/2:Math.acos(_(this.dot(t)/e,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){let e=this.x-t.x,r=this.y-t.y;return e*e+r*r}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,r){return this.x=t.x+(e.x-t.x)*r,this.y=t.y+(e.y-t.y)*r,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){let r=Math.cos(e),n=Math.sin(e),i=this.x-t.x,s=this.y-t.y;return this.x=i*r-s*n+t.x,this.y=i*n+s*r+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class T{constructor(t,e,r,n,i,s,a,o,l){T.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],void 0!==t&&this.set(t,e,r,n,i,s,a,o,l)}set(t,e,r,n,i,s,a,o,l){let h=this.elements;return h[0]=t,h[1]=n,h[2]=a,h[3]=e,h[4]=i,h[5]=o,h[6]=r,h[7]=s,h[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){let e=this.elements,r=t.elements;return e[0]=r[0],e[1]=r[1],e[2]=r[2],e[3]=r[3],e[4]=r[4],e[5]=r[5],e[6]=r[6],e[7]=r[7],e[8]=r[8],this}extractBasis(t,e,r){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),r.setFromMatrix3Column(this,2),this}setFromMatrix4(t){let e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){let r=t.elements,n=e.elements,i=this.elements,s=r[0],a=r[3],o=r[6],l=r[1],h=r[4],u=r[7],c=r[2],d=r[5],p=r[8],m=n[0],f=n[3],g=n[6],x=n[1],y=n[4],_=n[7],v=n[2],b=n[5],w=n[8];return i[0]=s*m+a*x+o*v,i[3]=s*f+a*y+o*b,i[6]=s*g+a*_+o*w,i[1]=l*m+h*x+u*v,i[4]=l*f+h*y+u*b,i[7]=l*g+h*_+u*w,i[2]=c*m+d*x+p*v,i[5]=c*f+d*y+p*b,i[8]=c*g+d*_+p*w,this}multiplyScalar(t){let e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){let t=this.elements,e=t[0],r=t[1],n=t[2],i=t[3],s=t[4],a=t[5],o=t[6],l=t[7],h=t[8];return e*s*h-e*a*l-r*i*h+r*a*o+n*i*l-n*s*o}invert(){let t=this.elements,e=t[0],r=t[1],n=t[2],i=t[3],s=t[4],a=t[5],o=t[6],l=t[7],h=t[8],u=h*s-a*l,c=a*o-h*i,d=l*i-s*o,p=e*u+r*c+n*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);let m=1/p;return t[0]=u*m,t[1]=(n*l-h*r)*m,t[2]=(a*r-n*s)*m,t[3]=c*m,t[4]=(h*e-n*o)*m,t[5]=(n*i-a*e)*m,t[6]=d*m,t[7]=(r*o-l*e)*m,t[8]=(s*e-r*i)*m,this}transpose(){let t;let e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){let e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,r,n,i,s,a){let o=Math.cos(i),l=Math.sin(i);return this.set(r*o,r*l,-r*(o*s+l*a)+s+t,-n*l,n*o,-n*(-l*s+o*a)+a+e,0,0,1),this}scale(t,e){return this.premultiply(z.makeScale(t,e)),this}rotate(t){return this.premultiply(z.makeRotation(-t)),this}translate(t,e){return this.premultiply(z.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){let e=Math.cos(t),r=Math.sin(t);return this.set(e,-r,0,r,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){let e=this.elements,r=t.elements;for(let t=0;t<9;t++)if(e[t]!==r[t])return!1;return!0}fromArray(t,e=0){for(let r=0;r<9;r++)this.elements[r]=t[r+e];return this}toArray(t=[],e=0){let r=this.elements;return t[e]=r[0],t[e+1]=r[1],t[e+2]=r[2],t[e+3]=r[3],t[e+4]=r[4],t[e+5]=r[5],t[e+6]=r[6],t[e+7]=r[7],t[e+8]=r[8],t}clone(){return new this.constructor().fromArray(this.elements)}}let z=new T;function E(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array;let B={},P=new T().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),N=new T().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),C={[l]:{transfer:u,primaries:d,toReference:t=>t,fromReference:t=>t},[o]:{transfer:c,primaries:d,toReference:t=>t.convertSRGBToLinear(),fromReference:t=>t.convertLinearToSRGB()},[h]:{transfer:u,primaries:"p3",toReference:t=>t.applyMatrix3(N),fromReference:t=>t.applyMatrix3(P)},"display-p3":{transfer:c,primaries:"p3",toReference:t=>t.convertSRGBToLinear().applyMatrix3(N),fromReference:t=>t.applyMatrix3(P).convertLinearToSRGB()}},O=new Set([l,h]),k={enabled:!0,_workingColorSpace:l,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(colorSpace){if(!O.has(colorSpace))throw Error(`Unsupported working color space, "${colorSpace}".`);this._workingColorSpace=colorSpace},convert:function(t,e,r){if(!1===this.enabled||e===r||!e||!r)return t;let n=C[e].toReference;return(0,C[r].fromReference)(n(t))},fromWorkingColorSpace:function(t,e){return this.convert(t,this._workingColorSpace,e)},toWorkingColorSpace:function(t,e){return this.convert(t,e,this._workingColorSpace)},getPrimaries:function(t){return C[t].primaries},getTransfer:function(t){return""===t?u:C[t].transfer}};function I(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function R(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}class V{static getDataURL(t){let e;if(/^data:/i.test(t.src)||"undefined"==typeof HTMLCanvasElement)return t.src;if(t instanceof HTMLCanvasElement)e=t;else{void 0===n&&(n=E("canvas")),n.width=t.width,n.height=t.height;let r=n.getContext("2d");t instanceof ImageData?r.putImageData(t,0,0):r.drawImage(t,0,0,t.width,t.height),e=n}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){let e=E("canvas");e.width=t.width,e.height=t.height;let r=e.getContext("2d");r.drawImage(t,0,0,t.width,t.height);let n=r.getImageData(0,0,t.width,t.height),i=n.data;for(let t=0;t<i.length;t++)i[t]=255*I(i[t]/255);return r.putImageData(n,0,0),e}if(!t.data)return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t;{let e=t.data.slice(0);for(let t=0;t<e.length;t++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[t]=Math.floor(255*I(e[t]/255)):e[t]=I(e[t]);return{data:e,width:t.width,height:t.height}}}}let F=0;class L{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:F++}),this.uuid=y(),this.data=t,this.dataReady=!0,this.version=0}set needsUpdate(t){!0===t&&this.version++}toJSON(t){let e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.images[this.uuid])return t.images[this.uuid];let r={uuid:this.uuid,url:""},n=this.data;if(null!==n){let t;if(Array.isArray(n)){t=[];for(let e=0,r=n.length;e<r;e++)n[e].isDataTexture?t.push(D(n[e].image)):t.push(D(n[e]))}else t=D(n);r.url=t}return e||(t.images[this.uuid]=r),r}}function D(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?V.getDataURL(t):t.data?{data:Array.from(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let U=0;class G extends p{constructor(t=G.DEFAULT_IMAGE,e=G.DEFAULT_MAPPING,r=1001,n=1001,i=1006,s=1008,a=1023,o=1009,l=G.DEFAULT_ANISOTROPY,h=""){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:U++}),this.uuid=y(),this.name="",this.source=new L(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=r,this.wrapT=n,this.magFilter=i,this.minFilter=s,this.anisotropy=l,this.format=a,this.internalFormat=null,this.type=o,this.offset=new A(0,0),this.repeat=new A(1,1),this.center=new A(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new T,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=h,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){let e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];let r={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(r.userData=this.userData),e||(t.textures[this.uuid]=r),r}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(300!==this.mapping)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case 1e3:t.x=t.x-Math.floor(t.x);break;case 1001:t.x=t.x<0?0:1;break;case 1002:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case 1e3:t.y=t.y-Math.floor(t.y);break;case 1001:t.y=t.y<0?0:1;break;case 1002:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(t){!0===t&&this.pmremVersion++}}G.DEFAULT_IMAGE=null,G.DEFAULT_MAPPING=300,G.DEFAULT_ANISOTROPY=1;class q{constructor(t=0,e=0,r=0,n=1){q.prototype.isVector4=!0,this.x=t,this.y=e,this.z=r,this.w=n}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,r,n){return this.x=t,this.y=e,this.z=r,this.w=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){let e=this.x,r=this.y,n=this.z,i=this.w,s=t.elements;return this.x=s[0]*e+s[4]*r+s[8]*n+s[12]*i,this.y=s[1]*e+s[5]*r+s[9]*n+s[13]*i,this.z=s[2]*e+s[6]*r+s[10]*n+s[14]*i,this.w=s[3]*e+s[7]*r+s[11]*n+s[15]*i,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);let e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,r,n,i;let s=t.elements,a=s[0],o=s[4],l=s[8],h=s[1],u=s[5],c=s[9],d=s[2],p=s[6],m=s[10];if(.01>Math.abs(o-h)&&.01>Math.abs(l-d)&&.01>Math.abs(c-p)){if(.1>Math.abs(o+h)&&.1>Math.abs(l+d)&&.1>Math.abs(c+p)&&.1>Math.abs(a+u+m-3))return this.set(1,0,0,0),this;e=Math.PI;let t=(a+1)/2,s=(u+1)/2,f=(m+1)/2,g=(o+h)/4,x=(l+d)/4,y=(c+p)/4;return t>s&&t>f?t<.01?(r=0,n=.707106781,i=.707106781):(n=g/(r=Math.sqrt(t)),i=x/r):s>f?s<.01?(r=.707106781,n=0,i=.707106781):(r=g/(n=Math.sqrt(s)),i=y/n):f<.01?(r=.707106781,n=.707106781,i=0):(r=x/(i=Math.sqrt(f)),n=y/i),this.set(r,n,i,e),this}let f=Math.sqrt((p-c)*(p-c)+(l-d)*(l-d)+(h-o)*(h-o));return .001>Math.abs(f)&&(f=1),this.x=(p-c)/f,this.y=(l-d)/f,this.z=(h-o)/f,this.w=Math.acos((a+u+m-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){let r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(t,Math.min(e,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,r){return this.x=t.x+(e.x-t.x)*r,this.y=t.y+(e.y-t.y)*r,this.z=t.z+(e.z-t.z)*r,this.w=t.w+(e.w-t.w)*r,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class j{constructor(t=0,e=0,r=0,n=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=r,this._w=n}static slerpFlat(t,e,r,n,i,s,a){let o=r[n+0],l=r[n+1],h=r[n+2],u=r[n+3],c=i[s+0],d=i[s+1],p=i[s+2],m=i[s+3];if(0===a){t[e+0]=o,t[e+1]=l,t[e+2]=h,t[e+3]=u;return}if(1===a){t[e+0]=c,t[e+1]=d,t[e+2]=p,t[e+3]=m;return}if(u!==m||o!==c||l!==d||h!==p){let t=1-a,e=o*c+l*d+h*p+u*m,r=e>=0?1:-1,n=1-e*e;if(n>Number.EPSILON){let i=Math.sqrt(n),s=Math.atan2(i,e*r);t=Math.sin(t*s)/i,a=Math.sin(a*s)/i}let i=a*r;if(o=o*t+c*i,l=l*t+d*i,h=h*t+p*i,u=u*t+m*i,t===1-a){let t=1/Math.sqrt(o*o+l*l+h*h+u*u);o*=t,l*=t,h*=t,u*=t}}t[e]=o,t[e+1]=l,t[e+2]=h,t[e+3]=u}static multiplyQuaternionsFlat(t,e,r,n,i,s){let a=r[n],o=r[n+1],l=r[n+2],h=r[n+3],u=i[s],c=i[s+1],d=i[s+2],p=i[s+3];return t[e]=a*p+h*u+o*d-l*c,t[e+1]=o*p+h*c+l*u-a*d,t[e+2]=l*p+h*d+a*c-o*u,t[e+3]=h*p-a*u-o*c-l*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,r,n){return this._x=t,this._y=e,this._z=r,this._w=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){let r=t._x,n=t._y,i=t._z,s=t._order,a=Math.cos,o=Math.sin,l=a(r/2),h=a(n/2),u=a(i/2),c=o(r/2),d=o(n/2),p=o(i/2);switch(s){case"XYZ":this._x=c*h*u+l*d*p,this._y=l*d*u-c*h*p,this._z=l*h*p+c*d*u,this._w=l*h*u-c*d*p;break;case"YXZ":this._x=c*h*u+l*d*p,this._y=l*d*u-c*h*p,this._z=l*h*p-c*d*u,this._w=l*h*u+c*d*p;break;case"ZXY":this._x=c*h*u-l*d*p,this._y=l*d*u+c*h*p,this._z=l*h*p+c*d*u,this._w=l*h*u-c*d*p;break;case"ZYX":this._x=c*h*u-l*d*p,this._y=l*d*u+c*h*p,this._z=l*h*p-c*d*u,this._w=l*h*u+c*d*p;break;case"YZX":this._x=c*h*u+l*d*p,this._y=l*d*u+c*h*p,this._z=l*h*p-c*d*u,this._w=l*h*u-c*d*p;break;case"XZY":this._x=c*h*u-l*d*p,this._y=l*d*u-c*h*p,this._z=l*h*p+c*d*u,this._w=l*h*u+c*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!0===e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){let r=e/2,n=Math.sin(r);return this._x=t.x*n,this._y=t.y*n,this._z=t.z*n,this._w=Math.cos(r),this._onChangeCallback(),this}setFromRotationMatrix(t){let e=t.elements,r=e[0],n=e[4],i=e[8],s=e[1],a=e[5],o=e[9],l=e[2],h=e[6],u=e[10],c=r+a+u;if(c>0){let t=.5/Math.sqrt(c+1);this._w=.25/t,this._x=(h-o)*t,this._y=(i-l)*t,this._z=(s-n)*t}else if(r>a&&r>u){let t=2*Math.sqrt(1+r-a-u);this._w=(h-o)/t,this._x=.25*t,this._y=(n+s)/t,this._z=(i+l)/t}else if(a>u){let t=2*Math.sqrt(1+a-r-u);this._w=(i-l)/t,this._x=(n+s)/t,this._y=.25*t,this._z=(o+h)/t}else{let t=2*Math.sqrt(1+u-r-a);this._w=(s-n)/t,this._x=(i+l)/t,this._y=(o+h)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let r=t.dot(e)+1;return r<Number.EPSILON?(r=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0):(this._x=0,this._y=-t.z,this._z=t.y)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x),this._w=r,this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(_(this.dot(t),-1,1)))}rotateTowards(t,e){let r=this.angleTo(t);return 0===r||this.slerp(t,Math.min(1,e/r)),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){let r=t._x,n=t._y,i=t._z,s=t._w,a=e._x,o=e._y,l=e._z,h=e._w;return this._x=r*h+s*a+n*l-i*o,this._y=n*h+s*o+i*a-r*l,this._z=i*h+s*l+r*o-n*a,this._w=s*h-r*a-n*o-i*l,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);let r=this._x,n=this._y,i=this._z,s=this._w,a=s*t._w+r*t._x+n*t._y+i*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=s,this._x=r,this._y=n,this._z=i,this;let o=1-a*a;if(o<=Number.EPSILON){let t=1-e;return this._w=t*s+e*this._w,this._x=t*r+e*this._x,this._y=t*n+e*this._y,this._z=t*i+e*this._z,this.normalize(),this}let l=Math.sqrt(o),h=Math.atan2(l,a),u=Math.sin((1-e)*h)/l,c=Math.sin(e*h)/l;return this._w=s*u+this._w*c,this._x=r*u+this._x*c,this._y=n*u+this._y*c,this._z=i*u+this._z*c,this._onChangeCallback(),this}slerpQuaternions(t,e,r){return this.copy(t).slerp(e,r)}random(){let t=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),r=Math.random(),n=Math.sqrt(1-r),i=Math.sqrt(r);return this.set(n*Math.sin(t),n*Math.cos(t),i*Math.sin(e),i*Math.cos(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class H{constructor(t=0,e=0,r=0){H.prototype.isVector3=!0,this.x=t,this.y=e,this.z=r}set(t,e,r){return void 0===r&&(r=this.z),this.x=t,this.y=e,this.z=r,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(X.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(X.setFromAxisAngle(t,e))}applyMatrix3(t){let e=this.x,r=this.y,n=this.z,i=t.elements;return this.x=i[0]*e+i[3]*r+i[6]*n,this.y=i[1]*e+i[4]*r+i[7]*n,this.z=i[2]*e+i[5]*r+i[8]*n,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){let e=this.x,r=this.y,n=this.z,i=t.elements,s=1/(i[3]*e+i[7]*r+i[11]*n+i[15]);return this.x=(i[0]*e+i[4]*r+i[8]*n+i[12])*s,this.y=(i[1]*e+i[5]*r+i[9]*n+i[13])*s,this.z=(i[2]*e+i[6]*r+i[10]*n+i[14])*s,this}applyQuaternion(t){let e=this.x,r=this.y,n=this.z,i=t.x,s=t.y,a=t.z,o=t.w,l=2*(s*n-a*r),h=2*(a*e-i*n),u=2*(i*r-s*e);return this.x=e+o*l+s*u-a*h,this.y=r+o*h+a*l-i*u,this.z=n+o*u+i*h-s*l,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){let e=this.x,r=this.y,n=this.z,i=t.elements;return this.x=i[0]*e+i[4]*r+i[8]*n,this.y=i[1]*e+i[5]*r+i[9]*n,this.z=i[2]*e+i[6]*r+i[10]*n,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){let r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(t,Math.min(e,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,r){return this.x=t.x+(e.x-t.x)*r,this.y=t.y+(e.y-t.y)*r,this.z=t.z+(e.z-t.z)*r,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){let r=t.x,n=t.y,i=t.z,s=e.x,a=e.y,o=e.z;return this.x=n*o-i*a,this.y=i*s-r*o,this.z=r*a-n*s,this}projectOnVector(t){let e=t.lengthSq();if(0===e)return this.set(0,0,0);let r=t.dot(this)/e;return this.copy(t).multiplyScalar(r)}projectOnPlane(t){return W.copy(this).projectOnVector(t),this.sub(W)}reflect(t){return this.sub(W.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){let e=Math.sqrt(this.lengthSq()*t.lengthSq());return 0===e?Math.PI/2:Math.acos(_(this.dot(t)/e,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){let e=this.x-t.x,r=this.y-t.y,n=this.z-t.z;return e*e+r*r+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,r){let n=Math.sin(e)*t;return this.x=n*Math.sin(r),this.y=Math.cos(e)*t,this.z=n*Math.cos(r),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,r){return this.x=t*Math.sin(e),this.y=r,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){let e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){let e=this.setFromMatrixColumn(t,0).length(),r=this.setFromMatrixColumn(t,1).length(),n=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=r,this.z=n,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){let t=Math.random()*Math.PI*2,e=2*Math.random()-1,r=Math.sqrt(1-e*e);return this.x=r*Math.cos(t),this.y=e,this.z=r*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}let W=new H,X=new j;class Y{constructor(t=new H(1/0,1/0,1/0),e=new H(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,r=t.length;e<r;e+=3)this.expandByPoint(J.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,r=t.count;e<r;e++)this.expandByPoint(J.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,r=t.length;e<r;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){let r=J.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(r),this.max.copy(t).add(r),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);let r=t.geometry;if(void 0!==r){let n=r.getAttribute("position");if(!0===e&&void 0!==n&&!0!==t.isInstancedMesh)for(let e=0,r=n.count;e<r;e++)!0===t.isMesh?t.getVertexPosition(e,J):J.fromBufferAttribute(n,e),J.applyMatrix4(t.matrixWorld),this.expandByPoint(J);else void 0!==t.boundingBox?(null===t.boundingBox&&t.computeBoundingBox(),K.copy(t.boundingBox)):(null===r.boundingBox&&r.computeBoundingBox(),K.copy(r.boundingBox)),K.applyMatrix4(t.matrixWorld),this.union(K)}let n=t.children;for(let t=0,r=n.length;t<r;t++)this.expandByObject(n[t],e);return this}containsPoint(t){return!(t.x<this.min.x)&&!(t.x>this.max.x)&&!(t.y<this.min.y)&&!(t.y>this.max.y)&&!(t.z<this.min.z)&&!(t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x)&&!(t.min.x>this.max.x)&&!(t.max.y<this.min.y)&&!(t.min.y>this.max.y)&&!(t.max.z<this.min.z)&&!(t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,J),J.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,r;return t.normal.x>0?(e=t.normal.x*this.min.x,r=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,r=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,r+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,r+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,r+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,r+=t.normal.z*this.min.z),e<=-t.constant&&r>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(ti),ts.subVectors(this.max,ti),Q.subVectors(t.a,ti),$.subVectors(t.b,ti),tt.subVectors(t.c,ti),te.subVectors($,Q),tr.subVectors(tt,$),tn.subVectors(Q,tt);let e=[0,-te.z,te.y,0,-tr.z,tr.y,0,-tn.z,tn.y,te.z,0,-te.x,tr.z,0,-tr.x,tn.z,0,-tn.x,-te.y,te.x,0,-tr.y,tr.x,0,-tn.y,tn.x,0];return!!(tl(e,Q,$,tt,ts)&&tl(e=[1,0,0,0,1,0,0,0,1],Q,$,tt,ts))&&(ta.crossVectors(te,tr),tl(e=[ta.x,ta.y,ta.z],Q,$,tt,ts))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,J).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=.5*this.getSize(J).length()),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(Z[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),Z[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),Z[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),Z[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),Z[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),Z[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),Z[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),Z[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(Z)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}let Z=[new H,new H,new H,new H,new H,new H,new H,new H],J=new H,K=new Y,Q=new H,$=new H,tt=new H,te=new H,tr=new H,tn=new H,ti=new H,ts=new H,ta=new H,to=new H;function tl(t,e,r,n,i){for(let s=0,a=t.length-3;s<=a;s+=3){to.fromArray(t,s);let a=i.x*Math.abs(to.x)+i.y*Math.abs(to.y)+i.z*Math.abs(to.z),o=e.dot(to),l=r.dot(to),h=n.dot(to);if(Math.max(-Math.max(o,l,h),Math.min(o,l,h))>a)return!1}return!0}let th=new Y,tu=new H,tc=new H;class td{constructor(t=new H,e=-1){this.isSphere=!0,this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){let r=this.center;void 0!==e?r.copy(e):th.setFromPoints(t).getCenter(r);let n=0;for(let e=0,i=t.length;e<i;e++)n=Math.max(n,r.distanceToSquared(t[e]));return this.radius=Math.sqrt(n),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){let e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){let r=this.center.distanceToSquared(t);return e.copy(t),r>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?t.makeEmpty():(t.set(this.center,this.center),t.expandByScalar(this.radius)),t}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;tu.subVectors(t,this.center);let e=tu.lengthSq();if(e>this.radius*this.radius){let t=Math.sqrt(e),r=(t-this.radius)*.5;this.center.addScaledVector(tu,r/t),this.radius+=r}return this}union(t){return t.isEmpty()||(this.isEmpty()?this.copy(t):!0===this.center.equals(t.center)?this.radius=Math.max(this.radius,t.radius):(tc.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(tu.copy(t.center).add(tc)),this.expandByPoint(tu.copy(t.center).sub(tc)))),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}class tp{constructor(t,e,r,n,i,s,a,o,l,h,u,c,d,p,m,f){tp.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],void 0!==t&&this.set(t,e,r,n,i,s,a,o,l,h,u,c,d,p,m,f)}set(t,e,r,n,i,s,a,o,l,h,u,c,d,p,m,f){let g=this.elements;return g[0]=t,g[4]=e,g[8]=r,g[12]=n,g[1]=i,g[5]=s,g[9]=a,g[13]=o,g[2]=l,g[6]=h,g[10]=u,g[14]=c,g[3]=d,g[7]=p,g[11]=m,g[15]=f,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new tp().fromArray(this.elements)}copy(t){let e=this.elements,r=t.elements;return e[0]=r[0],e[1]=r[1],e[2]=r[2],e[3]=r[3],e[4]=r[4],e[5]=r[5],e[6]=r[6],e[7]=r[7],e[8]=r[8],e[9]=r[9],e[10]=r[10],e[11]=r[11],e[12]=r[12],e[13]=r[13],e[14]=r[14],e[15]=r[15],this}copyPosition(t){let e=this.elements,r=t.elements;return e[12]=r[12],e[13]=r[13],e[14]=r[14],this}setFromMatrix3(t){let e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,r){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),r.setFromMatrixColumn(this,2),this}makeBasis(t,e,r){return this.set(t.x,e.x,r.x,0,t.y,e.y,r.y,0,t.z,e.z,r.z,0,0,0,0,1),this}extractRotation(t){let e=this.elements,r=t.elements,n=1/tm.setFromMatrixColumn(t,0).length(),i=1/tm.setFromMatrixColumn(t,1).length(),s=1/tm.setFromMatrixColumn(t,2).length();return e[0]=r[0]*n,e[1]=r[1]*n,e[2]=r[2]*n,e[3]=0,e[4]=r[4]*i,e[5]=r[5]*i,e[6]=r[6]*i,e[7]=0,e[8]=r[8]*s,e[9]=r[9]*s,e[10]=r[10]*s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){let e=this.elements,r=t.x,n=t.y,i=t.z,s=Math.cos(r),a=Math.sin(r),o=Math.cos(n),l=Math.sin(n),h=Math.cos(i),u=Math.sin(i);if("XYZ"===t.order){let t=s*h,r=s*u,n=a*h,i=a*u;e[0]=o*h,e[4]=-o*u,e[8]=l,e[1]=r+n*l,e[5]=t-i*l,e[9]=-a*o,e[2]=i-t*l,e[6]=n+r*l,e[10]=s*o}else if("YXZ"===t.order){let t=o*h,r=o*u,n=l*h,i=l*u;e[0]=t+i*a,e[4]=n*a-r,e[8]=s*l,e[1]=s*u,e[5]=s*h,e[9]=-a,e[2]=r*a-n,e[6]=i+t*a,e[10]=s*o}else if("ZXY"===t.order){let t=o*h,r=o*u,n=l*h,i=l*u;e[0]=t-i*a,e[4]=-s*u,e[8]=n+r*a,e[1]=r+n*a,e[5]=s*h,e[9]=i-t*a,e[2]=-s*l,e[6]=a,e[10]=s*o}else if("ZYX"===t.order){let t=s*h,r=s*u,n=a*h,i=a*u;e[0]=o*h,e[4]=n*l-r,e[8]=t*l+i,e[1]=o*u,e[5]=i*l+t,e[9]=r*l-n,e[2]=-l,e[6]=a*o,e[10]=s*o}else if("YZX"===t.order){let t=s*o,r=s*l,n=a*o,i=a*l;e[0]=o*h,e[4]=i-t*u,e[8]=n*u+r,e[1]=u,e[5]=s*h,e[9]=-a*h,e[2]=-l*h,e[6]=r*u+n,e[10]=t-i*u}else if("XZY"===t.order){let t=s*o,r=s*l,n=a*o,i=a*l;e[0]=o*h,e[4]=-u,e[8]=l*h,e[1]=t*u+i,e[5]=s*h,e[9]=r*u-n,e[2]=n*u-r,e[6]=a*h,e[10]=i*u+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(tg,t,tx)}lookAt(t,e,r){let n=this.elements;return tv.subVectors(t,e),0===tv.lengthSq()&&(tv.z=1),tv.normalize(),ty.crossVectors(r,tv),0===ty.lengthSq()&&(1===Math.abs(r.z)?tv.x+=1e-4:tv.z+=1e-4,tv.normalize(),ty.crossVectors(r,tv)),ty.normalize(),t_.crossVectors(tv,ty),n[0]=ty.x,n[4]=t_.x,n[8]=tv.x,n[1]=ty.y,n[5]=t_.y,n[9]=tv.y,n[2]=ty.z,n[6]=t_.z,n[10]=tv.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){let r=t.elements,n=e.elements,i=this.elements,s=r[0],a=r[4],o=r[8],l=r[12],h=r[1],u=r[5],c=r[9],d=r[13],p=r[2],m=r[6],f=r[10],g=r[14],x=r[3],y=r[7],_=r[11],v=r[15],b=n[0],w=n[4],M=n[8],S=n[12],A=n[1],T=n[5],z=n[9],E=n[13],B=n[2],P=n[6],N=n[10],C=n[14],O=n[3],k=n[7],I=n[11],R=n[15];return i[0]=s*b+a*A+o*B+l*O,i[4]=s*w+a*T+o*P+l*k,i[8]=s*M+a*z+o*N+l*I,i[12]=s*S+a*E+o*C+l*R,i[1]=h*b+u*A+c*B+d*O,i[5]=h*w+u*T+c*P+d*k,i[9]=h*M+u*z+c*N+d*I,i[13]=h*S+u*E+c*C+d*R,i[2]=p*b+m*A+f*B+g*O,i[6]=p*w+m*T+f*P+g*k,i[10]=p*M+m*z+f*N+g*I,i[14]=p*S+m*E+f*C+g*R,i[3]=x*b+y*A+_*B+v*O,i[7]=x*w+y*T+_*P+v*k,i[11]=x*M+y*z+_*N+v*I,i[15]=x*S+y*E+_*C+v*R,this}multiplyScalar(t){let e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){let t=this.elements,e=t[0],r=t[4],n=t[8],i=t[12],s=t[1],a=t[5],o=t[9],l=t[13],h=t[2],u=t[6],c=t[10],d=t[14],p=t[3];return p*(+i*o*u-n*l*u-i*a*c+r*l*c+n*a*d-r*o*d)+t[7]*(+e*o*d-e*l*c+i*s*c-n*s*d+n*l*h-i*o*h)+t[11]*(+e*l*u-e*a*d-i*s*u+r*s*d+i*a*h-r*l*h)+t[15]*(-n*a*h-e*o*u+e*a*c+n*s*u-r*s*c+r*o*h)}transpose(){let t;let e=this.elements;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(t,e,r){let n=this.elements;return t.isVector3?(n[12]=t.x,n[13]=t.y,n[14]=t.z):(n[12]=t,n[13]=e,n[14]=r),this}invert(){let t=this.elements,e=t[0],r=t[1],n=t[2],i=t[3],s=t[4],a=t[5],o=t[6],l=t[7],h=t[8],u=t[9],c=t[10],d=t[11],p=t[12],m=t[13],f=t[14],g=t[15],x=u*f*l-m*c*l+m*o*d-a*f*d-u*o*g+a*c*g,y=p*c*l-h*f*l-p*o*d+s*f*d+h*o*g-s*c*g,_=h*m*l-p*u*l+p*a*d-s*m*d-h*a*g+s*u*g,v=p*u*o-h*m*o-p*a*c+s*m*c+h*a*f-s*u*f,b=e*x+r*y+n*_+i*v;if(0===b)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);let w=1/b;return t[0]=x*w,t[1]=(m*c*i-u*f*i-m*n*d+r*f*d+u*n*g-r*c*g)*w,t[2]=(a*f*i-m*o*i+m*n*l-r*f*l-a*n*g+r*o*g)*w,t[3]=(u*o*i-a*c*i-u*n*l+r*c*l+a*n*d-r*o*d)*w,t[4]=y*w,t[5]=(h*f*i-p*c*i+p*n*d-e*f*d-h*n*g+e*c*g)*w,t[6]=(p*o*i-s*f*i-p*n*l+e*f*l+s*n*g-e*o*g)*w,t[7]=(s*c*i-h*o*i+h*n*l-e*c*l-s*n*d+e*o*d)*w,t[8]=_*w,t[9]=(p*u*i-h*m*i-p*r*d+e*m*d+h*r*g-e*u*g)*w,t[10]=(s*m*i-p*a*i+p*r*l-e*m*l-s*r*g+e*a*g)*w,t[11]=(h*a*i-s*u*i-h*r*l+e*u*l+s*r*d-e*a*d)*w,t[12]=v*w,t[13]=(h*m*n-p*u*n+p*r*c-e*m*c-h*r*f+e*u*f)*w,t[14]=(p*a*n-s*m*n-p*r*o+e*m*o+s*r*f-e*a*f)*w,t[15]=(s*u*n-h*a*n+h*r*o-e*u*o-s*r*c+e*a*c)*w,this}scale(t){let e=this.elements,r=t.x,n=t.y,i=t.z;return e[0]*=r,e[4]*=n,e[8]*=i,e[1]*=r,e[5]*=n,e[9]*=i,e[2]*=r,e[6]*=n,e[10]*=i,e[3]*=r,e[7]*=n,e[11]*=i,this}getMaxScaleOnAxis(){let t=this.elements;return Math.sqrt(Math.max(t[0]*t[0]+t[1]*t[1]+t[2]*t[2],t[4]*t[4]+t[5]*t[5]+t[6]*t[6],t[8]*t[8]+t[9]*t[9]+t[10]*t[10]))}makeTranslation(t,e,r){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,r,0,0,0,1),this}makeRotationX(t){let e=Math.cos(t),r=Math.sin(t);return this.set(1,0,0,0,0,e,-r,0,0,r,e,0,0,0,0,1),this}makeRotationY(t){let e=Math.cos(t),r=Math.sin(t);return this.set(e,0,r,0,0,1,0,0,-r,0,e,0,0,0,0,1),this}makeRotationZ(t){let e=Math.cos(t),r=Math.sin(t);return this.set(e,-r,0,0,r,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){let r=Math.cos(e),n=Math.sin(e),i=1-r,s=t.x,a=t.y,o=t.z,l=i*s,h=i*a;return this.set(l*s+r,l*a-n*o,l*o+n*a,0,l*a+n*o,h*a+r,h*o-n*s,0,l*o-n*a,h*o+n*s,i*o*o+r,0,0,0,0,1),this}makeScale(t,e,r){return this.set(t,0,0,0,0,e,0,0,0,0,r,0,0,0,0,1),this}makeShear(t,e,r,n,i,s){return this.set(1,r,i,0,t,1,s,0,e,n,1,0,0,0,0,1),this}compose(t,e,r){let n=this.elements,i=e._x,s=e._y,a=e._z,o=e._w,l=i+i,h=s+s,u=a+a,c=i*l,d=i*h,p=i*u,m=s*h,f=s*u,g=a*u,x=o*l,y=o*h,_=o*u,v=r.x,b=r.y,w=r.z;return n[0]=(1-(m+g))*v,n[1]=(d+_)*v,n[2]=(p-y)*v,n[3]=0,n[4]=(d-_)*b,n[5]=(1-(c+g))*b,n[6]=(f+x)*b,n[7]=0,n[8]=(p+y)*w,n[9]=(f-x)*w,n[10]=(1-(c+m))*w,n[11]=0,n[12]=t.x,n[13]=t.y,n[14]=t.z,n[15]=1,this}decompose(t,e,r){let n=this.elements,i=tm.set(n[0],n[1],n[2]).length(),s=tm.set(n[4],n[5],n[6]).length(),a=tm.set(n[8],n[9],n[10]).length();0>this.determinant()&&(i=-i),t.x=n[12],t.y=n[13],t.z=n[14],tf.copy(this);let o=1/i,l=1/s,h=1/a;return tf.elements[0]*=o,tf.elements[1]*=o,tf.elements[2]*=o,tf.elements[4]*=l,tf.elements[5]*=l,tf.elements[6]*=l,tf.elements[8]*=h,tf.elements[9]*=h,tf.elements[10]*=h,e.setFromRotationMatrix(tf),r.x=i,r.y=s,r.z=a,this}makePerspective(t,e,r,n,i,s,a=2e3){let o,l;let h=this.elements;if(2e3===a)o=-(s+i)/(s-i),l=-2*s*i/(s-i);else if(2001===a)o=-s/(s-i),l=-s*i/(s-i);else throw Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);return h[0]=2*i/(e-t),h[4]=0,h[8]=(e+t)/(e-t),h[12]=0,h[1]=0,h[5]=2*i/(r-n),h[9]=(r+n)/(r-n),h[13]=0,h[2]=0,h[6]=0,h[10]=o,h[14]=l,h[3]=0,h[7]=0,h[11]=-1,h[15]=0,this}makeOrthographic(t,e,r,n,i,s,a=2e3){let o,l;let h=this.elements,u=1/(e-t),c=1/(r-n),d=1/(s-i);if(2e3===a)o=(s+i)*d,l=-2*d;else if(2001===a)o=i*d,l=-1*d;else throw Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);return h[0]=2*u,h[4]=0,h[8]=0,h[12]=-((e+t)*u),h[1]=0,h[5]=2*c,h[9]=0,h[13]=-((r+n)*c),h[2]=0,h[6]=0,h[10]=l,h[14]=-o,h[3]=0,h[7]=0,h[11]=0,h[15]=1,this}equals(t){let e=this.elements,r=t.elements;for(let t=0;t<16;t++)if(e[t]!==r[t])return!1;return!0}fromArray(t,e=0){for(let r=0;r<16;r++)this.elements[r]=t[r+e];return this}toArray(t=[],e=0){let r=this.elements;return t[e]=r[0],t[e+1]=r[1],t[e+2]=r[2],t[e+3]=r[3],t[e+4]=r[4],t[e+5]=r[5],t[e+6]=r[6],t[e+7]=r[7],t[e+8]=r[8],t[e+9]=r[9],t[e+10]=r[10],t[e+11]=r[11],t[e+12]=r[12],t[e+13]=r[13],t[e+14]=r[14],t[e+15]=r[15],t}}let tm=new H,tf=new tp,tg=new H(0,0,0),tx=new H(1,1,1),ty=new H,t_=new H,tv=new H,tb=new tp,tw=new j;class tM{constructor(t=0,e=0,r=0,n=tM.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=r,this._order=n}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,r,n=this._order){return this._x=t,this._y=e,this._z=r,this._order=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,r=!0){let n=t.elements,i=n[0],s=n[4],a=n[8],o=n[1],l=n[5],h=n[9],u=n[2],c=n[6],d=n[10];switch(e){case"XYZ":this._y=Math.asin(_(a,-1,1)),.9999999>Math.abs(a)?(this._x=Math.atan2(-h,d),this._z=Math.atan2(-s,i)):(this._x=Math.atan2(c,l),this._z=0);break;case"YXZ":this._x=Math.asin(-_(h,-1,1)),.9999999>Math.abs(h)?(this._y=Math.atan2(a,d),this._z=Math.atan2(o,l)):(this._y=Math.atan2(-u,i),this._z=0);break;case"ZXY":this._x=Math.asin(_(c,-1,1)),.9999999>Math.abs(c)?(this._y=Math.atan2(-u,d),this._z=Math.atan2(-s,l)):(this._y=0,this._z=Math.atan2(o,i));break;case"ZYX":this._y=Math.asin(-_(u,-1,1)),.9999999>Math.abs(u)?(this._x=Math.atan2(c,d),this._z=Math.atan2(o,i)):(this._x=0,this._z=Math.atan2(-s,l));break;case"YZX":this._z=Math.asin(_(o,-1,1)),.9999999>Math.abs(o)?(this._x=Math.atan2(-h,l),this._y=Math.atan2(-u,i)):(this._x=0,this._y=Math.atan2(a,d));break;case"XZY":this._z=Math.asin(-_(s,-1,1)),.9999999>Math.abs(s)?(this._x=Math.atan2(c,l),this._y=Math.atan2(a,i)):(this._x=Math.atan2(-h,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===r&&this._onChangeCallback(),this}setFromQuaternion(t,e,r){return tb.makeRotationFromQuaternion(t),this.setFromRotationMatrix(tb,e,r)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return tw.setFromEuler(this),this.setFromQuaternion(tw,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}tM.DEFAULT_ORDER="XYZ";class tS{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!=0}isEnabled(t){return(this.mask&(1<<t|0))!=0}}let tA=0,tT=new H,tz=new j,tE=new tp,tB=new H,tP=new H,tN=new H,tC=new j,tO=new H(1,0,0),tk=new H(0,1,0),tI=new H(0,0,1),tR={type:"added"},tV={type:"removed"},tF={type:"childadded",child:null},tL={type:"childremoved",child:null};class tD extends p{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:tA++}),this.uuid=y(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=tD.DEFAULT_UP.clone();let t=new H,e=new tM,r=new j,n=new H(1,1,1);e._onChange(function(){r.setFromEuler(e,!1)}),r._onChange(function(){e.setFromQuaternion(r,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:r},scale:{configurable:!0,enumerable:!0,value:n},modelViewMatrix:{value:new tp},normalMatrix:{value:new T}}),this.matrix=new tp,this.matrixWorld=new tp,this.matrixAutoUpdate=tD.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=tD.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new tS,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return tz.setFromAxisAngle(t,e),this.quaternion.multiply(tz),this}rotateOnWorldAxis(t,e){return tz.setFromAxisAngle(t,e),this.quaternion.premultiply(tz),this}rotateX(t){return this.rotateOnAxis(tO,t)}rotateY(t){return this.rotateOnAxis(tk,t)}rotateZ(t){return this.rotateOnAxis(tI,t)}translateOnAxis(t,e){return tT.copy(t).applyQuaternion(this.quaternion),this.position.add(tT.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(tO,t)}translateY(t){return this.translateOnAxis(tk,t)}translateZ(t){return this.translateOnAxis(tI,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(tE.copy(this.matrixWorld).invert())}lookAt(t,e,r){t.isVector3?tB.copy(t):tB.set(t,e,r);let n=this.parent;this.updateWorldMatrix(!0,!1),tP.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?tE.lookAt(tP,tB,this.up):tE.lookAt(tB,tP,this.up),this.quaternion.setFromRotationMatrix(tE),n&&(tE.extractRotation(n.matrixWorld),tz.setFromRotationMatrix(tE),this.quaternion.premultiply(tz.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?console.error("THREE.Object3D.add: object can't be added as a child of itself.",t):t&&t.isObject3D?(t.removeFromParent(),t.parent=this,this.children.push(t),t.dispatchEvent(tR),tF.child=t,this.dispatchEvent(tF),tF.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}let e=this.children.indexOf(t);return -1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(tV),tL.child=t,this.dispatchEvent(tL),tL.child=null),this}removeFromParent(){let t=this.parent;return null!==t&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),tE.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),tE.multiply(t.parent.matrixWorld)),t.applyMatrix4(tE),t.removeFromParent(),t.parent=this,this.children.push(t),t.updateWorldMatrix(!1,!0),t.dispatchEvent(tR),tF.child=t,this.dispatchEvent(tF),tF.child=null,this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let r=0,n=this.children.length;r<n;r++){let n=this.children[r].getObjectByProperty(t,e);if(void 0!==n)return n}}getObjectsByProperty(t,e,r=[]){this[t]===e&&r.push(this);let n=this.children;for(let i=0,s=n.length;i<s;i++)n[i].getObjectsByProperty(t,e,r);return r}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(tP,t,tN),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(tP,tC,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);let e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);let e=this.children;for(let r=0,n=e.length;r<n;r++)e[r].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);let e=this.children;for(let r=0,n=e.length;r<n;r++)e[r].traverseVisible(t)}traverseAncestors(t){let e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);let e=this.children;for(let r=0,n=e.length;r<n;r++){let n=e[r];(!0===n.matrixWorldAutoUpdate||!0===t)&&n.updateMatrixWorld(t)}}updateWorldMatrix(t,e){let r=this.parent;if(!0===t&&null!==r&&!0===r.matrixWorldAutoUpdate&&r.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===e){let t=this.children;for(let e=0,r=t.length;e<r;e++){let r=t[e];!0===r.matrixWorldAutoUpdate&&r.updateWorldMatrix(!1,!0)}}}toJSON(t){let e=void 0===t||"string"==typeof t,r={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},r.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});let n={};function i(e,r){return void 0===e[r.uuid]&&(e[r.uuid]=r.toJSON(t)),r.uuid}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),!0===this.castShadow&&(n.castShadow=!0),!0===this.receiveShadow&&(n.receiveShadow=!0),!1===this.visible&&(n.visible=!1),!1===this.frustumCulled&&(n.frustumCulled=!1),0!==this.renderOrder&&(n.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(n.userData=this.userData),n.layers=this.layers.mask,n.matrix=this.matrix.toArray(),n.up=this.up.toArray(),!1===this.matrixAutoUpdate&&(n.matrixAutoUpdate=!1),this.isInstancedMesh&&(n.type="InstancedMesh",n.count=this.count,n.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(n.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(n.type="BatchedMesh",n.perObjectFrustumCulled=this.perObjectFrustumCulled,n.sortObjects=this.sortObjects,n.drawRanges=this._drawRanges,n.reservedRanges=this._reservedRanges,n.visibility=this._visibility,n.active=this._active,n.bounds=this._bounds.map(t=>({boxInitialized:t.boxInitialized,boxMin:t.box.min.toArray(),boxMax:t.box.max.toArray(),sphereInitialized:t.sphereInitialized,sphereRadius:t.sphere.radius,sphereCenter:t.sphere.center.toArray()})),n.maxGeometryCount=this._maxGeometryCount,n.maxVertexCount=this._maxVertexCount,n.maxIndexCount=this._maxIndexCount,n.geometryInitialized=this._geometryInitialized,n.geometryCount=this._geometryCount,n.matricesTexture=this._matricesTexture.toJSON(t),null!==this.boundingSphere&&(n.boundingSphere={center:n.boundingSphere.center.toArray(),radius:n.boundingSphere.radius}),null!==this.boundingBox&&(n.boundingBox={min:n.boundingBox.min.toArray(),max:n.boundingBox.max.toArray()})),this.isScene)this.background&&(this.background.isColor?n.background=this.background.toJSON():this.background.isTexture&&(n.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(n.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){n.geometry=i(t.geometries,this.geometry);let e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){let r=e.shapes;if(Array.isArray(r))for(let e=0,n=r.length;e<n;e++){let n=r[e];i(t.shapes,n)}else i(t.shapes,r)}}if(this.isSkinnedMesh&&(n.bindMode=this.bindMode,n.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(i(t.skeletons,this.skeleton),n.skeleton=this.skeleton.uuid)),void 0!==this.material){if(Array.isArray(this.material)){let e=[];for(let r=0,n=this.material.length;r<n;r++)e.push(i(t.materials,this.material[r]));n.material=e}else n.material=i(t.materials,this.material)}if(this.children.length>0){n.children=[];for(let e=0;e<this.children.length;e++)n.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){n.animations=[];for(let e=0;e<this.animations.length;e++){let r=this.animations[e];n.animations.push(i(t.animations,r))}}if(e){let e=s(t.geometries),n=s(t.materials),i=s(t.textures),a=s(t.images),o=s(t.shapes),l=s(t.skeletons),h=s(t.animations),u=s(t.nodes);e.length>0&&(r.geometries=e),n.length>0&&(r.materials=n),i.length>0&&(r.textures=i),a.length>0&&(r.images=a),o.length>0&&(r.shapes=o),l.length>0&&(r.skeletons=l),h.length>0&&(r.animations=h),u.length>0&&(r.nodes=u)}return r.object=n,r;function s(t){let e=[];for(let r in t){let n=t[r];delete n.metadata,e.push(n)}return e}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let e=0;e<t.children.length;e++){let r=t.children[e];this.add(r.clone())}return this}}tD.DEFAULT_UP=new H(0,1,0),tD.DEFAULT_MATRIX_AUTO_UPDATE=!0,tD.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;let tU=new H,tG=new H,tq=new H,tj=new H,tH=new H,tW=new H,tX=new H,tY=new H,tZ=new H,tJ=new H;class tK{constructor(t=new H,e=new H,r=new H){this.a=t,this.b=e,this.c=r}static getNormal(t,e,r,n){n.subVectors(r,e),tU.subVectors(t,e),n.cross(tU);let i=n.lengthSq();return i>0?n.multiplyScalar(1/Math.sqrt(i)):n.set(0,0,0)}static getBarycoord(t,e,r,n,i){tU.subVectors(n,e),tG.subVectors(r,e),tq.subVectors(t,e);let s=tU.dot(tU),a=tU.dot(tG),o=tU.dot(tq),l=tG.dot(tG),h=tG.dot(tq),u=s*l-a*a;if(0===u)return i.set(0,0,0),null;let c=1/u,d=(l*o-a*h)*c,p=(s*h-a*o)*c;return i.set(1-d-p,p,d)}static containsPoint(t,e,r,n){return null!==this.getBarycoord(t,e,r,n,tj)&&tj.x>=0&&tj.y>=0&&tj.x+tj.y<=1}static getInterpolation(t,e,r,n,i,s,a,o){return null===this.getBarycoord(t,e,r,n,tj)?(o.x=0,o.y=0,"z"in o&&(o.z=0),"w"in o&&(o.w=0),null):(o.setScalar(0),o.addScaledVector(i,tj.x),o.addScaledVector(s,tj.y),o.addScaledVector(a,tj.z),o)}static isFrontFacing(t,e,r,n){return tU.subVectors(r,e),tG.subVectors(t,e),0>tU.cross(tG).dot(n)}set(t,e,r){return this.a.copy(t),this.b.copy(e),this.c.copy(r),this}setFromPointsAndIndices(t,e,r,n){return this.a.copy(t[e]),this.b.copy(t[r]),this.c.copy(t[n]),this}setFromAttributeAndIndices(t,e,r,n){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,r),this.c.fromBufferAttribute(t,n),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return tU.subVectors(this.c,this.b),tG.subVectors(this.a,this.b),.5*tU.cross(tG).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return tK.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return tK.getBarycoord(t,this.a,this.b,this.c,e)}getInterpolation(t,e,r,n,i){return tK.getInterpolation(t,this.a,this.b,this.c,e,r,n,i)}containsPoint(t){return tK.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return tK.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){let r,n;let i=this.a,s=this.b,a=this.c;tH.subVectors(s,i),tW.subVectors(a,i),tY.subVectors(t,i);let o=tH.dot(tY),l=tW.dot(tY);if(o<=0&&l<=0)return e.copy(i);tZ.subVectors(t,s);let h=tH.dot(tZ),u=tW.dot(tZ);if(h>=0&&u<=h)return e.copy(s);let c=o*u-h*l;if(c<=0&&o>=0&&h<=0)return r=o/(o-h),e.copy(i).addScaledVector(tH,r);tJ.subVectors(t,a);let d=tH.dot(tJ),p=tW.dot(tJ);if(p>=0&&d<=p)return e.copy(a);let m=d*l-o*p;if(m<=0&&l>=0&&p<=0)return n=l/(l-p),e.copy(i).addScaledVector(tW,n);let f=h*p-d*u;if(f<=0&&u-h>=0&&d-p>=0)return tX.subVectors(a,s),n=(u-h)/(u-h+(d-p)),e.copy(s).addScaledVector(tX,n);let g=1/(f+m+c);return r=m*g,n=c*g,e.copy(i).addScaledVector(tH,r).addScaledVector(tW,n)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let tQ={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},t$={h:0,s:0,l:0},t0={h:0,s:0,l:0};function t1(t,e,r){return(r<0&&(r+=1),r>1&&(r-=1),r<1/6)?t+(e-t)*6*r:r<.5?e:r<2/3?t+(e-t)*6*(2/3-r):t}class t2{constructor(t,e,r){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,r)}set(t,e,r){return void 0===e&&void 0===r?t&&t.isColor?this.copy(t):"number"==typeof t?this.setHex(t):"string"==typeof t&&this.setStyle(t):this.setRGB(t,e,r),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=o){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,k.toWorkingColorSpace(this,e),this}setRGB(t,e,r,n=k.workingColorSpace){return this.r=t,this.g=e,this.b=r,k.toWorkingColorSpace(this,n),this}setHSL(t,e,r,n=k.workingColorSpace){if(t=v(t,1),e=_(e,0,1),r=_(r,0,1),0===e)this.r=this.g=this.b=r;else{let n=r<=.5?r*(1+e):r+e-r*e,i=2*r-n;this.r=t1(i,n,t+1/3),this.g=t1(i,n,t),this.b=t1(i,n,t-1/3)}return k.toWorkingColorSpace(this,n),this}setStyle(t,e=o){let r;function n(e){void 0!==e&&1>parseFloat(e)&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}if(r=/^(\w+)\(([^\)]*)\)/.exec(t)){let i;let s=r[1],a=r[2];switch(s){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return n(i[4]),this.setRGB(Math.min(255,parseInt(i[1],10))/255,Math.min(255,parseInt(i[2],10))/255,Math.min(255,parseInt(i[3],10))/255,e);if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return n(i[4]),this.setRGB(Math.min(100,parseInt(i[1],10))/100,Math.min(100,parseInt(i[2],10))/100,Math.min(100,parseInt(i[3],10))/100,e);break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return n(i[4]),this.setHSL(parseFloat(i[1])/360,parseFloat(i[2])/100,parseFloat(i[3])/100,e);break;default:console.warn("THREE.Color: Unknown color model "+t)}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(t)){let n=r[1],i=n.length;if(3===i)return this.setRGB(parseInt(n.charAt(0),16)/15,parseInt(n.charAt(1),16)/15,parseInt(n.charAt(2),16)/15,e);if(6===i)return this.setHex(parseInt(n,16),e);console.warn("THREE.Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=o){let r=tQ[t.toLowerCase()];return void 0!==r?this.setHex(r,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=I(t.r),this.g=I(t.g),this.b=I(t.b),this}copyLinearToSRGB(t){return this.r=R(t.r),this.g=R(t.g),this.b=R(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=o){return k.fromWorkingColorSpace(t3.copy(this),t),65536*Math.round(_(255*t3.r,0,255))+256*Math.round(_(255*t3.g,0,255))+Math.round(_(255*t3.b,0,255))}getHexString(t=o){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=k.workingColorSpace){let r,n;k.fromWorkingColorSpace(t3.copy(this),e);let i=t3.r,s=t3.g,a=t3.b,o=Math.max(i,s,a),l=Math.min(i,s,a),h=(l+o)/2;if(l===o)r=0,n=0;else{let t=o-l;switch(n=h<=.5?t/(o+l):t/(2-o-l),o){case i:r=(s-a)/t+(s<a?6:0);break;case s:r=(a-i)/t+2;break;case a:r=(i-s)/t+4}r/=6}return t.h=r,t.s=n,t.l=h,t}getRGB(t,e=k.workingColorSpace){return k.fromWorkingColorSpace(t3.copy(this),e),t.r=t3.r,t.g=t3.g,t.b=t3.b,t}getStyle(t=o){k.fromWorkingColorSpace(t3.copy(this),t);let e=t3.r,r=t3.g,n=t3.b;return t!==o?`color(${t} ${e.toFixed(3)} ${r.toFixed(3)} ${n.toFixed(3)})`:`rgb(${Math.round(255*e)},${Math.round(255*r)},${Math.round(255*n)})`}offsetHSL(t,e,r){return this.getHSL(t$),this.setHSL(t$.h+t,t$.s+e,t$.l+r)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,r){return this.r=t.r+(e.r-t.r)*r,this.g=t.g+(e.g-t.g)*r,this.b=t.b+(e.b-t.b)*r,this}lerpHSL(t,e){this.getHSL(t$),t.getHSL(t0);let r=b(t$.h,t0.h,e),n=b(t$.s,t0.s,e),i=b(t$.l,t0.l,e);return this.setHSL(r,n,i),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){let e=this.r,r=this.g,n=this.b,i=t.elements;return this.r=i[0]*e+i[3]*r+i[6]*n,this.g=i[1]*e+i[4]*r+i[7]*n,this.b=i[2]*e+i[5]*r+i[8]*n,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}let t3=new t2;t2.NAMES=tQ;let t4=0,t5=new H,t6=new A;class t7{constructor(t,e,r=!1){if(Array.isArray(t))throw TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=r,this.usage=35044,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.gpuType=1015,this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}get updateRange(){var t;return(t="THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.")in B||(B[t]=!0,console.warn(t)),this._updateRange}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,r){t*=this.itemSize,r*=e.itemSize;for(let n=0,i=this.itemSize;n<i;n++)this.array[t+n]=e.array[r+n];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,r=this.count;e<r;e++)t6.fromBufferAttribute(this,e),t6.applyMatrix3(t),this.setXY(e,t6.x,t6.y);else if(3===this.itemSize)for(let e=0,r=this.count;e<r;e++)t5.fromBufferAttribute(this,e),t5.applyMatrix3(t),this.setXYZ(e,t5.x,t5.y,t5.z);return this}applyMatrix4(t){for(let e=0,r=this.count;e<r;e++)t5.fromBufferAttribute(this,e),t5.applyMatrix4(t),this.setXYZ(e,t5.x,t5.y,t5.z);return this}applyNormalMatrix(t){for(let e=0,r=this.count;e<r;e++)t5.fromBufferAttribute(this,e),t5.applyNormalMatrix(t),this.setXYZ(e,t5.x,t5.y,t5.z);return this}transformDirection(t){for(let e=0,r=this.count;e<r;e++)t5.fromBufferAttribute(this,e),t5.transformDirection(t),this.setXYZ(e,t5.x,t5.y,t5.z);return this}set(t,e=0){return this.array.set(t,e),this}getComponent(t,e){let r=this.array[t*this.itemSize+e];return this.normalized&&(r=w(r,this.array)),r}setComponent(t,e,r){return this.normalized&&(r=M(r,this.array)),this.array[t*this.itemSize+e]=r,this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=w(e,this.array)),e}setX(t,e){return this.normalized&&(e=M(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=w(e,this.array)),e}setY(t,e){return this.normalized&&(e=M(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=w(e,this.array)),e}setZ(t,e){return this.normalized&&(e=M(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=w(e,this.array)),e}setW(t,e){return this.normalized&&(e=M(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,r){return t*=this.itemSize,this.normalized&&(e=M(e,this.array),r=M(r,this.array)),this.array[t+0]=e,this.array[t+1]=r,this}setXYZ(t,e,r,n){return t*=this.itemSize,this.normalized&&(e=M(e,this.array),r=M(r,this.array),n=M(n,this.array)),this.array[t+0]=e,this.array[t+1]=r,this.array[t+2]=n,this}setXYZW(t,e,r,n,i){return t*=this.itemSize,this.normalized&&(e=M(e,this.array),r=M(r,this.array),n=M(n,this.array),i=M(i,this.array)),this.array[t+0]=e,this.array[t+1]=r,this.array[t+2]=n,this.array[t+3]=i,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){let t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),35044!==this.usage&&(t.usage=this.usage),t}}class t9 extends t7{constructor(t,e,r){super(new Uint16Array(t),e,r)}}class t8 extends t7{constructor(t,e,r){super(new Uint32Array(t),e,r)}}class et extends t7{constructor(t,e,r){super(new Float32Array(t),e,r)}}let ee=0,er=new tp,en=new tD,ei=new H,es=new Y,ea=new Y,eo=new H;class el extends p{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:ee++}),this.uuid=y(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(!function(t){for(let e=t.length-1;e>=0;--e)if(t[e]>=65535)return!0;return!1}(t)?t9:t8)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,r=0){this.groups.push({start:t,count:e,materialIndex:r})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){let e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);let r=this.attributes.normal;if(void 0!==r){let e=new T().getNormalMatrix(t);r.applyNormalMatrix(e),r.needsUpdate=!0}let n=this.attributes.tangent;return void 0!==n&&(n.transformDirection(t),n.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return er.makeRotationFromQuaternion(t),this.applyMatrix4(er),this}rotateX(t){return er.makeRotationX(t),this.applyMatrix4(er),this}rotateY(t){return er.makeRotationY(t),this.applyMatrix4(er),this}rotateZ(t){return er.makeRotationZ(t),this.applyMatrix4(er),this}translate(t,e,r){return er.makeTranslation(t,e,r),this.applyMatrix4(er),this}scale(t,e,r){return er.makeScale(t,e,r),this.applyMatrix4(er),this}lookAt(t){return en.lookAt(t),en.updateMatrix(),this.applyMatrix4(en.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(ei).negate(),this.translate(ei.x,ei.y,ei.z),this}setFromPoints(t){let e=[];for(let r=0,n=t.length;r<n;r++){let n=t[r];e.push(n.x,n.y,n.z||0)}return this.setAttribute("position",new et(e,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new Y);let t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new H(-1/0,-1/0,-1/0),new H(1/0,1/0,1/0));return}if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,r=e.length;t<r;t++){let r=e[t];es.setFromBufferAttribute(r),this.morphTargetsRelative?(eo.addVectors(this.boundingBox.min,es.min),this.boundingBox.expandByPoint(eo),eo.addVectors(this.boundingBox.max,es.max),this.boundingBox.expandByPoint(eo)):(this.boundingBox.expandByPoint(es.min),this.boundingBox.expandByPoint(es.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new td);let t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new H,1/0);return}if(t){let r=this.boundingSphere.center;if(es.setFromBufferAttribute(t),e)for(let t=0,r=e.length;t<r;t++){let r=e[t];ea.setFromBufferAttribute(r),this.morphTargetsRelative?(eo.addVectors(es.min,ea.min),es.expandByPoint(eo),eo.addVectors(es.max,ea.max),es.expandByPoint(eo)):(es.expandByPoint(ea.min),es.expandByPoint(ea.max))}es.getCenter(r);let n=0;for(let e=0,i=t.count;e<i;e++)eo.fromBufferAttribute(t,e),n=Math.max(n,r.distanceToSquared(eo));if(e)for(let i=0,s=e.length;i<s;i++){let s=e[i],a=this.morphTargetsRelative;for(let e=0,i=s.count;e<i;e++)eo.fromBufferAttribute(s,e),a&&(ei.fromBufferAttribute(t,e),eo.add(ei)),n=Math.max(n,r.distanceToSquared(eo))}this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){let t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}let r=e.position,n=e.normal,i=e.uv;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new t7(new Float32Array(4*r.count),4));let s=this.getAttribute("tangent"),a=[],o=[];for(let t=0;t<r.count;t++)a[t]=new H,o[t]=new H;let l=new H,h=new H,u=new H,c=new A,d=new A,p=new A,m=new H,f=new H,g=this.groups;0===g.length&&(g=[{start:0,count:t.count}]);for(let e=0,n=g.length;e<n;++e){let n=g[e],s=n.start,x=n.count;for(let e=s,n=s+x;e<n;e+=3)!function(t,e,n){l.fromBufferAttribute(r,t),h.fromBufferAttribute(r,e),u.fromBufferAttribute(r,n),c.fromBufferAttribute(i,t),d.fromBufferAttribute(i,e),p.fromBufferAttribute(i,n),h.sub(l),u.sub(l),d.sub(c),p.sub(c);let s=1/(d.x*p.y-p.x*d.y);isFinite(s)&&(m.copy(h).multiplyScalar(p.y).addScaledVector(u,-d.y).multiplyScalar(s),f.copy(u).multiplyScalar(d.x).addScaledVector(h,-p.x).multiplyScalar(s),a[t].add(m),a[e].add(m),a[n].add(m),o[t].add(f),o[e].add(f),o[n].add(f))}(t.getX(e+0),t.getX(e+1),t.getX(e+2))}let x=new H,y=new H,_=new H,v=new H;function b(t){_.fromBufferAttribute(n,t),v.copy(_);let e=a[t];x.copy(e),x.sub(_.multiplyScalar(_.dot(e))).normalize(),y.crossVectors(v,e);let r=y.dot(o[t]);s.setXYZW(t,x.x,x.y,x.z,r<0?-1:1)}for(let e=0,r=g.length;e<r;++e){let r=g[e],n=r.start,i=r.count;for(let e=n,r=n+i;e<r;e+=3)b(t.getX(e+0)),b(t.getX(e+1)),b(t.getX(e+2))}}computeVertexNormals(){let t=this.index,e=this.getAttribute("position");if(void 0!==e){let r=this.getAttribute("normal");if(void 0===r)r=new t7(new Float32Array(3*e.count),3),this.setAttribute("normal",r);else for(let t=0,e=r.count;t<e;t++)r.setXYZ(t,0,0,0);let n=new H,i=new H,s=new H,a=new H,o=new H,l=new H,h=new H,u=new H;if(t)for(let c=0,d=t.count;c<d;c+=3){let d=t.getX(c+0),p=t.getX(c+1),m=t.getX(c+2);n.fromBufferAttribute(e,d),i.fromBufferAttribute(e,p),s.fromBufferAttribute(e,m),h.subVectors(s,i),u.subVectors(n,i),h.cross(u),a.fromBufferAttribute(r,d),o.fromBufferAttribute(r,p),l.fromBufferAttribute(r,m),a.add(h),o.add(h),l.add(h),r.setXYZ(d,a.x,a.y,a.z),r.setXYZ(p,o.x,o.y,o.z),r.setXYZ(m,l.x,l.y,l.z)}else for(let t=0,a=e.count;t<a;t+=3)n.fromBufferAttribute(e,t+0),i.fromBufferAttribute(e,t+1),s.fromBufferAttribute(e,t+2),h.subVectors(s,i),u.subVectors(n,i),h.cross(u),r.setXYZ(t+0,h.x,h.y,h.z),r.setXYZ(t+1,h.x,h.y,h.z),r.setXYZ(t+2,h.x,h.y,h.z);this.normalizeNormals(),r.needsUpdate=!0}}normalizeNormals(){let t=this.attributes.normal;for(let e=0,r=t.count;e<r;e++)eo.fromBufferAttribute(t,e),eo.normalize(),t.setXYZ(e,eo.x,eo.y,eo.z)}toNonIndexed(){function t(t,e){let r=t.array,n=t.itemSize,i=t.normalized,s=new r.constructor(e.length*n),a=0,o=0;for(let i=0,l=e.length;i<l;i++){a=t.isInterleavedBufferAttribute?e[i]*t.data.stride+t.offset:e[i]*n;for(let t=0;t<n;t++)s[o++]=r[a++]}return new t7(s,n,i)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;let e=new el,r=this.index.array,n=this.attributes;for(let i in n){let s=t(n[i],r);e.setAttribute(i,s)}let i=this.morphAttributes;for(let n in i){let s=[],a=i[n];for(let e=0,n=a.length;e<n;e++){let n=t(a[e],r);s.push(n)}e.morphAttributes[n]=s}e.morphTargetsRelative=this.morphTargetsRelative;let s=this.groups;for(let t=0,r=s.length;t<r;t++){let r=s[t];e.addGroup(r.start,r.count,r.materialIndex)}return e}toJSON(){let t={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){let e=this.parameters;for(let r in e)void 0!==e[r]&&(t[r]=e[r]);return t}t.data={attributes:{}};let e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});let r=this.attributes;for(let e in r){let n=r[e];t.data.attributes[e]=n.toJSON(t.data)}let n={},i=!1;for(let e in this.morphAttributes){let r=this.morphAttributes[e],s=[];for(let e=0,n=r.length;e<n;e++){let n=r[e];s.push(n.toJSON(t.data))}s.length>0&&(n[e]=s,i=!0)}i&&(t.data.morphAttributes=n,t.data.morphTargetsRelative=this.morphTargetsRelative);let s=this.groups;s.length>0&&(t.data.groups=JSON.parse(JSON.stringify(s)));let a=this.boundingSphere;return null!==a&&(t.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;let e={};this.name=t.name;let r=t.index;null!==r&&this.setIndex(r.clone(e));let n=t.attributes;for(let t in n){let r=n[t];this.setAttribute(t,r.clone(e))}let i=t.morphAttributes;for(let t in i){let r=[],n=i[t];for(let t=0,i=n.length;t<i;t++)r.push(n[t].clone(e));this.morphAttributes[t]=r}this.morphTargetsRelative=t.morphTargetsRelative;let s=t.groups;for(let t=0,e=s.length;t<e;t++){let e=s[t];this.addGroup(e.start,e.count,e.materialIndex)}let a=t.boundingBox;null!==a&&(this.boundingBox=a.clone());let o=t.boundingSphere;return null!==o&&(this.boundingSphere=o.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}class eh extends el{constructor(t=1,e=1,r=1,n=1,i=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:r,widthSegments:n,heightSegments:i,depthSegments:s};let a=this;n=Math.floor(n),i=Math.floor(i);let o=[],l=[],h=[],u=[],c=0,d=0;function p(t,e,r,n,i,s,p,m,f,g,x){let y=s/f,_=p/g,v=s/2,b=p/2,w=m/2,M=f+1,S=g+1,A=0,T=0,z=new H;for(let s=0;s<S;s++){let a=s*_-b;for(let o=0;o<M;o++){let c=o*y-v;z[t]=c*n,z[e]=a*i,z[r]=w,l.push(z.x,z.y,z.z),z[t]=0,z[e]=0,z[r]=m>0?1:-1,h.push(z.x,z.y,z.z),u.push(o/f),u.push(1-s/g),A+=1}}for(let t=0;t<g;t++)for(let e=0;e<f;e++){let r=c+e+M*t,n=c+e+M*(t+1),i=c+(e+1)+M*(t+1),s=c+(e+1)+M*t;o.push(r,n,s),o.push(n,i,s),T+=6}a.addGroup(d,T,x),d+=T,c+=A}p("z","y","x",-1,-1,r,e,t,s=Math.floor(s),i,0),p("z","y","x",1,-1,r,e,-t,s,i,1),p("x","z","y",1,1,t,r,e,n,s,2),p("x","z","y",1,-1,t,r,-e,n,s,3),p("x","y","z",1,-1,t,e,r,n,i,4),p("x","y","z",-1,-1,t,e,-r,n,i,5),this.setIndex(o),this.setAttribute("position",new et(l,3)),this.setAttribute("normal",new et(h,3)),this.setAttribute("uv",new et(u,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new eh(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function eu(t){let e={};for(let r=0;r<t.length;r++){let n=function(t){let e={};for(let r in t)for(let n in e[r]={},t[r]){let i=t[r][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[r][n]=null):e[r][n]=i.clone():Array.isArray(i)?e[r][n]=i.slice():e[r][n]=i}return e}(t[r]);for(let t in n)e[t]=n[t]}return e}let ec=new H,ed=new H,ep=new T;class em{constructor(t=new H(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,r,n){return this.normal.set(t,e,r),this.constant=n,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,r){let n=ec.subVectors(r,e).cross(ed.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(n,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){let t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){let r=t.delta(ec),n=this.normal.dot(r);if(0===n)return 0===this.distanceToPoint(t.start)?e.copy(t.start):null;let i=-(t.start.dot(this.normal)+this.constant)/n;return i<0||i>1?null:e.copy(t.start).addScaledVector(r,i)}intersectsLine(t){let e=this.distanceToPoint(t.start),r=this.distanceToPoint(t.end);return e<0&&r>0||r<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){let r=e||ep.getNormalMatrix(t),n=this.coplanarPoint(ec).applyMatrix4(t),i=this.normal.applyMatrix3(r).normalize();return this.constant=-n.dot(i),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}class ef extends el{constructor(t=1,e=1,r=1,n=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:r,heightSegments:n};let i=t/2,s=e/2,a=Math.floor(r),o=Math.floor(n),l=a+1,h=o+1,u=t/a,c=e/o,d=[],p=[],m=[],f=[];for(let t=0;t<h;t++){let e=t*c-s;for(let r=0;r<l;r++){let n=r*u-i;p.push(n,-e,0),m.push(0,0,1),f.push(r/a),f.push(1-t/o)}}for(let t=0;t<o;t++)for(let e=0;e<a;e++){let r=e+l*t,n=e+l*(t+1),i=e+1+l*(t+1),s=e+1+l*t;d.push(r,n,s),d.push(n,i,s)}this.setIndex(d),this.setAttribute("position",new et(p,3)),this.setAttribute("normal",new et(m,3)),this.setAttribute("uv",new et(f,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new ef(t.width,t.height,t.widthSegments,t.heightSegments)}}let eg="#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}",ex="#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",ey={common:{diffuse:{value:new t2(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new T},alphaMap:{value:null},alphaMapTransform:{value:new T},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new T}},envmap:{envMap:{value:null},envMapRotation:{value:new T},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new T}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new T}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new T},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new T},normalScale:{value:new A(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new T},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new T}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new T}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new T}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new t2(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new t2(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new T},alphaTest:{value:0},uvTransform:{value:new T}},sprite:{diffuse:{value:new t2(16777215)},opacity:{value:1},center:{value:new A(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new T},alphaMap:{value:null},alphaMapTransform:{value:new T},alphaTest:{value:0}}},e_={basic:{uniforms:eu([ey.common,ey.specularmap,ey.envmap,ey.aomap,ey.lightmap,ey.fog]),vertexShader:"#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}",fragmentShader:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}"},lambert:{uniforms:eu([ey.common,ey.specularmap,ey.envmap,ey.aomap,ey.lightmap,ey.emissivemap,ey.bumpmap,ey.normalmap,ey.displacementmap,ey.fog,ey.lights,{emissive:{value:new t2(0)}}]),vertexShader:"#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",fragmentShader:"#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}"},phong:{uniforms:eu([ey.common,ey.specularmap,ey.envmap,ey.aomap,ey.lightmap,ey.emissivemap,ey.bumpmap,ey.normalmap,ey.displacementmap,ey.fog,ey.lights,{emissive:{value:new t2(0)},specular:{value:new t2(1118481)},shininess:{value:30}}]),vertexShader:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",fragmentShader:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}"},standard:{uniforms:eu([ey.common,ey.envmap,ey.aomap,ey.lightmap,ey.emissivemap,ey.bumpmap,ey.normalmap,ey.displacementmap,ey.roughnessmap,ey.metalnessmap,ey.fog,ey.lights,{emissive:{value:new t2(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:eg,fragmentShader:ex},toon:{uniforms:eu([ey.common,ey.aomap,ey.lightmap,ey.emissivemap,ey.bumpmap,ey.normalmap,ey.displacementmap,ey.gradientmap,ey.fog,ey.lights,{emissive:{value:new t2(0)}}]),vertexShader:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",fragmentShader:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}"},matcap:{uniforms:eu([ey.common,ey.bumpmap,ey.normalmap,ey.displacementmap,ey.fog,{matcap:{value:null}}]),vertexShader:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}",fragmentShader:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}"},points:{uniforms:eu([ey.points,ey.fog]),vertexShader:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}",fragmentShader:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}"},dashed:{uniforms:eu([ey.common,ey.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",fragmentShader:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}"},depth:{uniforms:eu([ey.common,ey.displacementmap]),vertexShader:"#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}",fragmentShader:"#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}"},normal:{uniforms:eu([ey.common,ey.bumpmap,ey.normalmap,ey.displacementmap,{opacity:{value:1}}]),vertexShader:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}",fragmentShader:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}"},sprite:{uniforms:eu([ey.sprite,ey.fog]),vertexShader:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",fragmentShader:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}"},background:{uniforms:{uvTransform:{value:new T},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}",fragmentShader:"uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}"},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new T}},vertexShader:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",fragmentShader:"#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}"},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",fragmentShader:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}"},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}",fragmentShader:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}"},distanceRGBA:{uniforms:eu([ey.common,ey.displacementmap,{referencePosition:{value:new H},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}",fragmentShader:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}"},shadow:{uniforms:eu([ey.lights,ey.fog,{color:{value:new t2(0)},opacity:{value:1}}]),vertexShader:"#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",fragmentShader:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}"}};e_.physical={uniforms:eu([e_.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new T},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new T},clearcoatNormalScale:{value:new A(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new T},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new T},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new T},sheen:{value:0},sheenColor:{value:new t2(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new T},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new T},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new T},transmissionSamplerSize:{value:new A},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new T},attenuationDistance:{value:0},attenuationColor:{value:new t2(0)},specularColor:{value:new t2(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new T},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new T},anisotropyVector:{value:new A},anisotropyMap:{value:null},anisotropyMapTransform:{value:new T}}]),vertexShader:eg,fragmentShader:ex},new class extends G{constructor(t,e,r,n,i,s,a,o,l,h){if(1026!==(h=void 0!==h?h:1026)&&1027!==h)throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===r&&1026===h&&(r=1014),void 0===r&&1027===h&&(r=1020),super(null,n,i,s,a,o,h,r,l),this.isDepthTexture=!0,this.image={width:t,height:e},this.magFilter=void 0!==a?a:1003,this.minFilter=void 0!==o?o:1003,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(t){return super.copy(t),this.compareFunction=t.compareFunction,this}toJSON(t){let e=super.toJSON(t);return null!==this.compareFunction&&(e.compareFunction=this.compareFunction),e}}(1,1).compareFunction=515,new Float32Array(16),new Float32Array(9),new Float32Array(4);class ev{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){let r=this.getUtoTmapping(t);return this.getPoint(r,e)}getPoints(t=5){let e=[];for(let r=0;r<=t;r++)e.push(this.getPoint(r/t));return e}getSpacedPoints(t=5){let e=[];for(let r=0;r<=t;r++)e.push(this.getPointAt(r/t));return e}getLength(){let t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;let e=[],r,n=this.getPoint(0),i=0;e.push(0);for(let s=1;s<=t;s++)e.push(i+=(r=this.getPoint(s/t)).distanceTo(n)),n=r;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){let r;let n=this.getLengths(),i=0,s=n.length;r=e||t*n[s-1];let a=0,o=s-1,l;for(;a<=o;)if((l=n[i=Math.floor(a+(o-a)/2)]-r)<0)a=i+1;else if(l>0)o=i-1;else{o=i;break}if(n[i=o]===r)return i/(s-1);let h=n[i],u=n[i+1];return(i+(r-h)/(u-h))/(s-1)}getTangent(t,e){let r=t-1e-4,n=t+1e-4;r<0&&(r=0),n>1&&(n=1);let i=this.getPoint(r),s=this.getPoint(n),a=e||(i.isVector2?new A:new H);return a.copy(s).sub(i).normalize(),a}getTangentAt(t,e){let r=this.getUtoTmapping(t);return this.getTangent(r,e)}computeFrenetFrames(t,e){let r=new H,n=[],i=[],s=[],a=new H,o=new tp;for(let e=0;e<=t;e++){let r=e/t;n[e]=this.getTangentAt(r,new H)}i[0]=new H,s[0]=new H;let l=Number.MAX_VALUE,h=Math.abs(n[0].x),u=Math.abs(n[0].y),c=Math.abs(n[0].z);h<=l&&(l=h,r.set(1,0,0)),u<=l&&(l=u,r.set(0,1,0)),c<=l&&r.set(0,0,1),a.crossVectors(n[0],r).normalize(),i[0].crossVectors(n[0],a),s[0].crossVectors(n[0],i[0]);for(let e=1;e<=t;e++){if(i[e]=i[e-1].clone(),s[e]=s[e-1].clone(),a.crossVectors(n[e-1],n[e]),a.length()>Number.EPSILON){a.normalize();let t=Math.acos(_(n[e-1].dot(n[e]),-1,1));i[e].applyMatrix4(o.makeRotationAxis(a,t))}s[e].crossVectors(n[e],i[e])}if(!0===e){let e=Math.acos(_(i[0].dot(i[t]),-1,1));e/=t,n[0].dot(a.crossVectors(i[0],i[t]))>0&&(e=-e);for(let r=1;r<=t;r++)i[r].applyMatrix4(o.makeRotationAxis(n[r],e*r)),s[r].crossVectors(n[r],i[r])}return{tangents:n,normals:i,binormals:s}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){let t={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class eb extends ev{constructor(t=0,e=0,r=1,n=1,i=0,s=2*Math.PI,a=!1,o=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=r,this.yRadius=n,this.aStartAngle=i,this.aEndAngle=s,this.aClockwise=a,this.aRotation=o}getPoint(t,e=new A){let r=2*Math.PI,n=this.aEndAngle-this.aStartAngle,i=Math.abs(n)<Number.EPSILON;for(;n<0;)n+=r;for(;n>r;)n-=r;n<Number.EPSILON&&(n=i?0:r),!0!==this.aClockwise||i||(n===r?n=-r:n-=r);let s=this.aStartAngle+t*n,a=this.aX+this.xRadius*Math.cos(s),o=this.aY+this.yRadius*Math.sin(s);if(0!==this.aRotation){let t=Math.cos(this.aRotation),e=Math.sin(this.aRotation),r=a-this.aX,n=o-this.aY;a=r*t-n*e+this.aX,o=r*e+n*t+this.aY}return e.set(a,o)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){let t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}function ew(){let t=0,e=0,r=0,n=0;function i(i,s,a,o){t=i,e=a,r=-3*i+3*s-2*a-o,n=2*i-2*s+a+o}return{initCatmullRom:function(t,e,r,n,s){i(e,r,s*(r-t),s*(n-e))},initNonuniformCatmullRom:function(t,e,r,n,s,a,o){let l=(e-t)/s-(r-t)/(s+a)+(r-e)/a,h=(r-e)/a-(n-e)/(a+o)+(n-r)/o;i(e,r,l*=a,h*=a)},calc:function(i){let s=i*i;return t+e*i+r*s+s*i*n}}}let eM=new H,eS=new ew,eA=new ew,eT=new ew;function ez(t,e,r,n,i){let s=(n-e)*.5,a=(i-r)*.5,o=t*t;return t*o*(2*r-2*n+s+a)+(-3*r+3*n-2*s-a)*o+s*t+r}function eE(t,e,r,n){return function(t,e){let r=1-t;return r*r*e}(t,e)+2*(1-t)*t*r+t*t*n}function eB(t,e,r,n,i){return function(t,e){let r=1-t;return r*r*r*e}(t,e)+function(t,e){let r=1-t;return 3*r*r*t*e}(t,r)+3*(1-t)*t*t*n+t*t*t*i}class eP extends ev{constructor(t=new A,e=new A,r=new A,n=new A){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=r,this.v3=n}getPoint(t,e=new A){let r=this.v0,n=this.v1,i=this.v2,s=this.v3;return e.set(eB(t,r.x,n.x,i.x,s.x),eB(t,r.y,n.y,i.y,s.y)),e}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){let t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class eN extends ev{constructor(t=new A,e=new A){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new A){return 1===t?e.copy(this.v2):(e.copy(this.v2).sub(this.v1),e.multiplyScalar(t).add(this.v1)),e}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e=new A){return e.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,e){return this.getTangent(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){let t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class eC extends ev{constructor(t=new A,e=new A,r=new A){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=r}getPoint(t,e=new A){let r=this.v0,n=this.v1,i=this.v2;return e.set(eE(t,r.x,n.x,i.x),eE(t,r.y,n.y,i.y)),e}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){let t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class eO extends ev{constructor(t=new H,e=new H,r=new H){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=r}getPoint(t,e=new H){let r=this.v0,n=this.v1,i=this.v2;return e.set(eE(t,r.x,n.x,i.x),eE(t,r.y,n.y,i.y),eE(t,r.z,n.z,i.z)),e}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){let t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class ek extends ev{constructor(t=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=t}getPoint(t,e=new A){let r=this.points,n=(r.length-1)*t,i=Math.floor(n),s=n-i,a=r[0===i?i:i-1],o=r[i],l=r[i>r.length-2?r.length-1:i+1],h=r[i>r.length-3?r.length-1:i+2];return e.set(ez(s,a.x,o.x,l.x,h.x),ez(s,a.y,o.y,l.y,h.y)),e}copy(t){super.copy(t),this.points=[];for(let e=0,r=t.points.length;e<r;e++){let r=t.points[e];this.points.push(r.clone())}return this}toJSON(){let t=super.toJSON();t.points=[];for(let e=0,r=this.points.length;e<r;e++){let r=this.points[e];t.points.push(r.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,r=t.points.length;e<r;e++){let r=t.points[e];this.points.push(new A().fromArray(r))}return this}}var eI=Object.freeze({__proto__:null,ArcCurve:class extends eb{constructor(t,e,r,n,i,s){super(t,e,r,r,n,i,s),this.isArcCurve=!0,this.type="ArcCurve"}},CatmullRomCurve3:class extends ev{constructor(t=[],e=!1,r="centripetal",n=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=r,this.tension=n}getPoint(t,e=new H){let r,n;let i=this.points,s=i.length,a=(s-(this.closed?0:1))*t,o=Math.floor(a),l=a-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/s)+1)*s:0===l&&o===s-1&&(o=s-2,l=1),this.closed||o>0?r=i[(o-1)%s]:(eM.subVectors(i[0],i[1]).add(i[0]),r=eM);let h=i[o%s],u=i[(o+1)%s];if(this.closed||o+2<s?n=i[(o+2)%s]:(eM.subVectors(i[s-1],i[s-2]).add(i[s-1]),n=eM),"centripetal"===this.curveType||"chordal"===this.curveType){let t="chordal"===this.curveType?.5:.25,e=Math.pow(r.distanceToSquared(h),t),i=Math.pow(h.distanceToSquared(u),t),s=Math.pow(u.distanceToSquared(n),t);i<1e-4&&(i=1),e<1e-4&&(e=i),s<1e-4&&(s=i),eS.initNonuniformCatmullRom(r.x,h.x,u.x,n.x,e,i,s),eA.initNonuniformCatmullRom(r.y,h.y,u.y,n.y,e,i,s),eT.initNonuniformCatmullRom(r.z,h.z,u.z,n.z,e,i,s)}else"catmullrom"===this.curveType&&(eS.initCatmullRom(r.x,h.x,u.x,n.x,this.tension),eA.initCatmullRom(r.y,h.y,u.y,n.y,this.tension),eT.initCatmullRom(r.z,h.z,u.z,n.z,this.tension));return e.set(eS.calc(l),eA.calc(l),eT.calc(l)),e}copy(t){super.copy(t),this.points=[];for(let e=0,r=t.points.length;e<r;e++){let r=t.points[e];this.points.push(r.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){let t=super.toJSON();t.points=[];for(let e=0,r=this.points.length;e<r;e++){let r=this.points[e];t.points.push(r.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,r=t.points.length;e<r;e++){let r=t.points[e];this.points.push(new H().fromArray(r))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}},CubicBezierCurve:eP,CubicBezierCurve3:class extends ev{constructor(t=new H,e=new H,r=new H,n=new H){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=r,this.v3=n}getPoint(t,e=new H){let r=this.v0,n=this.v1,i=this.v2,s=this.v3;return e.set(eB(t,r.x,n.x,i.x,s.x),eB(t,r.y,n.y,i.y,s.y),eB(t,r.z,n.z,i.z,s.z)),e}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){let t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}},EllipseCurve:eb,LineCurve:eN,LineCurve3:class extends ev{constructor(t=new H,e=new H){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=t,this.v2=e}getPoint(t,e=new H){return 1===t?e.copy(this.v2):(e.copy(this.v2).sub(this.v1),e.multiplyScalar(t).add(this.v1)),e}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e=new H){return e.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,e){return this.getTangent(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){let t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}},QuadraticBezierCurve:eC,QuadraticBezierCurve3:eO,SplineCurve:ek});class eR extends ev{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){let t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);if(!t.equals(e)){let r=!0===t.isVector2?"LineCurve":"LineCurve3";this.curves.push(new eI[r](e,t))}return this}getPoint(t,e){let r=t*this.getLength(),n=this.getCurveLengths(),i=0;for(;i<n.length;){if(n[i]>=r){let t=n[i]-r,s=this.curves[i],a=s.getLength(),o=0===a?0:1-t/a;return s.getPointAt(o,e)}i++}return null}getLength(){let t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;let t=[],e=0;for(let r=0,n=this.curves.length;r<n;r++)t.push(e+=this.curves[r].getLength());return this.cacheLengths=t,t}getSpacedPoints(t=40){let e=[];for(let r=0;r<=t;r++)e.push(this.getPoint(r/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){let e;let r=[];for(let n=0,i=this.curves;n<i.length;n++){let s=i[n],a=s.isEllipseCurve?2*t:s.isLineCurve||s.isLineCurve3?1:s.isSplineCurve?t*s.points.length:t,o=s.getPoints(a);for(let t=0;t<o.length;t++){let n=o[t];e&&e.equals(n)||(r.push(n),e=n)}}return this.autoClose&&r.length>1&&!r[r.length-1].equals(r[0])&&r.push(r[0]),r}copy(t){super.copy(t),this.curves=[];for(let e=0,r=t.curves.length;e<r;e++){let r=t.curves[e];this.curves.push(r.clone())}return this.autoClose=t.autoClose,this}toJSON(){let t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,r=this.curves.length;e<r;e++){let r=this.curves[e];t.curves.push(r.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,r=t.curves.length;e<r;e++){let r=t.curves[e];this.curves.push(new eI[r.type]().fromJSON(r))}return this}}class eV extends eR{constructor(t){super(),this.type="Path",this.currentPoint=new A,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,r=t.length;e<r;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){let r=new eN(this.currentPoint.clone(),new A(t,e));return this.curves.push(r),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,r,n){let i=new eC(this.currentPoint.clone(),new A(t,e),new A(r,n));return this.curves.push(i),this.currentPoint.set(r,n),this}bezierCurveTo(t,e,r,n,i,s){let a=new eP(this.currentPoint.clone(),new A(t,e),new A(r,n),new A(i,s));return this.curves.push(a),this.currentPoint.set(i,s),this}splineThru(t){let e=new ek([this.currentPoint.clone()].concat(t));return this.curves.push(e),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,r,n,i,s){let a=this.currentPoint.x,o=this.currentPoint.y;return this.absarc(t+a,e+o,r,n,i,s),this}absarc(t,e,r,n,i,s){return this.absellipse(t,e,r,r,n,i,s),this}ellipse(t,e,r,n,i,s,a,o){let l=this.currentPoint.x,h=this.currentPoint.y;return this.absellipse(t+l,e+h,r,n,i,s,a,o),this}absellipse(t,e,r,n,i,s,a,o){let l=new eb(t,e,r,n,i,s,a,o);if(this.curves.length>0){let t=l.getPoint(0);t.equals(this.currentPoint)||this.lineTo(t.x,t.y)}this.curves.push(l);let h=l.getPoint(1);return this.currentPoint.copy(h),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){let t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class eF extends el{constructor(t=[new A(0,-.5),new A(.5,0),new A(0,.5)],e=12,r=0,n=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:r,phiLength:n},e=Math.floor(e),n=_(n,0,2*Math.PI);let i=[],s=[],a=[],o=[],l=[],h=1/e,u=new H,c=new A,d=new H,p=new H,m=new H,f=0,g=0;for(let e=0;e<=t.length-1;e++)switch(e){case 0:f=t[e+1].x-t[e].x,g=t[e+1].y-t[e].y,d.x=1*g,d.y=-f,d.z=0*g,m.copy(d),d.normalize(),o.push(d.x,d.y,d.z);break;case t.length-1:o.push(m.x,m.y,m.z);break;default:f=t[e+1].x-t[e].x,g=t[e+1].y-t[e].y,d.x=1*g,d.y=-f,d.z=0*g,p.copy(d),d.x+=m.x,d.y+=m.y,d.z+=m.z,d.normalize(),o.push(d.x,d.y,d.z),m.copy(p)}for(let i=0;i<=e;i++){let d=r+i*h*n,p=Math.sin(d),m=Math.cos(d);for(let r=0;r<=t.length-1;r++){u.x=t[r].x*p,u.y=t[r].y,u.z=t[r].x*m,s.push(u.x,u.y,u.z),c.x=i/e,c.y=r/(t.length-1),a.push(c.x,c.y);let n=o[3*r+0]*p,h=o[3*r+1],d=o[3*r+0]*m;l.push(n,h,d)}}for(let r=0;r<e;r++)for(let e=0;e<t.length-1;e++){let n=e+r*t.length,s=n+t.length,a=n+t.length+1,o=n+1;i.push(n,s,o),i.push(a,o,s)}this.setIndex(i),this.setAttribute("position",new et(s,3)),this.setAttribute("uv",new et(a,2)),this.setAttribute("normal",new et(l,3))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new eF(t.points,t.segments,t.phiStart,t.phiLength)}}class eL extends eF{constructor(t=1,e=1,r=4,n=8){let i=new eV;i.absarc(0,-e/2,t,1.5*Math.PI,0),i.absarc(0,e/2,t,0,.5*Math.PI),super(i.getPoints(r),n),this.type="CapsuleGeometry",this.parameters={radius:t,length:e,capSegments:r,radialSegments:n}}static fromJSON(t){return new eL(t.radius,t.length,t.capSegments,t.radialSegments)}}class eD extends el{constructor(t=1,e=32,r=0,n=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:e,thetaStart:r,thetaLength:n},e=Math.max(3,e);let i=[],s=[],a=[],o=[],l=new H,h=new A;s.push(0,0,0),a.push(0,0,1),o.push(.5,.5);for(let i=0,u=3;i<=e;i++,u+=3){let c=r+i/e*n;l.x=t*Math.cos(c),l.y=t*Math.sin(c),s.push(l.x,l.y,l.z),a.push(0,0,1),h.x=(s[u]/t+1)/2,h.y=(s[u+1]/t+1)/2,o.push(h.x,h.y)}for(let t=1;t<=e;t++)i.push(t,t+1,0);this.setIndex(i),this.setAttribute("position",new et(s,3)),this.setAttribute("normal",new et(a,3)),this.setAttribute("uv",new et(o,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new eD(t.radius,t.segments,t.thetaStart,t.thetaLength)}}class eU extends el{constructor(t=1,e=1,r=1,n=32,i=1,s=!1,a=0,o=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:r,radialSegments:n,heightSegments:i,openEnded:s,thetaStart:a,thetaLength:o};let l=this;n=Math.floor(n),i=Math.floor(i);let h=[],u=[],c=[],d=[],p=0,m=[],f=r/2,g=0;function x(r){let i=p,s=new A,m=new H,x=0,y=!0===r?t:e,_=!0===r?1:-1;for(let t=1;t<=n;t++)u.push(0,f*_,0),c.push(0,_,0),d.push(.5,.5),p++;let v=p;for(let t=0;t<=n;t++){let e=t/n*o+a,r=Math.cos(e),i=Math.sin(e);m.x=y*i,m.y=f*_,m.z=y*r,u.push(m.x,m.y,m.z),c.push(0,_,0),s.x=.5*r+.5,s.y=.5*i*_+.5,d.push(s.x,s.y),p++}for(let t=0;t<n;t++){let e=i+t,n=v+t;!0===r?h.push(n,n+1,e):h.push(n+1,n,e),x+=3}l.addGroup(g,x,!0===r?1:2),g+=x}(function(){let s=new H,x=new H,y=0,_=(e-t)/r;for(let l=0;l<=i;l++){let h=[],g=l/i,y=g*(e-t)+t;for(let t=0;t<=n;t++){let e=t/n,i=e*o+a,l=Math.sin(i),m=Math.cos(i);x.x=y*l,x.y=-g*r+f,x.z=y*m,u.push(x.x,x.y,x.z),s.set(l,_,m).normalize(),c.push(s.x,s.y,s.z),d.push(e,1-g),h.push(p++)}m.push(h)}for(let t=0;t<n;t++)for(let e=0;e<i;e++){let r=m[e][t],n=m[e+1][t],i=m[e+1][t+1],s=m[e][t+1];h.push(r,n,s),h.push(n,i,s),y+=6}l.addGroup(g,y,0),g+=y})(),!1===s&&(t>0&&x(!0),e>0&&x(!1)),this.setIndex(h),this.setAttribute("position",new et(u,3)),this.setAttribute("normal",new et(c,3)),this.setAttribute("uv",new et(d,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new eU(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class eG extends eU{constructor(t=1,e=1,r=32,n=1,i=!1,s=0,a=2*Math.PI){super(0,t,e,r,n,i,s,a),this.type="ConeGeometry",this.parameters={radius:t,height:e,radialSegments:r,heightSegments:n,openEnded:i,thetaStart:s,thetaLength:a}}static fromJSON(t){return new eG(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class eq extends el{constructor(t=[],e=[],r=1,n=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:r,detail:n};let i=[],s=[];function a(t){i.push(t.x,t.y,t.z)}function o(e,r){let n=3*e;r.x=t[n+0],r.y=t[n+1],r.z=t[n+2]}function l(t,e,r,n){n<0&&1===t.x&&(s[e]=t.x-1),0===r.x&&0===r.z&&(s[e]=n/2/Math.PI+.5)}function h(t){return Math.atan2(t.z,-t.x)}(function(t){let r=new H,n=new H,i=new H;for(let s=0;s<e.length;s+=3)o(e[s+0],r),o(e[s+1],n),o(e[s+2],i),function(t,e,r,n){let i=n+1,s=[];for(let n=0;n<=i;n++){s[n]=[];let a=t.clone().lerp(r,n/i),o=e.clone().lerp(r,n/i),l=i-n;for(let t=0;t<=l;t++)0===t&&n===i?s[n][t]=a:s[n][t]=a.clone().lerp(o,t/l)}for(let t=0;t<i;t++)for(let e=0;e<2*(i-t)-1;e++){let r=Math.floor(e/2);e%2==0?(a(s[t][r+1]),a(s[t+1][r]),a(s[t][r])):(a(s[t][r+1]),a(s[t+1][r+1]),a(s[t+1][r]))}}(r,n,i,t)})(n),function(t){let e=new H;for(let r=0;r<i.length;r+=3)e.x=i[r+0],e.y=i[r+1],e.z=i[r+2],e.normalize().multiplyScalar(t),i[r+0]=e.x,i[r+1]=e.y,i[r+2]=e.z}(r),function(){let t=new H;for(let e=0;e<i.length;e+=3){t.x=i[e+0],t.y=i[e+1],t.z=i[e+2];let r=h(t)/2/Math.PI+.5,n=Math.atan2(-t.y,Math.sqrt(t.x*t.x+t.z*t.z))/Math.PI+.5;s.push(r,1-n)}(function(){let t=new H,e=new H,r=new H,n=new H,a=new A,o=new A,u=new A;for(let c=0,d=0;c<i.length;c+=9,d+=6){t.set(i[c+0],i[c+1],i[c+2]),e.set(i[c+3],i[c+4],i[c+5]),r.set(i[c+6],i[c+7],i[c+8]),a.set(s[d+0],s[d+1]),o.set(s[d+2],s[d+3]),u.set(s[d+4],s[d+5]),n.copy(t).add(e).add(r).divideScalar(3);let p=h(n);l(a,d+0,t,p),l(o,d+2,e,p),l(u,d+4,r,p)}})(),function(){for(let t=0;t<s.length;t+=6){let e=s[t+0],r=s[t+2],n=s[t+4],i=Math.max(e,r,n),a=Math.min(e,r,n);i>.9&&a<.1&&(e<.2&&(s[t+0]+=1),r<.2&&(s[t+2]+=1),n<.2&&(s[t+4]+=1))}}()}(),this.setAttribute("position",new et(i,3)),this.setAttribute("normal",new et(i.slice(),3)),this.setAttribute("uv",new et(s,2)),0===n?this.computeVertexNormals():this.normalizeNormals()}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new eq(t.vertices,t.indices,t.radius,t.details)}}class ej extends eq{constructor(t=1,e=0){let r=(1+Math.sqrt(5))/2,n=1/r;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-n,-r,0,-n,r,0,n,-r,0,n,r,-n,-r,0,-n,r,0,n,-r,0,n,r,0,-r,0,-n,r,0,-n,-r,0,n,r,0,n],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],t,e),this.type="DodecahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new ej(t.radius,t.detail)}}class eH extends eV{constructor(t){super(t),this.uuid=y(),this.type="Shape",this.holes=[]}getPointsHoles(t){let e=[];for(let r=0,n=this.holes.length;r<n;r++)e[r]=this.holes[r].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,r=t.holes.length;e<r;e++){let r=t.holes[e];this.holes.push(r.clone())}return this}toJSON(){let t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,r=this.holes.length;e<r;e++){let r=this.holes[e];t.holes.push(r.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,r=t.holes.length;e<r;e++){let r=t.holes[e];this.holes.push(new eV().fromJSON(r))}return this}}let eW=function(t,e,r=2){let n,i,s,a,o,l,h;let u=e&&e.length,c=u?e[0]*r:t.length,d=eX(t,0,c,r,!0),p=[];if(!d||d.next===d.prev)return p;if(u&&(d=function(t,e,r,n){let i,s,a,o,l;let h=[];for(i=0,s=e.length;i<s;i++)a=e[i]*n,o=i<s-1?e[i+1]*n:t.length,(l=eX(t,a,o,n,!1))===l.next&&(l.steiner=!0),h.push(function(t){let e=t,r=t;do(e.x<r.x||e.x===r.x&&e.y<r.y)&&(r=e),e=e.next;while(e!==t)return r}(l));for(h.sort(eZ),i=0;i<h.length;i++)r=function(t,e){let r=function(t,e){let r=e,n=-1/0,i,s=t.x,a=t.y;do{if(a<=r.y&&a>=r.next.y&&r.next.y!==r.y){let t=r.x+(a-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(t<=s&&t>n&&(n=t,i=r.x<r.next.x?r:r.next,t===s))return i}r=r.next}while(r!==e)if(!i)return null;let o=i,l=i.x,h=i.y,u=1/0,c;r=i;do{var d,p;s>=r.x&&r.x>=l&&s!==r.x&&eK(a<h?s:n,a,l,h,a<h?n:s,a,r.x,r.y)&&(c=Math.abs(a-r.y)/(s-r.x),e3(r,t)&&(c<u||c===u&&(r.x>i.x||r.x===i.x&&(d=i,p=r,0>eQ(d.prev,d,p.prev)&&0>eQ(p.next,d,d.next))))&&(i=r,u=c)),r=r.next}while(r!==o)return i}(t,e);if(!r)return e;let n=e4(r,t);return eY(n,n.next),eY(r,r.next)}(h[i],r);return r}(t,e,d,r)),t.length>80*r){n=s=t[0],i=a=t[1];for(let e=r;e<c;e+=r)o=t[e],l=t[e+1],o<n&&(n=o),l<i&&(i=l),o>s&&(s=o),l>a&&(a=l);h=0!==(h=Math.max(s-n,a-i))?32767/h:0}return function t(e,r,n,i,s,a,o){if(!e)return;!o&&a&&function(t,e,r,n){let i=t;do 0===i.z&&(i.z=eJ(i.x,i.y,e,r,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==t)i.prevZ.nextZ=null,i.prevZ=null,function(t){let e,r,n,i,s,a,o,l,h=1;do{for(r=t,t=null,s=null,a=0;r;){for(a++,n=r,o=0,e=0;e<h&&(o++,n=n.nextZ);e++);for(l=h;o>0||l>0&&n;)0!==o&&(0===l||!n||r.z<=n.z)?(i=r,r=r.nextZ,o--):(i=n,n=n.nextZ,l--),s?s.nextZ=i:t=i,i.prevZ=s,s=i;r=n}s.nextZ=null,h*=2}while(a>1)}(i)}(e,i,s,a);let l=e,h,u;for(;e.prev!==e.next;){if(h=e.prev,u=e.next,a?function(t,e,r,n){let i=t.prev,s=t.next;if(eQ(i,t,s)>=0)return!1;let a=i.x,o=t.x,l=s.x,h=i.y,u=t.y,c=s.y,d=a<o?a<l?a:l:o<l?o:l,p=h<u?h<c?h:c:u<c?u:c,m=a>o?a>l?a:l:o>l?o:l,f=h>u?h>c?h:c:u>c?u:c,g=eJ(d,p,e,r,n),x=eJ(m,f,e,r,n),y=t.prevZ,_=t.nextZ;for(;y&&y.z>=g&&_&&_.z<=x;){if(y.x>=d&&y.x<=m&&y.y>=p&&y.y<=f&&y!==i&&y!==s&&eK(a,h,o,u,l,c,y.x,y.y)&&eQ(y.prev,y,y.next)>=0||(y=y.prevZ,_.x>=d&&_.x<=m&&_.y>=p&&_.y<=f&&_!==i&&_!==s&&eK(a,h,o,u,l,c,_.x,_.y)&&eQ(_.prev,_,_.next)>=0))return!1;_=_.nextZ}for(;y&&y.z>=g;){if(y.x>=d&&y.x<=m&&y.y>=p&&y.y<=f&&y!==i&&y!==s&&eK(a,h,o,u,l,c,y.x,y.y)&&eQ(y.prev,y,y.next)>=0)return!1;y=y.prevZ}for(;_&&_.z<=x;){if(_.x>=d&&_.x<=m&&_.y>=p&&_.y<=f&&_!==i&&_!==s&&eK(a,h,o,u,l,c,_.x,_.y)&&eQ(_.prev,_,_.next)>=0)return!1;_=_.nextZ}return!0}(e,i,s,a):function(t){let e=t.prev,r=t.next;if(eQ(e,t,r)>=0)return!1;let n=e.x,i=t.x,s=r.x,a=e.y,o=t.y,l=r.y,h=n<i?n<s?n:s:i<s?i:s,u=a<o?a<l?a:l:o<l?o:l,c=n>i?n>s?n:s:i>s?i:s,d=a>o?a>l?a:l:o>l?o:l,p=r.next;for(;p!==e;){if(p.x>=h&&p.x<=c&&p.y>=u&&p.y<=d&&eK(n,a,i,o,s,l,p.x,p.y)&&eQ(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}(e)){r.push(h.i/n|0),r.push(e.i/n|0),r.push(u.i/n|0),e6(e),e=u.next,l=u.next;continue}if((e=u)===l){o?1===o?t(e=function(t,e,r){let n=t;do{let i=n.prev,s=n.next.next;!e$(i,s)&&e0(i,n,n.next,s)&&e3(i,s)&&e3(s,i)&&(e.push(i.i/r|0),e.push(n.i/r|0),e.push(s.i/r|0),e6(n),e6(n.next),n=t=s),n=n.next}while(n!==t)return eY(n)}(eY(e),r,n),r,n,i,s,a,2):2===o&&function(e,r,n,i,s,a){let o=e;do{let e=o.next.next;for(;e!==o.prev;){var l,h;if(o.i!==e.i&&(l=o,h=e,l.next.i!==h.i&&l.prev.i!==h.i&&!function(t,e){let r=t;do{if(r.i!==t.i&&r.next.i!==t.i&&r.i!==e.i&&r.next.i!==e.i&&e0(r,r.next,t,e))return!0;r=r.next}while(r!==t)return!1}(l,h)&&(e3(l,h)&&e3(h,l)&&function(t,e){let r=t,n=!1,i=(t.x+e.x)/2,s=(t.y+e.y)/2;do r.y>s!=r.next.y>s&&r.next.y!==r.y&&i<(r.next.x-r.x)*(s-r.y)/(r.next.y-r.y)+r.x&&(n=!n),r=r.next;while(r!==t)return n}(l,h)&&(eQ(l.prev,l,h.prev)||eQ(l,h.prev,h))||e$(l,h)&&eQ(l.prev,l,l.next)>0&&eQ(h.prev,h,h.next)>0))){let l=e4(o,e);o=eY(o,o.next),l=eY(l,l.next),t(o,r,n,i,s,a,0),t(l,r,n,i,s,a,0);return}e=e.next}o=o.next}while(o!==e)}(e,r,n,i,s,a):t(eY(e),r,n,i,s,a,1);break}}}(d,p,r,n,i,h,0),p};function eX(t,e,r,n,i){let s,a;if(i===function(t,e,r,n){let i=0;for(let s=e,a=r-n;s<r;s+=n)i+=(t[a]-t[s])*(t[s+1]+t[a+1]),a=s;return i}(t,e,r,n)>0)for(s=e;s<r;s+=n)a=e5(s,t[s],t[s+1],a);else for(s=r-n;s>=e;s-=n)a=e5(s,t[s],t[s+1],a);return a&&e$(a,a.next)&&(e6(a),a=a.next),a}function eY(t,e){if(!t)return t;e||(e=t);let r=t,n;do if(n=!1,!r.steiner&&(e$(r,r.next)||0===eQ(r.prev,r,r.next))){if(e6(r),(r=e=r.prev)===r.next)break;n=!0}else r=r.next;while(n||r!==e)return e}function eZ(t,e){return t.x-e.x}function eJ(t,e,r,n,i){return(t=((t=((t=((t=((t=(t-r)*i|0)|t<<8)&16711935)|t<<4)&252645135)|t<<2)&858993459)|t<<1)&1431655765)|(e=((e=((e=((e=((e=(e-n)*i|0)|e<<8)&16711935)|e<<4)&252645135)|e<<2)&858993459)|e<<1)&1431655765)<<1}function eK(t,e,r,n,i,s,a,o){return(i-a)*(e-o)>=(t-a)*(s-o)&&(t-a)*(n-o)>=(r-a)*(e-o)&&(r-a)*(s-o)>=(i-a)*(n-o)}function eQ(t,e,r){return(e.y-t.y)*(r.x-e.x)-(e.x-t.x)*(r.y-e.y)}function e$(t,e){return t.x===e.x&&t.y===e.y}function e0(t,e,r,n){let i=e2(eQ(t,e,r)),s=e2(eQ(t,e,n)),a=e2(eQ(r,n,t)),o=e2(eQ(r,n,e));return!!(i!==s&&a!==o||0===i&&e1(t,r,e)||0===s&&e1(t,n,e)||0===a&&e1(r,t,n)||0===o&&e1(r,e,n))}function e1(t,e,r){return e.x<=Math.max(t.x,r.x)&&e.x>=Math.min(t.x,r.x)&&e.y<=Math.max(t.y,r.y)&&e.y>=Math.min(t.y,r.y)}function e2(t){return t>0?1:t<0?-1:0}function e3(t,e){return 0>eQ(t.prev,t,t.next)?eQ(t,e,t.next)>=0&&eQ(t,t.prev,e)>=0:0>eQ(t,e,t.prev)||0>eQ(t,t.next,e)}function e4(t,e){let r=new e7(t.i,t.x,t.y),n=new e7(e.i,e.x,e.y),i=t.next,s=e.prev;return t.next=e,e.prev=t,r.next=i,i.prev=r,n.next=r,r.prev=n,s.next=n,n.prev=s,n}function e5(t,e,r,n){let i=new e7(t,e,r);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function e6(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function e7(t,e,r){this.i=t,this.x=e,this.y=r,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}class e9{static area(t){let e=t.length,r=0;for(let n=e-1,i=0;i<e;n=i++)r+=t[n].x*t[i].y-t[i].x*t[n].y;return .5*r}static isClockWise(t){return 0>e9.area(t)}static triangulateShape(t,e){let r=[],n=[],i=[];e8(t),rt(r,t);let s=t.length;e.forEach(e8);for(let t=0;t<e.length;t++)n.push(s),s+=e[t].length,rt(r,e[t]);let a=eW(r,n);for(let t=0;t<a.length;t+=3)i.push(a.slice(t,t+3));return i}}function e8(t){let e=t.length;e>2&&t[e-1].equals(t[0])&&t.pop()}function rt(t,e){for(let r=0;r<e.length;r++)t.push(e[r].x),t.push(e[r].y)}class re extends el{constructor(t=new eH([new A(.5,.5),new A(-.5,.5),new A(-.5,-.5),new A(.5,-.5)]),e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];let r=this,n=[],i=[];for(let s=0,a=t.length;s<a;s++)(function(t){let s,a,o,l;let h=[],u=void 0!==e.curveSegments?e.curveSegments:12,c=void 0!==e.steps?e.steps:1,d=void 0!==e.depth?e.depth:1,p=void 0===e.bevelEnabled||e.bevelEnabled,m=void 0!==e.bevelThickness?e.bevelThickness:.2,f=void 0!==e.bevelSize?e.bevelSize:m-.1,g=void 0!==e.bevelOffset?e.bevelOffset:0,x=void 0!==e.bevelSegments?e.bevelSegments:3,y=e.extrudePath,_=void 0!==e.UVGenerator?e.UVGenerator:rr,v,b=!1;y&&(v=y.getSpacedPoints(c),b=!0,p=!1,s=y.computeFrenetFrames(c,!1),a=new H,o=new H,l=new H),p||(x=0,m=0,f=0,g=0);let w=t.extractPoints(u),M=w.shape,S=w.holes;if(!e9.isClockWise(M)){M=M.reverse();for(let t=0,e=S.length;t<e;t++){let e=S[t];e9.isClockWise(e)&&(S[t]=e.reverse())}}let T=e9.triangulateShape(M,S),z=M;for(let t=0,e=S.length;t<e;t++){let e=S[t];M=M.concat(e)}function E(t,e,r){return e||console.error("THREE.ExtrudeGeometry: vec does not exist"),t.clone().addScaledVector(e,r)}let B=M.length,P=T.length;function N(t,e,r){let n,i,s;let a=t.x-e.x,o=t.y-e.y,l=r.x-t.x,h=r.y-t.y,u=a*a+o*o;if(Math.abs(a*h-o*l)>Number.EPSILON){let c=Math.sqrt(u),d=Math.sqrt(l*l+h*h),p=e.x-o/c,m=e.y+a/c,f=((r.x-h/d-p)*h-(r.y+l/d-m)*l)/(a*h-o*l),g=(n=p+a*f-t.x)*n+(i=m+o*f-t.y)*i;if(g<=2)return new A(n,i);s=Math.sqrt(g/2)}else{let t=!1;a>Number.EPSILON?l>Number.EPSILON&&(t=!0):a<-Number.EPSILON?l<-Number.EPSILON&&(t=!0):Math.sign(o)===Math.sign(h)&&(t=!0),t?(n=-o,i=a,s=Math.sqrt(u)):(n=a,i=o,s=Math.sqrt(u/2))}return new A(n/s,i/s)}let C=[];for(let t=0,e=z.length,r=e-1,n=t+1;t<e;t++,r++,n++)r===e&&(r=0),n===e&&(n=0),C[t]=N(z[t],z[r],z[n]);let O=[],k,I=C.concat();for(let t=0,e=S.length;t<e;t++){let e=S[t];k=[];for(let t=0,r=e.length,n=r-1,i=t+1;t<r;t++,n++,i++)n===r&&(n=0),i===r&&(i=0),k[t]=N(e[t],e[n],e[i]);O.push(k),I=I.concat(k)}for(let t=0;t<x;t++){let e=t/x,r=m*Math.cos(e*Math.PI/2),n=f*Math.sin(e*Math.PI/2)+g;for(let t=0,e=z.length;t<e;t++){let e=E(z[t],C[t],n);F(e.x,e.y,-r)}for(let t=0,e=S.length;t<e;t++){let e=S[t];k=O[t];for(let t=0,i=e.length;t<i;t++){let i=E(e[t],k[t],n);F(i.x,i.y,-r)}}}let R=f+g;for(let t=0;t<B;t++){let e=p?E(M[t],I[t],R):M[t];b?(o.copy(s.normals[0]).multiplyScalar(e.x),a.copy(s.binormals[0]).multiplyScalar(e.y),l.copy(v[0]).add(o).add(a),F(l.x,l.y,l.z)):F(e.x,e.y,0)}for(let t=1;t<=c;t++)for(let e=0;e<B;e++){let r=p?E(M[e],I[e],R):M[e];b?(o.copy(s.normals[t]).multiplyScalar(r.x),a.copy(s.binormals[t]).multiplyScalar(r.y),l.copy(v[t]).add(o).add(a),F(l.x,l.y,l.z)):F(r.x,r.y,d/c*t)}for(let t=x-1;t>=0;t--){let e=t/x,r=m*Math.cos(e*Math.PI/2),n=f*Math.sin(e*Math.PI/2)+g;for(let t=0,e=z.length;t<e;t++){let e=E(z[t],C[t],n);F(e.x,e.y,d+r)}for(let t=0,e=S.length;t<e;t++){let e=S[t];k=O[t];for(let t=0,i=e.length;t<i;t++){let i=E(e[t],k[t],n);b?F(i.x,i.y+v[c-1].y,v[c-1].x+r):F(i.x,i.y,d+r)}}}function V(t,e){let i=t.length;for(;--i>=0;){let s=i,a=i-1;a<0&&(a=t.length-1);for(let t=0,i=c+2*x;t<i;t++){let i=B*t,o=B*(t+1);(function(t,e,i,s){D(t),D(e),D(s),D(e),D(i),D(s);let a=n.length/3,o=_.generateSideWallUV(r,n,a-6,a-3,a-2,a-1);U(o[0]),U(o[1]),U(o[3]),U(o[1]),U(o[2]),U(o[3])})(e+s+i,e+a+i,e+a+o,e+s+o)}}}function F(t,e,r){h.push(t),h.push(e),h.push(r)}function L(t,e,i){D(t),D(e),D(i);let s=n.length/3,a=_.generateTopUV(r,n,s-3,s-2,s-1);U(a[0]),U(a[1]),U(a[2])}function D(t){n.push(h[3*t+0]),n.push(h[3*t+1]),n.push(h[3*t+2])}function U(t){i.push(t.x),i.push(t.y)}(function(){let t=n.length/3;if(p){let t=0*B;for(let e=0;e<P;e++){let r=T[e];L(r[2]+t,r[1]+t,r[0]+t)}t=B*(c+2*x);for(let e=0;e<P;e++){let r=T[e];L(r[0]+t,r[1]+t,r[2]+t)}}else{for(let t=0;t<P;t++){let e=T[t];L(e[2],e[1],e[0])}for(let t=0;t<P;t++){let e=T[t];L(e[0]+B*c,e[1]+B*c,e[2]+B*c)}}r.addGroup(t,n.length/3-t,0)})(),function(){let t=n.length/3,e=0;V(z,0),e+=z.length;for(let t=0,r=S.length;t<r;t++){let r=S[t];V(r,e),e+=r.length}r.addGroup(t,n.length/3-t,1)}()})(t[s]);this.setAttribute("position",new et(n,3)),this.setAttribute("uv",new et(i,2)),this.computeVertexNormals()}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){let t=super.toJSON();return function(t,e,r){if(r.shapes=[],Array.isArray(t))for(let e=0,n=t.length;e<n;e++){let n=t[e];r.shapes.push(n.uuid)}else r.shapes.push(t.uuid);return r.options=Object.assign({},e),void 0!==e.extrudePath&&(r.options.extrudePath=e.extrudePath.toJSON()),r}(this.parameters.shapes,this.parameters.options,t)}static fromJSON(t,e){let r=[];for(let n=0,i=t.shapes.length;n<i;n++){let i=e[t.shapes[n]];r.push(i)}let n=t.options.extrudePath;return void 0!==n&&(t.options.extrudePath=new eI[n.type]().fromJSON(n)),new re(r,t.options)}}let rr={generateTopUV:function(t,e,r,n,i){let s=e[3*r],a=e[3*r+1],o=e[3*n],l=e[3*n+1],h=e[3*i],u=e[3*i+1];return[new A(s,a),new A(o,l),new A(h,u)]},generateSideWallUV:function(t,e,r,n,i,s){let a=e[3*r],o=e[3*r+1],l=e[3*r+2],h=e[3*n],u=e[3*n+1],c=e[3*n+2],d=e[3*i],p=e[3*i+1],m=e[3*i+2],f=e[3*s],g=e[3*s+1],x=e[3*s+2];return Math.abs(o-u)<Math.abs(a-h)?[new A(a,1-l),new A(h,1-c),new A(d,1-m),new A(f,1-x)]:[new A(o,1-l),new A(u,1-c),new A(p,1-m),new A(g,1-x)]}};class rn extends eq{constructor(t=1,e=0){let r=(1+Math.sqrt(5))/2;super([-1,r,0,1,r,0,-1,-r,0,1,-r,0,0,-1,r,0,1,r,0,-1,-r,0,1,-r,r,0,-1,r,0,1,-r,0,-1,-r,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],t,e),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new rn(t.radius,t.detail)}}class ri extends eq{constructor(t=1,e=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],t,e),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new ri(t.radius,t.detail)}}class rs extends el{constructor(t=.5,e=1,r=32,n=1,i=0,s=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:r,phiSegments:n,thetaStart:i,thetaLength:s},r=Math.max(3,r);let a=[],o=[],l=[],h=[],u=t,c=(e-t)/(n=Math.max(1,n)),d=new H,p=new A;for(let t=0;t<=n;t++){for(let t=0;t<=r;t++){let n=i+t/r*s;d.x=u*Math.cos(n),d.y=u*Math.sin(n),o.push(d.x,d.y,d.z),l.push(0,0,1),p.x=(d.x/e+1)/2,p.y=(d.y/e+1)/2,h.push(p.x,p.y)}u+=c}for(let t=0;t<n;t++){let e=t*(r+1);for(let t=0;t<r;t++){let n=t+e,i=n+r+1,s=n+r+2,o=n+1;a.push(n,i,o),a.push(i,s,o)}}this.setIndex(a),this.setAttribute("position",new et(o,3)),this.setAttribute("normal",new et(l,3)),this.setAttribute("uv",new et(h,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new rs(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)}}class ra extends el{constructor(t=new eH([new A(0,.5),new A(-.5,-.5),new A(.5,-.5)]),e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};let r=[],n=[],i=[],s=[],a=0,o=0;if(!1===Array.isArray(t))l(t);else for(let e=0;e<t.length;e++)l(t[e]),this.addGroup(a,o,e),a+=o,o=0;function l(t){let a=n.length/3,l=t.extractPoints(e),h=l.shape,u=l.holes;!1===e9.isClockWise(h)&&(h=h.reverse());for(let t=0,e=u.length;t<e;t++){let e=u[t];!0===e9.isClockWise(e)&&(u[t]=e.reverse())}let c=e9.triangulateShape(h,u);for(let t=0,e=u.length;t<e;t++){let e=u[t];h=h.concat(e)}for(let t=0,e=h.length;t<e;t++){let e=h[t];n.push(e.x,e.y,0),i.push(0,0,1),s.push(e.x,e.y)}for(let t=0,e=c.length;t<e;t++){let e=c[t],n=e[0]+a,i=e[1]+a,s=e[2]+a;r.push(n,i,s),o+=3}}this.setIndex(r),this.setAttribute("position",new et(n,3)),this.setAttribute("normal",new et(i,3)),this.setAttribute("uv",new et(s,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){let t=super.toJSON();return function(t,e){if(e.shapes=[],Array.isArray(t))for(let r=0,n=t.length;r<n;r++){let n=t[r];e.shapes.push(n.uuid)}else e.shapes.push(t.uuid);return e}(this.parameters.shapes,t)}static fromJSON(t,e){let r=[];for(let n=0,i=t.shapes.length;n<i;n++){let i=e[t.shapes[n]];r.push(i)}return new ra(r,t.curveSegments)}}class ro extends el{constructor(t=1,e=32,r=16,n=0,i=2*Math.PI,s=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:r,phiStart:n,phiLength:i,thetaStart:s,thetaLength:a},e=Math.max(3,Math.floor(e)),r=Math.max(2,Math.floor(r));let o=Math.min(s+a,Math.PI),l=0,h=[],u=new H,c=new H,d=[],p=[],m=[],f=[];for(let d=0;d<=r;d++){let g=[],x=d/r,y=0;0===d&&0===s?y=.5/e:d===r&&o===Math.PI&&(y=-.5/e);for(let r=0;r<=e;r++){let o=r/e;u.x=-t*Math.cos(n+o*i)*Math.sin(s+x*a),u.y=t*Math.cos(s+x*a),u.z=t*Math.sin(n+o*i)*Math.sin(s+x*a),p.push(u.x,u.y,u.z),c.copy(u).normalize(),m.push(c.x,c.y,c.z),f.push(o+y,1-x),g.push(l++)}h.push(g)}for(let t=0;t<r;t++)for(let n=0;n<e;n++){let e=h[t][n+1],i=h[t][n],a=h[t+1][n],l=h[t+1][n+1];(0!==t||s>0)&&d.push(e,i,l),(t!==r-1||o<Math.PI)&&d.push(i,a,l)}this.setIndex(d),this.setAttribute("position",new et(p,3)),this.setAttribute("normal",new et(m,3)),this.setAttribute("uv",new et(f,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new ro(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class rl extends eq{constructor(t=1,e=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],t,e),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new rl(t.radius,t.detail)}}class rh extends el{constructor(t=1,e=.4,r=12,n=48,i=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:r,tubularSegments:n,arc:i},r=Math.floor(r),n=Math.floor(n);let s=[],a=[],o=[],l=[],h=new H,u=new H,c=new H;for(let s=0;s<=r;s++)for(let d=0;d<=n;d++){let p=d/n*i,m=s/r*Math.PI*2;u.x=(t+e*Math.cos(m))*Math.cos(p),u.y=(t+e*Math.cos(m))*Math.sin(p),u.z=e*Math.sin(m),a.push(u.x,u.y,u.z),h.x=t*Math.cos(p),h.y=t*Math.sin(p),c.subVectors(u,h).normalize(),o.push(c.x,c.y,c.z),l.push(d/n),l.push(s/r)}for(let t=1;t<=r;t++)for(let e=1;e<=n;e++){let r=(n+1)*t+e-1,i=(n+1)*(t-1)+e-1,a=(n+1)*(t-1)+e,o=(n+1)*t+e;s.push(r,i,o),s.push(i,a,o)}this.setIndex(s),this.setAttribute("position",new et(a,3)),this.setAttribute("normal",new et(o,3)),this.setAttribute("uv",new et(l,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new rh(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)}}class ru extends el{constructor(t=1,e=.4,r=64,n=8,i=2,s=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:t,tube:e,tubularSegments:r,radialSegments:n,p:i,q:s},r=Math.floor(r),n=Math.floor(n);let a=[],o=[],l=[],h=[],u=new H,c=new H,d=new H,p=new H,m=new H,f=new H,g=new H;for(let a=0;a<=r;++a){let y=a/r*i*Math.PI*2;x(y,i,s,t,d),x(y+.01,i,s,t,p),f.subVectors(p,d),g.addVectors(p,d),m.crossVectors(f,g),g.crossVectors(m,f),m.normalize(),g.normalize();for(let t=0;t<=n;++t){let i=t/n*Math.PI*2,s=-e*Math.cos(i),p=e*Math.sin(i);u.x=d.x+(s*g.x+p*m.x),u.y=d.y+(s*g.y+p*m.y),u.z=d.z+(s*g.z+p*m.z),o.push(u.x,u.y,u.z),c.subVectors(u,d).normalize(),l.push(c.x,c.y,c.z),h.push(a/r),h.push(t/n)}}for(let t=1;t<=r;t++)for(let e=1;e<=n;e++){let r=(n+1)*(t-1)+(e-1),i=(n+1)*t+(e-1),s=(n+1)*t+e,o=(n+1)*(t-1)+e;a.push(r,i,o),a.push(i,s,o)}function x(t,e,r,n,i){let s=r/e*t,a=Math.cos(s);i.x=n*(2+a)*.5*Math.cos(t),i.y=n*(2+a)*Math.sin(t)*.5,i.z=n*Math.sin(s)*.5}this.setIndex(a),this.setAttribute("position",new et(o,3)),this.setAttribute("normal",new et(l,3)),this.setAttribute("uv",new et(h,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new ru(t.radius,t.tube,t.tubularSegments,t.radialSegments,t.p,t.q)}}class rc extends el{constructor(t=new eO(new H(-1,-1,0),new H(-1,1,0),new H(1,1,0)),e=64,r=1,n=8,i=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:r,radialSegments:n,closed:i};let s=t.computeFrenetFrames(e,i);this.tangents=s.tangents,this.normals=s.normals,this.binormals=s.binormals;let a=new H,o=new H,l=new A,h=new H,u=[],c=[],d=[],p=[];function m(i){h=t.getPointAt(i/e,h);let l=s.normals[i],d=s.binormals[i];for(let t=0;t<=n;t++){let e=t/n*Math.PI*2,i=Math.sin(e),s=-Math.cos(e);o.x=s*l.x+i*d.x,o.y=s*l.y+i*d.y,o.z=s*l.z+i*d.z,o.normalize(),c.push(o.x,o.y,o.z),a.x=h.x+r*o.x,a.y=h.y+r*o.y,a.z=h.z+r*o.z,u.push(a.x,a.y,a.z)}}(function(){for(let t=0;t<e;t++)m(t);m(!1===i?e:0),function(){for(let t=0;t<=e;t++)for(let r=0;r<=n;r++)l.x=t/e,l.y=r/n,d.push(l.x,l.y)}(),function(){for(let t=1;t<=e;t++)for(let e=1;e<=n;e++){let r=(n+1)*(t-1)+(e-1),i=(n+1)*t+(e-1),s=(n+1)*t+e,a=(n+1)*(t-1)+e;p.push(r,i,a),p.push(i,s,a)}}()})(),this.setIndex(p),this.setAttribute("position",new et(u,3)),this.setAttribute("normal",new et(c,3)),this.setAttribute("uv",new et(d,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){let t=super.toJSON();return t.path=this.parameters.path.toJSON(),t}static fromJSON(t){return new rc(new eI[t.path.type]().fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)}}function rd(t,e,r){return t&&(r||t.constructor!==e)?"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t):t}class rp{constructor(t,e,r,n){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=void 0!==n?n:new e.constructor(r),this.sampleValues=e,this.valueSize=r,this.settings=null,this.DefaultSettings_={}}evaluate(t){let e=this.parameterPositions,r=this._cachedIndex,n=e[r],i=e[r-1];t:{e:{let s;r:{n:if(!(t<n)){for(let s=r+2;;){if(void 0===n){if(t<i)break n;return r=e.length,this._cachedIndex=r,this.copySampleValue_(r-1)}if(r===s)break;if(i=n,t<(n=e[++r]))break e}s=e.length;break r}if(!(t>=i)){let a=e[1];t<a&&(r=2,i=a);for(let s=r-2;;){if(void 0===i)return this._cachedIndex=0,this.copySampleValue_(0);if(r===s)break;if(n=i,t>=(i=e[--r-1]))break e}s=r,r=0;break r}break t}for(;r<s;){let n=r+s>>>1;t<e[n]?s=n:r=n+1}if(n=e[r],void 0===(i=e[r-1]))return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===n)return r=e.length,this._cachedIndex=r,this.copySampleValue_(r-1)}this._cachedIndex=r,this.intervalChanged_(r,i,n)}return this.interpolate_(r,i,t,n)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){let e=this.resultBuffer,r=this.sampleValues,n=this.valueSize,i=t*n;for(let t=0;t!==n;++t)e[t]=r[i+t];return e}interpolate_(){throw Error("call to abstract method")}intervalChanged_(){}}class rm extends rp{constructor(t,e,r,n){super(t,e,r,n),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:2400,endingEnd:2400}}intervalChanged_(t,e,r){let n=this.parameterPositions,i=t-2,s=t+1,a=n[i],o=n[s];if(void 0===a)switch(this.getSettings_().endingStart){case 2401:i=t,a=2*e-r;break;case 2402:i=n.length-2,a=e+n[i]-n[i+1];break;default:i=t,a=r}if(void 0===o)switch(this.getSettings_().endingEnd){case 2401:s=t,o=2*r-e;break;case 2402:s=1,o=r+n[1]-n[0];break;default:s=t-1,o=e}let l=(r-e)*.5,h=this.valueSize;this._weightPrev=l/(e-a),this._weightNext=l/(o-r),this._offsetPrev=i*h,this._offsetNext=s*h}interpolate_(t,e,r,n){let i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=t*a,l=o-a,h=this._offsetPrev,u=this._offsetNext,c=this._weightPrev,d=this._weightNext,p=(r-e)/(n-e),m=p*p,f=m*p,g=-c*f+2*c*m-c*p,x=(1+c)*f+(-1.5-2*c)*m+(-.5+c)*p+1,y=(-1-d)*f+(1.5+d)*m+.5*p,_=d*f-d*m;for(let t=0;t!==a;++t)i[t]=g*s[h+t]+x*s[l+t]+y*s[o+t]+_*s[u+t];return i}}class rf extends rp{constructor(t,e,r,n){super(t,e,r,n)}interpolate_(t,e,r,n){let i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=t*a,l=o-a,h=(r-e)/(n-e),u=1-h;for(let t=0;t!==a;++t)i[t]=s[l+t]*u+s[o+t]*h;return i}}class rg extends rp{constructor(t,e,r,n){super(t,e,r,n)}interpolate_(t){return this.copySampleValue_(t-1)}}class rx{constructor(t,e,r,n){if(void 0===t)throw Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=rd(e,this.TimeBufferType),this.values=rd(r,this.ValueBufferType),this.setInterpolation(n||this.DefaultInterpolation)}static toJSON(t){let e;let r=t.constructor;if(r.toJSON!==this.toJSON)e=r.toJSON(t);else{e={name:t.name,times:rd(t.times,Array),values:rd(t.values,Array)};let r=t.getInterpolation();r!==t.DefaultInterpolation&&(e.interpolation=r)}return e.type=t.ValueTypeName,e}InterpolantFactoryMethodDiscrete(t){return new rg(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new rf(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new rm(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case 2300:e=this.InterpolantFactoryMethodDiscrete;break;case 2301:e=this.InterpolantFactoryMethodLinear;break;case 2302:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){let e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw Error(e)}return console.warn("THREE.KeyframeTrack:",e),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return 2300;case this.InterpolantFactoryMethodLinear:return 2301;case this.InterpolantFactoryMethodSmooth:return 2302}}getValueSize(){return this.values.length/this.times.length}shift(t){if(0!==t){let e=this.times;for(let r=0,n=e.length;r!==n;++r)e[r]+=t}return this}scale(t){if(1!==t){let e=this.times;for(let r=0,n=e.length;r!==n;++r)e[r]*=t}return this}trim(t,e){let r=this.times,n=r.length,i=0,s=n-1;for(;i!==n&&r[i]<t;)++i;for(;-1!==s&&r[s]>e;)--s;if(++s,0!==i||s!==n){i>=s&&(i=(s=Math.max(s,1))-1);let t=this.getValueSize();this.times=r.slice(i,s),this.values=this.values.slice(i*t,s*t)}return this}validate(){let t=!0,e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);let r=this.times,n=this.values,i=r.length;0===i&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let s=null;for(let e=0;e!==i;e++){let n=r[e];if("number"==typeof n&&isNaN(n)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,e,n),t=!1;break}if(null!==s&&s>n){console.error("THREE.KeyframeTrack: Out of order keys.",this,e,n,s),t=!1;break}s=n}if(void 0!==n&&ArrayBuffer.isView(n)&&!(n instanceof DataView))for(let e=0,r=n.length;e!==r;++e){let r=n[e];if(isNaN(r)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,e,r),t=!1;break}}return t}optimize(){let t=this.times.slice(),e=this.values.slice(),r=this.getValueSize(),n=2302===this.getInterpolation(),i=t.length-1,s=1;for(let a=1;a<i;++a){let i=!1,o=t[a];if(o!==t[a+1]&&(1!==a||o!==t[0])){if(n)i=!0;else{let t=a*r,n=t-r,s=t+r;for(let a=0;a!==r;++a){let r=e[t+a];if(r!==e[n+a]||r!==e[s+a]){i=!0;break}}}}if(i){if(a!==s){t[s]=t[a];let n=a*r,i=s*r;for(let t=0;t!==r;++t)e[i+t]=e[n+t]}++s}}if(i>0){t[s]=t[i];for(let t=i*r,n=s*r,a=0;a!==r;++a)e[n+a]=e[t+a];++s}return s!==t.length?(this.times=t.slice(0,s),this.values=e.slice(0,s*r)):(this.times=t,this.values=e),this}clone(){let t=this.times.slice(),e=this.values.slice(),r=new this.constructor(this.name,t,e);return r.createInterpolant=this.createInterpolant,r}}rx.prototype.TimeBufferType=Float32Array,rx.prototype.ValueBufferType=Float32Array,rx.prototype.DefaultInterpolation=2301;class ry extends rx{}ry.prototype.ValueTypeName="bool",ry.prototype.ValueBufferType=Array,ry.prototype.DefaultInterpolation=2300,ry.prototype.InterpolantFactoryMethodLinear=void 0,ry.prototype.InterpolantFactoryMethodSmooth=void 0,(class extends rx{}).prototype.ValueTypeName="color",(class extends rx{}).prototype.ValueTypeName="number";class r_ extends rp{constructor(t,e,r,n){super(t,e,r,n)}interpolate_(t,e,r,n){let i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=(r-e)/(n-e),l=t*a;for(let t=l+a;l!==t;l+=4)j.slerpFlat(i,0,s,l-a,s,l,o);return i}}class rv extends rx{InterpolantFactoryMethodLinear(t){return new r_(this.times,this.values,this.getValueSize(),t)}}rv.prototype.ValueTypeName="quaternion",rv.prototype.DefaultInterpolation=2301,rv.prototype.InterpolantFactoryMethodSmooth=void 0;class rb extends rx{}rb.prototype.ValueTypeName="string",rb.prototype.ValueBufferType=Array,rb.prototype.DefaultInterpolation=2300,rb.prototype.InterpolantFactoryMethodLinear=void 0,rb.prototype.InterpolantFactoryMethodSmooth=void 0,(class extends rx{}).prototype.ValueTypeName="vector";let rw="\\[\\]\\.:\\/",rM=RegExp("["+rw+"]","g"),rS="[^"+rw+"]",rA="[^"+rw.replace("\\.","")+"]",rT=/((?:WC+[\/:])*)/.source.replace("WC",rS),rz=RegExp("^"+rT+/(WCOD+)?/.source.replace("WCOD",rA)+/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",rS)+/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",rS)+"$"),rE=["material","materials","bones","map"];class rB{constructor(t,e,r){this.path=e,this.parsedPath=r||rB.parseTrackName(e),this.node=rB.findNode(t,this.parsedPath.nodeName),this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,r){return t&&t.isAnimationObjectGroup?new rB.Composite(t,e,r):new rB(t,e,r)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(rM,"")}static parseTrackName(t){let e=rz.exec(t);if(null===e)throw Error("PropertyBinding: Cannot parse trackName: "+t);let r={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},n=r.nodeName&&r.nodeName.lastIndexOf(".");if(void 0!==n&&-1!==n){let t=r.nodeName.substring(n+1);-1!==rE.indexOf(t)&&(r.nodeName=r.nodeName.substring(0,n),r.objectName=t)}if(null===r.propertyName||0===r.propertyName.length)throw Error("PropertyBinding: can not parse propertyName from trackName: "+t);return r}static findNode(t,e){if(void 0===e||""===e||"."===e||-1===e||e===t.name||e===t.uuid)return t;if(t.skeleton){let r=t.skeleton.getBoneByName(e);if(void 0!==r)return r}if(t.children){let r=function(t){for(let n=0;n<t.length;n++){let i=t[n];if(i.name===e||i.uuid===e)return i;let s=r(i.children);if(s)return s}return null},n=r(t.children);if(n)return n}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){let r=this.resolvedProperty;for(let n=0,i=r.length;n!==i;++n)t[e++]=r[n]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){let r=this.resolvedProperty;for(let n=0,i=r.length;n!==i;++n)r[n]=t[e++]}_setValue_array_setNeedsUpdate(t,e){let r=this.resolvedProperty;for(let n=0,i=r.length;n!==i;++n)r[n]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){let r=this.resolvedProperty;for(let n=0,i=r.length;n!==i;++n)r[n]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node,e=this.parsedPath,r=e.objectName,n=e.propertyName,i=e.propertyIndex;if(t||(t=rB.findNode(this.rootNode,e.nodeName),this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(r){let n=e.objectIndex;switch(r){case"materials":if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}t=t.material.materials;break;case"bones":if(!t.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}t=t.skeleton.bones;for(let e=0;e<t.length;e++)if(t[e].name===n){n=e;break}break;case"map":if("map"in t){t=t.map;break}if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}t=t.material.map;break;default:if(void 0===t[r]){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}t=t[r]}if(void 0!==n){if(void 0===t[n]){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);return}t=t[n]}}let s=t[n];if(void 0===s){console.error("THREE.PropertyBinding: Trying to update property for track: "+e.nodeName+"."+n+" but it wasn't found.",t);return}let a=this.Versioning.None;this.targetObject=t,void 0!==t.needsUpdate?a=this.Versioning.NeedsUpdate:void 0!==t.matrixWorldNeedsUpdate&&(a=this.Versioning.MatrixWorldNeedsUpdate);let o=this.BindingType.Direct;if(void 0!==i){if("morphTargetInfluences"===n){if(!t.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!t.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}void 0!==t.morphTargetDictionary[i]&&(i=t.morphTargetDictionary[i])}o=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=i}else void 0!==s.fromArray&&void 0!==s.toArray?(o=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(o=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=n;this.getValue=this.GetterByBindingType[o],this.setValue=this.SetterByBindingTypeAndVersioning[o][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}rB.Composite=class{constructor(t,e,r){let n=r||rB.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,n)}getValue(t,e){this.bind();let r=this._targetGroup.nCachedObjects_,n=this._bindings[r];void 0!==n&&n.getValue(t,e)}setValue(t,e){let r=this._bindings;for(let n=this._targetGroup.nCachedObjects_,i=r.length;n!==i;++n)r[n].setValue(t,e)}bind(){let t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,r=t.length;e!==r;++e)t[e].bind()}unbind(){let t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,r=t.length;e!==r;++e)t[e].unbind()}},rB.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},rB.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},rB.prototype.GetterByBindingType=[rB.prototype._getValue_direct,rB.prototype._getValue_array,rB.prototype._getValue_arrayElement,rB.prototype._getValue_toArray],rB.prototype.SetterByBindingTypeAndVersioning=[[rB.prototype._setValue_direct,rB.prototype._setValue_direct_setNeedsUpdate,rB.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[rB.prototype._setValue_array,rB.prototype._setValue_array_setNeedsUpdate,rB.prototype._setValue_array_setMatrixWorldNeedsUpdate],[rB.prototype._setValue_arrayElement,rB.prototype._setValue_arrayElement_setNeedsUpdate,rB.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[rB.prototype._setValue_fromArray,rB.prototype._setValue_fromArray_setNeedsUpdate,rB.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]],new Float32Array(1);let rP=new H,rN=new H;class rC{constructor(t=new H,e=new H){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){rP.subVectors(t,this.start),rN.subVectors(this.end,this.start);let r=rN.dot(rN),n=rN.dot(rP)/r;return e&&(n=_(n,0,1)),n}closestPointToPoint(t,e,r){let n=this.closestPointToPointParameter(t,e);return this.delta(r).multiplyScalar(n).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:"163"}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__="163")}),s("i1Cyt",function(e,r){t(e.exports,"DEFAULT_OPTIONS",()=>B),t(e.exports,"MeshBVH",()=>P);var n=i("e06gU"),s=i("gbfhP"),a=i("2lzJi"),o=i("2Vkjh"),l=i("iiPZZ"),h=i("eohSc"),u=i("7HfaT"),c=i("5W1a5"),d=i("cKddI"),p=i("ipX80"),m=i("AZSfZ"),f=i("b2q45"),g=i("5uIRP"),x=i("hby9v"),y=i("49xTg"),_=i("l19Kf"),v=i("gLkZA"),b=i("gH1ap"),w=i("jTzI1"),M=i("74moN"),S=i("4ORoa"),A=i("kddjw"),T=i("3rKF7");let z=new o.OrientedBox,E=new n.Box3,B={strategy:s.CENTER,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class P{static serialize(t,e={}){e={cloneBuffers:!0,...e};let r=t.geometry,n=t._roots,i=t._indirectBuffer,s=r.getIndex();return e.cloneBuffers?{roots:n.map(t=>t.slice()),index:s?s.array.slice():null,indirectBuffer:i?i.slice():null}:{roots:n,index:s?s.array:null,indirectBuffer:i}}static deserialize(t,e,r={}){r={setIndex:!0,indirect:!!t.indirectBuffer,...r};let{index:i,roots:a,indirectBuffer:o}=t,l=new P(e,{...r,[s.SKIP_GENERATION]:!0});if(l._roots=a,l._indirectBuffer=o||null,r.setIndex){let r=e.getIndex();if(null===r){let r=new n.BufferAttribute(t.index,1,!1);e.setIndex(r)}else r.array!==i&&(r.array.set(i),r.needsUpdate=!0)}return l}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw Error("MeshBVH: Only BufferGeometries are supported.");if((e=Object.assign({...B,[s.SKIP_GENERATION]:!1},e)).useSharedArrayBuffer&&!(0,S.isSharedArrayBufferSupported)())throw Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[s.SKIP_GENERATION]||((0,a.buildPackedTree)(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new n.Box3)));let{_indirectBuffer:r}=this;this.resolveTriangleIndex=e.indirect?t=>r[t]:t=>t}refit(t=null){return(this.indirect?_.refit_indirect:p.refit)(this,t)}traverse(t,e=0){let r=this._roots[e],n=new Uint32Array(r),i=new Uint16Array(r);(function e(a,o=0){let l=2*a,h=i[l+15]===s.IS_LEAFNODE_FLAG;if(h){let e=n[a+6],s=i[l+14];t(o,h,new Float32Array(r,4*a,6),e,s)}else{let i=a+s.BYTES_PER_NODE/4,l=n[a+6],u=n[a+7];t(o,h,new Float32Array(r,4*a,6),u)||(e(i,o+1),e(l,o+1))}})(0)}raycast(t,e=n.FrontSide){let r=this._roots,i=this.geometry,s=[],a=e.isMaterial,o=Array.isArray(e),l=i.groups,h=a?e.side:e,u=this.indirect?v.raycast_indirect:m.raycast;for(let n=0,i=r.length;n<i;n++){let r=o?e[l[n].materialIndex].side:h,i=s.length;if(u(this,n,r,t,s),o){let t=l[n].materialIndex;for(let e=i,r=s.length;e<r;e++)s[e].face.materialIndex=t}}return s}raycastFirst(t,e=n.FrontSide){let r=this._roots,i=this.geometry,s=e.isMaterial,a=Array.isArray(e),o=null,l=i.groups,h=s?e.side:e,u=this.indirect?b.raycastFirst_indirect:f.raycastFirst;for(let n=0,i=r.length;n<i;n++){let r=a?e[l[n].materialIndex].side:h,i=u(this,n,r,t);null!=i&&(null==o||i.distance<o.distance)&&(o=i,a&&(i.face.materialIndex=l[n].materialIndex))}return o}intersectsGeometry(t,e){let r=!1,n=this._roots,i=this.indirect?w.intersectsGeometry_indirect:g.intersectsGeometry;for(let s=0,a=n.length;s<a&&!(r=i(this,s,t,e));s++);return r}shapecast(t){let e=(0,h.ExtendedTrianglePool).getPrimitive(),r=this.indirect?y.iterateOverTriangles_indirect:d.iterateOverTriangles,{boundsTraverseOrder:n,intersectsBounds:i,intersectsRange:s,intersectsTriangle:a}=t;if(s&&a){let t=s;s=(n,i,s,o,l)=>!!t(n,i,s,o,l)||r(n,i,this,a,s,o,e)}else s||(s=a?(t,n,i,s)=>r(t,n,this,a,i,s,e):(t,e,r)=>r);let o=!1,l=0,c=this._roots;for(let t=0,e=c.length;t<e;t++){let e=c[t];if(o=(0,u.shapecast)(this,t,i,s,n,l))break;l+=e.byteLength}return(0,h.ExtendedTrianglePool).releasePrimitive(e),o}bvhcast(t,e,r){let{intersectsRanges:n,intersectsTriangles:i}=r,s=(0,h.ExtendedTrianglePool).getPrimitive(),a=this.geometry.index,o=this.geometry.attributes.position,l=this.indirect?t=>{let e=this.resolveTriangleIndex(t);(0,A.setTriangle)(s,3*e,a,o)}:t=>{(0,A.setTriangle)(s,3*t,a,o)},u=(0,h.ExtendedTrianglePool).getPrimitive(),c=t.geometry.index,d=t.geometry.attributes.position,p=t.indirect?e=>{let r=t.resolveTriangleIndex(e);(0,A.setTriangle)(u,3*r,c,d)}:t=>{(0,A.setTriangle)(u,3*t,c,d)};if(i){let t=(t,r,n,a,o,h,c,d)=>{for(let m=n,f=n+a;m<f;m++){p(m),u.a.applyMatrix4(e),u.b.applyMatrix4(e),u.c.applyMatrix4(e),u.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++)if(l(e),s.needsUpdate=!0,i(s,u,e,m,o,h,c,d))return!0}return!1};if(n){let e=n;n=function(r,n,i,s,a,o,l,h){return!!e(r,n,i,s,a,o,l,h)||t(r,n,i,s,a,o,l,h)}}else n=t}return(0,T.bvhcast)(this,t,e,n)}intersectsBox(t,e){return z.set(t.min,t.max,e),z.needsUpdate=!0,this.shapecast({intersectsBounds:t=>z.intersectsBox(t),intersectsTriangle:t=>z.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,r={},n={},i=0,s=1/0){return(this.indirect?M.closestPointToGeometry_indirect:x.closestPointToGeometry)(this,t,e,r,n,i,s)}closestPointToPoint(t,e={},r=0,n=1/0){return(0,c.closestPointToPoint)(this,t,e,r,n)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(e=>{(0,l.arrayToBox)(0,new Float32Array(e),E),t.union(E)}),t}}}),s("gbfhP",function(e,r){t(e.exports,"CENTER",()=>n),t(e.exports,"AVERAGE",()=>i),t(e.exports,"SAH",()=>s),t(e.exports,"CONTAINED",()=>a),t(e.exports,"TRIANGLE_INTERSECT_COST",()=>o),t(e.exports,"TRAVERSAL_COST",()=>l),t(e.exports,"BYTES_PER_NODE",()=>h),t(e.exports,"IS_LEAFNODE_FLAG",()=>u),t(e.exports,"FLOAT32_EPSILON",()=>c),t(e.exports,"SKIP_GENERATION",()=>d);let n=0,i=1,s=2,a=2,o=1.25,l=1,h=32,u=65535,c=5960464477539063e-23,d=Symbol("SKIP_GENERATION")}),s("2lzJi",function(e,r){t(e.exports,"generateIndirectBuffer",()=>d),t(e.exports,"buildTree",()=>p),t(e.exports,"buildPackedTree",()=>m);var n=i("6Y4FX"),s=i("lxFhA"),a=i("8skbp"),o=i("8al98"),l=i("gbfhP"),h=i("iTdGp"),u=i("eFbLe"),c=i("271LZ");function d(t,e){let r=(t.index?t.index.count:t.attributes.position.count)/3,n=r>65536,i=n?4:2,s=e?new SharedArrayBuffer(r*i):new ArrayBuffer(r*i),a=n?new Uint32Array(s):new Uint16Array(s);for(let t=0,e=a.length;t<e;t++)a[t]=t;return a}function p(t,e,r,i,l){let{maxDepth:c,verbose:d,maxLeafTris:p,strategy:m,onProgress:f,indirect:g}=l,x=t._indirectBuffer,y=t.geometry,_=y.index?y.index.array:null,v=g?u.partition_indirect:h.partition,b=(0,n.getTriCount)(y),w=new Float32Array(6),M=!1,S=new o.MeshBVHNode;return(0,s.getBounds)(e,r,i,S.boundingData,w),function t(r,n,i,l=null,h=0){if(!M&&h>=c&&(M=!0,d&&(console.warn(`MeshBVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`),console.warn(y))),i<=p||h>=c)return A(n+i),r.offset=n,r.count=i,r;let u=(0,a.getOptimalSplit)(r.boundingData,l,e,n,i,m);if(-1===u.axis)return A(n+i),r.offset=n,r.count=i,r;let f=v(x,_,e,n,i,u);if(f===n||f===n+i)A(n+i),r.offset=n,r.count=i;else{r.splitAxis=u.axis;let a=new o.MeshBVHNode,l=f-n;r.left=a,(0,s.getBounds)(e,n,l,a.boundingData,w),t(a,n,l,w,h+1);let c=new o.MeshBVHNode,d=i-l;r.right=c,(0,s.getBounds)(e,f,d,c.boundingData,w),t(c,f,d,w,h+1)}return r}(S,r,i,w),S;function A(t){f&&f(t/b)}}function m(t,e){let r=t.geometry;e.indirect&&(t._indirectBuffer=d(r,e.useSharedArrayBuffer),(0,n.hasGroupGaps)(r)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),t._indirectBuffer||(0,n.ensureIndex)(r,e);let i=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,a=(0,s.computeTriangleBounds)(r),o=e.indirect?(0,n.getFullGeometryRange)(r):(0,n.getRootIndexRanges)(r);t._roots=o.map(r=>{let n=p(t,a,r.offset,r.count,e),s=(0,c.countNodes)(n),o=new i(l.BYTES_PER_NODE*s);return(0,c.populateBuffer)(0,n,o),o})}}),s("6Y4FX",function(e,r){t(e.exports,"getTriCount",()=>s),t(e.exports,"ensureIndex",()=>a),t(e.exports,"getFullGeometryRange",()=>o),t(e.exports,"getRootIndexRanges",()=>l),t(e.exports,"hasGroupGaps",()=>h);var n=i("e06gU");function s(t){return(t.index?t.index.count:t.attributes.position.count)/3}function a(t,e){if(!t.index){let r=t.attributes.position.count,i=function(t,e=ArrayBuffer){return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}(r,e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);t.setIndex(new n.BufferAttribute(i,1));for(let t=0;t<r;t++)i[t]=t}}function o(t){let e=s(t),r=t.drawRange,n=r.start/3,i=(r.start+r.count)/3,a=Math.max(0,n);return[{offset:Math.floor(a),count:Math.floor(Math.min(e,i)-a)}]}function l(t){if(!t.groups||!t.groups.length)return o(t);let e=[],r=new Set,n=t.drawRange,i=n.start/3,s=(n.start+n.count)/3;for(let e of t.groups){let t=e.start/3,n=(e.start+e.count)/3;r.add(Math.max(i,t)),r.add(Math.min(s,n))}let a=Array.from(r.values()).sort((t,e)=>t-e);for(let t=0;t<a.length-1;t++){let r=a[t],n=a[t+1];e.push({offset:Math.floor(r),count:Math.floor(n-r)})}return e}function h(t){if(0===t.groups.length)return!1;let e=s(t),r=l(t).sort((t,e)=>t.offset-e.offset),n=r[r.length-1];n.count=Math.min(e-n.offset,n.count);let i=0;return r.forEach(({count:t})=>i+=t),e!==i}}),s("lxFhA",function(e,r){t(e.exports,"getBounds",()=>a),t(e.exports,"computeTriangleBounds",()=>o);var n=i("gbfhP"),s=i("6Y4FX");function a(t,e,r,n,i){let s=1/0,a=1/0,o=1/0,l=-1/0,h=-1/0,u=-1/0,c=1/0,d=1/0,p=1/0,m=-1/0,f=-1/0,g=-1/0;for(let n=6*e,i=(e+r)*6;n<i;n+=6){let e=t[n+0],r=t[n+1],i=e-r,x=e+r;i<s&&(s=i),x>l&&(l=x),e<c&&(c=e),e>m&&(m=e);let y=t[n+2],_=t[n+3],v=y-_,b=y+_;v<a&&(a=v),b>h&&(h=b),y<d&&(d=y),y>f&&(f=y);let w=t[n+4],M=t[n+5],S=w-M,A=w+M;S<o&&(o=S),A>u&&(u=A),w<p&&(p=w),w>g&&(g=w)}n[0]=s,n[1]=a,n[2]=o,n[3]=l,n[4]=h,n[5]=u,i[0]=c,i[1]=d,i[2]=p,i[3]=m,i[4]=f,i[5]=g}function o(t,e=null,r=null,i=null){let a;let o=t.attributes.position,l=t.index?t.index.array:null,h=(0,s.getTriCount)(t),u=o.normalized;null===e?(a=new Float32Array(24*h),r=0,i=h):(a=e,r=r||0,i=i||h);let c=o.array,d=o.offset||0,p=3;o.isInterleavedBufferAttribute&&(p=o.data.stride);let m=["getX","getY","getZ"];for(let t=r;t<r+i;t++){let e=3*t,r=6*t,i=e+0,s=e+1,h=e+2;l&&(i=l[i],s=l[s],h=l[h]),u||(i=i*p+d,s=s*p+d,h=h*p+d);for(let t=0;t<3;t++){let e,l,d;u?(e=o[m[t]](i),l=o[m[t]](s),d=o[m[t]](h)):(e=c[i+t],l=c[s+t],d=c[h+t]);let p=e;l<p&&(p=l),d<p&&(p=d);let f=e;l>f&&(f=l),d>f&&(f=d);let g=(f-p)/2,x=2*t;a[r+x+0]=p+g,a[r+x+1]=g+(Math.abs(p)+g)*n.FLOAT32_EPSILON}}return a}}),s("8skbp",function(e,r){t(e.exports,"getOptimalSplit",()=>h);var n=i("iiPZZ"),s=i("gbfhP");let a=(t,e)=>t.candidate-e.candidate,o=Array(32).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),l=new Float32Array(6);function h(t,e,r,i,h,u){let c=-1,d=0;if(u===s.CENTER)-1!==(c=(0,n.getLongestEdgeIndex)(e))&&(d=(e[c]+e[c+3])/2);else if(u===s.AVERAGE)-1!==(c=(0,n.getLongestEdgeIndex)(t))&&(d=function(t,e,r,n){let i=0;for(let s=e,a=e+r;s<a;s++)i+=t[6*s+2*n];return i/r}(r,i,h,c));else if(u===s.SAH){let u=(0,n.computeSurfaceArea)(t),p=s.TRIANGLE_INTERSECT_COST*h,m=6*i,f=(i+h)*6;for(let t=0;t<3;t++){let i=e[t],g=(e[t+3]-i)/32;if(h<8){let e=[...o];e.length=h;let i=0;for(let s=m;s<f;s+=6,i++){let a=e[i];a.candidate=r[s+2*t],a.count=0;let{bounds:o,leftCacheBounds:l,rightCacheBounds:h}=a;for(let t=0;t<3;t++)h[t]=1/0,h[t+3]=-1/0,l[t]=1/0,l[t+3]=-1/0,o[t]=1/0,o[t+3]=-1/0;(0,n.expandByTriangleBounds)(s,r,o)}e.sort(a);let l=h;for(let t=0;t<l;t++){let r=e[t];for(;t+1<l&&e[t+1].candidate===r.candidate;)e.splice(t+1,1),l--}for(let i=m;i<f;i+=6){let s=r[i+2*t];for(let t=0;t<l;t++){let a=e[t];s>=a.candidate?(0,n.expandByTriangleBounds)(i,r,a.rightCacheBounds):((0,n.expandByTriangleBounds)(i,r,a.leftCacheBounds),a.count++)}}for(let r=0;r<l;r++){let i=e[r],a=i.count,o=h-i.count,l=i.leftCacheBounds,m=i.rightCacheBounds,f=0;0!==a&&(f=(0,n.computeSurfaceArea)(l)/u);let g=0;0!==o&&(g=(0,n.computeSurfaceArea)(m)/u);let x=s.TRAVERSAL_COST+s.TRIANGLE_INTERSECT_COST*(f*a+g*o);x<p&&(c=t,p=x,d=i.candidate)}}else{for(let t=0;t<32;t++){let e=o[t];e.count=0,e.candidate=i+g+t*g;let r=e.bounds;for(let t=0;t<3;t++)r[t]=1/0,r[t+3]=-1/0}for(let e=m;e<f;e+=6){let s=~~((r[e+2*t]-i)/g);s>=32&&(s=31);let a=o[s];a.count++,(0,n.expandByTriangleBounds)(e,r,a.bounds)}let e=o[31];(0,n.copyBounds)(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){let e=o[t],r=o[t+1];(0,n.unionBounds)(e.bounds,r.rightCacheBounds,e.rightCacheBounds)}let a=0;for(let e=0;e<31;e++){let r=o[e],i=r.count,m=r.bounds,f=o[e+1].rightCacheBounds;0!==i&&(0===a?(0,n.copyBounds)(m,l):(0,n.unionBounds)(m,l,l));let g=0,x=0;0!==(a+=i)&&(g=(0,n.computeSurfaceArea)(l)/u);let y=h-a;0!==y&&(x=(0,n.computeSurfaceArea)(f)/u);let _=s.TRAVERSAL_COST+s.TRIANGLE_INTERSECT_COST*(g*a+x*y);_<p&&(c=t,p=_,d=r.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${u} used.`);return{axis:c,pos:d}}}),s("iiPZZ",function(e,r){function n(t,e,r){return r.min.x=e[t],r.min.y=e[t+1],r.min.z=e[t+2],r.max.x=e[t+3],r.max.y=e[t+4],r.max.z=e[t+5],r}function i(t){let e=-1,r=-1/0;for(let n=0;n<3;n++){let i=t[n+3]-t[n];i>r&&(r=i,e=n)}return e}function s(t,e){e.set(t)}function a(t,e,r){let n,i;for(let s=0;s<3;s++){let a=s+3;n=t[s],i=e[s],r[s]=n<i?n:i,n=t[a],i=e[a],r[a]=n>i?n:i}}function o(t,e,r){for(let n=0;n<3;n++){let i=e[t+2*n],s=e[t+2*n+1],a=i-s,o=i+s;a<r[n]&&(r[n]=a),o>r[n+3]&&(r[n+3]=o)}}function l(t){let e=t[3]-t[0],r=t[4]-t[1],n=t[5]-t[2];return 2*(e*r+r*n+n*e)}t(e.exports,"arrayToBox",()=>n),t(e.exports,"getLongestEdgeIndex",()=>i),t(e.exports,"copyBounds",()=>s),t(e.exports,"unionBounds",()=>a),t(e.exports,"expandByTriangleBounds",()=>o),t(e.exports,"computeSurfaceArea",()=>l)}),s("8al98",function(e,r){t(e.exports,"MeshBVHNode",()=>n);class n{constructor(){this.boundingData=new Float32Array(6)}}}),s("iTdGp",function(e,r){t(e.exports,"partition",()=>n);function n(t,e,r,n,i,s){let a=n,o=n+i-1,l=s.pos,h=2*s.axis;for(;;){for(;a<=o&&r[6*a+h]<l;)a++;for(;a<=o&&r[6*o+h]>=l;)o--;if(!(a<o))return a;for(let t=0;t<3;t++){let r=e[3*a+t];e[3*a+t]=e[3*o+t],e[3*o+t]=r}for(let t=0;t<6;t++){let e=r[6*a+t];r[6*a+t]=r[6*o+t],r[6*o+t]=e}a++,o--}}}),s("eFbLe",function(e,r){t(e.exports,"partition_indirect",()=>n);function n(t,e,r,n,i,s){let a=n,o=n+i-1,l=s.pos,h=2*s.axis;for(;;){for(;a<=o&&r[6*a+h]<l;)a++;for(;a<=o&&r[6*o+h]>=l;)o--;if(!(a<o))return a;{let e=t[a];t[a]=t[o],t[o]=e;for(let t=0;t<6;t++){let e=r[6*a+t];r[6*a+t]=r[6*o+t],r[6*o+t]=e}a++,o--}}}}),s("271LZ",function(e,r){let n,s,a,o;t(e.exports,"countNodes",()=>function t(e){return"count"in e?1:1+t(e.left)+t(e.right)}),t(e.exports,"populateBuffer",()=>u);var l=i("gbfhP"),h=i("c3KjY");function u(t,e,r){return n=new Float32Array(r),s=new Uint32Array(r),a=new Uint16Array(r),o=new Uint8Array(r),function t(e,r){let i=e/4,u=e/2,c=r.boundingData;for(let t=0;t<6;t++)n[i+t]=c[t];if("count"in r){if(r.buffer){let t=r.buffer;o.set(new Uint8Array(t),e);for(let r=e,n=e+t.byteLength;r<n;r+=l.BYTES_PER_NODE){let t=r/2;(0,h.IS_LEAF)(t,a)||(s[r/4+6]+=i)}return e+t.byteLength}{let t=r.offset,n=r.count;return s[i+6]=t,a[u+14]=n,a[u+15]=l.IS_LEAFNODE_FLAG,e+l.BYTES_PER_NODE}}{let n;let a=r.left,o=r.right,h=r.splitAxis;if((n=t(e+l.BYTES_PER_NODE,a))/4>4294967296)throw Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return s[i+6]=n/4,n=t(n,o),s[i+7]=h,n}}(t,e)}}),s("c3KjY",function(e,r){function n(t,e){return 65535===e[t+15]}function i(t,e){return e[t+6]}function s(t,e){return e[t+14]}function a(t){return t+8}function o(t,e){return e[t+6]}function l(t,e){return e[t+7]}function h(t){return t}t(e.exports,"IS_LEAF",()=>n),t(e.exports,"OFFSET",()=>i),t(e.exports,"COUNT",()=>s),t(e.exports,"LEFT_NODE",()=>a),t(e.exports,"RIGHT_NODE",()=>o),t(e.exports,"SPLIT_AXIS",()=>l),t(e.exports,"BOUNDING_DATA_INDEX",()=>h)}),s("2Vkjh",function(e,r){t(e.exports,"OrientedBox",()=>l);var n=i("e06gU"),s=i("4xYKL"),a=i("3oesN"),o=i("1D9ks");class l{constructor(t,e,r){this.isOrientedBox=!0,this.min=new n.Vector3,this.max=new n.Vector3,this.matrix=new n.Matrix4,this.invMatrix=new n.Matrix4,this.points=Array(8).fill().map(()=>new n.Vector3),this.satAxes=[,,,].fill().map(()=>new n.Vector3),this.satBounds=[,,,].fill().map(()=>new s.SeparatingAxisBounds),this.alignedSatBounds=[,,,].fill().map(()=>new s.SeparatingAxisBounds),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),r&&this.matrix.copy(r)}set(t,e,r){this.min.copy(t),this.max.copy(e),this.matrix.copy(r),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}l.prototype.update=function(){let t=this.matrix,e=this.min,r=this.max,n=this.points;for(let i=0;i<=1;i++)for(let s=0;s<=1;s++)for(let a=0;a<=1;a++){let o=n[1*i|2*s|4*a];o.x=i?r.x:e.x,o.y=s?r.y:e.y,o.z=a?r.z:e.z,o.applyMatrix4(t)}let i=this.satBounds,s=this.satAxes,a=n[0];for(let t=0;t<3;t++){let e=s[t],r=i[t],o=n[1<<t];e.subVectors(a,o),r.setFromPoints(e,n)}let o=this.alignedSatBounds;o[0].setFromPointsField(n,"x"),o[1].setFromPointsField(n,"y"),o[2].setFromPointsField(n,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},l.prototype.intersectsBox=function(){let t=new s.SeparatingAxisBounds;return function(e){this.needsUpdate&&this.update();let r=e.min,n=e.max,i=this.satBounds,s=this.satAxes,a=this.alignedSatBounds;if(t.min=r.x,t.max=n.x,a[0].isSeparated(t)||(t.min=r.y,t.max=n.y,a[1].isSeparated(t))||(t.min=r.z,t.max=n.z,a[2].isSeparated(t)))return!1;for(let r=0;r<3;r++){let n=s[r],a=i[r];if(t.setFromBox(n,e),a.isSeparated(t))return!1}return!0}}(),l.prototype.intersectsTriangle=function(){let t=new a.ExtendedTriangle,e=[,,,],r=new s.SeparatingAxisBounds,i=new s.SeparatingAxisBounds,o=new n.Vector3;return function(n){this.needsUpdate&&this.update(),n.isExtendedTriangle?n.needsUpdate&&n.update():(t.copy(n),t.update(),n=t);let s=this.satBounds,a=this.satAxes;e[0]=n.a,e[1]=n.b,e[2]=n.c;for(let t=0;t<3;t++){let n=s[t],i=a[t];if(r.setFromPoints(i,e),n.isSeparated(r))return!1}let l=n.satBounds,h=n.satAxes,u=this.points;for(let t=0;t<3;t++){let e=l[t],n=h[t];if(r.setFromPoints(n,u),e.isSeparated(r))return!1}for(let t=0;t<3;t++){let n=a[t];for(let t=0;t<4;t++){let s=h[t];if(o.crossVectors(n,s),r.setFromPoints(o,e),i.setFromPoints(o,u),r.isSeparated(i))return!1}}return!0}}(),l.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},l.prototype.distanceToPoint=function(){let t=new n.Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),l.prototype.distanceToBox=function(){let t=["x","y","z"],e=Array(12).fill().map(()=>new n.Line3),r=Array(12).fill().map(()=>new n.Line3),i=new n.Vector3,s=new n.Vector3;return function(n,a=0,l=null,h=null){if(this.needsUpdate&&this.update(),this.intersectsBox(n))return(l||h)&&(n.getCenter(s),this.closestPointToPoint(s,i),n.closestPointToPoint(i,s),l&&l.copy(i),h&&h.copy(s)),0;let u=a*a,c=n.min,d=n.max,p=this.points,m=1/0;for(let t=0;t<8;t++){let e=p[t];s.copy(e).clamp(c,d);let r=e.distanceToSquared(s);if(r<m&&(m=r,l&&l.copy(e),h&&h.copy(s),r<u))return Math.sqrt(r)}let f=0;for(let n=0;n<3;n++)for(let i=0;i<=1;i++)for(let s=0;s<=1;s++){let a=(n+1)%3,o=(n+2)%3,l=i<<a|s<<o,h=1<<n|i<<a|s<<o,u=p[l],m=p[h];e[f].set(u,m);let g=t[n],x=t[a],y=t[o],_=r[f],v=_.start,b=_.end;v[g]=c[g],v[x]=i?c[x]:d[x],v[y]=s?c[y]:d[x],b[g]=d[g],b[x]=i?c[x]:d[x],b[y]=s?c[y]:d[x],f++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let r=0;r<=1;r++){s.x=t?d.x:c.x,s.y=e?d.y:c.y,s.z=r?d.z:c.z,this.closestPointToPoint(s,i);let n=s.distanceToSquared(i);if(n<m&&(m=n,l&&l.copy(i),h&&h.copy(s),n<u))return Math.sqrt(n)}for(let t=0;t<12;t++){let n=e[t];for(let t=0;t<12;t++){let e=r[t];(0,o.closestPointsSegmentToSegment)(n,e,i,s);let a=i.distanceToSquared(s);if(a<m&&(m=a,l&&l.copy(i),h&&h.copy(s),a<u))return Math.sqrt(a)}}return Math.sqrt(m)}}()}),s("4xYKL",function(e,r){t(e.exports,"SeparatingAxisBounds",()=>s);var n=i("e06gU");class s{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let r=1/0,n=-1/0;for(let i=0,s=t.length;i<s;i++){let s=t[i][e];r=s<r?s:r,n=s>n?s:n}this.min=r,this.max=n}setFromPoints(t,e){let r=1/0,n=-1/0;for(let i=0,s=e.length;i<s;i++){let s=e[i],a=t.dot(s);r=a<r?a:r,n=a>n?a:n}this.min=r,this.max=n}isSeparated(t){return this.min>t.max||t.min>this.max}}s.prototype.setFromBox=function(){let t=new n.Vector3;return function(e,r){let n=r.min,i=r.max,s=1/0,a=-1/0;for(let r=0;r<=1;r++)for(let o=0;o<=1;o++)for(let l=0;l<=1;l++){t.x=n.x*r+i.x*(1-r),t.y=n.y*o+i.y*(1-o),t.z=n.z*l+i.z*(1-l);let h=e.dot(t);s=Math.min(h,s),a=Math.max(h,a)}this.min=s,this.max=a}}(),new s}),s("3oesN",function(e,r){t(e.exports,"ExtendedTriangle",()=>l);var n=i("e06gU"),s=i("4xYKL"),a=i("1D9ks");function o(t){return 1e-15>Math.abs(t)}class l extends n.Triangle{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=[,,,,].fill().map(()=>new n.Vector3),this.satBounds=[,,,,].fill().map(()=>new s.SeparatingAxisBounds),this.points=[this.a,this.b,this.c],this.sphere=new n.Sphere,this.plane=new n.Plane,this.needsUpdate=!0}intersectsSphere(t){return(0,a.sphereIntersectTriangle)(t,this)}update(){let t=this.a,e=this.b,r=this.c,n=this.points,i=this.satAxes,s=this.satBounds,a=i[0],o=s[0];this.getNormal(a),o.setFromPoints(a,n);let l=i[1],h=s[1];l.subVectors(t,e),h.setFromPoints(l,n);let u=i[2],c=s[2];u.subVectors(e,r),c.setFromPoints(u,n);let d=i[3],p=s[3];d.subVectors(r,t),p.setFromPoints(d,n),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(a,t),this.needsUpdate=!1}}l.prototype.closestPointToSegment=function(){let t=new n.Vector3,e=new n.Vector3,r=new n.Line3;return function(n,i=null,s=null){let o;let{start:l,end:h}=n,u=this.points,c=1/0;for(let l=0;l<3;l++){let h=(l+1)%3;r.start.copy(u[l]),r.end.copy(u[h]),(0,a.closestPointsSegmentToSegment)(r,n,t,e),(o=t.distanceToSquared(e))<c&&(c=o,i&&i.copy(t),s&&s.copy(e))}return this.closestPointToPoint(l,t),(o=l.distanceToSquared(t))<c&&(c=o,i&&i.copy(t),s&&s.copy(l)),this.closestPointToPoint(h,t),(o=h.distanceToSquared(t))<c&&(c=o,i&&i.copy(t),s&&s.copy(h)),Math.sqrt(c)}}(),l.prototype.intersectsTriangle=function(){let t=new l,e=[,,,],r=[,,,],i=new s.SeparatingAxisBounds,a=new s.SeparatingAxisBounds,h=new n.Vector3,u=new n.Vector3,c=new n.Vector3,d=new n.Vector3,p=new n.Vector3,m=new n.Line3,f=new n.Line3,g=new n.Line3,x=new n.Vector3;function y(t,e,r){let n=t.points,i=0,s=-1;for(let t=0;t<3;t++){let{start:a,end:l}=m;a.copy(n[t]),l.copy(n[(t+1)%3]),m.delta(u);let h=o(e.distanceToPoint(a));if(o(e.normal.dot(u))&&h){r.copy(m),i=2;break}let c=e.intersectLine(m,x);if(!c&&h&&x.copy(a),(c||h)&&!o(x.distanceTo(l))){if(i<=1)(1===i?r.start:r.end).copy(x),h&&(s=i);else if(i>=2){(1===s?r.start:r.end).copy(x),i=2;break}if(2==++i&&-1===s)break}}return i}return function(n,s=null,o=!1){this.needsUpdate&&this.update(),n.isExtendedTriangle?n.needsUpdate&&n.update():(t.copy(n),t.update(),n=t);let l=this.plane,u=n.plane;if(Math.abs(l.normal.dot(u.normal))>1-1e-10){let t=this.satBounds,l=this.satAxes;r[0]=n.a,r[1]=n.b,r[2]=n.c;for(let e=0;e<4;e++){let n=t[e],s=l[e];if(i.setFromPoints(s,r),n.isSeparated(i))return!1}let u=n.satBounds,c=n.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let t=0;t<4;t++){let r=u[t],n=c[t];if(i.setFromPoints(n,e),r.isSeparated(i))return!1}for(let t=0;t<4;t++){let n=l[t];for(let t=0;t<4;t++){let s=c[t];if(h.crossVectors(n,s),i.setFromPoints(h,e),a.setFromPoints(h,r),i.isSeparated(a))return!1}}return s&&(o||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),s.start.set(0,0,0),s.end.set(0,0,0)),!0}{let t=y(this,u,f);if(1===t&&n.containsPoint(f.end))return s&&(s.start.copy(f.end),s.end.copy(f.end)),!0;if(2!==t)return!1;let e=y(n,l,g);if(1===e&&this.containsPoint(g.end))return s&&(s.start.copy(g.end),s.end.copy(g.end)),!0;if(2!==e)return!1;if(f.delta(c),g.delta(d),0>c.dot(d)){let t=g.start;g.start=g.end,g.end=t}let r=f.start.dot(c),i=f.end.dot(c),a=g.start.dot(c),o=g.end.dot(c);return(r===o||a===i||i<a!=r<o)&&(s&&(p.subVectors(f.start,g.start),p.dot(c)>0?s.start.copy(f.start):s.start.copy(g.start),p.subVectors(f.end,g.end),0>p.dot(c)?s.end.copy(f.end):s.end.copy(g.end)),!0)}}}(),l.prototype.distanceToPoint=function(){let t=new n.Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),l.prototype.distanceToTriangle=function(){let t=new n.Vector3,e=new n.Vector3,r=["a","b","c"],i=new n.Line3,s=new n.Line3;return function(n,o=null,l=null){let h=o||l?i:null;if(this.intersectsTriangle(n,h))return(o||l)&&(o&&h.getCenter(o),l&&h.getCenter(l)),0;let u=1/0;for(let e=0;e<3;e++){let i;let s=r[e],a=n[s];this.closestPointToPoint(a,t),(i=a.distanceToSquared(t))<u&&(u=i,o&&o.copy(t),l&&l.copy(a));let h=this[s];n.closestPointToPoint(h,t),(i=h.distanceToSquared(t))<u&&(u=i,o&&o.copy(h),l&&l.copy(t))}for(let h=0;h<3;h++){let c=r[h],d=r[(h+1)%3];i.set(this[c],this[d]);for(let h=0;h<3;h++){let c=r[h],d=r[(h+1)%3];s.set(n[c],n[d]),(0,a.closestPointsSegmentToSegment)(i,s,t,e);let p=t.distanceToSquared(e);p<u&&(u=p,o&&o.copy(t),l&&l.copy(e))}}return Math.sqrt(u)}}()}),s("1D9ks",function(e,r){t(e.exports,"closestPointsSegmentToSegment",()=>a),t(e.exports,"sphereIntersectTriangle",()=>o);var n=i("e06gU");let s=function(){let t=new n.Vector3,e=new n.Vector3,r=new n.Vector3;return function(n,i,s){let a,o;let l=n.start,h=i.start;r.subVectors(l,h),t.subVectors(n.end,n.start),e.subVectors(i.end,i.start);let u=r.dot(e),c=e.dot(t),d=e.dot(e),p=r.dot(t),m=t.dot(t)*d-c*c;a=0!==m?(u*c-p*d)/m:0,o=(u+a*c)/d,s.x=a,s.y=o}}(),a=function(){let t=new n.Vector2,e=new n.Vector3,r=new n.Vector3;return function(n,i,a,o){s(n,i,t);let l=t.x,h=t.y;if(l>=0&&l<=1&&h>=0&&h<=1){n.at(l,a),i.at(h,o);return}if(l>=0&&l<=1){h<0?i.at(0,o):i.at(1,o),n.closestPointToPoint(o,!0,a);return}if(h>=0&&h<=1){l<0?n.at(0,a):n.at(1,a),i.closestPointToPoint(a,!0,o);return}{let t,s;if(t=l<0?n.start:n.end,s=h<0?i.start:i.end,n.closestPointToPoint(s,!0,e),i.closestPointToPoint(t,!0,r),e.distanceToSquared(s)<=r.distanceToSquared(t)){a.copy(e),o.copy(s);return}a.copy(t),o.copy(r);return}}}(),o=function(){let t=new n.Vector3,e=new n.Vector3,r=new n.Plane,i=new n.Line3;return function(n,s){let{radius:a,center:o}=n,{a:l,b:h,c:u}=s;if(i.start=l,i.end=h,i.closestPointToPoint(o,!0,t).distanceTo(o)<=a||(i.start=l,i.end=u,i.closestPointToPoint(o,!0,t).distanceTo(o)<=a)||(i.start=h,i.end=u,i.closestPointToPoint(o,!0,t).distanceTo(o)<=a))return!0;let c=s.getPlane(r);if(Math.abs(c.distanceToPoint(o))<=a){let t=c.projectPoint(o,e);if(s.containsPoint(t))return!0}return!1}}()}),s("eohSc",function(e,r){t(e.exports,"ExtendedTrianglePool",()=>o);var n=i("3oesN"),s=i("6ncSE");class a extends s.PrimitivePool{constructor(){super(()=>new n.ExtendedTriangle)}}let o=new a}),s("6ncSE",function(e,r){t(e.exports,"PrimitivePool",()=>n);class n{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){let t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}}),s("7HfaT",function(e,r){let n,s;t(e.exports,"shapecast",()=>m);var a=i("e06gU"),o=i("gbfhP"),l=i("iiPZZ"),h=i("6ncSE"),u=i("c3KjY"),c=i("028YM");let d=[],p=new h.PrimitivePool(()=>new a.Box3);function m(t,e,r,i,a,h){n=p.getPrimitive(),s=p.getPrimitive(),d.push(n,s),(0,c.BufferStack).setBuffer(t._roots[e]);let m=function t(e,r,i,a,h=null,d=0,p=0){let{float32Array:m,uint16Array:f,uint32Array:g}=c.BufferStack,x=2*e;if((0,u.IS_LEAF)(x,f)){let t=(0,u.OFFSET)(e,g),r=(0,u.COUNT)(x,f);return(0,l.arrayToBox)((0,u.BOUNDING_DATA_INDEX)(e),m,n),a(t,r,!1,p,d+e,n)}{let x,v,b,w,M,S;let A=(0,u.LEFT_NODE)(e),T=(0,u.RIGHT_NODE)(e,g),z=A,E=T;if(h&&(b=n,w=s,(0,l.arrayToBox)((0,u.BOUNDING_DATA_INDEX)(z),m,b),(0,l.arrayToBox)((0,u.BOUNDING_DATA_INDEX)(E),m,w),x=h(b),(v=h(w))<x)){z=T,E=A;let t=x;x=v,v=t,b=w}b||(b=n,(0,l.arrayToBox)((0,u.BOUNDING_DATA_INDEX)(z),m,b));let B=i(b,(0,u.IS_LEAF)(2*z,f),x,p+1,d+z);if(B===o.CONTAINED){let t=y(z);M=a(t,_(z)-t,!0,p+1,d+z,b)}else M=B&&t(z,r,i,a,h,d,p+1);if(M)return!0;w=s,(0,l.arrayToBox)((0,u.BOUNDING_DATA_INDEX)(E),m,w);let P=i(w,(0,u.IS_LEAF)(2*E,f),v,p+1,d+E);if(P===o.CONTAINED){let t=y(E);S=a(t,_(E)-t,!0,p+1,d+E,w)}else S=P&&t(E,r,i,a,h,d,p+1);if(S)return!0;return!1;function y(t){let{uint16Array:e,uint32Array:r}=c.BufferStack,n=2*t;for(;!(0,u.IS_LEAF)(n,e);)n=2*(t=(0,u.LEFT_NODE)(t));return(0,u.OFFSET)(t,r)}function _(t){let{uint16Array:e,uint32Array:r}=c.BufferStack,n=2*t;for(;!(0,u.IS_LEAF)(n,e);)n=2*(t=(0,u.RIGHT_NODE)(t,r));return(0,u.OFFSET)(t,r)+(0,u.COUNT)(n,e)}}}(0,t.geometry,r,i,a,h);(0,c.BufferStack).clearBuffer(),p.releasePrimitive(n),p.releasePrimitive(s),d.pop(),d.pop();let f=d.length;return f>0&&(s=d[f-1],n=d[f-2]),m}}),s("028YM",function(e,r){t(e.exports,"BufferStack",()=>n);let n=new class{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;let t=[],e=null;this.setBuffer=r=>{e&&t.push(e),e=r,this.float32Array=new Float32Array(r),this.uint16Array=new Uint16Array(r),this.uint32Array=new Uint32Array(r)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,0!==t.length&&this.setBuffer(t.pop())}}}}),s("5W1a5",function(e,r){t(e.exports,"closestPointToPoint",()=>o);var n=i("e06gU");let s=new n.Vector3,a=new n.Vector3;function o(t,e,r={},n=0,i=1/0){let o=n*n,l=i*i,h=1/0,u=null;if(t.shapecast({boundsTraverseOrder:t=>(s.copy(e).clamp(t.min,t.max),s.distanceToSquared(e)),intersectsBounds:(t,e,r)=>r<h&&r<l,intersectsTriangle:(t,r)=>{t.closestPointToPoint(e,s);let n=e.distanceToSquared(s);return n<h&&(a.copy(s),h=n,u=r),n<o}}),h===1/0)return null;let c=Math.sqrt(h);return r.point?r.point.copy(a):r.point=a.clone(),r.distance=c,r.faceIndex=u,r}}),s("cKddI",function(e,r){t(e.exports,"intersectTris",()=>a),t(e.exports,"intersectClosestTri",()=>o),t(e.exports,"iterateOverTriangles",()=>l);var n=i("aN6dG"),s=i("kddjw");function a(t,e,r,i,s,a){let{geometry:o,_indirectBuffer:l}=t;for(let t=i,l=i+s;t<l;t++)(0,n.intersectTri)(o,e,r,t,a)}function o(t,e,r,i,s){let{geometry:a,_indirectBuffer:o}=t,l=1/0,h=null;for(let t=i,o=i+s;t<o;t++){let i;(i=(0,n.intersectTri)(a,e,r,t))&&i.distance<l&&(h=i,l=i.distance)}return h}function l(t,e,r,n,i,a,o){let{geometry:l}=r,{index:h}=l,u=l.attributes.position;for(let r=t,l=e+t;r<l;r++){let t;if(t=r,(0,s.setTriangle)(o,3*t,h,u),o.needsUpdate=!0,n(o,t,i,a))return!0}return!1}}),s("aN6dG",function(e,r){t(e.exports,"intersectTri",()=>f);var n=i("e06gU");let s=new n.Vector3,a=new n.Vector3,o=new n.Vector3,l=new n.Vector2,h=new n.Vector2,u=new n.Vector2,c=new n.Vector3,d=new n.Vector3,p=new n.Vector3,m=new n.Vector3;function f(t,e,r,i,f){let g=3*i,x=g+0,y=g+1,_=g+2,v=t.index;t.index&&(x=v.getX(x),y=v.getX(y),_=v.getX(_));let{position:b,normal:w,uv:M,uv1:S}=t.attributes,A=function(t,e,r,i,f,g,x,y,_){s.fromBufferAttribute(e,g),a.fromBufferAttribute(e,x),o.fromBufferAttribute(e,y);let v=null===(_===n.BackSide?t.intersectTriangle(o,a,s,!0,m):t.intersectTriangle(s,a,o,_!==n.DoubleSide,m))?null:{distance:t.origin.distanceTo(m),point:m.clone()};if(v){i&&(l.fromBufferAttribute(i,g),h.fromBufferAttribute(i,x),u.fromBufferAttribute(i,y),v.uv=(0,n.Triangle).getInterpolation(m,s,a,o,l,h,u,new n.Vector2)),f&&(l.fromBufferAttribute(f,g),h.fromBufferAttribute(f,x),u.fromBufferAttribute(f,y),v.uv1=(0,n.Triangle).getInterpolation(m,s,a,o,l,h,u,new n.Vector2)),r&&(c.fromBufferAttribute(r,g),d.fromBufferAttribute(r,x),p.fromBufferAttribute(r,y),v.normal=(0,n.Triangle).getInterpolation(m,s,a,o,c,d,p,new n.Vector3),v.normal.dot(t.direction)>0&&v.normal.multiplyScalar(-1));let e={a:g,b:x,c:y,normal:new n.Vector3,materialIndex:0};(0,n.Triangle).getNormal(s,a,o,e.normal),v.face=e,v.faceIndex=g}return v}(r,b,w,M,S,x,y,_,e);return A?(A.faceIndex=i,f&&f.push(A),A):null}}),s("kddjw",function(e,r){function n(t,e,r,n){let i=t.a,s=t.b,a=t.c,o=e,l=e+1,h=e+2;r&&(o=r.getX(o),l=r.getX(l),h=r.getX(h)),i.x=n.getX(o),i.y=n.getY(o),i.z=n.getZ(o),s.x=n.getX(l),s.y=n.getY(l),s.z=n.getZ(l),a.x=n.getX(h),a.y=n.getY(h),a.z=n.getZ(h)}t(e.exports,"setTriangle",()=>n),i("e06gU")}),s("ipX80",function(e,r){t(e.exports,"refit",()=>s);var n=i("gbfhP");function s(t,e=null){let r,i,s,a;e&&Array.isArray(e)&&(e=new Set(e));let o=t.geometry,l=o.index?o.index.array:null,h=o.attributes.position,u=0,c=t._roots;for(let t=0,o=c.length;t<o;t++)i=new Uint32Array(r=c[t]),s=new Uint16Array(r),a=new Float32Array(r),function t(r,o,u=!1){let c=2*r;if(s[c+15]===n.IS_LEAFNODE_FLAG){let t=i[r+6],e=s[c+14],n=1/0,o=1/0,u=1/0,d=-1/0,p=-1/0,m=-1/0;for(let r=3*t,i=3*(t+e);r<i;r++){let t=l[r],e=h.getX(t),i=h.getY(t),s=h.getZ(t);e<n&&(n=e),e>d&&(d=e),i<o&&(o=i),i>p&&(p=i),s<u&&(u=s),s>m&&(m=s)}return(a[r+0]!==n||a[r+1]!==o||a[r+2]!==u||a[r+3]!==d||a[r+4]!==p||a[r+5]!==m)&&(a[r+0]=n,a[r+1]=o,a[r+2]=u,a[r+3]=d,a[r+4]=p,a[r+5]=m,!0)}{let n=r+8,s=i[r+6],l=n+o,h=s+o,c=u,d=!1,p=!1;e?c||(d=e.has(l),p=e.has(h),c=!d&&!p):(d=!0,p=!0);let m=c||d,f=c||p,g=!1;m&&(g=t(n,o,c));let x=!1;f&&(x=t(s,o,c));let y=g||x;if(y)for(let t=0;t<3;t++){let e=n+t,i=s+t,o=a[e],l=a[e+3],h=a[i],u=a[i+3];a[r+t]=o<h?o:h,a[r+t+3]=l>u?l:u}return y}}(0,u),u+=r.byteLength}}),s("AZSfZ",function(e,r){t(e.exports,"raycast",()=>l);var n=i("h599n"),s=i("c3KjY"),a=i("028YM"),o=i("cKddI");function l(t,e,r,i,l){(0,a.BufferStack).setBuffer(t._roots[e]),function t(e,r,i,l,h){let{float32Array:u,uint16Array:c,uint32Array:d}=a.BufferStack,p=2*e;if((0,s.IS_LEAF)(p,c)){let t=(0,s.OFFSET)(e,d),n=(0,s.COUNT)(p,c);(0,o.intersectTris)(r,i,l,t,n,h)}else{let a=(0,s.LEFT_NODE)(e);(0,n.intersectRay)(a,u,l)&&t(a,r,i,l,h);let o=(0,s.RIGHT_NODE)(e,d);(0,n.intersectRay)(o,u,l)&&t(o,r,i,l,h)}}(0,t,r,i,l),(0,a.BufferStack).clearBuffer()}}),s("h599n",function(e,r){t(e.exports,"intersectRay",()=>n);function n(t,e,r){let n,i,s,a,o,l;let h=1/r.direction.x,u=1/r.direction.y,c=1/r.direction.z,d=r.origin.x,p=r.origin.y,m=r.origin.z,f=e[t],g=e[t+3],x=e[t+1],y=e[t+3+1],_=e[t+2],v=e[t+3+2];return h>=0?(n=(f-d)*h,i=(g-d)*h):(n=(g-d)*h,i=(f-d)*h),u>=0?(s=(x-p)*u,a=(y-p)*u):(s=(y-p)*u,a=(x-p)*u),!(n>a)&&!(s>i)&&((s>n||isNaN(n))&&(n=s),(a<i||isNaN(i))&&(i=a),c>=0?(o=(_-m)*c,l=(v-m)*c):(o=(v-m)*c,l=(_-m)*c),!(n>l)&&!(o>i)&&((l<i||i!=i)&&(i=l),!(i<0)))}}),s("b2q45",function(e,r){t(e.exports,"raycastFirst",()=>h);var n=i("c3KjY"),s=i("028YM"),a=i("h599n"),o=i("cKddI");let l=["x","y","z"];function h(t,e,r,i){(0,s.BufferStack).setBuffer(t._roots[e]);let h=function t(e,r,i,h){let{float32Array:u,uint16Array:c,uint32Array:d}=s.BufferStack,p=2*e;if((0,n.IS_LEAF)(p,c)){let t=(0,n.OFFSET)(e,d),s=(0,n.COUNT)(p,c);return(0,o.intersectClosestTri)(r,i,h,t,s)}{let s,o;let c=(0,n.SPLIT_AXIS)(e,d),p=l[c],m=h.direction[p]>=0;m?(s=(0,n.LEFT_NODE)(e),o=(0,n.RIGHT_NODE)(e,d)):(s=(0,n.RIGHT_NODE)(e,d),o=(0,n.LEFT_NODE)(e));let f=(0,a.intersectRay)(s,u,h)?t(s,r,i,h):null;if(f){let t=f.point[p];if(m?t<=u[o+c]:t>=u[o+c+3])return f}let g=(0,a.intersectRay)(o,u,h)?t(o,r,i,h):null;return f&&g?f.distance<=g.distance?f:g:f||g||null}}(0,t,r,i);return(0,s.BufferStack).clearBuffer(),h}}),s("5uIRP",function(e,r){t(e.exports,"intersectsGeometry",()=>x);var n=i("e06gU"),s=i("2Vkjh"),a=i("3oesN"),o=i("kddjw"),l=i("iiPZZ"),h=i("c3KjY"),u=i("028YM");let c=new n.Box3,d=new a.ExtendedTriangle,p=new a.ExtendedTriangle,m=new n.Matrix4,f=new s.OrientedBox,g=new s.OrientedBox;function x(t,e,r,n){(0,u.BufferStack).setBuffer(t._roots[e]);let i=function t(e,r,n,i,s=null){let{float32Array:a,uint16Array:x,uint32Array:y}=u.BufferStack,_=2*e;if(null===s&&(n.boundingBox||n.computeBoundingBox(),f.set(n.boundingBox.min,n.boundingBox.max,i),s=f),(0,h.IS_LEAF)(_,x)){let t=r.geometry,s=t.index,u=t.attributes.position,c=n.index,f=n.attributes.position,v=(0,h.OFFSET)(e,y),b=(0,h.COUNT)(_,x);if(m.copy(i).invert(),n.boundsTree)return(0,l.arrayToBox)((0,h.BOUNDING_DATA_INDEX)(e),a,g),g.matrix.copy(m),g.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:t=>g.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(i),t.b.applyMatrix4(i),t.c.applyMatrix4(i),t.needsUpdate=!0;for(let e=3*v,r=(b+v)*3;e<r;e+=3)if((0,o.setTriangle)(p,e,s,u),p.needsUpdate=!0,t.intersectsTriangle(p))return!0;return!1}});for(let t=3*v,e=(b+v)*3;t<e;t+=3){(0,o.setTriangle)(d,t,s,u),d.a.applyMatrix4(m),d.b.applyMatrix4(m),d.c.applyMatrix4(m),d.needsUpdate=!0;for(let t=0,e=c.count;t<e;t+=3)if((0,o.setTriangle)(p,t,c,f),p.needsUpdate=!0,d.intersectsTriangle(p))return!0}}else{let o=e+8,u=y[e+6];return(0,l.arrayToBox)((0,h.BOUNDING_DATA_INDEX)(o),a,c),!!(s.intersectsBox(c)&&t(o,r,n,i,s))||((0,l.arrayToBox)((0,h.BOUNDING_DATA_INDEX)(u),a,c),!!(s.intersectsBox(c)&&t(u,r,n,i,s)))}}(0,t,r,n);return(0,u.BufferStack).clearBuffer(),i}}),s("hby9v",function(e,r){t(e.exports,"closestPointToGeometry",()=>g);var n=i("e06gU"),s=i("2Vkjh"),a=i("kddjw"),o=i("6Y4FX"),l=i("eohSc");let h=new n.Matrix4,u=new s.OrientedBox,c=new s.OrientedBox,d=new n.Vector3,p=new n.Vector3,m=new n.Vector3,f=new n.Vector3;function g(t,e,r,n={},i={},s=0,g=1/0){e.boundingBox||e.computeBoundingBox(),u.set(e.boundingBox.min,e.boundingBox.max,r),u.needsUpdate=!0;let x=t.geometry,y=x.attributes.position,_=x.index,v=e.attributes.position,b=e.index,w=(0,l.ExtendedTrianglePool).getPrimitive(),M=(0,l.ExtendedTrianglePool).getPrimitive(),S=null,A=null;i&&(S=m,A=f);let T=1/0,z=null,E=null;return(h.copy(r).invert(),c.matrix.copy(h),t.shapecast({boundsTraverseOrder:t=>u.distanceToBox(t),intersectsBounds:(t,e,r)=>r<T&&r<g&&(e&&(c.min.copy(t.min),c.max.copy(t.max),c.needsUpdate=!0),!0),intersectsRange:(t,n)=>{if(e.boundsTree)return e.boundsTree.shapecast({boundsTraverseOrder:t=>c.distanceToBox(t),intersectsBounds:(t,e,r)=>r<T&&r<g,intersectsRange:(e,i)=>{for(let o=e,l=e+i;o<l;o++){(0,a.setTriangle)(M,3*o,b,v),M.a.applyMatrix4(r),M.b.applyMatrix4(r),M.c.applyMatrix4(r),M.needsUpdate=!0;for(let e=t,r=t+n;e<r;e++){(0,a.setTriangle)(w,3*e,_,y),w.needsUpdate=!0;let t=w.distanceToTriangle(M,d,S);if(t<T&&(p.copy(d),A&&A.copy(S),T=t,z=e,E=o),t<s)return!0}}}});{let i=(0,o.getTriCount)(e);for(let e=0;e<i;e++){(0,a.setTriangle)(M,3*e,b,v),M.a.applyMatrix4(r),M.b.applyMatrix4(r),M.c.applyMatrix4(r),M.needsUpdate=!0;for(let r=t,i=t+n;r<i;r++){(0,a.setTriangle)(w,3*r,_,y),w.needsUpdate=!0;let t=w.distanceToTriangle(M,d,S);if(t<T&&(p.copy(d),A&&A.copy(S),T=t,z=r,E=e),t<s)return!0}}}}}),(0,l.ExtendedTrianglePool).releasePrimitive(w),(0,l.ExtendedTrianglePool).releasePrimitive(M),T===1/0)?null:(n.point?n.point.copy(p):n.point=p.clone(),n.distance=T,n.faceIndex=z,i&&(i.point?i.point.copy(A):i.point=A.clone(),i.point.applyMatrix4(h),p.applyMatrix4(h),i.distance=p.sub(i.point).length(),i.faceIndex=E),n)}}),s("49xTg",function(e,r){t(e.exports,"intersectTris_indirect",()=>a),t(e.exports,"intersectClosestTri_indirect",()=>o),t(e.exports,"iterateOverTriangles_indirect",()=>l);var n=i("aN6dG"),s=i("kddjw");function a(t,e,r,i,s,a){let{geometry:o,_indirectBuffer:l}=t;for(let t=i,h=i+s;t<h;t++){let i=l?l[t]:t;(0,n.intersectTri)(o,e,r,i,a)}}function o(t,e,r,i,s){let{geometry:a,_indirectBuffer:o}=t,l=1/0,h=null;for(let t=i,u=i+s;t<u;t++){let i;(i=(0,n.intersectTri)(a,e,r,o?o[t]:t))&&i.distance<l&&(h=i,l=i.distance)}return h}function l(t,e,r,n,i,a,o){let{geometry:l}=r,{index:h}=l,u=l.attributes.position;for(let l=t,c=e+t;l<c;l++){let t;if(t=r.resolveTriangleIndex(l),(0,s.setTriangle)(o,3*t,h,u),o.needsUpdate=!0,n(o,t,i,a))return!0}return!1}}),s("l19Kf",function(e,r){t(e.exports,"refit_indirect",()=>s);var n=i("gbfhP");function s(t,e=null){let r,i,s,a;e&&Array.isArray(e)&&(e=new Set(e));let o=t.geometry,l=o.index?o.index.array:null,h=o.attributes.position,u=0,c=t._roots;for(let o=0,d=c.length;o<d;o++)i=new Uint32Array(r=c[o]),s=new Uint16Array(r),a=new Float32Array(r),function r(o,u,c=!1){let d=2*o;if(s[d+15]===n.IS_LEAFNODE_FLAG){let e=i[o+6],r=s[d+14],n=1/0,u=1/0,c=1/0,p=-1/0,m=-1/0,f=-1/0;for(let i=e,s=e+r;i<s;i++){let e=3*t.resolveTriangleIndex(i);for(let t=0;t<3;t++){let r=e+t;r=l?l[r]:r;let i=h.getX(r),s=h.getY(r),a=h.getZ(r);i<n&&(n=i),i>p&&(p=i),s<u&&(u=s),s>m&&(m=s),a<c&&(c=a),a>f&&(f=a)}}return(a[o+0]!==n||a[o+1]!==u||a[o+2]!==c||a[o+3]!==p||a[o+4]!==m||a[o+5]!==f)&&(a[o+0]=n,a[o+1]=u,a[o+2]=c,a[o+3]=p,a[o+4]=m,a[o+5]=f,!0)}{let t=o+8,n=i[o+6],s=t+u,l=n+u,h=c,d=!1,p=!1;e?h||(d=e.has(s),p=e.has(l),h=!d&&!p):(d=!0,p=!0);let m=h||d,f=h||p,g=!1;m&&(g=r(t,u,h));let x=!1;f&&(x=r(n,u,h));let y=g||x;if(y)for(let e=0;e<3;e++){let r=t+e,i=n+e,s=a[r],l=a[r+3],h=a[i],u=a[i+3];a[o+e]=s<h?s:h,a[o+e+3]=l>u?l:u}return y}}(0,u),u+=r.byteLength}}),s("gLkZA",function(e,r){t(e.exports,"raycast_indirect",()=>l);var n=i("h599n"),s=i("c3KjY"),a=i("028YM"),o=i("49xTg");function l(t,e,r,i,l){(0,a.BufferStack).setBuffer(t._roots[e]),function t(e,r,i,l,h){let{float32Array:u,uint16Array:c,uint32Array:d}=a.BufferStack,p=2*e;if((0,s.IS_LEAF)(p,c)){let t=(0,s.OFFSET)(e,d),n=(0,s.COUNT)(p,c);(0,o.intersectTris_indirect)(r,i,l,t,n,h)}else{let a=(0,s.LEFT_NODE)(e);(0,n.intersectRay)(a,u,l)&&t(a,r,i,l,h);let o=(0,s.RIGHT_NODE)(e,d);(0,n.intersectRay)(o,u,l)&&t(o,r,i,l,h)}}(0,t,r,i,l),(0,a.BufferStack).clearBuffer()}}),s("gH1ap",function(e,r){t(e.exports,"raycastFirst_indirect",()=>h);var n=i("c3KjY"),s=i("028YM"),a=i("h599n"),o=i("49xTg");let l=["x","y","z"];function h(t,e,r,i){(0,s.BufferStack).setBuffer(t._roots[e]);let h=function t(e,r,i,h){let{float32Array:u,uint16Array:c,uint32Array:d}=s.BufferStack,p=2*e;if((0,n.IS_LEAF)(p,c)){let t=(0,n.OFFSET)(e,d),s=(0,n.COUNT)(p,c);return(0,o.intersectClosestTri_indirect)(r,i,h,t,s)}{let s,o;let c=(0,n.SPLIT_AXIS)(e,d),p=l[c],m=h.direction[p]>=0;m?(s=(0,n.LEFT_NODE)(e),o=(0,n.RIGHT_NODE)(e,d)):(s=(0,n.RIGHT_NODE)(e,d),o=(0,n.LEFT_NODE)(e));let f=(0,a.intersectRay)(s,u,h)?t(s,r,i,h):null;if(f){let t=f.point[p];if(m?t<=u[o+c]:t>=u[o+c+3])return f}let g=(0,a.intersectRay)(o,u,h)?t(o,r,i,h):null;return f&&g?f.distance<=g.distance?f:g:f||g||null}}(0,t,r,i);return(0,s.BufferStack).clearBuffer(),h}}),s("jTzI1",function(e,r){t(e.exports,"intersectsGeometry_indirect",()=>x);var n=i("e06gU"),s=i("2Vkjh"),a=i("3oesN"),o=i("kddjw"),l=i("iiPZZ"),h=i("c3KjY"),u=i("028YM");let c=new n.Box3,d=new a.ExtendedTriangle,p=new a.ExtendedTriangle,m=new n.Matrix4,f=new s.OrientedBox,g=new s.OrientedBox;function x(t,e,r,n){(0,u.BufferStack).setBuffer(t._roots[e]);let i=function t(e,r,n,i,s=null){let{float32Array:a,uint16Array:x,uint32Array:y}=u.BufferStack,_=2*e;if(null===s&&(n.boundingBox||n.computeBoundingBox(),f.set(n.boundingBox.min,n.boundingBox.max,i),s=f),(0,h.IS_LEAF)(_,x)){let t=r.geometry,s=t.index,u=t.attributes.position,c=n.index,f=n.attributes.position,v=(0,h.OFFSET)(e,y),b=(0,h.COUNT)(_,x);if(m.copy(i).invert(),n.boundsTree)return(0,l.arrayToBox)((0,h.BOUNDING_DATA_INDEX)(e),a,g),g.matrix.copy(m),g.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:t=>g.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(i),t.b.applyMatrix4(i),t.c.applyMatrix4(i),t.needsUpdate=!0;for(let e=v,n=b+v;e<n;e++)if((0,o.setTriangle)(p,3*r.resolveTriangleIndex(e),s,u),p.needsUpdate=!0,t.intersectsTriangle(p))return!0;return!1}});for(let t=v,e=b+v;t<e;t++){let e=r.resolveTriangleIndex(t);(0,o.setTriangle)(d,3*e,s,u),d.a.applyMatrix4(m),d.b.applyMatrix4(m),d.c.applyMatrix4(m),d.needsUpdate=!0;for(let t=0,e=c.count;t<e;t+=3)if((0,o.setTriangle)(p,t,c,f),p.needsUpdate=!0,d.intersectsTriangle(p))return!0}}else{let o=e+8,u=y[e+6];return(0,l.arrayToBox)((0,h.BOUNDING_DATA_INDEX)(o),a,c),!!(s.intersectsBox(c)&&t(o,r,n,i,s))||((0,l.arrayToBox)((0,h.BOUNDING_DATA_INDEX)(u),a,c),!!(s.intersectsBox(c)&&t(u,r,n,i,s)))}}(0,t,r,n);return(0,u.BufferStack).clearBuffer(),i}}),s("74moN",function(e,r){t(e.exports,"closestPointToGeometry_indirect",()=>g);var n=i("e06gU"),s=i("2Vkjh"),a=i("kddjw"),o=i("6Y4FX"),l=i("eohSc");let h=new n.Matrix4,u=new s.OrientedBox,c=new s.OrientedBox,d=new n.Vector3,p=new n.Vector3,m=new n.Vector3,f=new n.Vector3;function g(t,e,r,n={},i={},s=0,g=1/0){e.boundingBox||e.computeBoundingBox(),u.set(e.boundingBox.min,e.boundingBox.max,r),u.needsUpdate=!0;let x=t.geometry,y=x.attributes.position,_=x.index,v=e.attributes.position,b=e.index,w=(0,l.ExtendedTrianglePool).getPrimitive(),M=(0,l.ExtendedTrianglePool).getPrimitive(),S=null,A=null;i&&(S=m,A=f);let T=1/0,z=null,E=null;return(h.copy(r).invert(),c.matrix.copy(h),t.shapecast({boundsTraverseOrder:t=>u.distanceToBox(t),intersectsBounds:(t,e,r)=>r<T&&r<g&&(e&&(c.min.copy(t.min),c.max.copy(t.max),c.needsUpdate=!0),!0),intersectsRange:(n,i)=>{if(e.boundsTree){let o=e.boundsTree;return o.shapecast({boundsTraverseOrder:t=>c.distanceToBox(t),intersectsBounds:(t,e,r)=>r<T&&r<g,intersectsRange:(e,l)=>{for(let h=e,u=e+l;h<u;h++){let e=o.resolveTriangleIndex(h);(0,a.setTriangle)(M,3*e,b,v),M.a.applyMatrix4(r),M.b.applyMatrix4(r),M.c.applyMatrix4(r),M.needsUpdate=!0;for(let e=n,r=n+i;e<r;e++){let r=t.resolveTriangleIndex(e);(0,a.setTriangle)(w,3*r,_,y),w.needsUpdate=!0;let n=w.distanceToTriangle(M,d,S);if(n<T&&(p.copy(d),A&&A.copy(S),T=n,z=e,E=h),n<s)return!0}}}})}{let l=(0,o.getTriCount)(e);for(let e=0;e<l;e++){(0,a.setTriangle)(M,3*e,b,v),M.a.applyMatrix4(r),M.b.applyMatrix4(r),M.c.applyMatrix4(r),M.needsUpdate=!0;for(let r=n,o=n+i;r<o;r++){let n=t.resolveTriangleIndex(r);(0,a.setTriangle)(w,3*n,_,y),w.needsUpdate=!0;let i=w.distanceToTriangle(M,d,S);if(i<T&&(p.copy(d),A&&A.copy(S),T=i,z=r,E=e),i<s)return!0}}}}}),(0,l.ExtendedTrianglePool).releasePrimitive(w),(0,l.ExtendedTrianglePool).releasePrimitive(M),T===1/0)?null:(n.point?n.point.copy(p):n.point=p.clone(),n.distance=T,n.faceIndex=z,i&&(i.point?i.point.copy(A):i.point=A.clone(),i.point.applyMatrix4(h),p.applyMatrix4(h),i.distance=p.sub(i.point).length(),i.faceIndex=E),n)}}),s("4ORoa",function(e,r){t(e.exports,"isSharedArrayBufferSupported",()=>n);function n(){return"undefined"!=typeof SharedArrayBuffer}}),s("3rKF7",function(e,r){t(e.exports,"bvhcast",()=>x);var n=i("e06gU"),s=i("028YM"),a=i("c3KjY"),o=i("iiPZZ"),l=i("6ncSE");let h=new s.BufferStack.constructor,u=new s.BufferStack.constructor,c=new l.PrimitivePool(()=>new n.Box3),d=new n.Box3,p=new n.Box3,m=new n.Box3,f=new n.Box3,g=!1;function x(t,e,r,i){let s;if(g)throw Error("MeshBVH: Recursive calls to bvhcast not supported.");g=!0;let l=t._roots,x=e._roots,y=0,_=0,v=new(0,n.Matrix4)().copy(r).invert();for(let t=0,e=l.length;t<e;t++){h.setBuffer(l[t]),_=0;let e=c.getPrimitive();(0,o.arrayToBox)((0,a.BOUNDING_DATA_INDEX)(0),h.float32Array,e),e.applyMatrix4(v);for(let n=0,l=x.length;n<l&&(u.setBuffer(x[t]),s=function t(e,r,n,i,s,l=0,g=0,x=0,y=0,_=null,v=!1){let b,w;v?(b=u,w=h):(b=h,w=u);let M=b.float32Array,S=b.uint32Array,A=b.uint16Array,T=w.float32Array,z=w.uint32Array,E=w.uint16Array,B=2*e,P=2*r,N=(0,a.IS_LEAF)(B,A),C=(0,a.IS_LEAF)(P,E),O=!1;if(C&&N)O=v?s((0,a.OFFSET)(r,z),(0,a.COUNT)(2*r,E),(0,a.OFFSET)(e,S),(0,a.COUNT)(2*e,A),y,g+r,x,l+e):s((0,a.OFFSET)(e,S),(0,a.COUNT)(2*e,A),(0,a.OFFSET)(r,z),(0,a.COUNT)(2*r,E),x,l+e,y,g+r);else if(C){let h=c.getPrimitive();(0,o.arrayToBox)((0,a.BOUNDING_DATA_INDEX)(r),T,h),h.applyMatrix4(n);let u=(0,a.LEFT_NODE)(e),m=(0,a.RIGHT_NODE)(e,S);(0,o.arrayToBox)((0,a.BOUNDING_DATA_INDEX)(u),M,d),(0,o.arrayToBox)((0,a.BOUNDING_DATA_INDEX)(m),M,p);let f=h.intersectsBox(d),_=h.intersectsBox(p);O=f&&t(r,u,i,n,s,g,l,y,x+1,h,!v)||_&&t(r,m,i,n,s,g,l,y,x+1,h,!v),c.releasePrimitive(h)}else{let h=(0,a.LEFT_NODE)(r),u=(0,a.RIGHT_NODE)(r,z);(0,o.arrayToBox)((0,a.BOUNDING_DATA_INDEX)(h),T,m),(0,o.arrayToBox)((0,a.BOUNDING_DATA_INDEX)(u),T,f);let b=_.intersectsBox(m),w=_.intersectsBox(f);if(b&&w)O=t(e,h,n,i,s,l,g,x,y+1,_,v)||t(e,u,n,i,s,l,g,x,y+1,_,v);else if(b){if(N)O=t(e,h,n,i,s,l,g,x,y+1,_,v);else{let r=c.getPrimitive();r.copy(m).applyMatrix4(n);let u=(0,a.LEFT_NODE)(e),f=(0,a.RIGHT_NODE)(e,S);(0,o.arrayToBox)((0,a.BOUNDING_DATA_INDEX)(u),M,d),(0,o.arrayToBox)((0,a.BOUNDING_DATA_INDEX)(f),M,p);let _=r.intersectsBox(d),b=r.intersectsBox(p);O=_&&t(h,u,i,n,s,g,l,y,x+1,r,!v)||b&&t(h,f,i,n,s,g,l,y,x+1,r,!v),c.releasePrimitive(r)}}else if(w){if(N)O=t(e,u,n,i,s,l,g,x,y+1,_,v);else{let r=c.getPrimitive();r.copy(f).applyMatrix4(n);let h=(0,a.LEFT_NODE)(e),m=(0,a.RIGHT_NODE)(e,S);(0,o.arrayToBox)((0,a.BOUNDING_DATA_INDEX)(h),M,d),(0,o.arrayToBox)((0,a.BOUNDING_DATA_INDEX)(m),M,p);let _=r.intersectsBox(d),b=r.intersectsBox(p);O=_&&t(u,h,i,n,s,g,l,y,x+1,r,!v)||b&&t(u,m,i,n,s,g,l,y,x+1,r,!v),c.releasePrimitive(r)}}}return O}(0,0,r,v,i,y,_,0,0,e),u.clearBuffer(),_+=x[n].length,!s);n++);if(c.releasePrimitive(e),h.clearBuffer(),y+=l[t].length,s)break}return g=!1,s}})})();
//# sourceMappingURL=generateMeshBVH.worker.cd4b9fc6.js.map
