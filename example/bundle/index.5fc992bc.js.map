{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,c,I,G,I,E,E,SC0CA,IAAM,EAAoB,EAAA,cAAa,CAEjC,EAAY,IAAI,EAAA,OAAM,CACtB,EAAY,IAAI,EAAA,OAAM,AAE5B,OAAM,UAAqC,EAAA,cAAa,CAEvD,YAAa,CAAU,CAAG,CAEzB,KAAK,CAAE,CAEN,SAAU,AAAA,CAAA,EAAA,EAAA,aAAY,AAAZ,EAAc,KAAK,CAAE,CAC9B,AAAA,EAAA,WAAU,CAAE,GAAG,CACf,CACC,QAAS,CACR,MAAO,IAAI,EAAA,KAAI,AAChB,EACA,QAAS,CACR,MAAO,CACR,CACD,EACA,EAED,aAAwB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA8CzB,CAAC,CAED,eAA0B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;GA0B3B,CAAC,AAEF,GAEA,OAAO,gBAAgB,CAAE,IAAI,CAAE,CAE9B,QAAS,CACR,IAAK,WAEJ,OAAO,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,AAEnC,EAEA,IAAK,SAAW,CAAK,EAEpB,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAG,CAE/B,CACD,EAEA,MAAO,CACN,IAAK,WAEJ,OAAO,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,AAEnC,CACD,CAED,GAEA,IAAI,CAAC,SAAS,CAAE,GAChB,IAAI,CAAC,8BAA8B,CAAG,CAAA,CAEvC,CAED,CAEA,MAAM,UAAgC,EAAA,YAAW,CAEhD,YAAa,CAAQ,CAAE,CAAQ,CAAG,CAEjC,KAAK,CAAE,EAAU,GACjB,IAAI,CAAC,iBAAiB,CAAG,CA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","sources":["<anon>","node_modules/three/examples/jsm/loaders/LDrawLoader.js","node_modules/three/examples/jsm/utils/LDrawUtils.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5b70\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5b70\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"cpS3d\", function(module, exports) {\n\n$parcel$export(module.exports, \"LDrawLoader\", () => $90a1bf3572dc4d5f$export$12d9a9ad6192c950);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n// Special surface finish tag types.\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\nconst $90a1bf3572dc4d5f$var$FINISH_TYPE_DEFAULT = 0;\nconst $90a1bf3572dc4d5f$var$FINISH_TYPE_CHROME = 1;\nconst $90a1bf3572dc4d5f$var$FINISH_TYPE_PEARLESCENT = 2;\nconst $90a1bf3572dc4d5f$var$FINISH_TYPE_RUBBER = 3;\nconst $90a1bf3572dc4d5f$var$FINISH_TYPE_MATTE_METALLIC = 4;\nconst $90a1bf3572dc4d5f$var$FINISH_TYPE_METAL = 5;\n// State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\nconst $90a1bf3572dc4d5f$var$FILE_LOCATION_TRY_PARTS = 0;\nconst $90a1bf3572dc4d5f$var$FILE_LOCATION_TRY_P = 1;\nconst $90a1bf3572dc4d5f$var$FILE_LOCATION_TRY_MODELS = 2;\nconst $90a1bf3572dc4d5f$var$FILE_LOCATION_AS_IS = 3;\nconst $90a1bf3572dc4d5f$var$FILE_LOCATION_TRY_RELATIVE = 4;\nconst $90a1bf3572dc4d5f$var$FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst $90a1bf3572dc4d5f$var$FILE_LOCATION_NOT_FOUND = 6;\nconst $90a1bf3572dc4d5f$var$MAIN_COLOUR_CODE = \"16\";\nconst $90a1bf3572dc4d5f$var$MAIN_EDGE_COLOUR_CODE = \"24\";\nconst $90a1bf3572dc4d5f$var$COLOR_SPACE_LDRAW = (0, $ilwiq.SRGBColorSpace);\nconst $90a1bf3572dc4d5f$var$_tempVec0 = new (0, $ilwiq.Vector3)();\nconst $90a1bf3572dc4d5f$var$_tempVec1 = new (0, $ilwiq.Vector3)();\nclass $90a1bf3572dc4d5f$var$LDrawConditionalLineMaterial extends (0, $ilwiq.ShaderMaterial) {\n    constructor(parameters){\n        super({\n            uniforms: (0, $ilwiq.UniformsUtils).merge([\n                (0, $ilwiq.UniformsLib).fog,\n                {\n                    diffuse: {\n                        value: new (0, $ilwiq.Color)()\n                    },\n                    opacity: {\n                        value: 1.0\n                    }\n                }\n            ]),\n            vertexShader: /* glsl */ `\n\t\t\t\tattribute vec3 control0;\n\t\t\t\tattribute vec3 control1;\n\t\t\t\tattribute vec3 direction;\n\t\t\t\tvarying float discardFlag;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <color_pars_vertex>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <color_vertex>\n\n\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\t// Transform the line segment ends and control points into camera clip space\n\t\t\t\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\t\t\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\t\t\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\t\t\t\tc0.xy /= c0.w;\n\t\t\t\t\tc1.xy /= c1.w;\n\t\t\t\t\tp0.xy /= p0.w;\n\t\t\t\t\tp1.xy /= p1.w;\n\n\t\t\t\t\t// Get the direction of the segment and an orthogonal vector\n\t\t\t\t\tvec2 dir = p1.xy - p0.xy;\n\t\t\t\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t\t\t\t// Get control point directions from the line\n\t\t\t\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\t\t\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t\t\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t\t\t\t// from the line segment then the line should not be drawn.\n\t\t\t\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\t\t\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\t\t\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\t\t\t\t}\n\t\t\t`,\n            fragmentShader: /* glsl */ `\n\t\t\tuniform vec3 diffuse;\n\t\t\tuniform float opacity;\n\t\t\tvarying float discardFlag;\n\n\t\t\t#include <common>\n\t\t\t#include <color_pars_fragment>\n\t\t\t#include <fog_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t#include <clipping_planes_pars_fragment>\n\t\t\tvoid main() {\n\n\t\t\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t\t\t#include <clipping_planes_fragment>\n\t\t\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t#include <color_fragment>\n\t\t\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <colorspace_fragment>\n\t\t\t\t#include <fog_fragment>\n\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t}\n\t\t\t`\n        });\n        Object.defineProperties(this, {\n            opacity: {\n                get: function() {\n                    return this.uniforms.opacity.value;\n                },\n                set: function(value) {\n                    this.uniforms.opacity.value = value;\n                }\n            },\n            color: {\n                get: function() {\n                    return this.uniforms.diffuse.value;\n                }\n            }\n        });\n        this.setValues(parameters);\n        this.isLDrawConditionalLineMaterial = true;\n    }\n}\nclass $90a1bf3572dc4d5f$var$ConditionalLineSegments extends (0, $ilwiq.LineSegments) {\n    constructor(geometry, material){\n        super(geometry, material);\n        this.isConditionalLine = true;\n    }\n}\nfunction $90a1bf3572dc4d5f$var$generateFaceNormals(faces) {\n    for(let i = 0, l = faces.length; i < l; i++){\n        const face = faces[i];\n        const vertices = face.vertices;\n        const v0 = vertices[0];\n        const v1 = vertices[1];\n        const v2 = vertices[2];\n        $90a1bf3572dc4d5f$var$_tempVec0.subVectors(v1, v0);\n        $90a1bf3572dc4d5f$var$_tempVec1.subVectors(v2, v1);\n        face.faceNormal = new (0, $ilwiq.Vector3)().crossVectors($90a1bf3572dc4d5f$var$_tempVec0, $90a1bf3572dc4d5f$var$_tempVec1).normalize();\n    }\n}\nconst $90a1bf3572dc4d5f$var$_ray = new (0, $ilwiq.Ray)();\nfunction $90a1bf3572dc4d5f$var$smoothNormals(faces, lineSegments, checkSubSegments = false) {\n    // NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\n    // it allows edges to be smoothed as expected (see minifig arms).\n    // --\n    // And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\n    // point errors on vertices along quantization boundaries. Ie after matrix multiplication\n    // vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\n    // get merged. This added epsilon attempts to push these error values to the same quantized\n    // value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\n    const hashMultiplier = (1 + 1e-10) * 1e2;\n    function hashVertex(v) {\n        const x = ~~(v.x * hashMultiplier);\n        const y = ~~(v.y * hashMultiplier);\n        const z = ~~(v.z * hashMultiplier);\n        return `${x},${y},${z}`;\n    }\n    function hashEdge(v0, v1) {\n        return `${hashVertex(v0)}_${hashVertex(v1)}`;\n    }\n    // converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\n    // onto the original line.\n    function toNormalizedRay(v0, v1, targetRay) {\n        targetRay.direction.subVectors(v1, v0).normalize();\n        const scalar = v0.dot(targetRay.direction);\n        targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar);\n        return targetRay;\n    }\n    function hashRay(ray) {\n        return hashEdge(ray.origin, ray.direction);\n    }\n    const hardEdges = new Set();\n    const hardEdgeRays = new Map();\n    const halfEdgeList = {};\n    const normals = [];\n    // Save the list of hard edges by hash\n    for(let i = 0, l = lineSegments.length; i < l; i++){\n        const ls = lineSegments[i];\n        const vertices = ls.vertices;\n        const v0 = vertices[0];\n        const v1 = vertices[1];\n        hardEdges.add(hashEdge(v0, v1));\n        hardEdges.add(hashEdge(v1, v0));\n        // only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\n        // and requires more memory.\n        if (checkSubSegments) {\n            // add both ray directions to the map\n            const ray = toNormalizedRay(v0, v1, new (0, $ilwiq.Ray)());\n            const rh1 = hashRay(ray);\n            if (!hardEdgeRays.has(rh1)) {\n                toNormalizedRay(v1, v0, ray);\n                const rh2 = hashRay(ray);\n                const info = {\n                    ray: ray,\n                    distances: []\n                };\n                hardEdgeRays.set(rh1, info);\n                hardEdgeRays.set(rh2, info);\n            }\n            // store both segments ends in min, max order in the distances array to check if a face edge is a\n            // subsegment later.\n            const info = hardEdgeRays.get(rh1);\n            let d0 = info.ray.direction.dot(v0);\n            let d1 = info.ray.direction.dot(v1);\n            if (d0 > d1) [d0, d1] = [\n                d1,\n                d0\n            ];\n            info.distances.push(d0, d1);\n        }\n    }\n    // track the half edges associated with each triangle\n    for(let i = 0, l = faces.length; i < l; i++){\n        const tri = faces[i];\n        const vertices = tri.vertices;\n        const vertCount = vertices.length;\n        for(let i2 = 0; i2 < vertCount; i2++){\n            const index = i2;\n            const next = (i2 + 1) % vertCount;\n            const v0 = vertices[index];\n            const v1 = vertices[next];\n            const hash = hashEdge(v0, v1);\n            // don't add the triangle if the edge is supposed to be hard\n            if (hardEdges.has(hash)) continue;\n            // if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\n            if (checkSubSegments) {\n                toNormalizedRay(v0, v1, $90a1bf3572dc4d5f$var$_ray);\n                const rayHash = hashRay($90a1bf3572dc4d5f$var$_ray);\n                if (hardEdgeRays.has(rayHash)) {\n                    const info = hardEdgeRays.get(rayHash);\n                    const { ray: ray, distances: distances } = info;\n                    let d0 = ray.direction.dot(v0);\n                    let d1 = ray.direction.dot(v1);\n                    if (d0 > d1) [d0, d1] = [\n                        d1,\n                        d0\n                    ];\n                    // return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\n                    let found = false;\n                    for(let i = 0, l = distances.length; i < l; i += 2)if (d0 >= distances[i] && d1 <= distances[i + 1]) {\n                        found = true;\n                        break;\n                    }\n                    if (found) continue;\n                }\n            }\n            const info = {\n                index: index,\n                tri: tri\n            };\n            halfEdgeList[hash] = info;\n        }\n    }\n    // Iterate until we've tried to connect all faces to share normals\n    while(true){\n        // Stop if there are no more faces left\n        let halfEdge = null;\n        for(const key in halfEdgeList){\n            halfEdge = halfEdgeList[key];\n            break;\n        }\n        if (halfEdge === null) break;\n        // Exhaustively find all connected faces\n        const queue = [\n            halfEdge\n        ];\n        while(queue.length > 0){\n            // initialize all vertex normals in this triangle\n            const tri = queue.pop().tri;\n            const vertices = tri.vertices;\n            const vertNormals = tri.normals;\n            const faceNormal = tri.faceNormal;\n            // Check if any edge is connected to another triangle edge\n            const vertCount = vertices.length;\n            for(let i2 = 0; i2 < vertCount; i2++){\n                const index = i2;\n                const next = (i2 + 1) % vertCount;\n                const v0 = vertices[index];\n                const v1 = vertices[next];\n                // delete this triangle from the list so it won't be found again\n                const hash = hashEdge(v0, v1);\n                delete halfEdgeList[hash];\n                const reverseHash = hashEdge(v1, v0);\n                const otherInfo = halfEdgeList[reverseHash];\n                if (otherInfo) {\n                    const otherTri = otherInfo.tri;\n                    const otherIndex = otherInfo.index;\n                    const otherNormals = otherTri.normals;\n                    const otherVertCount = otherNormals.length;\n                    const otherFaceNormal = otherTri.faceNormal;\n                    // NOTE: If the angle between faces is > 67.5 degrees then assume it's\n                    // hard edge. There are some cases where the line segments do not line up exactly\n                    // with or span multiple triangle edges (see Lunar Vehicle wheels).\n                    if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) continue;\n                    // if this triangle has already been traversed then it won't be in\n                    // the halfEdgeList. If it has not then add it to the queue and delete\n                    // it so it won't be found again.\n                    if (reverseHash in halfEdgeList) {\n                        queue.push(otherInfo);\n                        delete halfEdgeList[reverseHash];\n                    }\n                    // share the first normal\n                    const otherNext = (otherIndex + 1) % otherVertCount;\n                    if (vertNormals[index] && otherNormals[otherNext] && vertNormals[index] !== otherNormals[otherNext]) {\n                        otherNormals[otherNext].norm.add(vertNormals[index].norm);\n                        vertNormals[index].norm = otherNormals[otherNext].norm;\n                    }\n                    let sharedNormal1 = vertNormals[index] || otherNormals[otherNext];\n                    if (sharedNormal1 === null) {\n                        // it's possible to encounter an edge of a triangle that has already been traversed meaning\n                        // both edges already have different normals defined and shared. To work around this we create\n                        // a wrapper object so when those edges are merged the normals can be updated everywhere.\n                        sharedNormal1 = {\n                            norm: new (0, $ilwiq.Vector3)()\n                        };\n                        normals.push(sharedNormal1.norm);\n                    }\n                    if (vertNormals[index] === null) {\n                        vertNormals[index] = sharedNormal1;\n                        sharedNormal1.norm.add(faceNormal);\n                    }\n                    if (otherNormals[otherNext] === null) {\n                        otherNormals[otherNext] = sharedNormal1;\n                        sharedNormal1.norm.add(otherFaceNormal);\n                    }\n                    // share the second normal\n                    if (vertNormals[next] && otherNormals[otherIndex] && vertNormals[next] !== otherNormals[otherIndex]) {\n                        otherNormals[otherIndex].norm.add(vertNormals[next].norm);\n                        vertNormals[next].norm = otherNormals[otherIndex].norm;\n                    }\n                    let sharedNormal2 = vertNormals[next] || otherNormals[otherIndex];\n                    if (sharedNormal2 === null) {\n                        sharedNormal2 = {\n                            norm: new (0, $ilwiq.Vector3)()\n                        };\n                        normals.push(sharedNormal2.norm);\n                    }\n                    if (vertNormals[next] === null) {\n                        vertNormals[next] = sharedNormal2;\n                        sharedNormal2.norm.add(faceNormal);\n                    }\n                    if (otherNormals[otherIndex] === null) {\n                        otherNormals[otherIndex] = sharedNormal2;\n                        sharedNormal2.norm.add(otherFaceNormal);\n                    }\n                }\n            }\n        }\n    }\n    // The normals of each face have been added up so now we average them by normalizing the vector.\n    for(let i = 0, l = normals.length; i < l; i++)normals[i].normalize();\n}\nfunction $90a1bf3572dc4d5f$var$isPartType(type) {\n    return type === \"Part\" || type === \"Unofficial_Part\";\n}\nfunction $90a1bf3572dc4d5f$var$isPrimitiveType(type) {\n    return /primitive/i.test(type) || type === \"Subpart\";\n}\nclass $90a1bf3572dc4d5f$var$LineParser {\n    constructor(line, lineNumber){\n        this.line = line;\n        this.lineLength = line.length;\n        this.currentCharIndex = 0;\n        this.currentChar = \" \";\n        this.lineNumber = lineNumber;\n    }\n    seekNonSpace() {\n        while(this.currentCharIndex < this.lineLength){\n            this.currentChar = this.line.charAt(this.currentCharIndex);\n            if (this.currentChar !== \" \" && this.currentChar !== \"\t\") return;\n            this.currentCharIndex++;\n        }\n    }\n    getToken() {\n        const pos0 = this.currentCharIndex++;\n        // Seek space\n        while(this.currentCharIndex < this.lineLength){\n            this.currentChar = this.line.charAt(this.currentCharIndex);\n            if (this.currentChar === \" \" || this.currentChar === \"\t\") break;\n            this.currentCharIndex++;\n        }\n        const pos1 = this.currentCharIndex;\n        this.seekNonSpace();\n        return this.line.substring(pos0, pos1);\n    }\n    getVector() {\n        return new (0, $ilwiq.Vector3)(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()));\n    }\n    getRemainingString() {\n        return this.line.substring(this.currentCharIndex, this.lineLength);\n    }\n    isAtTheEnd() {\n        return this.currentCharIndex >= this.lineLength;\n    }\n    setToEnd() {\n        this.currentCharIndex = this.lineLength;\n    }\n    getLineNumberString() {\n        return this.lineNumber >= 0 ? \" at line \" + this.lineNumber : \"\";\n    }\n}\n// Fetches and parses an intermediate representation of LDraw parts files.\nclass $90a1bf3572dc4d5f$var$LDrawParsedCache {\n    constructor(loader){\n        this.loader = loader;\n        this._cache = {};\n    }\n    cloneResult(original) {\n        const result = {};\n        // vertices are transformed and normals computed before being converted to geometry\n        // so these pieces must be cloned.\n        result.faces = original.faces.map((face)=>{\n            return {\n                colorCode: face.colorCode,\n                material: face.material,\n                vertices: face.vertices.map((v)=>v.clone()),\n                normals: face.normals.map(()=>null),\n                faceNormal: null\n            };\n        });\n        result.conditionalSegments = original.conditionalSegments.map((face)=>{\n            return {\n                colorCode: face.colorCode,\n                material: face.material,\n                vertices: face.vertices.map((v)=>v.clone()),\n                controlPoints: face.controlPoints.map((v)=>v.clone())\n            };\n        });\n        result.lineSegments = original.lineSegments.map((face)=>{\n            return {\n                colorCode: face.colorCode,\n                material: face.material,\n                vertices: face.vertices.map((v)=>v.clone())\n            };\n        });\n        // none if this is subsequently modified\n        result.type = original.type;\n        result.category = original.category;\n        result.keywords = original.keywords;\n        result.author = original.author;\n        result.subobjects = original.subobjects;\n        result.fileName = original.fileName;\n        result.totalFaces = original.totalFaces;\n        result.startingBuildingStep = original.startingBuildingStep;\n        result.materials = original.materials;\n        result.group = null;\n        return result;\n    }\n    async fetchData(fileName) {\n        let triedLowerCase = false;\n        let locationState = $90a1bf3572dc4d5f$var$FILE_LOCATION_TRY_PARTS;\n        while(locationState !== $90a1bf3572dc4d5f$var$FILE_LOCATION_NOT_FOUND){\n            let subobjectURL = fileName;\n            switch(locationState){\n                case $90a1bf3572dc4d5f$var$FILE_LOCATION_AS_IS:\n                    locationState = locationState + 1;\n                    break;\n                case $90a1bf3572dc4d5f$var$FILE_LOCATION_TRY_PARTS:\n                    subobjectURL = \"parts/\" + subobjectURL;\n                    locationState = locationState + 1;\n                    break;\n                case $90a1bf3572dc4d5f$var$FILE_LOCATION_TRY_P:\n                    subobjectURL = \"p/\" + subobjectURL;\n                    locationState = locationState + 1;\n                    break;\n                case $90a1bf3572dc4d5f$var$FILE_LOCATION_TRY_MODELS:\n                    subobjectURL = \"models/\" + subobjectURL;\n                    locationState = locationState + 1;\n                    break;\n                case $90a1bf3572dc4d5f$var$FILE_LOCATION_TRY_RELATIVE:\n                    subobjectURL = fileName.substring(0, fileName.lastIndexOf(\"/\") + 1) + subobjectURL;\n                    locationState = locationState + 1;\n                    break;\n                case $90a1bf3572dc4d5f$var$FILE_LOCATION_TRY_ABSOLUTE:\n                    if (triedLowerCase) // Try absolute path\n                    locationState = $90a1bf3572dc4d5f$var$FILE_LOCATION_NOT_FOUND;\n                    else {\n                        // Next attempt is lower case\n                        fileName = fileName.toLowerCase();\n                        subobjectURL = fileName;\n                        triedLowerCase = true;\n                        locationState = $90a1bf3572dc4d5f$var$FILE_LOCATION_TRY_PARTS;\n                    }\n                    break;\n            }\n            const loader = this.loader;\n            const fileLoader = new (0, $ilwiq.FileLoader)(loader.manager);\n            fileLoader.setPath(loader.partsLibraryPath);\n            fileLoader.setRequestHeader(loader.requestHeader);\n            fileLoader.setWithCredentials(loader.withCredentials);\n            try {\n                const text = await fileLoader.loadAsync(subobjectURL);\n                return text;\n            } catch (_) {\n                continue;\n            }\n        }\n        throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.');\n    }\n    parse(text, fileName = null) {\n        const loader = this.loader;\n        // final results\n        const faces = [];\n        const lineSegments = [];\n        const conditionalSegments = [];\n        const subobjects = [];\n        const materials = {};\n        const getLocalMaterial = (colorCode)=>{\n            return materials[colorCode] || null;\n        };\n        let type = \"Model\";\n        let category = null;\n        let keywords = null;\n        let author = null;\n        let totalFaces = 0;\n        // split into lines\n        if (text.indexOf(\"\\r\\n\") !== -1) // This is faster than String.split with regex that splits on both\n        text = text.replace(/\\r\\n/g, \"\\n\");\n        const lines = text.split(\"\\n\");\n        const numLines = lines.length;\n        let parsingEmbeddedFiles = false;\n        let currentEmbeddedFileName = null;\n        let currentEmbeddedText = null;\n        let bfcCertified = false;\n        let bfcCCW = true;\n        let bfcInverted = false;\n        let bfcCull = true;\n        let startingBuildingStep = false;\n        // Parse all line commands\n        for(let lineIndex = 0; lineIndex < numLines; lineIndex++){\n            const line = lines[lineIndex];\n            if (line.length === 0) continue;\n            if (parsingEmbeddedFiles) {\n                if (line.startsWith(\"0 FILE \")) {\n                    // Save previous embedded file in the cache\n                    this.setData(currentEmbeddedFileName, currentEmbeddedText);\n                    // New embedded text file\n                    currentEmbeddedFileName = line.substring(7);\n                    currentEmbeddedText = \"\";\n                } else currentEmbeddedText += line + \"\\n\";\n                continue;\n            }\n            const lp = new $90a1bf3572dc4d5f$var$LineParser(line, lineIndex + 1);\n            lp.seekNonSpace();\n            if (lp.isAtTheEnd()) continue;\n            // Parse the line type\n            const lineType = lp.getToken();\n            let material;\n            let colorCode;\n            let segment;\n            let ccw;\n            let doubleSided;\n            let v0, v1, v2, v3, c0, c1;\n            switch(lineType){\n                // Line type 0: Comment or META\n                case \"0\":\n                    // Parse meta directive\n                    const meta = lp.getToken();\n                    if (meta) switch(meta){\n                        case \"!LDRAW_ORG\":\n                            type = lp.getToken();\n                            break;\n                        case \"!COLOUR\":\n                            material = loader.parseColorMetaDirective(lp);\n                            if (material) materials[material.userData.code] = material;\n                            else console.warn(\"LDrawLoader: Error parsing material\" + lp.getLineNumberString());\n                            break;\n                        case \"!CATEGORY\":\n                            category = lp.getToken();\n                            break;\n                        case \"!KEYWORDS\":\n                            const newKeywords = lp.getRemainingString().split(\",\");\n                            if (newKeywords.length > 0) {\n                                if (!keywords) keywords = [];\n                                newKeywords.forEach(function(keyword) {\n                                    keywords.push(keyword.trim());\n                                });\n                            }\n                            break;\n                        case \"FILE\":\n                            if (lineIndex > 0) {\n                                // Start embedded text files parsing\n                                parsingEmbeddedFiles = true;\n                                currentEmbeddedFileName = lp.getRemainingString();\n                                currentEmbeddedText = \"\";\n                                bfcCertified = false;\n                                bfcCCW = true;\n                            }\n                            break;\n                        case \"BFC\":\n                            // Changes to the backface culling state\n                            while(!lp.isAtTheEnd()){\n                                const token = lp.getToken();\n                                switch(token){\n                                    case \"CERTIFY\":\n                                    case \"NOCERTIFY\":\n                                        bfcCertified = token === \"CERTIFY\";\n                                        bfcCCW = true;\n                                        break;\n                                    case \"CW\":\n                                    case \"CCW\":\n                                        bfcCCW = token === \"CCW\";\n                                        break;\n                                    case \"INVERTNEXT\":\n                                        bfcInverted = true;\n                                        break;\n                                    case \"CLIP\":\n                                    case \"NOCLIP\":\n                                        bfcCull = token === \"CLIP\";\n                                        break;\n                                    default:\n                                        console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                                        break;\n                                }\n                            }\n                            break;\n                        case \"STEP\":\n                            startingBuildingStep = true;\n                            break;\n                        case \"Author:\":\n                            author = lp.getToken();\n                            break;\n                        default:\n                            break;\n                    }\n                    break;\n                // Line type 1: Sub-object file\n                case \"1\":\n                    colorCode = lp.getToken();\n                    material = getLocalMaterial(colorCode);\n                    const posX = parseFloat(lp.getToken());\n                    const posY = parseFloat(lp.getToken());\n                    const posZ = parseFloat(lp.getToken());\n                    const m0 = parseFloat(lp.getToken());\n                    const m1 = parseFloat(lp.getToken());\n                    const m2 = parseFloat(lp.getToken());\n                    const m3 = parseFloat(lp.getToken());\n                    const m4 = parseFloat(lp.getToken());\n                    const m5 = parseFloat(lp.getToken());\n                    const m6 = parseFloat(lp.getToken());\n                    const m7 = parseFloat(lp.getToken());\n                    const m8 = parseFloat(lp.getToken());\n                    const matrix = new (0, $ilwiq.Matrix4)().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n                    let fileName = lp.getRemainingString().trim().replace(/\\\\/g, \"/\");\n                    if (loader.fileMap[fileName]) // Found the subobject path in the preloaded file path map\n                    fileName = loader.fileMap[fileName];\n                    else {\n                        // Standardized subfolders\n                        if (fileName.startsWith(\"s/\")) fileName = \"parts/\" + fileName;\n                        else if (fileName.startsWith(\"48/\")) fileName = \"p/\" + fileName;\n                    }\n                    subobjects.push({\n                        material: material,\n                        colorCode: colorCode,\n                        matrix: matrix,\n                        fileName: fileName,\n                        inverted: bfcInverted,\n                        startingBuildingStep: startingBuildingStep\n                    });\n                    startingBuildingStep = false;\n                    bfcInverted = false;\n                    break;\n                // Line type 2: Line segment\n                case \"2\":\n                    colorCode = lp.getToken();\n                    material = getLocalMaterial(colorCode);\n                    v0 = lp.getVector();\n                    v1 = lp.getVector();\n                    segment = {\n                        material: material,\n                        colorCode: colorCode,\n                        vertices: [\n                            v0,\n                            v1\n                        ]\n                    };\n                    lineSegments.push(segment);\n                    break;\n                // Line type 5: Conditional Line segment\n                case \"5\":\n                    colorCode = lp.getToken();\n                    material = getLocalMaterial(colorCode);\n                    v0 = lp.getVector();\n                    v1 = lp.getVector();\n                    c0 = lp.getVector();\n                    c1 = lp.getVector();\n                    segment = {\n                        material: material,\n                        colorCode: colorCode,\n                        vertices: [\n                            v0,\n                            v1\n                        ],\n                        controlPoints: [\n                            c0,\n                            c1\n                        ]\n                    };\n                    conditionalSegments.push(segment);\n                    break;\n                // Line type 3: Triangle\n                case \"3\":\n                    colorCode = lp.getToken();\n                    material = getLocalMaterial(colorCode);\n                    ccw = bfcCCW;\n                    doubleSided = !bfcCertified || !bfcCull;\n                    if (ccw === true) {\n                        v0 = lp.getVector();\n                        v1 = lp.getVector();\n                        v2 = lp.getVector();\n                    } else {\n                        v2 = lp.getVector();\n                        v1 = lp.getVector();\n                        v0 = lp.getVector();\n                    }\n                    faces.push({\n                        material: material,\n                        colorCode: colorCode,\n                        faceNormal: null,\n                        vertices: [\n                            v0,\n                            v1,\n                            v2\n                        ],\n                        normals: [\n                            null,\n                            null,\n                            null\n                        ]\n                    });\n                    totalFaces++;\n                    if (doubleSided === true) {\n                        faces.push({\n                            material: material,\n                            colorCode: colorCode,\n                            faceNormal: null,\n                            vertices: [\n                                v2,\n                                v1,\n                                v0\n                            ],\n                            normals: [\n                                null,\n                                null,\n                                null\n                            ]\n                        });\n                        totalFaces++;\n                    }\n                    break;\n                // Line type 4: Quadrilateral\n                case \"4\":\n                    colorCode = lp.getToken();\n                    material = getLocalMaterial(colorCode);\n                    ccw = bfcCCW;\n                    doubleSided = !bfcCertified || !bfcCull;\n                    if (ccw === true) {\n                        v0 = lp.getVector();\n                        v1 = lp.getVector();\n                        v2 = lp.getVector();\n                        v3 = lp.getVector();\n                    } else {\n                        v3 = lp.getVector();\n                        v2 = lp.getVector();\n                        v1 = lp.getVector();\n                        v0 = lp.getVector();\n                    }\n                    // specifically place the triangle diagonal in the v0 and v1 slots so we can\n                    // account for the doubling of vertices later when smoothing normals.\n                    faces.push({\n                        material: material,\n                        colorCode: colorCode,\n                        faceNormal: null,\n                        vertices: [\n                            v0,\n                            v1,\n                            v2,\n                            v3\n                        ],\n                        normals: [\n                            null,\n                            null,\n                            null,\n                            null\n                        ]\n                    });\n                    totalFaces += 2;\n                    if (doubleSided === true) {\n                        faces.push({\n                            material: material,\n                            colorCode: colorCode,\n                            faceNormal: null,\n                            vertices: [\n                                v3,\n                                v2,\n                                v1,\n                                v0\n                            ],\n                            normals: [\n                                null,\n                                null,\n                                null,\n                                null\n                            ]\n                        });\n                        totalFaces += 2;\n                    }\n                    break;\n                default:\n                    throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + \".\");\n            }\n        }\n        if (parsingEmbeddedFiles) this.setData(currentEmbeddedFileName, currentEmbeddedText);\n        return {\n            faces: faces,\n            conditionalSegments: conditionalSegments,\n            lineSegments: lineSegments,\n            type: type,\n            category: category,\n            keywords: keywords,\n            author: author,\n            subobjects: subobjects,\n            totalFaces: totalFaces,\n            startingBuildingStep: startingBuildingStep,\n            materials: materials,\n            fileName: fileName,\n            group: null\n        };\n    }\n    // returns an (optionally cloned) instance of the data\n    getData(fileName, clone = true) {\n        const key = fileName.toLowerCase();\n        const result = this._cache[key];\n        if (result === null || result instanceof Promise) return null;\n        if (clone) return this.cloneResult(result);\n        else return result;\n    }\n    // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n    // the data is ready to use and can be retrieved synchronously with \"getData\".\n    async ensureDataLoaded(fileName) {\n        const key = fileName.toLowerCase();\n        if (!(key in this._cache)) // replace the promise with a copy of the parsed data for immediate processing\n        this._cache[key] = this.fetchData(fileName).then((text)=>{\n            const info = this.parse(text, fileName);\n            this._cache[key] = info;\n            return info;\n        });\n        await this._cache[key];\n    }\n    // sets the data in the cache from parsed data\n    setData(fileName, text) {\n        const key = fileName.toLowerCase();\n        this._cache[key] = this.parse(text, fileName);\n    }\n}\n// returns the material for an associated color code. If the color code is 16 for a face or 24 for\n// an edge then the passthroughColorCode is used.\nfunction $90a1bf3572dc4d5f$var$getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n    const isPassthrough = !forEdge && colorCode === $90a1bf3572dc4d5f$var$MAIN_COLOUR_CODE || forEdge && colorCode === $90a1bf3572dc4d5f$var$MAIN_EDGE_COLOUR_CODE;\n    if (isPassthrough) colorCode = parentColorCode;\n    return materialHierarchy[colorCode] || null;\n}\n// Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\nclass $90a1bf3572dc4d5f$var$LDrawPartsGeometryCache {\n    constructor(loader){\n        this.loader = loader;\n        this.parseCache = new $90a1bf3572dc4d5f$var$LDrawParsedCache(loader);\n        this._cache = {};\n    }\n    // Convert the given file information into a mesh by processing subobjects.\n    async processIntoMesh(info) {\n        const loader = this.loader;\n        const parseCache = this.parseCache;\n        const faceMaterials = new Set();\n        // Processes the part subobject information to load child parts and merge geometry onto part\n        // piece object.\n        const processInfoSubobjects = async (info, subobject = null)=>{\n            const subobjects = info.subobjects;\n            const promises = [];\n            // Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\n            // group which lets instruction steps apply correctly.\n            for(let i = 0, l = subobjects.length; i < l; i++){\n                const subobject = subobjects[i];\n                const promise = parseCache.ensureDataLoaded(subobject.fileName).then(()=>{\n                    const subobjectInfo = parseCache.getData(subobject.fileName, false);\n                    if (!$90a1bf3572dc4d5f$var$isPrimitiveType(subobjectInfo.type)) return this.loadModel(subobject.fileName).catch((error)=>{\n                        console.warn(error);\n                        return null;\n                    });\n                    return processInfoSubobjects(parseCache.getData(subobject.fileName), subobject);\n                });\n                promises.push(promise);\n            }\n            const group = new (0, $ilwiq.Group)();\n            group.userData.category = info.category;\n            group.userData.keywords = info.keywords;\n            group.userData.author = info.author;\n            group.userData.type = info.type;\n            group.userData.fileName = info.fileName;\n            info.group = group;\n            const subobjectInfos = await Promise.all(promises);\n            for(let i = 0, l = subobjectInfos.length; i < l; i++){\n                const subobject = info.subobjects[i];\n                const subobjectInfo = subobjectInfos[i];\n                if (subobjectInfo === null) continue;\n                // if the subobject was loaded as a separate group then apply the parent scopes materials\n                if (subobjectInfo.isGroup) {\n                    const subobjectGroup = subobjectInfo;\n                    subobject.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale);\n                    subobjectGroup.userData.startingBuildingStep = subobject.startingBuildingStep;\n                    subobjectGroup.name = subobject.fileName;\n                    loader.applyMaterialsToMesh(subobjectGroup, subobject.colorCode, info.materials);\n                    subobjectGroup.userData.colorCode = subobject.colorCode;\n                    group.add(subobjectGroup);\n                    continue;\n                }\n                // add the subobject group if it has children in case it has both children and primitives\n                if (subobjectInfo.group.children.length) group.add(subobjectInfo.group);\n                // transform the primitives into the local space of the parent piece and append them to\n                // to the parent primitives list.\n                const parentLineSegments = info.lineSegments;\n                const parentConditionalSegments = info.conditionalSegments;\n                const parentFaces = info.faces;\n                const lineSegments = subobjectInfo.lineSegments;\n                const conditionalSegments = subobjectInfo.conditionalSegments;\n                const faces = subobjectInfo.faces;\n                const matrix = subobject.matrix;\n                const inverted = subobject.inverted;\n                const matrixScaleInverted = matrix.determinant() < 0;\n                const colorCode = subobject.colorCode;\n                const lineColorCode = colorCode === $90a1bf3572dc4d5f$var$MAIN_COLOUR_CODE ? $90a1bf3572dc4d5f$var$MAIN_EDGE_COLOUR_CODE : colorCode;\n                for(let i = 0, l = lineSegments.length; i < l; i++){\n                    const ls = lineSegments[i];\n                    const vertices = ls.vertices;\n                    vertices[0].applyMatrix4(matrix);\n                    vertices[1].applyMatrix4(matrix);\n                    ls.colorCode = ls.colorCode === $90a1bf3572dc4d5f$var$MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n                    ls.material = ls.material || $90a1bf3572dc4d5f$var$getMaterialFromCode(ls.colorCode, ls.colorCode, info.materials, true);\n                    parentLineSegments.push(ls);\n                }\n                for(let i = 0, l = conditionalSegments.length; i < l; i++){\n                    const os = conditionalSegments[i];\n                    const vertices = os.vertices;\n                    const controlPoints = os.controlPoints;\n                    vertices[0].applyMatrix4(matrix);\n                    vertices[1].applyMatrix4(matrix);\n                    controlPoints[0].applyMatrix4(matrix);\n                    controlPoints[1].applyMatrix4(matrix);\n                    os.colorCode = os.colorCode === $90a1bf3572dc4d5f$var$MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n                    os.material = os.material || $90a1bf3572dc4d5f$var$getMaterialFromCode(os.colorCode, os.colorCode, info.materials, true);\n                    parentConditionalSegments.push(os);\n                }\n                for(let i = 0, l = faces.length; i < l; i++){\n                    const tri = faces[i];\n                    const vertices = tri.vertices;\n                    for(let i = 0, l = vertices.length; i < l; i++)vertices[i].applyMatrix4(matrix);\n                    tri.colorCode = tri.colorCode === $90a1bf3572dc4d5f$var$MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n                    tri.material = tri.material || $90a1bf3572dc4d5f$var$getMaterialFromCode(tri.colorCode, colorCode, info.materials, false);\n                    faceMaterials.add(tri.colorCode);\n                    // If the scale of the object is negated then the triangle winding order\n                    // needs to be flipped.\n                    if (matrixScaleInverted !== inverted) vertices.reverse();\n                    parentFaces.push(tri);\n                }\n                info.totalFaces += subobjectInfo.totalFaces;\n            }\n            // Apply the parent subobjects pass through material code to this object. This is done several times due\n            // to material scoping.\n            if (subobject) {\n                loader.applyMaterialsToMesh(group, subobject.colorCode, info.materials);\n                group.userData.colorCode = subobject.colorCode;\n            }\n            return info;\n        };\n        // Track material use to see if we need to use the normal smooth slow path for hard edges.\n        for(let i = 0, l = info.faces; i < l; i++)faceMaterials.add(info.faces[i].colorCode);\n        await processInfoSubobjects(info);\n        if (loader.smoothNormals) {\n            const checkSubSegments = faceMaterials.size > 1;\n            $90a1bf3572dc4d5f$var$generateFaceNormals(info.faces);\n            $90a1bf3572dc4d5f$var$smoothNormals(info.faces, info.lineSegments, checkSubSegments);\n        }\n        // Add the primitive objects and metadata.\n        const group = info.group;\n        if (info.faces.length > 0) group.add($90a1bf3572dc4d5f$var$createObject(this.loader, info.faces, 3, false, info.totalFaces));\n        if (info.lineSegments.length > 0) group.add($90a1bf3572dc4d5f$var$createObject(this.loader, info.lineSegments, 2));\n        if (info.conditionalSegments.length > 0) group.add($90a1bf3572dc4d5f$var$createObject(this.loader, info.conditionalSegments, 2, true));\n        return group;\n    }\n    hasCachedModel(fileName) {\n        return fileName !== null && fileName.toLowerCase() in this._cache;\n    }\n    async getCachedModel(fileName) {\n        if (fileName !== null && this.hasCachedModel(fileName)) {\n            const key = fileName.toLowerCase();\n            const group = await this._cache[key];\n            return group.clone();\n        } else return null;\n    }\n    // Loads and parses the model with the given file name. Returns a cached copy if available.\n    async loadModel(fileName) {\n        const parseCache = this.parseCache;\n        const key = fileName.toLowerCase();\n        if (this.hasCachedModel(fileName)) // Return cached model if available.\n        return this.getCachedModel(fileName);\n        else {\n            // Otherwise parse a new model.\n            // Ensure the file data is loaded and pre parsed.\n            await parseCache.ensureDataLoaded(fileName);\n            const info = parseCache.getData(fileName);\n            const promise = this.processIntoMesh(info);\n            // Now that the file has loaded it's possible that another part parse has been waiting in parallel\n            // so check the cache again to see if it's been added since the last async operation so we don't\n            // do unnecessary work.\n            if (this.hasCachedModel(fileName)) return this.getCachedModel(fileName);\n            // Cache object if it's a part so it can be reused later.\n            if ($90a1bf3572dc4d5f$var$isPartType(info.type)) this._cache[key] = promise;\n            // return a copy\n            const group = await promise;\n            return group.clone();\n        }\n    }\n    // parses the given model text into a renderable object. Returns cached copy if available.\n    async parseModel(text) {\n        const parseCache = this.parseCache;\n        const info = parseCache.parse(text);\n        if ($90a1bf3572dc4d5f$var$isPartType(info.type) && this.hasCachedModel(info.fileName)) return this.getCachedModel(info.fileName);\n        return this.processIntoMesh(info);\n    }\n}\nfunction $90a1bf3572dc4d5f$var$sortByMaterial(a, b) {\n    if (a.colorCode === b.colorCode) return 0;\n    if (a.colorCode < b.colorCode) return -1;\n    return 1;\n}\nfunction $90a1bf3572dc4d5f$var$createObject(loader, elements, elementSize, isConditionalSegments = false, totalElements = null) {\n    // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n    // With per face / segment material, implemented with mesh groups and materials array\n    // Sort the faces or line segments by color code to make later the mesh groups\n    elements.sort($90a1bf3572dc4d5f$var$sortByMaterial);\n    if (totalElements === null) totalElements = elements.length;\n    const positions = new Float32Array(elementSize * totalElements * 3);\n    const normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null;\n    const materials = [];\n    const quadArray = new Array(6);\n    const bufferGeometry = new (0, $ilwiq.BufferGeometry)();\n    let prevMaterial = null;\n    let index0 = 0;\n    let numGroupVerts = 0;\n    let offset = 0;\n    for(let iElem = 0, nElem = elements.length; iElem < nElem; iElem++){\n        const elem = elements[iElem];\n        let vertices = elem.vertices;\n        if (vertices.length === 4) {\n            quadArray[0] = vertices[0];\n            quadArray[1] = vertices[1];\n            quadArray[2] = vertices[2];\n            quadArray[3] = vertices[0];\n            quadArray[4] = vertices[2];\n            quadArray[5] = vertices[3];\n            vertices = quadArray;\n        }\n        for(let j = 0, l = vertices.length; j < l; j++){\n            const v = vertices[j];\n            const index = offset + j * 3;\n            positions[index + 0] = v.x;\n            positions[index + 1] = v.y;\n            positions[index + 2] = v.z;\n        }\n        // create the normals array if this is a set of faces\n        if (elementSize === 3) {\n            if (!elem.faceNormal) {\n                const v0 = vertices[0];\n                const v1 = vertices[1];\n                const v2 = vertices[2];\n                $90a1bf3572dc4d5f$var$_tempVec0.subVectors(v1, v0);\n                $90a1bf3572dc4d5f$var$_tempVec1.subVectors(v2, v1);\n                elem.faceNormal = new (0, $ilwiq.Vector3)().crossVectors($90a1bf3572dc4d5f$var$_tempVec0, $90a1bf3572dc4d5f$var$_tempVec1).normalize();\n            }\n            let elemNormals = elem.normals;\n            if (elemNormals.length === 4) {\n                quadArray[0] = elemNormals[0];\n                quadArray[1] = elemNormals[1];\n                quadArray[2] = elemNormals[2];\n                quadArray[3] = elemNormals[0];\n                quadArray[4] = elemNormals[2];\n                quadArray[5] = elemNormals[3];\n                elemNormals = quadArray;\n            }\n            for(let j = 0, l = elemNormals.length; j < l; j++){\n                // use face normal if a vertex normal is not provided\n                let n = elem.faceNormal;\n                if (elemNormals[j]) n = elemNormals[j].norm;\n                const index = offset + j * 3;\n                normals[index + 0] = n.x;\n                normals[index + 1] = n.y;\n                normals[index + 2] = n.z;\n            }\n        }\n        if (prevMaterial !== elem.colorCode) {\n            if (prevMaterial !== null) bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n            const material = elem.material;\n            if (material !== null) {\n                if (elementSize === 3) materials.push(material);\n                else if (elementSize === 2) {\n                    if (isConditionalSegments) {\n                        const edgeMaterial = loader.edgeMaterialCache.get(material);\n                        materials.push(loader.conditionalEdgeMaterialCache.get(edgeMaterial));\n                    } else materials.push(loader.edgeMaterialCache.get(material));\n                }\n            } else // If a material has not been made available yet then keep the color code string in the material array\n            // to save the spot for the material once a parent scopes materials are being applied to the object.\n            materials.push(elem.colorCode);\n            prevMaterial = elem.colorCode;\n            index0 = offset / 3;\n            numGroupVerts = vertices.length;\n        } else numGroupVerts += vertices.length;\n        offset += 3 * vertices.length;\n    }\n    if (numGroupVerts > 0) bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n    bufferGeometry.setAttribute(\"position\", new (0, $ilwiq.BufferAttribute)(positions, 3));\n    if (normals !== null) bufferGeometry.setAttribute(\"normal\", new (0, $ilwiq.BufferAttribute)(normals, 3));\n    let object3d = null;\n    if (elementSize === 2) {\n        if (isConditionalSegments) object3d = new $90a1bf3572dc4d5f$var$ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n        else object3d = new (0, $ilwiq.LineSegments)(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    } else if (elementSize === 3) object3d = new (0, $ilwiq.Mesh)(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    if (isConditionalSegments) {\n        object3d.isConditionalLine = true;\n        const controlArray0 = new Float32Array(elements.length * 6);\n        const controlArray1 = new Float32Array(elements.length * 6);\n        const directionArray = new Float32Array(elements.length * 6);\n        for(let i = 0, l = elements.length; i < l; i++){\n            const os = elements[i];\n            const vertices = os.vertices;\n            const controlPoints = os.controlPoints;\n            const c0 = controlPoints[0];\n            const c1 = controlPoints[1];\n            const v0 = vertices[0];\n            const v1 = vertices[1];\n            const index = i * 6;\n            controlArray0[index + 0] = c0.x;\n            controlArray0[index + 1] = c0.y;\n            controlArray0[index + 2] = c0.z;\n            controlArray0[index + 3] = c0.x;\n            controlArray0[index + 4] = c0.y;\n            controlArray0[index + 5] = c0.z;\n            controlArray1[index + 0] = c1.x;\n            controlArray1[index + 1] = c1.y;\n            controlArray1[index + 2] = c1.z;\n            controlArray1[index + 3] = c1.x;\n            controlArray1[index + 4] = c1.y;\n            controlArray1[index + 5] = c1.z;\n            directionArray[index + 0] = v1.x - v0.x;\n            directionArray[index + 1] = v1.y - v0.y;\n            directionArray[index + 2] = v1.z - v0.z;\n            directionArray[index + 3] = v1.x - v0.x;\n            directionArray[index + 4] = v1.y - v0.y;\n            directionArray[index + 5] = v1.z - v0.z;\n        }\n        bufferGeometry.setAttribute(\"control0\", new (0, $ilwiq.BufferAttribute)(controlArray0, 3, false));\n        bufferGeometry.setAttribute(\"control1\", new (0, $ilwiq.BufferAttribute)(controlArray1, 3, false));\n        bufferGeometry.setAttribute(\"direction\", new (0, $ilwiq.BufferAttribute)(directionArray, 3, false));\n    }\n    return object3d;\n}\n//\nclass $90a1bf3572dc4d5f$export$12d9a9ad6192c950 extends (0, $ilwiq.Loader) {\n    constructor(manager){\n        super(manager);\n        // Array of THREE.Material\n        this.materials = [];\n        this.materialLibrary = {};\n        this.edgeMaterialCache = new WeakMap();\n        this.conditionalEdgeMaterialCache = new WeakMap();\n        // This also allows to handle the embedded text files (\"0 FILE\" lines)\n        this.partsCache = new $90a1bf3572dc4d5f$var$LDrawPartsGeometryCache(this);\n        // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n        this.fileMap = {};\n        // Initializes the materials library with default materials\n        this.setMaterials([]);\n        // If this flag is set to true the vertex normals will be smoothed.\n        this.smoothNormals = true;\n        // The path to load parts from the LDraw parts library from.\n        this.partsLibraryPath = \"\";\n        // Material assigned to not available colors for meshes and edges\n        this.missingColorMaterial = new (0, $ilwiq.MeshStandardMaterial)({\n            name: (0, $ilwiq.Loader).DEFAULT_MATERIAL_NAME,\n            color: 0xFF00FF,\n            roughness: 0.3,\n            metalness: 0\n        });\n        this.missingEdgeColorMaterial = new (0, $ilwiq.LineBasicMaterial)({\n            name: (0, $ilwiq.Loader).DEFAULT_MATERIAL_NAME,\n            color: 0xFF00FF\n        });\n        this.missingConditionalEdgeColorMaterial = new $90a1bf3572dc4d5f$var$LDrawConditionalLineMaterial({\n            name: (0, $ilwiq.Loader).DEFAULT_MATERIAL_NAME,\n            fog: true,\n            color: 0xFF00FF\n        });\n        this.edgeMaterialCache.set(this.missingColorMaterial, this.missingEdgeColorMaterial);\n        this.conditionalEdgeMaterialCache.set(this.missingEdgeColorMaterial, this.missingConditionalEdgeColorMaterial);\n    }\n    setPartsLibraryPath(path) {\n        this.partsLibraryPath = path;\n        return this;\n    }\n    async preloadMaterials(url) {\n        const fileLoader = new (0, $ilwiq.FileLoader)(this.manager);\n        fileLoader.setPath(this.path);\n        fileLoader.setRequestHeader(this.requestHeader);\n        fileLoader.setWithCredentials(this.withCredentials);\n        const text = await fileLoader.loadAsync(url);\n        const colorLineRegex = /^0 !COLOUR/;\n        const lines = text.split(/[\\n\\r]/g);\n        const materials = [];\n        for(let i = 0, l = lines.length; i < l; i++){\n            const line = lines[i];\n            if (colorLineRegex.test(line)) {\n                const directive = line.replace(colorLineRegex, \"\");\n                const material = this.parseColorMetaDirective(new $90a1bf3572dc4d5f$var$LineParser(directive));\n                materials.push(material);\n            }\n        }\n        this.setMaterials(materials);\n    }\n    load(url, onLoad, onProgress, onError) {\n        const fileLoader = new (0, $ilwiq.FileLoader)(this.manager);\n        fileLoader.setPath(this.path);\n        fileLoader.setRequestHeader(this.requestHeader);\n        fileLoader.setWithCredentials(this.withCredentials);\n        fileLoader.load(url, (text)=>{\n            this.partsCache.parseModel(text, this.materialLibrary).then((group)=>{\n                this.applyMaterialsToMesh(group, $90a1bf3572dc4d5f$var$MAIN_COLOUR_CODE, this.materialLibrary, true);\n                this.computeBuildingSteps(group);\n                group.userData.fileName = url;\n                onLoad(group);\n            }).catch(onError);\n        }, onProgress, onError);\n    }\n    parse(text, onLoad) {\n        this.partsCache.parseModel(text, this.materialLibrary).then((group)=>{\n            this.applyMaterialsToMesh(group, $90a1bf3572dc4d5f$var$MAIN_COLOUR_CODE, this.materialLibrary, true);\n            this.computeBuildingSteps(group);\n            group.userData.fileName = \"\";\n            onLoad(group);\n        });\n    }\n    setMaterials(materials) {\n        this.materialLibrary = {};\n        this.materials = [];\n        for(let i = 0, l = materials.length; i < l; i++)this.addMaterial(materials[i]);\n        // Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\n        this.addMaterial(this.parseColorMetaDirective(new $90a1bf3572dc4d5f$var$LineParser(\"Main_Colour CODE 16 VALUE #FF8080 EDGE #333333\")));\n        this.addMaterial(this.parseColorMetaDirective(new $90a1bf3572dc4d5f$var$LineParser(\"Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333\")));\n        return this;\n    }\n    setFileMap(fileMap) {\n        this.fileMap = fileMap;\n        return this;\n    }\n    addMaterial(material) {\n        // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n        const matLib = this.materialLibrary;\n        if (!matLib[material.userData.code]) {\n            this.materials.push(material);\n            matLib[material.userData.code] = material;\n        }\n        return this;\n    }\n    getMaterial(colorCode) {\n        if (colorCode.startsWith(\"0x2\")) {\n            // Special 'direct' material value (RGB color)\n            const color = colorCode.substring(3);\n            return this.parseColorMetaDirective(new $90a1bf3572dc4d5f$var$LineParser(\"Direct_Color_\" + color + \" CODE -1 VALUE #\" + color + \" EDGE #\" + color + \"\"));\n        }\n        return this.materialLibrary[colorCode] || null;\n    }\n    // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n    // in the material array if they need to be filled in.\n    applyMaterialsToMesh(group, parentColorCode, materialHierarchy, finalMaterialPass = false) {\n        // find any missing materials as indicated by a color code string and replace it with a material from the current material lib\n        const loader = this;\n        const parentIsPassthrough = parentColorCode === $90a1bf3572dc4d5f$var$MAIN_COLOUR_CODE;\n        group.traverse((c)=>{\n            if (c.isMesh || c.isLineSegments) {\n                if (Array.isArray(c.material)) {\n                    for(let i = 0, l = c.material.length; i < l; i++)if (!c.material[i].isMaterial) c.material[i] = getMaterial(c, c.material[i]);\n                } else if (!c.material.isMaterial) c.material = getMaterial(c, c.material);\n            }\n        });\n        // Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\n        // (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\n        // simply returned for the subsequent material application.\n        function getMaterial(c, colorCode) {\n            // if our parent is a passthrough color code and we don't have the current material color available then\n            // return early.\n            if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) return colorCode;\n            const forEdge = c.isLineSegments || c.isConditionalLine;\n            const isPassthrough = !forEdge && colorCode === $90a1bf3572dc4d5f$var$MAIN_COLOUR_CODE || forEdge && colorCode === $90a1bf3572dc4d5f$var$MAIN_EDGE_COLOUR_CODE;\n            if (isPassthrough) colorCode = parentColorCode;\n            let material = null;\n            if (colorCode in materialHierarchy) material = materialHierarchy[colorCode];\n            else if (finalMaterialPass) {\n                // see if we can get the final material from from the \"getMaterial\" function which will attempt to\n                // parse the \"direct\" colors\n                material = loader.getMaterial(colorCode);\n                if (material === null) {\n                    // otherwise throw a warning if this is final opportunity to set the material\n                    console.warn(`LDrawLoader: Material properties for code ${colorCode} not available.`);\n                    // And return the 'missing color' material\n                    material = loader.missingColorMaterial;\n                }\n            } else return colorCode;\n            if (c.isLineSegments) {\n                material = loader.edgeMaterialCache.get(material);\n                if (c.isConditionalLine) material = loader.conditionalEdgeMaterialCache.get(material);\n            }\n            return material;\n        }\n    }\n    getMainMaterial() {\n        return this.getMaterial($90a1bf3572dc4d5f$var$MAIN_COLOUR_CODE);\n    }\n    getMainEdgeMaterial() {\n        const mat = this.getMaterial($90a1bf3572dc4d5f$var$MAIN_EDGE_COLOUR_CODE);\n        return mat ? this.edgeMaterialCache.get(mat) : null;\n    }\n    parseColorMetaDirective(lineParser) {\n        // Parses a color definition and returns a THREE.Material\n        let code = null;\n        // Triangle and line colors\n        let fillColor = \"#FF00FF\";\n        let edgeColor = \"#FF00FF\";\n        // Transparency\n        let alpha = 1;\n        let isTransparent = false;\n        // Self-illumination:\n        let luminance = 0;\n        let finishType = $90a1bf3572dc4d5f$var$FINISH_TYPE_DEFAULT;\n        let edgeMaterial = null;\n        const name = lineParser.getToken();\n        if (!name) throw new Error('LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + \".\");\n        // Parse tag tokens and their parameters\n        let token = null;\n        while(true){\n            token = lineParser.getToken();\n            if (!token) break;\n            if (!parseLuminance(token)) switch(token.toUpperCase()){\n                case \"CODE\":\n                    code = lineParser.getToken();\n                    break;\n                case \"VALUE\":\n                    fillColor = lineParser.getToken();\n                    if (fillColor.startsWith(\"0x\")) fillColor = \"#\" + fillColor.substring(2);\n                    else if (!fillColor.startsWith(\"#\")) throw new Error(\"LDrawLoader: Invalid color while parsing material\" + lineParser.getLineNumberString() + \".\");\n                    break;\n                case \"EDGE\":\n                    edgeColor = lineParser.getToken();\n                    if (edgeColor.startsWith(\"0x\")) edgeColor = \"#\" + edgeColor.substring(2);\n                    else if (!edgeColor.startsWith(\"#\")) {\n                        // Try to see if edge color is a color code\n                        edgeMaterial = this.getMaterial(edgeColor);\n                        if (!edgeMaterial) throw new Error(\"LDrawLoader: Invalid edge color while parsing material\" + lineParser.getLineNumberString() + \".\");\n                        // Get the edge material for this triangle material\n                        edgeMaterial = this.edgeMaterialCache.get(edgeMaterial);\n                    }\n                    break;\n                case \"ALPHA\":\n                    alpha = parseInt(lineParser.getToken());\n                    if (isNaN(alpha)) throw new Error(\"LDrawLoader: Invalid alpha value in material definition\" + lineParser.getLineNumberString() + \".\");\n                    alpha = Math.max(0, Math.min(1, alpha / 255));\n                    if (alpha < 1) isTransparent = true;\n                    break;\n                case \"LUMINANCE\":\n                    if (!parseLuminance(lineParser.getToken())) throw new Error(\"LDrawLoader: Invalid luminance value in material definition\" + $90a1bf3572dc4d5f$var$LineParser.getLineNumberString() + \".\");\n                    break;\n                case \"CHROME\":\n                    finishType = $90a1bf3572dc4d5f$var$FINISH_TYPE_CHROME;\n                    break;\n                case \"PEARLESCENT\":\n                    finishType = $90a1bf3572dc4d5f$var$FINISH_TYPE_PEARLESCENT;\n                    break;\n                case \"RUBBER\":\n                    finishType = $90a1bf3572dc4d5f$var$FINISH_TYPE_RUBBER;\n                    break;\n                case \"MATTE_METALLIC\":\n                    finishType = $90a1bf3572dc4d5f$var$FINISH_TYPE_MATTE_METALLIC;\n                    break;\n                case \"METAL\":\n                    finishType = $90a1bf3572dc4d5f$var$FINISH_TYPE_METAL;\n                    break;\n                case \"MATERIAL\":\n                    // Not implemented\n                    lineParser.setToEnd();\n                    break;\n                default:\n                    throw new Error('LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + \".\");\n            }\n        }\n        let material = null;\n        switch(finishType){\n            case $90a1bf3572dc4d5f$var$FINISH_TYPE_DEFAULT:\n                material = new (0, $ilwiq.MeshStandardMaterial)({\n                    roughness: 0.3,\n                    metalness: 0\n                });\n                break;\n            case $90a1bf3572dc4d5f$var$FINISH_TYPE_PEARLESCENT:\n                // Try to imitate pearlescency by making the surface glossy\n                material = new (0, $ilwiq.MeshStandardMaterial)({\n                    roughness: 0.3,\n                    metalness: 0.25\n                });\n                break;\n            case $90a1bf3572dc4d5f$var$FINISH_TYPE_CHROME:\n                // Mirror finish surface\n                material = new (0, $ilwiq.MeshStandardMaterial)({\n                    roughness: 0,\n                    metalness: 1\n                });\n                break;\n            case $90a1bf3572dc4d5f$var$FINISH_TYPE_RUBBER:\n                // Rubber finish\n                material = new (0, $ilwiq.MeshStandardMaterial)({\n                    roughness: 0.9,\n                    metalness: 0\n                });\n                break;\n            case $90a1bf3572dc4d5f$var$FINISH_TYPE_MATTE_METALLIC:\n                // Brushed metal finish\n                material = new (0, $ilwiq.MeshStandardMaterial)({\n                    roughness: 0.8,\n                    metalness: 0.4\n                });\n                break;\n            case $90a1bf3572dc4d5f$var$FINISH_TYPE_METAL:\n                // Average metal finish\n                material = new (0, $ilwiq.MeshStandardMaterial)({\n                    roughness: 0.2,\n                    metalness: 0.85\n                });\n                break;\n            default:\n                break;\n        }\n        material.color.setStyle(fillColor, $90a1bf3572dc4d5f$var$COLOR_SPACE_LDRAW);\n        material.transparent = isTransparent;\n        material.premultipliedAlpha = true;\n        material.opacity = alpha;\n        material.depthWrite = !isTransparent;\n        material.polygonOffset = true;\n        material.polygonOffsetFactor = 1;\n        if (luminance !== 0) material.emissive.setStyle(fillColor, $90a1bf3572dc4d5f$var$COLOR_SPACE_LDRAW).multiplyScalar(luminance);\n        if (!edgeMaterial) {\n            // This is the material used for edges\n            edgeMaterial = new (0, $ilwiq.LineBasicMaterial)({\n                color: new (0, $ilwiq.Color)().setStyle(edgeColor, $90a1bf3572dc4d5f$var$COLOR_SPACE_LDRAW),\n                transparent: isTransparent,\n                opacity: alpha,\n                depthWrite: !isTransparent\n            });\n            edgeMaterial.color;\n            edgeMaterial.userData.code = code;\n            edgeMaterial.name = name + \" - Edge\";\n            // This is the material used for conditional edges\n            const conditionalEdgeMaterial = new $90a1bf3572dc4d5f$var$LDrawConditionalLineMaterial({\n                fog: true,\n                transparent: isTransparent,\n                depthWrite: !isTransparent,\n                color: new (0, $ilwiq.Color)().setStyle(edgeColor, $90a1bf3572dc4d5f$var$COLOR_SPACE_LDRAW),\n                opacity: alpha\n            });\n            conditionalEdgeMaterial.userData.code = code;\n            conditionalEdgeMaterial.name = name + \" - Conditional Edge\";\n            this.conditionalEdgeMaterialCache.set(edgeMaterial, conditionalEdgeMaterial);\n        }\n        material.userData.code = code;\n        material.name = name;\n        this.edgeMaterialCache.set(material, edgeMaterial);\n        this.addMaterial(material);\n        return material;\n        function parseLuminance(token) {\n            // Returns success\n            let lum;\n            if (token.startsWith(\"LUMINANCE\")) lum = parseInt(token.substring(9));\n            else lum = parseInt(token);\n            if (isNaN(lum)) return false;\n            luminance = Math.max(0, Math.min(1, lum / 255));\n            return true;\n        }\n    }\n    computeBuildingSteps(model) {\n        // Sets userdata.buildingStep number in Group objects and userData.numBuildingSteps number in the root Group object.\n        let stepNumber = 0;\n        model.traverse((c)=>{\n            if (c.isGroup) {\n                if (c.userData.startingBuildingStep) stepNumber++;\n                c.userData.buildingStep = stepNumber;\n            }\n        });\n        model.userData.numBuildingSteps = stepNumber + 1;\n    }\n}\n\n});\n\nparcelRegister(\"9hfHi\", function(module, exports) {\n\n$parcel$export(module.exports, \"LDrawUtils\", () => $6c11e0c31e042374$export$7732348bb2ed1dd9);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $7ePFa = parcelRequire(\"7ePFa\");\nclass $6c11e0c31e042374$export$7732348bb2ed1dd9 {\n    static mergeObject(object) {\n        // Merges geometries in object by materials and returns new object. Use on not indexed geometries.\n        // The object buffers reference the old object ones.\n        // Special treatment is done to the conditional lines generated by LDrawLoader.\n        function extractGroup(geometry, group, elementSize, isConditionalLine) {\n            // Extracts a group from a geometry as a new geometry (with attribute buffers referencing original buffers)\n            const newGeometry = new (0, $ilwiq.BufferGeometry)();\n            const originalPositions = geometry.getAttribute(\"position\").array;\n            const originalNormals = elementSize === 3 ? geometry.getAttribute(\"normal\").array : null;\n            const numVertsGroup = Math.min(group.count, Math.floor(originalPositions.length / 3) - group.start);\n            const vertStart = group.start * 3;\n            const vertEnd = (group.start + numVertsGroup) * 3;\n            const positions = originalPositions.subarray(vertStart, vertEnd);\n            const normals = originalNormals !== null ? originalNormals.subarray(vertStart, vertEnd) : null;\n            newGeometry.setAttribute(\"position\", new (0, $ilwiq.BufferAttribute)(positions, 3));\n            if (normals !== null) newGeometry.setAttribute(\"normal\", new (0, $ilwiq.BufferAttribute)(normals, 3));\n            if (isConditionalLine) {\n                const controlArray0 = geometry.getAttribute(\"control0\").array.subarray(vertStart, vertEnd);\n                const controlArray1 = geometry.getAttribute(\"control1\").array.subarray(vertStart, vertEnd);\n                const directionArray = geometry.getAttribute(\"direction\").array.subarray(vertStart, vertEnd);\n                newGeometry.setAttribute(\"control0\", new (0, $ilwiq.BufferAttribute)(controlArray0, 3, false));\n                newGeometry.setAttribute(\"control1\", new (0, $ilwiq.BufferAttribute)(controlArray1, 3, false));\n                newGeometry.setAttribute(\"direction\", new (0, $ilwiq.BufferAttribute)(directionArray, 3, false));\n            }\n            return newGeometry;\n        }\n        function addGeometry(mat, geometry, geometries) {\n            const geoms = geometries[mat.uuid];\n            if (!geoms) geometries[mat.uuid] = {\n                mat: mat,\n                arr: [\n                    geometry\n                ]\n            };\n            else geoms.arr.push(geometry);\n        }\n        function permuteAttribute(attribute, elemSize) {\n            // Permutes first two vertices of each attribute element\n            if (!attribute) return;\n            const verts = attribute.array;\n            const numVerts = Math.floor(verts.length / 3);\n            let offset = 0;\n            for(let i = 0; i < numVerts; i++){\n                const x = verts[offset];\n                const y = verts[offset + 1];\n                const z = verts[offset + 2];\n                verts[offset] = verts[offset + 3];\n                verts[offset + 1] = verts[offset + 4];\n                verts[offset + 2] = verts[offset + 5];\n                verts[offset + 3] = x;\n                verts[offset + 4] = y;\n                verts[offset + 5] = z;\n                offset += elemSize * 3;\n            }\n        }\n        // Traverse the object hierarchy collecting geometries and transforming them to world space\n        const meshGeometries = {};\n        const linesGeometries = {};\n        const condLinesGeometries = {};\n        object.updateMatrixWorld(true);\n        const normalMatrix = new (0, $ilwiq.Matrix3)();\n        object.traverse((c)=>{\n            if (c.isMesh | c.isLineSegments) {\n                const elemSize = c.isMesh ? 3 : 2;\n                const geometry = c.geometry.clone();\n                const matrixIsInverted = c.matrixWorld.determinant() < 0;\n                if (matrixIsInverted) {\n                    permuteAttribute(geometry.attributes.position, elemSize);\n                    permuteAttribute(geometry.attributes.normal, elemSize);\n                }\n                geometry.applyMatrix4(c.matrixWorld);\n                if (c.isConditionalLine) {\n                    geometry.attributes.control0.applyMatrix4(c.matrixWorld);\n                    geometry.attributes.control1.applyMatrix4(c.matrixWorld);\n                    normalMatrix.getNormalMatrix(c.matrixWorld);\n                    geometry.attributes.direction.applyNormalMatrix(normalMatrix);\n                }\n                const geometries = c.isMesh ? meshGeometries : c.isConditionalLine ? condLinesGeometries : linesGeometries;\n                if (Array.isArray(c.material)) for(const groupIndex in geometry.groups){\n                    const group = geometry.groups[groupIndex];\n                    const mat = c.material[group.materialIndex];\n                    const newGeometry = extractGroup(geometry, group, elemSize, c.isConditionalLine);\n                    addGeometry(mat, newGeometry, geometries);\n                }\n                else addGeometry(c.material, geometry, geometries);\n            }\n        });\n        // Create object with merged geometries\n        const mergedObject = new (0, $ilwiq.Group)();\n        const meshMaterialsIds = Object.keys(meshGeometries);\n        for (const meshMaterialsId of meshMaterialsIds){\n            const meshGeometry = meshGeometries[meshMaterialsId];\n            const mergedGeometry = (0, $7ePFa.mergeGeometries)(meshGeometry.arr);\n            mergedObject.add(new (0, $ilwiq.Mesh)(mergedGeometry, meshGeometry.mat));\n        }\n        const linesMaterialsIds = Object.keys(linesGeometries);\n        for (const linesMaterialsId of linesMaterialsIds){\n            const lineGeometry = linesGeometries[linesMaterialsId];\n            const mergedGeometry = (0, $7ePFa.mergeGeometries)(lineGeometry.arr);\n            mergedObject.add(new (0, $ilwiq.LineSegments)(mergedGeometry, lineGeometry.mat));\n        }\n        const condLinesMaterialsIds = Object.keys(condLinesGeometries);\n        for (const condLinesMaterialsId of condLinesMaterialsIds){\n            const condLineGeometry = condLinesGeometries[condLinesMaterialsId];\n            const mergedGeometry = (0, $7ePFa.mergeGeometries)(condLineGeometry.arr);\n            const condLines = new (0, $ilwiq.LineSegments)(mergedGeometry, condLineGeometry.mat);\n            condLines.isConditionalLine = true;\n            mergedObject.add(condLines);\n        }\n        mergedObject.userData.constructionStep = 0;\n        mergedObject.userData.numConstructionSteps = 1;\n        return mergedObject;\n    }\n}\n\n});\n\n\n//# sourceMappingURL=index.5fc992bc.js.map\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tGroup,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader,\n\tMatrix4,\n\tMesh,\n\tMeshStandardMaterial,\n\tShaderMaterial,\n\tSRGBColorSpace,\n\tUniformsLib,\n\tUniformsUtils,\n\tVector3,\n\tRay\n} from 'three';\n\n// Special surface finish tag types.\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5;\n\n// State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\nconst FILE_LOCATION_TRY_PARTS = 0;\nconst FILE_LOCATION_TRY_P = 1;\nconst FILE_LOCATION_TRY_MODELS = 2;\nconst FILE_LOCATION_AS_IS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\n\nconst MAIN_COLOUR_CODE = '16';\nconst MAIN_EDGE_COLOUR_CODE = '24';\n\nconst COLOR_SPACE_LDRAW = SRGBColorSpace;\n\nconst _tempVec0 = new Vector3();\nconst _tempVec1 = new Vector3();\n\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib.fog,\n\t\t\t\t{\n\t\t\t\t\tdiffuse: {\n\t\t\t\t\t\tvalue: new Color()\n\t\t\t\t\t},\n\t\t\t\t\topacity: {\n\t\t\t\t\t\tvalue: 1.0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t] ),\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tattribute vec3 control0;\n\t\t\t\tattribute vec3 control1;\n\t\t\t\tattribute vec3 direction;\n\t\t\t\tvarying float discardFlag;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <color_pars_vertex>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <color_vertex>\n\n\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\t// Transform the line segment ends and control points into camera clip space\n\t\t\t\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\t\t\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\t\t\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\t\t\t\tc0.xy /= c0.w;\n\t\t\t\t\tc1.xy /= c1.w;\n\t\t\t\t\tp0.xy /= p0.w;\n\t\t\t\t\tp1.xy /= p1.w;\n\n\t\t\t\t\t// Get the direction of the segment and an orthogonal vector\n\t\t\t\t\tvec2 dir = p1.xy - p0.xy;\n\t\t\t\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t\t\t\t// Get control point directions from the line\n\t\t\t\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\t\t\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t\t\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t\t\t\t// from the line segment then the line should not be drawn.\n\t\t\t\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\t\t\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\t\t\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\tuniform vec3 diffuse;\n\t\t\tuniform float opacity;\n\t\t\tvarying float discardFlag;\n\n\t\t\t#include <common>\n\t\t\t#include <color_pars_fragment>\n\t\t\t#include <fog_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t#include <clipping_planes_pars_fragment>\n\t\t\tvoid main() {\n\n\t\t\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t\t\t#include <clipping_planes_fragment>\n\t\t\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t#include <color_fragment>\n\t\t\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <colorspace_fragment>\n\t\t\t\t#include <fog_fragment>\n\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t}\n\t\t\t`,\n\n\t\t} );\n\n\t\tObject.defineProperties( this, {\n\n\t\t\topacity: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.opacity.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.opacity.value = value;\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcolor: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.diffuse.value;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\t\tthis.isLDrawConditionalLineMaterial = true;\n\n\t}\n\n}\n\nclass ConditionalLineSegments extends LineSegments {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\t\tthis.isConditionalLine = true;\n\n\t}\n\n}\n\nfunction generateFaceNormals( faces ) {\n\n\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tconst face = faces[ i ];\n\t\tconst vertices = face.vertices;\n\t\tconst v0 = vertices[ 0 ];\n\t\tconst v1 = vertices[ 1 ];\n\t\tconst v2 = vertices[ 2 ];\n\n\t\t_tempVec0.subVectors( v1, v0 );\n\t\t_tempVec1.subVectors( v2, v1 );\n\t\tface.faceNormal = new Vector3()\n\t\t\t.crossVectors( _tempVec0, _tempVec1 )\n\t\t\t.normalize();\n\n\t}\n\n}\n\nconst _ray = new Ray();\nfunction smoothNormals( faces, lineSegments, checkSubSegments = false ) {\n\n\t// NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\n\t// it allows edges to be smoothed as expected (see minifig arms).\n\t// --\n\t// And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\n\t// point errors on vertices along quantization boundaries. Ie after matrix multiplication\n\t// vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\n\t// get merged. This added epsilon attempts to push these error values to the same quantized\n\t// value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\n\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\n\t\treturn `${ x },${ y },${ z }`;\n\n\t}\n\n\tfunction hashEdge( v0, v1 ) {\n\n\t\treturn `${ hashVertex( v0 ) }_${ hashVertex( v1 ) }`;\n\n\t}\n\n\t// converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\n\t// onto the original line.\n\tfunction toNormalizedRay( v0, v1, targetRay ) {\n\n\t\ttargetRay.direction.subVectors( v1, v0 ).normalize();\n\n\t\tconst scalar = v0.dot( targetRay.direction );\n\t\ttargetRay.origin.copy( v0 ).addScaledVector( targetRay.direction, - scalar );\n\n\t\treturn targetRay;\n\n\t}\n\n\tfunction hashRay( ray ) {\n\n\t\treturn hashEdge( ray.origin, ray.direction );\n\n\t}\n\n\tconst hardEdges = new Set();\n\tconst hardEdgeRays = new Map();\n\tconst halfEdgeList = {};\n\tconst normals = [];\n\n\t// Save the list of hard edges by hash\n\tfor ( let i = 0, l = lineSegments.length; i < l; i ++ ) {\n\n\t\tconst ls = lineSegments[ i ];\n\t\tconst vertices = ls.vertices;\n\t\tconst v0 = vertices[ 0 ];\n\t\tconst v1 = vertices[ 1 ];\n\t\thardEdges.add( hashEdge( v0, v1 ) );\n\t\thardEdges.add( hashEdge( v1, v0 ) );\n\n\t\t// only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\n\t\t// and requires more memory.\n\t\tif ( checkSubSegments ) {\n\n\t\t\t// add both ray directions to the map\n\t\t\tconst ray = toNormalizedRay( v0, v1, new Ray() );\n\t\t\tconst rh1 = hashRay( ray );\n\t\t\tif ( ! hardEdgeRays.has( rh1 ) ) {\n\n\t\t\t\ttoNormalizedRay( v1, v0, ray );\n\t\t\t\tconst rh2 = hashRay( ray );\n\n\t\t\t\tconst info = {\n\t\t\t\t\tray,\n\t\t\t\t\tdistances: [],\n\t\t\t\t};\n\n\t\t\t\thardEdgeRays.set( rh1, info );\n\t\t\t\thardEdgeRays.set( rh2, info );\n\n\t\t\t}\n\n\t\t\t// store both segments ends in min, max order in the distances array to check if a face edge is a\n\t\t\t// subsegment later.\n\t\t\tconst info = hardEdgeRays.get( rh1 );\n\t\t\tlet d0 = info.ray.direction.dot( v0 );\n\t\t\tlet d1 = info.ray.direction.dot( v1 );\n\t\t\tif ( d0 > d1 ) {\n\n\t\t\t\t[ d0, d1 ] = [ d1, d0 ];\n\n\t\t\t}\n\n\t\t\tinfo.distances.push( d0, d1 );\n\n\t\t}\n\n\t}\n\n\t// track the half edges associated with each triangle\n\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tconst tri = faces[ i ];\n\t\tconst vertices = tri.vertices;\n\t\tconst vertCount = vertices.length;\n\t\tfor ( let i2 = 0; i2 < vertCount; i2 ++ ) {\n\n\t\t\tconst index = i2;\n\t\t\tconst next = ( i2 + 1 ) % vertCount;\n\t\t\tconst v0 = vertices[ index ];\n\t\t\tconst v1 = vertices[ next ];\n\t\t\tconst hash = hashEdge( v0, v1 );\n\n\t\t\t// don't add the triangle if the edge is supposed to be hard\n\t\t\tif ( hardEdges.has( hash ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\n\t\t\tif ( checkSubSegments ) {\n\n\t\t\t\ttoNormalizedRay( v0, v1, _ray );\n\n\t\t\t\tconst rayHash = hashRay( _ray );\n\t\t\t\tif ( hardEdgeRays.has( rayHash ) ) {\n\n\t\t\t\t\tconst info = hardEdgeRays.get( rayHash );\n\t\t\t\t\tconst { ray, distances } = info;\n\t\t\t\t\tlet d0 = ray.direction.dot( v0 );\n\t\t\t\t\tlet d1 = ray.direction.dot( v1 );\n\n\t\t\t\t\tif ( d0 > d1 ) {\n\n\t\t\t\t\t\t[ d0, d1 ] = [ d1, d0 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\n\t\t\t\t\tlet found = false;\n\t\t\t\t\tfor ( let i = 0, l = distances.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\tif ( d0 >= distances[ i ] && d1 <= distances[ i + 1 ] ) {\n\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( found ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst info = {\n\t\t\t\tindex: index,\n\t\t\t\ttri: tri\n\t\t\t};\n\t\t\thalfEdgeList[ hash ] = info;\n\n\t\t}\n\n\t}\n\n\t// Iterate until we've tried to connect all faces to share normals\n\twhile ( true ) {\n\n\t\t// Stop if there are no more faces left\n\t\tlet halfEdge = null;\n\t\tfor ( const key in halfEdgeList ) {\n\n\t\t\thalfEdge = halfEdgeList[ key ];\n\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( halfEdge === null ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\t// Exhaustively find all connected faces\n\t\tconst queue = [ halfEdge ];\n\t\twhile ( queue.length > 0 ) {\n\n\t\t\t// initialize all vertex normals in this triangle\n\t\t\tconst tri = queue.pop().tri;\n\t\t\tconst vertices = tri.vertices;\n\t\t\tconst vertNormals = tri.normals;\n\t\t\tconst faceNormal = tri.faceNormal;\n\n\t\t\t// Check if any edge is connected to another triangle edge\n\t\t\tconst vertCount = vertices.length;\n\t\t\tfor ( let i2 = 0; i2 < vertCount; i2 ++ ) {\n\n\t\t\t\tconst index = i2;\n\t\t\t\tconst next = ( i2 + 1 ) % vertCount;\n\t\t\t\tconst v0 = vertices[ index ];\n\t\t\t\tconst v1 = vertices[ next ];\n\n\t\t\t\t// delete this triangle from the list so it won't be found again\n\t\t\t\tconst hash = hashEdge( v0, v1 );\n\t\t\t\tdelete halfEdgeList[ hash ];\n\n\t\t\t\tconst reverseHash = hashEdge( v1, v0 );\n\t\t\t\tconst otherInfo = halfEdgeList[ reverseHash ];\n\t\t\t\tif ( otherInfo ) {\n\n\t\t\t\t\tconst otherTri = otherInfo.tri;\n\t\t\t\t\tconst otherIndex = otherInfo.index;\n\t\t\t\t\tconst otherNormals = otherTri.normals;\n\t\t\t\t\tconst otherVertCount = otherNormals.length;\n\t\t\t\t\tconst otherFaceNormal = otherTri.faceNormal;\n\n\t\t\t\t\t// NOTE: If the angle between faces is > 67.5 degrees then assume it's\n\t\t\t\t\t// hard edge. There are some cases where the line segments do not line up exactly\n\t\t\t\t\t// with or span multiple triangle edges (see Lunar Vehicle wheels).\n\t\t\t\t\tif ( Math.abs( otherTri.faceNormal.dot( tri.faceNormal ) ) < 0.25 ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if this triangle has already been traversed then it won't be in\n\t\t\t\t\t// the halfEdgeList. If it has not then add it to the queue and delete\n\t\t\t\t\t// it so it won't be found again.\n\t\t\t\t\tif ( reverseHash in halfEdgeList ) {\n\n\t\t\t\t\t\tqueue.push( otherInfo );\n\t\t\t\t\t\tdelete halfEdgeList[ reverseHash ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// share the first normal\n\t\t\t\t\tconst otherNext = ( otherIndex + 1 ) % otherVertCount;\n\t\t\t\t\tif (\n\t\t\t\t\t\tvertNormals[ index ] && otherNormals[ otherNext ] &&\n\t\t\t\t\t\tvertNormals[ index ] !== otherNormals[ otherNext ]\n\t\t\t\t\t) {\n\n\t\t\t\t\t\totherNormals[ otherNext ].norm.add( vertNormals[ index ].norm );\n\t\t\t\t\t\tvertNormals[ index ].norm = otherNormals[ otherNext ].norm;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet sharedNormal1 = vertNormals[ index ] || otherNormals[ otherNext ];\n\t\t\t\t\tif ( sharedNormal1 === null ) {\n\n\t\t\t\t\t\t// it's possible to encounter an edge of a triangle that has already been traversed meaning\n\t\t\t\t\t\t// both edges already have different normals defined and shared. To work around this we create\n\t\t\t\t\t\t// a wrapper object so when those edges are merged the normals can be updated everywhere.\n\t\t\t\t\t\tsharedNormal1 = { norm: new Vector3() };\n\t\t\t\t\t\tnormals.push( sharedNormal1.norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( vertNormals[ index ] === null ) {\n\n\t\t\t\t\t\tvertNormals[ index ] = sharedNormal1;\n\t\t\t\t\t\tsharedNormal1.norm.add( faceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( otherNormals[ otherNext ] === null ) {\n\n\t\t\t\t\t\totherNormals[ otherNext ] = sharedNormal1;\n\t\t\t\t\t\tsharedNormal1.norm.add( otherFaceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// share the second normal\n\t\t\t\t\tif (\n\t\t\t\t\t\tvertNormals[ next ] && otherNormals[ otherIndex ] &&\n\t\t\t\t\t\tvertNormals[ next ] !== otherNormals[ otherIndex ]\n\t\t\t\t\t) {\n\n\t\t\t\t\t\totherNormals[ otherIndex ].norm.add( vertNormals[ next ].norm );\n\t\t\t\t\t\tvertNormals[ next ].norm = otherNormals[ otherIndex ].norm;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet sharedNormal2 = vertNormals[ next ] || otherNormals[ otherIndex ];\n\t\t\t\t\tif ( sharedNormal2 === null ) {\n\n\t\t\t\t\t\tsharedNormal2 = { norm: new Vector3() };\n\t\t\t\t\t\tnormals.push( sharedNormal2.norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( vertNormals[ next ] === null ) {\n\n\t\t\t\t\t\tvertNormals[ next ] = sharedNormal2;\n\t\t\t\t\t\tsharedNormal2.norm.add( faceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( otherNormals[ otherIndex ] === null ) {\n\n\t\t\t\t\t\totherNormals[ otherIndex ] = sharedNormal2;\n\t\t\t\t\t\tsharedNormal2.norm.add( otherFaceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// The normals of each face have been added up so now we average them by normalizing the vector.\n\tfor ( let i = 0, l = normals.length; i < l; i ++ ) {\n\n\t\tnormals[ i ].normalize();\n\n\t}\n\n}\n\nfunction isPartType( type ) {\n\n\treturn type === 'Part' || type === 'Unofficial_Part';\n\n}\n\nfunction isPrimitiveType( type ) {\n\n\treturn /primitive/i.test( type ) || type === 'Subpart';\n\n}\n\nclass LineParser {\n\n\tconstructor( line, lineNumber ) {\n\n\t\tthis.line = line;\n\t\tthis.lineLength = line.length;\n\t\tthis.currentCharIndex = 0;\n\t\tthis.currentChar = ' ';\n\t\tthis.lineNumber = lineNumber;\n\n\t}\n\n\tseekNonSpace() {\n\n\t\twhile ( this.currentCharIndex < this.lineLength ) {\n\n\t\t\tthis.currentChar = this.line.charAt( this.currentCharIndex );\n\n\t\t\tif ( this.currentChar !== ' ' && this.currentChar !== '\\t' ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.currentCharIndex ++;\n\n\t\t}\n\n\t}\n\n\tgetToken() {\n\n\t\tconst pos0 = this.currentCharIndex ++;\n\n\t\t// Seek space\n\t\twhile ( this.currentCharIndex < this.lineLength ) {\n\n\t\t\tthis.currentChar = this.line.charAt( this.currentCharIndex );\n\n\t\t\tif ( this.currentChar === ' ' || this.currentChar === '\\t' ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.currentCharIndex ++;\n\n\t\t}\n\n\t\tconst pos1 = this.currentCharIndex;\n\n\t\tthis.seekNonSpace();\n\n\t\treturn this.line.substring( pos0, pos1 );\n\n\t}\n\n\tgetVector() {\n\n\t\treturn new Vector3( parseFloat( this.getToken() ), parseFloat( this.getToken() ), parseFloat( this.getToken() ) );\n\n\t}\n\n\tgetRemainingString() {\n\n\t\treturn this.line.substring( this.currentCharIndex, this.lineLength );\n\n\t}\n\n\tisAtTheEnd() {\n\n\t\treturn this.currentCharIndex >= this.lineLength;\n\n\t}\n\n\tsetToEnd() {\n\n\t\tthis.currentCharIndex = this.lineLength;\n\n\t}\n\n\tgetLineNumberString() {\n\n\t\treturn this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n\n\t}\n\n}\n\n// Fetches and parses an intermediate representation of LDraw parts files.\nclass LDrawParsedCache {\n\n\tconstructor( loader ) {\n\n\t\tthis.loader = loader;\n\t\tthis._cache = {};\n\n\t}\n\n\tcloneResult( original ) {\n\n\t\tconst result = {};\n\n\t\t// vertices are transformed and normals computed before being converted to geometry\n\t\t// so these pieces must be cloned.\n\t\tresult.faces = original.faces.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() ),\n\t\t\t\tnormals: face.normals.map( () => null ),\n\t\t\t\tfaceNormal: null\n\t\t\t};\n\n\t\t} );\n\n\t\tresult.conditionalSegments = original.conditionalSegments.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() ),\n\t\t\t\tcontrolPoints: face.controlPoints.map( v => v.clone() )\n\t\t\t};\n\n\t\t} );\n\n\t\tresult.lineSegments = original.lineSegments.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() )\n\t\t\t};\n\n\t\t} );\n\n\t\t// none if this is subsequently modified\n\t\tresult.type = original.type;\n\t\tresult.category = original.category;\n\t\tresult.keywords = original.keywords;\n\t\tresult.author = original.author;\n\t\tresult.subobjects = original.subobjects;\n\t\tresult.fileName = original.fileName;\n\t\tresult.totalFaces = original.totalFaces;\n\t\tresult.startingBuildingStep = original.startingBuildingStep;\n\t\tresult.materials = original.materials;\n\t\tresult.group = null;\n\t\treturn result;\n\n\t}\n\n\tasync fetchData( fileName ) {\n\n\t\tlet triedLowerCase = false;\n\t\tlet locationState = FILE_LOCATION_TRY_PARTS;\n\t\twhile ( locationState !== FILE_LOCATION_NOT_FOUND ) {\n\n\t\t\tlet subobjectURL = fileName;\n\t\t\tswitch ( locationState ) {\n\n\t\t\t\tcase FILE_LOCATION_AS_IS:\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_PARTS:\n\t\t\t\t\tsubobjectURL = 'parts/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_P:\n\t\t\t\t\tsubobjectURL = 'p/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_MODELS:\n\t\t\t\t\tsubobjectURL = 'models/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_RELATIVE:\n\t\t\t\t\tsubobjectURL = fileName.substring( 0, fileName.lastIndexOf( '/' ) + 1 ) + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_ABSOLUTE:\n\n\t\t\t\t\tif ( triedLowerCase ) {\n\n\t\t\t\t\t\t// Try absolute path\n\t\t\t\t\t\tlocationState = FILE_LOCATION_NOT_FOUND;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Next attempt is lower case\n\t\t\t\t\t\tfileName = fileName.toLowerCase();\n\t\t\t\t\t\tsubobjectURL = fileName;\n\t\t\t\t\t\ttriedLowerCase = true;\n\t\t\t\t\t\tlocationState = FILE_LOCATION_TRY_PARTS;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tconst loader = this.loader;\n\t\t\tconst fileLoader = new FileLoader( loader.manager );\n\t\t\tfileLoader.setPath( loader.partsLibraryPath );\n\t\t\tfileLoader.setRequestHeader( loader.requestHeader );\n\t\t\tfileLoader.setWithCredentials( loader.withCredentials );\n\n\t\t\ttry {\n\n\t\t\t\tconst text = await fileLoader.loadAsync( subobjectURL );\n\t\t\t\treturn text;\n\n\t\t\t} catch ( _ ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthrow new Error( 'LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.' );\n\n\t}\n\n\tparse( text, fileName = null ) {\n\n\t\tconst loader = this.loader;\n\n\t\t// final results\n\t\tconst faces = [];\n\t\tconst lineSegments = [];\n\t\tconst conditionalSegments = [];\n\t\tconst subobjects = [];\n\t\tconst materials = {};\n\n\t\tconst getLocalMaterial = colorCode => {\n\n\t\t\treturn materials[ colorCode ] || null;\n\n\t\t};\n\n\t\tlet type = 'Model';\n\t\tlet category = null;\n\t\tlet keywords = null;\n\t\tlet author = null;\n\t\tlet totalFaces = 0;\n\n\t\t// split into lines\n\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\n\n\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\n\n\t\t}\n\n\t\tconst lines = text.split( '\\n' );\n\t\tconst numLines = lines.length;\n\n\t\tlet parsingEmbeddedFiles = false;\n\t\tlet currentEmbeddedFileName = null;\n\t\tlet currentEmbeddedText = null;\n\n\t\tlet bfcCertified = false;\n\t\tlet bfcCCW = true;\n\t\tlet bfcInverted = false;\n\t\tlet bfcCull = true;\n\n\t\tlet startingBuildingStep = false;\n\n\t\t// Parse all line commands\n\t\tfor ( let lineIndex = 0; lineIndex < numLines; lineIndex ++ ) {\n\n\t\t\tconst line = lines[ lineIndex ];\n\n\t\t\tif ( line.length === 0 ) continue;\n\n\t\t\tif ( parsingEmbeddedFiles ) {\n\n\t\t\t\tif ( line.startsWith( '0 FILE ' ) ) {\n\n\t\t\t\t\t// Save previous embedded file in the cache\n\t\t\t\t\tthis.setData( currentEmbeddedFileName, currentEmbeddedText );\n\n\t\t\t\t\t// New embedded text file\n\t\t\t\t\tcurrentEmbeddedFileName = line.substring( 7 );\n\t\t\t\t\tcurrentEmbeddedText = '';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentEmbeddedText += line + '\\n';\n\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst lp = new LineParser( line, lineIndex + 1 );\n\t\t\tlp.seekNonSpace();\n\n\t\t\tif ( lp.isAtTheEnd() ) {\n\n\t\t\t\t// Empty line\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// Parse the line type\n\t\t\tconst lineType = lp.getToken();\n\n\t\t\tlet material;\n\t\t\tlet colorCode;\n\t\t\tlet segment;\n\t\t\tlet ccw;\n\t\t\tlet doubleSided;\n\t\t\tlet v0, v1, v2, v3, c0, c1;\n\n\t\t\tswitch ( lineType ) {\n\n\t\t\t\t// Line type 0: Comment or META\n\t\t\t\tcase '0':\n\n\t\t\t\t\t// Parse meta directive\n\t\t\t\t\tconst meta = lp.getToken();\n\n\t\t\t\t\tif ( meta ) {\n\n\t\t\t\t\t\tswitch ( meta ) {\n\n\t\t\t\t\t\t\tcase '!LDRAW_ORG':\n\n\t\t\t\t\t\t\t\ttype = lp.getToken();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!COLOUR':\n\n\t\t\t\t\t\t\t\tmaterial = loader.parseColorMetaDirective( lp );\n\t\t\t\t\t\t\t\tif ( material ) {\n\n\t\t\t\t\t\t\t\t\tmaterials[ material.userData.code ] = material;\n\n\t\t\t\t\t\t\t\t}\telse {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( 'LDrawLoader: Error parsing material' + lp.getLineNumberString() );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!CATEGORY':\n\n\t\t\t\t\t\t\t\tcategory = lp.getToken();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!KEYWORDS':\n\n\t\t\t\t\t\t\t\tconst newKeywords = lp.getRemainingString().split( ',' );\n\t\t\t\t\t\t\t\tif ( newKeywords.length > 0 ) {\n\n\t\t\t\t\t\t\t\t\tif ( ! keywords ) {\n\n\t\t\t\t\t\t\t\t\t\tkeywords = [];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tnewKeywords.forEach( function ( keyword ) {\n\n\t\t\t\t\t\t\t\t\t\tkeywords.push( keyword.trim() );\n\n\t\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'FILE':\n\n\t\t\t\t\t\t\t\tif ( lineIndex > 0 ) {\n\n\t\t\t\t\t\t\t\t\t// Start embedded text files parsing\n\t\t\t\t\t\t\t\t\tparsingEmbeddedFiles = true;\n\t\t\t\t\t\t\t\t\tcurrentEmbeddedFileName = lp.getRemainingString();\n\t\t\t\t\t\t\t\t\tcurrentEmbeddedText = '';\n\n\t\t\t\t\t\t\t\t\tbfcCertified = false;\n\t\t\t\t\t\t\t\t\tbfcCCW = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'BFC':\n\n\t\t\t\t\t\t\t\t// Changes to the backface culling state\n\t\t\t\t\t\t\t\twhile ( ! lp.isAtTheEnd() ) {\n\n\t\t\t\t\t\t\t\t\tconst token = lp.getToken();\n\n\t\t\t\t\t\t\t\t\tswitch ( token ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'CERTIFY':\n\t\t\t\t\t\t\t\t\t\tcase 'NOCERTIFY':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCertified = token === 'CERTIFY';\n\t\t\t\t\t\t\t\t\t\t\tbfcCCW = true;\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'CW':\n\t\t\t\t\t\t\t\t\t\tcase 'CCW':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCCW = token === 'CCW';\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'INVERTNEXT':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcInverted = true;\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'CLIP':\n\t\t\t\t\t\t\t\t\t\tcase 'NOCLIP':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCull = token === 'CLIP';\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.' );\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'STEP':\n\n\t\t\t\t\t\t\t\tstartingBuildingStep = true;\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'Author:':\n\n\t\t\t\t\t\t\t\tauthor = lp.getToken();\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// Other meta directives are not implemented\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 1: Sub-object file\n\t\t\t\tcase '1':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\n\t\t\t\t\tconst posX = parseFloat( lp.getToken() );\n\t\t\t\t\tconst posY = parseFloat( lp.getToken() );\n\t\t\t\t\tconst posZ = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m0 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m1 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m2 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m3 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m4 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m5 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m6 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m7 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m8 = parseFloat( lp.getToken() );\n\n\t\t\t\t\tconst matrix = new Matrix4().set(\n\t\t\t\t\t\tm0, m1, m2, posX,\n\t\t\t\t\t\tm3, m4, m5, posY,\n\t\t\t\t\t\tm6, m7, m8, posZ,\n\t\t\t\t\t\t0, 0, 0, 1\n\t\t\t\t\t);\n\n\t\t\t\t\tlet fileName = lp.getRemainingString().trim().replace( /\\\\/g, '/' );\n\n\t\t\t\t\tif ( loader.fileMap[ fileName ] ) {\n\n\t\t\t\t\t\t// Found the subobject path in the preloaded file path map\n\t\t\t\t\t\tfileName = loader.fileMap[ fileName ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Standardized subfolders\n\t\t\t\t\t\tif ( fileName.startsWith( 's/' ) ) {\n\n\t\t\t\t\t\t\tfileName = 'parts/' + fileName;\n\n\t\t\t\t\t\t} else if ( fileName.startsWith( '48/' ) ) {\n\n\t\t\t\t\t\t\tfileName = 'p/' + fileName;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsubobjects.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tmatrix: matrix,\n\t\t\t\t\t\tfileName: fileName,\n\t\t\t\t\t\tinverted: bfcInverted,\n\t\t\t\t\t\tstartingBuildingStep: startingBuildingStep\n\t\t\t\t\t} );\n\n\t\t\t\t\tstartingBuildingStep = false;\n\t\t\t\t\tbfcInverted = false;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 2: Line segment\n\t\t\t\tcase '2':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\tv1 = lp.getVector();\n\n\t\t\t\t\tsegment = {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tvertices: [ v0, v1 ],\n\t\t\t\t\t};\n\n\t\t\t\t\tlineSegments.push( segment );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 5: Conditional Line segment\n\t\t\t\tcase '5':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\tc0 = lp.getVector();\n\t\t\t\t\tc1 = lp.getVector();\n\n\t\t\t\t\tsegment = {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tvertices: [ v0, v1 ],\n\t\t\t\t\t\tcontrolPoints: [ c0, c1 ],\n\t\t\t\t\t};\n\n\t\t\t\t\tconditionalSegments.push( segment );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 3: Triangle\n\t\t\t\tcase '3':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tccw = bfcCCW;\n\t\t\t\t\tdoubleSided = ! bfcCertified || ! bfcCull;\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv0 = lp.getVector();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\tvertices: [ v0, v1, v2 ],\n\t\t\t\t\t\tnormals: [ null, null, null ],\n\t\t\t\t\t} );\n\t\t\t\t\ttotalFaces ++;\n\n\t\t\t\t\tif ( doubleSided === true ) {\n\n\t\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\t\tvertices: [ v2, v1, v0 ],\n\t\t\t\t\t\t\tnormals: [ null, null, null ],\n\t\t\t\t\t\t} );\n\t\t\t\t\t\ttotalFaces ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 4: Quadrilateral\n\t\t\t\tcase '4':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tccw = bfcCCW;\n\t\t\t\t\tdoubleSided = ! bfcCertified || ! bfcCull;\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv3 = lp.getVector();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv3 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv0 = lp.getVector();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// specifically place the triangle diagonal in the v0 and v1 slots so we can\n\t\t\t\t\t// account for the doubling of vertices later when smoothing normals.\n\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\tvertices: [ v0, v1, v2, v3 ],\n\t\t\t\t\t\tnormals: [ null, null, null, null ],\n\t\t\t\t\t} );\n\t\t\t\t\ttotalFaces += 2;\n\n\t\t\t\t\tif ( doubleSided === true ) {\n\n\t\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\t\tvertices: [ v3, v2, v1, v0 ],\n\t\t\t\t\t\t\tnormals: [ null, null, null, null ],\n\t\t\t\t\t\t} );\n\t\t\t\t\t\ttotalFaces += 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parsingEmbeddedFiles ) {\n\n\t\t\tthis.setData( currentEmbeddedFileName, currentEmbeddedText );\n\n\t\t}\n\n\t\treturn {\n\t\t\tfaces,\n\t\t\tconditionalSegments,\n\t\t\tlineSegments,\n\t\t\ttype,\n\t\t\tcategory,\n\t\t\tkeywords,\n\t\t\tauthor,\n\t\t\tsubobjects,\n\t\t\ttotalFaces,\n\t\t\tstartingBuildingStep,\n\t\t\tmaterials,\n\t\t\tfileName,\n\t\t\tgroup: null\n\t\t};\n\n\t}\n\n\t// returns an (optionally cloned) instance of the data\n\tgetData( fileName, clone = true ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tconst result = this._cache[ key ];\n\t\tif ( result === null || result instanceof Promise ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( clone ) {\n\n\t\t\treturn this.cloneResult( result );\n\n\t\t} else {\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n\t// kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n\t// the data is ready to use and can be retrieved synchronously with \"getData\".\n\tasync ensureDataLoaded( fileName ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tif ( ! ( key in this._cache ) ) {\n\n\t\t\t// replace the promise with a copy of the parsed data for immediate processing\n\t\t\tthis._cache[ key ] = this.fetchData( fileName ).then( text => {\n\n\t\t\t\tconst info = this.parse( text, fileName );\n\t\t\t\tthis._cache[ key ] = info;\n\t\t\t\treturn info;\n\n\t\t\t} );\n\n\t\t}\n\n\t\tawait this._cache[ key ];\n\n\t}\n\n\t// sets the data in the cache from parsed data\n\tsetData( fileName, text ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tthis._cache[ key ] = this.parse( text, fileName );\n\n\t}\n\n}\n\n// returns the material for an associated color code. If the color code is 16 for a face or 24 for\n// an edge then the passthroughColorCode is used.\nfunction getMaterialFromCode( colorCode, parentColorCode, materialHierarchy, forEdge ) {\n\n\tconst isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\tif ( isPassthrough ) {\n\n\t\tcolorCode = parentColorCode;\n\n\t}\n\n\treturn materialHierarchy[ colorCode ] || null;\n\n}\n\n// Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\nclass LDrawPartsGeometryCache {\n\n\tconstructor( loader ) {\n\n\t\tthis.loader = loader;\n\t\tthis.parseCache = new LDrawParsedCache( loader );\n\t\tthis._cache = {};\n\n\t}\n\n\t// Convert the given file information into a mesh by processing subobjects.\n\tasync processIntoMesh( info ) {\n\n\t\tconst loader = this.loader;\n\t\tconst parseCache = this.parseCache;\n\t\tconst faceMaterials = new Set();\n\n\t\t// Processes the part subobject information to load child parts and merge geometry onto part\n\t\t// piece object.\n\t\tconst processInfoSubobjects = async ( info, subobject = null ) => {\n\n\t\t\tconst subobjects = info.subobjects;\n\t\t\tconst promises = [];\n\n\t\t\t// Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\n\t\t\t// group which lets instruction steps apply correctly.\n\t\t\tfor ( let i = 0, l = subobjects.length; i < l; i ++ ) {\n\n\t\t\t\tconst subobject = subobjects[ i ];\n\t\t\t\tconst promise = parseCache.ensureDataLoaded( subobject.fileName ).then( () => {\n\n\t\t\t\t\tconst subobjectInfo = parseCache.getData( subobject.fileName, false );\n\t\t\t\t\tif ( ! isPrimitiveType( subobjectInfo.type ) ) {\n\n\t\t\t\t\t\treturn this.loadModel( subobject.fileName ).catch( error => {\n\n\t\t\t\t\t\t\tconsole.warn( error );\n\t\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn processInfoSubobjects( parseCache.getData( subobject.fileName ), subobject );\n\n\t\t\t\t} );\n\n\t\t\t\tpromises.push( promise );\n\n\t\t\t}\n\n\t\t\tconst group = new Group();\n\t\t\tgroup.userData.category = info.category;\n\t\t\tgroup.userData.keywords = info.keywords;\n\t\t\tgroup.userData.author = info.author;\n\t\t\tgroup.userData.type = info.type;\n\t\t\tgroup.userData.fileName = info.fileName;\n\t\t\tinfo.group = group;\n\n\t\t\tconst subobjectInfos = await Promise.all( promises );\n\t\t\tfor ( let i = 0, l = subobjectInfos.length; i < l; i ++ ) {\n\n\t\t\t\tconst subobject = info.subobjects[ i ];\n\t\t\t\tconst subobjectInfo = subobjectInfos[ i ];\n\n\t\t\t\tif ( subobjectInfo === null ) {\n\n\t\t\t\t\t// the subobject failed to load\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// if the subobject was loaded as a separate group then apply the parent scopes materials\n\t\t\t\tif ( subobjectInfo.isGroup ) {\n\n\t\t\t\t\tconst subobjectGroup = subobjectInfo;\n\t\t\t\t\tsubobject.matrix.decompose( subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale );\n\t\t\t\t\tsubobjectGroup.userData.startingBuildingStep = subobject.startingBuildingStep;\n\t\t\t\t\tsubobjectGroup.name = subobject.fileName;\n\n\t\t\t\t\tloader.applyMaterialsToMesh( subobjectGroup, subobject.colorCode, info.materials );\n\t\t\t\t\tsubobjectGroup.userData.colorCode = subobject.colorCode;\n\n\t\t\t\t\tgroup.add( subobjectGroup );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// add the subobject group if it has children in case it has both children and primitives\n\t\t\t\tif ( subobjectInfo.group.children.length ) {\n\n\t\t\t\t\tgroup.add( subobjectInfo.group );\n\n\t\t\t\t}\n\n\t\t\t\t// transform the primitives into the local space of the parent piece and append them to\n\t\t\t\t// to the parent primitives list.\n\t\t\t\tconst parentLineSegments = info.lineSegments;\n\t\t\t\tconst parentConditionalSegments = info.conditionalSegments;\n\t\t\t\tconst parentFaces = info.faces;\n\n\t\t\t\tconst lineSegments = subobjectInfo.lineSegments;\n\t\t\t\tconst conditionalSegments = subobjectInfo.conditionalSegments;\n\n\t\t\t\tconst faces = subobjectInfo.faces;\n\t\t\t\tconst matrix = subobject.matrix;\n\t\t\t\tconst inverted = subobject.inverted;\n\t\t\t\tconst matrixScaleInverted = matrix.determinant() < 0;\n\t\t\t\tconst colorCode = subobject.colorCode;\n\n\t\t\t\tconst lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n\t\t\t\tfor ( let i = 0, l = lineSegments.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst ls = lineSegments[ i ];\n\t\t\t\t\tconst vertices = ls.vertices;\n\t\t\t\t\tvertices[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tvertices[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n\t\t\t\t\tls.material = ls.material || getMaterialFromCode( ls.colorCode, ls.colorCode, info.materials, true );\n\n\t\t\t\t\tparentLineSegments.push( ls );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = conditionalSegments.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst os = conditionalSegments[ i ];\n\t\t\t\t\tconst vertices = os.vertices;\n\t\t\t\t\tconst controlPoints = os.controlPoints;\n\t\t\t\t\tvertices[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tvertices[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tcontrolPoints[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tcontrolPoints[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tos.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n\t\t\t\t\tos.material = os.material || getMaterialFromCode( os.colorCode, os.colorCode, info.materials, true );\n\n\t\t\t\t\tparentConditionalSegments.push( os );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst tri = faces[ i ];\n\t\t\t\t\tconst vertices = tri.vertices;\n\t\t\t\t\tfor ( let i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvertices[ i ].applyMatrix4( matrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n\t\t\t\t\ttri.material = tri.material || getMaterialFromCode( tri.colorCode, colorCode, info.materials, false );\n\t\t\t\t\tfaceMaterials.add( tri.colorCode );\n\n\t\t\t\t\t// If the scale of the object is negated then the triangle winding order\n\t\t\t\t\t// needs to be flipped.\n\t\t\t\t\tif ( matrixScaleInverted !== inverted ) {\n\n\t\t\t\t\t\tvertices.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tparentFaces.push( tri );\n\n\t\t\t\t}\n\n\t\t\t\tinfo.totalFaces += subobjectInfo.totalFaces;\n\n\t\t\t}\n\n\t\t\t// Apply the parent subobjects pass through material code to this object. This is done several times due\n\t\t\t// to material scoping.\n\t\t\tif ( subobject ) {\n\n\t\t\t\tloader.applyMaterialsToMesh( group, subobject.colorCode, info.materials );\n\t\t\t\tgroup.userData.colorCode = subobject.colorCode;\n\n\t\t\t}\n\n\t\t\treturn info;\n\n\t\t};\n\n\t\t// Track material use to see if we need to use the normal smooth slow path for hard edges.\n\t\tfor ( let i = 0, l = info.faces; i < l; i ++ ) {\n\n\t\t\tfaceMaterials.add( info.faces[ i ].colorCode );\n\n\t\t}\n\n\t\tawait processInfoSubobjects( info );\n\n\t\tif ( loader.smoothNormals ) {\n\n\t\t\tconst checkSubSegments = faceMaterials.size > 1;\n\t\t\tgenerateFaceNormals( info.faces );\n\t\t\tsmoothNormals( info.faces, info.lineSegments, checkSubSegments );\n\n\t\t}\n\n\t\t// Add the primitive objects and metadata.\n\t\tconst group = info.group;\n\t\tif ( info.faces.length > 0 ) {\n\n\t\t\tgroup.add( createObject( this.loader, info.faces, 3, false, info.totalFaces ) );\n\n\t\t}\n\n\t\tif ( info.lineSegments.length > 0 ) {\n\n\t\t\tgroup.add( createObject( this.loader, info.lineSegments, 2 ) );\n\n\t\t}\n\n\t\tif ( info.conditionalSegments.length > 0 ) {\n\n\t\t\tgroup.add( createObject( this.loader, info.conditionalSegments, 2, true ) );\n\n\t\t}\n\n\t\treturn group;\n\n\t}\n\n\thasCachedModel( fileName ) {\n\n\t\treturn fileName !== null && fileName.toLowerCase() in this._cache;\n\n\t}\n\n\tasync getCachedModel( fileName ) {\n\n\t\tif ( fileName !== null && this.hasCachedModel( fileName ) ) {\n\n\t\t\tconst key = fileName.toLowerCase();\n\t\t\tconst group = await this._cache[ key ];\n\t\t\treturn group.clone();\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t// Loads and parses the model with the given file name. Returns a cached copy if available.\n\tasync loadModel( fileName ) {\n\n\t\tconst parseCache = this.parseCache;\n\t\tconst key = fileName.toLowerCase();\n\t\tif ( this.hasCachedModel( fileName ) ) {\n\n\t\t\t// Return cached model if available.\n\t\t\treturn this.getCachedModel( fileName );\n\n\t\t} else {\n\n\t\t\t// Otherwise parse a new model.\n\t\t\t// Ensure the file data is loaded and pre parsed.\n\t\t\tawait parseCache.ensureDataLoaded( fileName );\n\n\t\t\tconst info = parseCache.getData( fileName );\n\t\t\tconst promise = this.processIntoMesh( info );\n\n\t\t\t// Now that the file has loaded it's possible that another part parse has been waiting in parallel\n\t\t\t// so check the cache again to see if it's been added since the last async operation so we don't\n\t\t\t// do unnecessary work.\n\t\t\tif ( this.hasCachedModel( fileName ) ) {\n\n\t\t\t\treturn this.getCachedModel( fileName );\n\n\t\t\t}\n\n\t\t\t// Cache object if it's a part so it can be reused later.\n\t\t\tif ( isPartType( info.type ) ) {\n\n\t\t\t\tthis._cache[ key ] = promise;\n\n\t\t\t}\n\n\t\t\t// return a copy\n\t\t\tconst group = await promise;\n\t\t\treturn group.clone();\n\n\t\t}\n\n\t}\n\n\t// parses the given model text into a renderable object. Returns cached copy if available.\n\tasync parseModel( text ) {\n\n\t\tconst parseCache = this.parseCache;\n\t\tconst info = parseCache.parse( text );\n\t\tif ( isPartType( info.type ) && this.hasCachedModel( info.fileName ) ) {\n\n\t\t\treturn this.getCachedModel( info.fileName );\n\n\t\t}\n\n\t\treturn this.processIntoMesh( info );\n\n\t}\n\n}\n\nfunction sortByMaterial( a, b ) {\n\n\tif ( a.colorCode === b.colorCode ) {\n\n\t\treturn 0;\n\n\t}\n\n\tif ( a.colorCode < b.colorCode ) {\n\n\t\treturn - 1;\n\n\t}\n\n\treturn 1;\n\n}\n\nfunction createObject( loader, elements, elementSize, isConditionalSegments = false, totalElements = null ) {\n\n\t// Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n\t// With per face / segment material, implemented with mesh groups and materials array\n\n\t// Sort the faces or line segments by color code to make later the mesh groups\n\telements.sort( sortByMaterial );\n\n\tif ( totalElements === null ) {\n\n\t\ttotalElements = elements.length;\n\n\t}\n\n\tconst positions = new Float32Array( elementSize * totalElements * 3 );\n\tconst normals = elementSize === 3 ? new Float32Array( elementSize * totalElements * 3 ) : null;\n\tconst materials = [];\n\n\tconst quadArray = new Array( 6 );\n\tconst bufferGeometry = new BufferGeometry();\n\tlet prevMaterial = null;\n\tlet index0 = 0;\n\tlet numGroupVerts = 0;\n\tlet offset = 0;\n\n\tfor ( let iElem = 0, nElem = elements.length; iElem < nElem; iElem ++ ) {\n\n\t\tconst elem = elements[ iElem ];\n\t\tlet vertices = elem.vertices;\n\t\tif ( vertices.length === 4 ) {\n\n\t\t\tquadArray[ 0 ] = vertices[ 0 ];\n\t\t\tquadArray[ 1 ] = vertices[ 1 ];\n\t\t\tquadArray[ 2 ] = vertices[ 2 ];\n\t\t\tquadArray[ 3 ] = vertices[ 0 ];\n\t\t\tquadArray[ 4 ] = vertices[ 2 ];\n\t\t\tquadArray[ 5 ] = vertices[ 3 ];\n\t\t\tvertices = quadArray;\n\n\t\t}\n\n\t\tfor ( let j = 0, l = vertices.length; j < l; j ++ ) {\n\n\t\t\tconst v = vertices[ j ];\n\t\t\tconst index = offset + j * 3;\n\t\t\tpositions[ index + 0 ] = v.x;\n\t\t\tpositions[ index + 1 ] = v.y;\n\t\t\tpositions[ index + 2 ] = v.z;\n\n\t\t}\n\n\t\t// create the normals array if this is a set of faces\n\t\tif ( elementSize === 3 ) {\n\n\t\t\tif ( ! elem.faceNormal ) {\n\n\t\t\t\tconst v0 = vertices[ 0 ];\n\t\t\t\tconst v1 = vertices[ 1 ];\n\t\t\t\tconst v2 = vertices[ 2 ];\n\t\t\t\t_tempVec0.subVectors( v1, v0 );\n\t\t\t\t_tempVec1.subVectors( v2, v1 );\n\t\t\t\telem.faceNormal = new Vector3()\n\t\t\t\t\t.crossVectors( _tempVec0, _tempVec1 )\n\t\t\t\t\t.normalize();\n\n\t\t\t}\n\n\t\t\tlet elemNormals = elem.normals;\n\t\t\tif ( elemNormals.length === 4 ) {\n\n\t\t\t\tquadArray[ 0 ] = elemNormals[ 0 ];\n\t\t\t\tquadArray[ 1 ] = elemNormals[ 1 ];\n\t\t\t\tquadArray[ 2 ] = elemNormals[ 2 ];\n\t\t\t\tquadArray[ 3 ] = elemNormals[ 0 ];\n\t\t\t\tquadArray[ 4 ] = elemNormals[ 2 ];\n\t\t\t\tquadArray[ 5 ] = elemNormals[ 3 ];\n\t\t\t\telemNormals = quadArray;\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, l = elemNormals.length; j < l; j ++ ) {\n\n\t\t\t\t// use face normal if a vertex normal is not provided\n\t\t\t\tlet n = elem.faceNormal;\n\t\t\t\tif ( elemNormals[ j ] ) {\n\n\t\t\t\t\tn = elemNormals[ j ].norm;\n\n\t\t\t\t}\n\n\t\t\t\tconst index = offset + j * 3;\n\t\t\t\tnormals[ index + 0 ] = n.x;\n\t\t\t\tnormals[ index + 1 ] = n.y;\n\t\t\t\tnormals[ index + 2 ] = n.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( prevMaterial !== elem.colorCode ) {\n\n\t\t\tif ( prevMaterial !== null ) {\n\n\t\t\t\tbufferGeometry.addGroup( index0, numGroupVerts, materials.length - 1 );\n\n\t\t\t}\n\n\t\t\tconst material = elem.material;\n\n\t\t\tif ( material !== null ) {\n\n\t\t\t\tif ( elementSize === 3 ) {\n\n\t\t\t\t\tmaterials.push( material );\n\n\t\t\t\t} else if ( elementSize === 2 ) {\n\n\t\t\t\t\tif ( isConditionalSegments ) {\n\n\t\t\t\t\t\tconst edgeMaterial = loader.edgeMaterialCache.get( material );\n\n\t\t\t\t\t\tmaterials.push( loader.conditionalEdgeMaterialCache.get( edgeMaterial ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push( loader.edgeMaterialCache.get( material ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// If a material has not been made available yet then keep the color code string in the material array\n\t\t\t\t// to save the spot for the material once a parent scopes materials are being applied to the object.\n\t\t\t\tmaterials.push( elem.colorCode );\n\n\t\t\t}\n\n\t\t\tprevMaterial = elem.colorCode;\n\t\t\tindex0 = offset / 3;\n\t\t\tnumGroupVerts = vertices.length;\n\n\t\t} else {\n\n\t\t\tnumGroupVerts += vertices.length;\n\n\t\t}\n\n\t\toffset += 3 * vertices.length;\n\n\t}\n\n\tif ( numGroupVerts > 0 ) {\n\n\t\tbufferGeometry.addGroup( index0, Infinity, materials.length - 1 );\n\n\t}\n\n\tbufferGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\tif ( normals !== null ) {\n\n\t\tbufferGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t}\n\n\tlet object3d = null;\n\n\tif ( elementSize === 2 ) {\n\n\t\tif ( isConditionalSegments ) {\n\n\t\t\tobject3d = new ConditionalLineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t\t} else {\n\n\t\t\tobject3d = new LineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t\t}\n\n\t} else if ( elementSize === 3 ) {\n\n\t\tobject3d = new Mesh( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t}\n\n\tif ( isConditionalSegments ) {\n\n\t\tobject3d.isConditionalLine = true;\n\n\t\tconst controlArray0 = new Float32Array( elements.length * 3 * 2 );\n\t\tconst controlArray1 = new Float32Array( elements.length * 3 * 2 );\n\t\tconst directionArray = new Float32Array( elements.length * 3 * 2 );\n\t\tfor ( let i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\tconst os = elements[ i ];\n\t\t\tconst vertices = os.vertices;\n\t\t\tconst controlPoints = os.controlPoints;\n\t\t\tconst c0 = controlPoints[ 0 ];\n\t\t\tconst c1 = controlPoints[ 1 ];\n\t\t\tconst v0 = vertices[ 0 ];\n\t\t\tconst v1 = vertices[ 1 ];\n\t\t\tconst index = i * 3 * 2;\n\t\t\tcontrolArray0[ index + 0 ] = c0.x;\n\t\t\tcontrolArray0[ index + 1 ] = c0.y;\n\t\t\tcontrolArray0[ index + 2 ] = c0.z;\n\t\t\tcontrolArray0[ index + 3 ] = c0.x;\n\t\t\tcontrolArray0[ index + 4 ] = c0.y;\n\t\t\tcontrolArray0[ index + 5 ] = c0.z;\n\n\t\t\tcontrolArray1[ index + 0 ] = c1.x;\n\t\t\tcontrolArray1[ index + 1 ] = c1.y;\n\t\t\tcontrolArray1[ index + 2 ] = c1.z;\n\t\t\tcontrolArray1[ index + 3 ] = c1.x;\n\t\t\tcontrolArray1[ index + 4 ] = c1.y;\n\t\t\tcontrolArray1[ index + 5 ] = c1.z;\n\n\t\t\tdirectionArray[ index + 0 ] = v1.x - v0.x;\n\t\t\tdirectionArray[ index + 1 ] = v1.y - v0.y;\n\t\t\tdirectionArray[ index + 2 ] = v1.z - v0.z;\n\t\t\tdirectionArray[ index + 3 ] = v1.x - v0.x;\n\t\t\tdirectionArray[ index + 4 ] = v1.y - v0.y;\n\t\t\tdirectionArray[ index + 5 ] = v1.z - v0.z;\n\n\t\t}\n\n\t\tbufferGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) );\n\t\tbufferGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) );\n\t\tbufferGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) );\n\n\t}\n\n\treturn object3d;\n\n}\n\n//\n\nclass LDrawLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t// Array of THREE.Material\n\t\tthis.materials = [];\n\t\tthis.materialLibrary = {};\n\t\tthis.edgeMaterialCache = new WeakMap();\n\t\tthis.conditionalEdgeMaterialCache = new WeakMap();\n\n\t\t// This also allows to handle the embedded text files (\"0 FILE\" lines)\n\t\tthis.partsCache = new LDrawPartsGeometryCache( this );\n\n\t\t// This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\t\tthis.fileMap = {};\n\n\t\t// Initializes the materials library with default materials\n\t\tthis.setMaterials( [] );\n\n\t\t// If this flag is set to true the vertex normals will be smoothed.\n\t\tthis.smoothNormals = true;\n\n\t\t// The path to load parts from the LDraw parts library from.\n\t\tthis.partsLibraryPath = '';\n\n\t\t// Material assigned to not available colors for meshes and edges\n\t\tthis.missingColorMaterial = new MeshStandardMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xFF00FF, roughness: 0.3, metalness: 0 } );\n\t\tthis.missingEdgeColorMaterial = new LineBasicMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xFF00FF } );\n\t\tthis.missingConditionalEdgeColorMaterial = new LDrawConditionalLineMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, fog: true, color: 0xFF00FF } );\n\t\tthis.edgeMaterialCache.set( this.missingColorMaterial, this.missingEdgeColorMaterial );\n\t\tthis.conditionalEdgeMaterialCache.set( this.missingEdgeColorMaterial, this.missingConditionalEdgeColorMaterial );\n\n\t}\n\n\tsetPartsLibraryPath( path ) {\n\n\t\tthis.partsLibraryPath = path;\n\t\treturn this;\n\n\t}\n\n\tasync preloadMaterials( url ) {\n\n\t\tconst fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path );\n\t\tfileLoader.setRequestHeader( this.requestHeader );\n\t\tfileLoader.setWithCredentials( this.withCredentials );\n\n\t\tconst text = await fileLoader.loadAsync( url );\n\t\tconst colorLineRegex = /^0 !COLOUR/;\n\t\tconst lines = text.split( /[\\n\\r]/g );\n\t\tconst materials = [];\n\t\tfor ( let i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\tconst line = lines[ i ];\n\t\t\tif ( colorLineRegex.test( line ) ) {\n\n\t\t\t\tconst directive = line.replace( colorLineRegex, '' );\n\t\t\t\tconst material = this.parseColorMetaDirective( new LineParser( directive ) );\n\t\t\t\tmaterials.push( material );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setMaterials( materials );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path );\n\t\tfileLoader.setRequestHeader( this.requestHeader );\n\t\tfileLoader.setWithCredentials( this.withCredentials );\n\t\tfileLoader.load( url, text => {\n\n\t\t\tthis.partsCache\n\t\t\t\t.parseModel( text, this.materialLibrary )\n\t\t\t\t.then( group => {\n\n\t\t\t\t\tthis.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );\n\t\t\t\t\tthis.computeBuildingSteps( group );\n\t\t\t\t\tgroup.userData.fileName = url;\n\t\t\t\t\tonLoad( group );\n\n\t\t\t\t} )\n\t\t\t\t.catch( onError );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( text, onLoad ) {\n\n\t\tthis.partsCache\n\t\t\t.parseModel( text, this.materialLibrary )\n\t\t\t.then( group => {\n\n\t\t\t\tthis.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );\n\t\t\t\tthis.computeBuildingSteps( group );\n\t\t\t\tgroup.userData.fileName = '';\n\t\t\t\tonLoad( group );\n\n\t\t\t} );\n\n\t}\n\n\tsetMaterials( materials ) {\n\n\t\tthis.materialLibrary = {};\n\t\tthis.materials = [];\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tthis.addMaterial( materials[ i ] );\n\n\t\t}\n\n\t\t// Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\n\t\tthis.addMaterial( this.parseColorMetaDirective( new LineParser( 'Main_Colour CODE 16 VALUE #FF8080 EDGE #333333' ) ) );\n\t\tthis.addMaterial( this.parseColorMetaDirective( new LineParser( 'Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333' ) ) );\n\n\t\treturn this;\n\n\t}\n\n\tsetFileMap( fileMap ) {\n\n\t\tthis.fileMap = fileMap;\n\n\t\treturn this;\n\n\t}\n\n\taddMaterial( material ) {\n\n\t\t// Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n\n\t\tconst matLib = this.materialLibrary;\n\t\tif ( ! matLib[ material.userData.code ] ) {\n\n\t\t\tthis.materials.push( material );\n\t\t\tmatLib[ material.userData.code ] = material;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetMaterial( colorCode ) {\n\n\t\tif ( colorCode.startsWith( '0x2' ) ) {\n\n\t\t\t// Special 'direct' material value (RGB color)\n\t\t\tconst color = colorCode.substring( 3 );\n\n\t\t\treturn this.parseColorMetaDirective( new LineParser( 'Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + '' ) );\n\n\t\t}\n\n\t\treturn this.materialLibrary[ colorCode ] || null;\n\n\t}\n\n\t// Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n\t// in the material array if they need to be filled in.\n\tapplyMaterialsToMesh( group, parentColorCode, materialHierarchy, finalMaterialPass = false ) {\n\n\t\t// find any missing materials as indicated by a color code string and replace it with a material from the current material lib\n\t\tconst loader = this;\n\t\tconst parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n\t\tgroup.traverse( c => {\n\n\t\t\tif ( c.isMesh || c.isLineSegments ) {\n\n\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\tfor ( let i = 0, l = c.material.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( ! c.material[ i ].isMaterial ) {\n\n\t\t\t\t\t\t\tc.material[ i ] = getMaterial( c, c.material[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( ! c.material.isMaterial ) {\n\n\t\t\t\t\tc.material = getMaterial( c, c.material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\n\t\t// Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\n\t\t// (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\n\t\t// simply returned for the subsequent material application.\n\t\tfunction getMaterial( c, colorCode ) {\n\n\t\t\t// if our parent is a passthrough color code and we don't have the current material color available then\n\t\t\t// return early.\n\t\t\tif ( parentIsPassthrough && ! ( colorCode in materialHierarchy ) && ! finalMaterialPass ) {\n\n\t\t\t\treturn colorCode;\n\n\t\t\t}\n\n\t\t\tconst forEdge = c.isLineSegments || c.isConditionalLine;\n\t\t\tconst isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\t\t\tif ( isPassthrough ) {\n\n\t\t\t\tcolorCode = parentColorCode;\n\n\t\t\t}\n\n\t\t\tlet material = null;\n\t\t\tif ( colorCode in materialHierarchy ) {\n\n\t\t\t\tmaterial = materialHierarchy[ colorCode ];\n\n\t\t\t} else if ( finalMaterialPass ) {\n\n\t\t\t\t// see if we can get the final material from from the \"getMaterial\" function which will attempt to\n\t\t\t\t// parse the \"direct\" colors\n\t\t\t\tmaterial = loader.getMaterial( colorCode );\n\t\t\t\tif ( material === null ) {\n\n\t\t\t\t\t// otherwise throw a warning if this is final opportunity to set the material\n\t\t\t\t\tconsole.warn( `LDrawLoader: Material properties for code ${ colorCode } not available.` );\n\n\t\t\t\t\t// And return the 'missing color' material\n\t\t\t\t\tmaterial = loader.missingColorMaterial;\n\n\t\t\t\t}\n\n\n\t\t\t} else {\n\n\t\t\t\treturn colorCode;\n\n\t\t\t}\n\n\t\t\tif ( c.isLineSegments ) {\n\n\t\t\t\tmaterial = loader.edgeMaterialCache.get( material );\n\n\t\t\t\tif ( c.isConditionalLine ) {\n\n\t\t\t\t\tmaterial = loader.conditionalEdgeMaterialCache.get( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t}\n\n\tgetMainMaterial() {\n\n\t\treturn this.getMaterial( MAIN_COLOUR_CODE );\n\n\t}\n\n\tgetMainEdgeMaterial() {\n\n\t\tconst mat = this.getMaterial( MAIN_EDGE_COLOUR_CODE );\n\t\treturn mat ? this.edgeMaterialCache.get( mat ) : null;\n\n\t}\n\n\tparseColorMetaDirective( lineParser ) {\n\n\t\t// Parses a color definition and returns a THREE.Material\n\n\t\tlet code = null;\n\n\t\t// Triangle and line colors\n\t\tlet fillColor = '#FF00FF';\n\t\tlet edgeColor = '#FF00FF';\n\n\t\t// Transparency\n\t\tlet alpha = 1;\n\t\tlet isTransparent = false;\n\t\t// Self-illumination:\n\t\tlet luminance = 0;\n\n\t\tlet finishType = FINISH_TYPE_DEFAULT;\n\n\t\tlet edgeMaterial = null;\n\n\t\tconst name = lineParser.getToken();\n\t\tif ( ! name ) {\n\n\t\t\tthrow new Error( 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.' );\n\n\t\t}\n\n\t\t// Parse tag tokens and their parameters\n\t\tlet token = null;\n\t\twhile ( true ) {\n\n\t\t\ttoken = lineParser.getToken();\n\n\t\t\tif ( ! token ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( ! parseLuminance( token ) ) {\n\n\t\t\t\tswitch ( token.toUpperCase() ) {\n\n\t\t\t\t\tcase 'CODE':\n\n\t\t\t\t\t\tcode = lineParser.getToken();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'VALUE':\n\n\t\t\t\t\t\tfillColor = lineParser.getToken();\n\t\t\t\t\t\tif ( fillColor.startsWith( '0x' ) ) {\n\n\t\t\t\t\t\t\tfillColor = '#' + fillColor.substring( 2 );\n\n\t\t\t\t\t\t} else if ( ! fillColor.startsWith( '#' ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'EDGE':\n\n\t\t\t\t\t\tedgeColor = lineParser.getToken();\n\t\t\t\t\t\tif ( edgeColor.startsWith( '0x' ) ) {\n\n\t\t\t\t\t\t\tedgeColor = '#' + edgeColor.substring( 2 );\n\n\t\t\t\t\t\t} else if ( ! edgeColor.startsWith( '#' ) ) {\n\n\t\t\t\t\t\t\t// Try to see if edge color is a color code\n\t\t\t\t\t\t\tedgeMaterial = this.getMaterial( edgeColor );\n\t\t\t\t\t\t\tif ( ! edgeMaterial ) {\n\n\t\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get the edge material for this triangle material\n\t\t\t\t\t\t\tedgeMaterial = this.edgeMaterialCache.get( edgeMaterial );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ALPHA':\n\n\t\t\t\t\t\talpha = parseInt( lineParser.getToken() );\n\n\t\t\t\t\t\tif ( isNaN( alpha ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\talpha = Math.max( 0, Math.min( 1, alpha / 255 ) );\n\n\t\t\t\t\t\tif ( alpha < 1 ) {\n\n\t\t\t\t\t\t\tisTransparent = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LUMINANCE':\n\n\t\t\t\t\t\tif ( ! parseLuminance( lineParser.getToken() ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CHROME':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_CHROME;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PEARLESCENT':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_PEARLESCENT;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RUBBER':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_RUBBER;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'MATTE_METALLIC':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_MATTE_METALLIC;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'METAL':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_METAL;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'MATERIAL':\n\t\t\t\t\t\t// Not implemented\n\t\t\t\t\t\tlineParser.setToEnd();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet material = null;\n\n\t\tswitch ( finishType ) {\n\n\t\t\tcase FINISH_TYPE_DEFAULT:\n\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.3, metalness: 0 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_PEARLESCENT:\n\n\t\t\t\t// Try to imitate pearlescency by making the surface glossy\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.3, metalness: 0.25 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_CHROME:\n\n\t\t\t\t// Mirror finish surface\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0, metalness: 1 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_RUBBER:\n\n\t\t\t\t// Rubber finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.9, metalness: 0 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_MATTE_METALLIC:\n\n\t\t\t\t// Brushed metal finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.8, metalness: 0.4 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_METAL:\n\n\t\t\t\t// Average metal finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.2, metalness: 0.85 } );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// Should not happen\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tmaterial.color.setStyle( fillColor, COLOR_SPACE_LDRAW );\n\t\tmaterial.transparent = isTransparent;\n\t\tmaterial.premultipliedAlpha = true;\n\t\tmaterial.opacity = alpha;\n\t\tmaterial.depthWrite = ! isTransparent;\n\n\t\tmaterial.polygonOffset = true;\n\t\tmaterial.polygonOffsetFactor = 1;\n\n\t\tif ( luminance !== 0 ) {\n\n\t\t\tmaterial.emissive.setStyle( fillColor, COLOR_SPACE_LDRAW ).multiplyScalar( luminance );\n\n\t\t}\n\n\t\tif ( ! edgeMaterial ) {\n\n\t\t\t// This is the material used for edges\n\t\t\tedgeMaterial = new LineBasicMaterial( {\n\t\t\t\tcolor: new Color().setStyle( edgeColor, COLOR_SPACE_LDRAW ),\n\t\t\t\ttransparent: isTransparent,\n\t\t\t\topacity: alpha,\n\t\t\t\tdepthWrite: ! isTransparent\n\t\t\t} );\n\t\t\tedgeMaterial.color;\n\t\t\tedgeMaterial.userData.code = code;\n\t\t\tedgeMaterial.name = name + ' - Edge';\n\n\t\t\t// This is the material used for conditional edges\n\t\t\tconst conditionalEdgeMaterial = new LDrawConditionalLineMaterial( {\n\n\t\t\t\tfog: true,\n\t\t\t\ttransparent: isTransparent,\n\t\t\t\tdepthWrite: ! isTransparent,\n\t\t\t\tcolor: new Color().setStyle( edgeColor, COLOR_SPACE_LDRAW ),\n\t\t\t\topacity: alpha,\n\n\t\t\t} );\n\t\t\tconditionalEdgeMaterial.userData.code = code;\n\t\t\tconditionalEdgeMaterial.name = name + ' - Conditional Edge';\n\n\t\t\tthis.conditionalEdgeMaterialCache.set( edgeMaterial, conditionalEdgeMaterial );\n\n\t\t}\n\n\t\tmaterial.userData.code = code;\n\t\tmaterial.name = name;\n\n\t\tthis.edgeMaterialCache.set( material, edgeMaterial );\n\n\t\tthis.addMaterial( material );\n\n\t\treturn material;\n\n\t\tfunction parseLuminance( token ) {\n\n\t\t\t// Returns success\n\n\t\t\tlet lum;\n\n\t\t\tif ( token.startsWith( 'LUMINANCE' ) ) {\n\n\t\t\t\tlum = parseInt( token.substring( 9 ) );\n\n\t\t\t} else {\n\n\t\t\t\tlum = parseInt( token );\n\n\t\t\t}\n\n\t\t\tif ( isNaN( lum ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tluminance = Math.max( 0, Math.min( 1, lum / 255 ) );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\tcomputeBuildingSteps( model ) {\n\n\t\t// Sets userdata.buildingStep number in Group objects and userData.numBuildingSteps number in the root Group object.\n\n\t\tlet stepNumber = 0;\n\n\t\tmodel.traverse( c => {\n\n\t\t\tif ( c.isGroup ) {\n\n\t\t\t\tif ( c.userData.startingBuildingStep ) {\n\n\t\t\t\t\tstepNumber ++;\n\n\t\t\t\t}\n\n\t\t\t\tc.userData.buildingStep = stepNumber;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tmodel.userData.numBuildingSteps = stepNumber + 1;\n\n\t}\n\n}\n\nexport { LDrawLoader };\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tGroup,\n\tLineSegments,\n\tMatrix3,\n\tMesh\n} from 'three';\n\nimport { mergeGeometries } from './BufferGeometryUtils.js';\n\nclass LDrawUtils {\n\n\tstatic mergeObject( object ) {\n\n\t\t// Merges geometries in object by materials and returns new object. Use on not indexed geometries.\n\t\t// The object buffers reference the old object ones.\n\t\t// Special treatment is done to the conditional lines generated by LDrawLoader.\n\n\t\tfunction extractGroup( geometry, group, elementSize, isConditionalLine ) {\n\n\t\t\t// Extracts a group from a geometry as a new geometry (with attribute buffers referencing original buffers)\n\n\t\t\tconst newGeometry = new BufferGeometry();\n\n\t\t\tconst originalPositions = geometry.getAttribute( 'position' ).array;\n\t\t\tconst originalNormals = elementSize === 3 ? geometry.getAttribute( 'normal' ).array : null;\n\n\t\t\tconst numVertsGroup = Math.min( group.count, Math.floor( originalPositions.length / 3 ) - group.start );\n\t\t\tconst vertStart = group.start * 3;\n\t\t\tconst vertEnd = ( group.start + numVertsGroup ) * 3;\n\n\t\t\tconst positions = originalPositions.subarray( vertStart, vertEnd );\n\t\t\tconst normals = originalNormals !== null ? originalNormals.subarray( vertStart, vertEnd ) : null;\n\n\t\t\tnewGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\t\t\tif ( normals !== null ) newGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t\t\tif ( isConditionalLine ) {\n\n\t\t\t\tconst controlArray0 = geometry.getAttribute( 'control0' ).array.subarray( vertStart, vertEnd );\n\t\t\t\tconst controlArray1 = geometry.getAttribute( 'control1' ).array.subarray( vertStart, vertEnd );\n\t\t\t\tconst directionArray = geometry.getAttribute( 'direction' ).array.subarray( vertStart, vertEnd );\n\n\t\t\t\tnewGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) );\n\t\t\t\tnewGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) );\n\t\t\t\tnewGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) );\n\n\t\t\t}\n\n\t\t\treturn newGeometry;\n\n\t\t}\n\n\t\tfunction addGeometry( mat, geometry, geometries ) {\n\n\t\t\tconst geoms = geometries[ mat.uuid ];\n\t\t\tif ( ! geoms ) {\n\n\t\t\t\tgeometries[ mat.uuid ] = {\n\t\t\t\t\tmat: mat,\n\t\t\t\t\tarr: [ geometry ]\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tgeoms.arr.push( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction permuteAttribute( attribute, elemSize ) {\n\n\t\t\t// Permutes first two vertices of each attribute element\n\n\t\t\tif ( ! attribute ) return;\n\n\t\t\tconst verts = attribute.array;\n\t\t\tconst numVerts = Math.floor( verts.length / 3 );\n\t\t\tlet offset = 0;\n\t\t\tfor ( let i = 0; i < numVerts; i ++ ) {\n\n\t\t\t\tconst x = verts[ offset ];\n\t\t\t\tconst y = verts[ offset + 1 ];\n\t\t\t\tconst z = verts[ offset + 2 ];\n\n\t\t\t\tverts[ offset ] = verts[ offset + 3 ];\n\t\t\t\tverts[ offset + 1 ] = verts[ offset + 4 ];\n\t\t\t\tverts[ offset + 2 ] = verts[ offset + 5 ];\n\n\t\t\t\tverts[ offset + 3 ] = x;\n\t\t\t\tverts[ offset + 4 ] = y;\n\t\t\t\tverts[ offset + 5 ] = z;\n\n\t\t\t\toffset += elemSize * 3;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Traverse the object hierarchy collecting geometries and transforming them to world space\n\n\t\tconst meshGeometries = {};\n\t\tconst linesGeometries = {};\n\t\tconst condLinesGeometries = {};\n\n\t\tobject.updateMatrixWorld( true );\n\t\tconst normalMatrix = new Matrix3();\n\n\t\tobject.traverse( c => {\n\n\t\t\tif ( c.isMesh | c.isLineSegments ) {\n\n\t\t\t\tconst elemSize = c.isMesh ? 3 : 2;\n\n\t\t\t\tconst geometry = c.geometry.clone();\n\t\t\t\tconst matrixIsInverted = c.matrixWorld.determinant() < 0;\n\t\t\t\tif ( matrixIsInverted ) {\n\n\t\t\t\t\tpermuteAttribute( geometry.attributes.position, elemSize );\n\t\t\t\t\tpermuteAttribute( geometry.attributes.normal, elemSize );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.applyMatrix4( c.matrixWorld );\n\n\t\t\t\tif ( c.isConditionalLine ) {\n\n\t\t\t\t\tgeometry.attributes.control0.applyMatrix4( c.matrixWorld );\n\t\t\t\t\tgeometry.attributes.control1.applyMatrix4( c.matrixWorld );\n\t\t\t\t\tnormalMatrix.getNormalMatrix( c.matrixWorld );\n\t\t\t\t\tgeometry.attributes.direction.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tconst geometries = c.isMesh ? meshGeometries : ( c.isConditionalLine ? condLinesGeometries : linesGeometries );\n\n\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\tfor ( const groupIndex in geometry.groups ) {\n\n\t\t\t\t\t\tconst group = geometry.groups[ groupIndex ];\n\t\t\t\t\t\tconst mat = c.material[ group.materialIndex ];\n\t\t\t\t\t\tconst newGeometry = extractGroup( geometry, group, elemSize, c.isConditionalLine );\n\t\t\t\t\t\taddGeometry( mat, newGeometry, geometries );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddGeometry( c.material, geometry, geometries );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Create object with merged geometries\n\n\t\tconst mergedObject = new Group();\n\n\t\tconst meshMaterialsIds = Object.keys( meshGeometries );\n\t\tfor ( const meshMaterialsId of meshMaterialsIds ) {\n\n\t\t\tconst meshGeometry = meshGeometries[ meshMaterialsId ];\n\t\t\tconst mergedGeometry = mergeGeometries( meshGeometry.arr );\n\t\t\tmergedObject.add( new Mesh( mergedGeometry, meshGeometry.mat ) );\n\n\t\t}\n\n\t\tconst linesMaterialsIds = Object.keys( linesGeometries );\n\t\tfor ( const linesMaterialsId of linesMaterialsIds ) {\n\n\t\t\tconst lineGeometry = linesGeometries[ linesMaterialsId ];\n\t\t\tconst mergedGeometry = mergeGeometries( lineGeometry.arr );\n\t\t\tmergedObject.add( new LineSegments( mergedGeometry, lineGeometry.mat ) );\n\n\t\t}\n\n\t\tconst condLinesMaterialsIds = Object.keys( condLinesGeometries );\n\t\tfor ( const condLinesMaterialsId of condLinesMaterialsIds ) {\n\n\t\t\tconst condLineGeometry = condLinesGeometries[ condLinesMaterialsId ];\n\t\t\tconst mergedGeometry = mergeGeometries( condLineGeometry.arr );\n\t\t\tconst condLines = new LineSegments( mergedGeometry, condLineGeometry.mat );\n\t\t\tcondLines.isConditionalLine = true;\n\t\t\tmergedObject.add( condLines );\n\n\t\t}\n\n\t\tmergedObject.userData.constructionStep = 0;\n\t\tmergedObject.userData.numConstructionSteps = 1;\n\n\t\treturn mergedObject;\n\n\t}\n\n}\n\nexport { LDrawUtils };\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$90a1bf3572dc4d5f$export$12d9a9ad6192c950","$ilwiq","$90a1bf3572dc4d5f$var$COLOR_SPACE_LDRAW","SRGBColorSpace","$90a1bf3572dc4d5f$var$_tempVec0","Vector3","$90a1bf3572dc4d5f$var$_tempVec1","$90a1bf3572dc4d5f$var$LDrawConditionalLineMaterial","ShaderMaterial","constructor","parameters","uniforms","UniformsUtils","merge","UniformsLib","fog","diffuse","value","Color","opacity","vertexShader","fragmentShader","defineProperties","color","setValues","isLDrawConditionalLineMaterial","$90a1bf3572dc4d5f$var$ConditionalLineSegments","LineSegments","geometry","material","isConditionalLine","$90a1bf3572dc4d5f$var$_ray","Ray","$90a1bf3572dc4d5f$var$isPartType","type","$90a1bf3572dc4d5f$var$LineParser","line","lineNumber","lineLength","length","currentCharIndex","currentChar","seekNonSpace","charAt","getToken","pos0","pos1","substring","getVector","parseFloat","getRemainingString","isAtTheEnd","setToEnd","getLineNumberString","$90a1bf3572dc4d5f$var$LDrawParsedCache","loader","_cache","cloneResult","original","result","faces","map","face","colorCode","vertices","clone","normals","faceNormal","conditionalSegments","controlPoints","lineSegments","category","keywords","author","subobjects","fileName","totalFaces","startingBuildingStep","materials","group","fetchData","triedLowerCase","locationState","subobjectURL","lastIndexOf","toLowerCase","fileLoader","FileLoader","manager","setPath","partsLibraryPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","loadAsync","_","parse","text","getLocalMaterial","indexOf","replace","lines","split","numLines","parsingEmbeddedFiles","currentEmbeddedFileName","currentEmbeddedText","bfcCertified","bfcCCW","bfcInverted","bfcCull","lineIndex","segment","ccw","doubleSided","v0","v1","v2","v3","startsWith","setData","lp","lineType","meta","parseColorMetaDirective","userData","console","warn","newKeywords","forEach","keyword","push","trim","token","posX","posY","posZ","m0","m1","m2","m3","m4","m5","m6","m7","m8","matrix","Matrix4","fileMap","inverted","getData","key","Promise","ensureDataLoaded","then","info","$90a1bf3572dc4d5f$var$getMaterialFromCode","parentColorCode","materialHierarchy","forEdge","$90a1bf3572dc4d5f$var$LDrawPartsGeometryCache","parseCache","processIntoMesh","faceMaterials","Set","processInfoSubobjects","subobject","promises","i","l","promise","subobjectInfo","test","loadModel","catch","error","Group","subobjectInfos","all","isGroup","decompose","subobjectGroup","position","quaternion","scale","name","applyMaterialsToMesh","add","children","parentLineSegments","parentConditionalSegments","parentFaces","matrixScaleInverted","determinant","lineColorCode","ls","applyMatrix4","os","tri","reverse","smoothNormals","checkSubSegments","size","$90a1bf3572dc4d5f$var$generateFaceNormals","subVectors","crossVectors","normalize","$90a1bf3572dc4d5f$var$smoothNormals","hashMultiplier","hashVertex","x","y","z","hashEdge","toNormalizedRay","targetRay","direction","scalar","dot","origin","copy","addScaledVector","hashRay","ray","hardEdges","hardEdgeRays","Map","halfEdgeList","rh1","has","rh2","distances","d0","d1","vertCount","i2","index","next","hash","rayHash","found","halfEdge","queue","pop","vertNormals","reverseHash","otherInfo","otherTri","otherIndex","otherNormals","otherVertCount","otherFaceNormal","Math","abs","otherNext","norm","sharedNormal1","sharedNormal2","$90a1bf3572dc4d5f$var$createObject","hasCachedModel","getCachedModel","parseModel","$90a1bf3572dc4d5f$var$sortByMaterial","a","b","elements","elementSize","isConditionalSegments","totalElements","sort","positions","Float32Array","quadArray","Array","bufferGeometry","BufferGeometry","prevMaterial","index0","numGroupVerts","offset","iElem","nElem","elem","j","elemNormals","addGroup","edgeMaterial","edgeMaterialCache","conditionalEdgeMaterialCache","Infinity","setAttribute","BufferAttribute","object3d","Mesh","controlArray0","controlArray1","directionArray","c0","c1","Loader","materialLibrary","WeakMap","partsCache","setMaterials","missingColorMaterial","MeshStandardMaterial","DEFAULT_MATERIAL_NAME","roughness","metalness","missingEdgeColorMaterial","LineBasicMaterial","missingConditionalEdgeColorMaterial","setPartsLibraryPath","path","preloadMaterials","url","colorLineRegex","directive","load","onLoad","onProgress","onError","computeBuildingSteps","addMaterial","setFileMap","matLib","getMaterial","finalMaterialPass","parentIsPassthrough","c","isLineSegments","traverse","isMesh","isArray","isMaterial","getMainMaterial","getMainEdgeMaterial","mat","lineParser","fillColor","edgeColor","alpha","isTransparent","luminance","finishType","parseLuminance","toUpperCase","isNaN","parseInt","max","min","setStyle","transparent","premultipliedAlpha","depthWrite","polygonOffset","polygonOffsetFactor","emissive","multiplyScalar","conditionalEdgeMaterial","lum","model","stepNumber","buildingStep","numBuildingSteps","$6c11e0c31e042374$export$7732348bb2ed1dd9","$7ePFa","mergeObject","object","addGeometry","geometries","geoms","uuid","arr","permuteAttribute","attribute","elemSize","verts","array","numVerts","floor","meshGeometries","linesGeometries","condLinesGeometries","updateMatrixWorld","normalMatrix","Matrix3","matrixWorld","attributes","normal","control0","control1","getNormalMatrix","applyNormalMatrix","groupIndex","groups","materialIndex","extractGroup","newGeometry","originalPositions","getAttribute","originalNormals","numVertsGroup","count","start","vertStart","vertEnd","subarray","mergedObject","meshMaterialsId","keys","meshGeometry","mergedGeometry","mergeGeometries","linesMaterialsId","lineGeometry","condLinesMaterialsId","condLineGeometry","condLines","constructionStep","numConstructionSteps"],"version":3,"file":"index.5fc992bc.js.map"}