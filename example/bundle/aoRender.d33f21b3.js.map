{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,S,E,C,C,C,E,O,O,I,C,G,O,C,S,C,E,Y,G,A,e,G,O,S,C,c,C,I,C,E,I,O,c,C,E,E,C,W,C,E,I,W,O,C,C,E,A,C,E,G,C,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,iB,I,G,I,E,E,SCyCA,IAAM,EAAU,IAAI,EAAA,kBAAiB,CAAG,GAAK,EAAG,EAAG,GAAK,EAAG,EAI3D,OAAM,UAAmC,EAAA,cAAa,CAErD,aAAc,CAEb,KAAK,GAEL,IAAI,CAAC,YAAY,CAAE,WAAY,IAAI,EAAA,sBAAqB,CAAG,CAAE,GAAK,EAAG,EAAG,GAAK,GAAK,EAAG,EAAG,GAAK,EAAG,CAAE,IAClG,IAAI,CAAC,YAAY,CAAE,KAAM,IAAI,EAAA,sBAAqB,CAAG,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAE,GAE5E,CAED,CAEA,IAAM,EAAY,IAAI,CAEtB,OAAM,EAEL,YAAa,CAAQ,CAAG,CAEvB,IAAI,CAAC,KAAK,CAAG,IAAI,EAAA,IAAG,CAAG,EAAW,EAEnC,CAEA,SAAU,CAET,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO,EAE5B,CAEA,OAAQ,CAAQ,CAAG,CAElB,EAAS,MAAM,CAAE,IAAI,CAAC,KAAK,CAAE,EAE9B,CAEA,IAAI,UAAW,CAEd,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,AAE3B,CAEA,IAAI,SAAU,CAAK,CAAG,CAErB,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAG,CAEvB,CAED,C,G,E,Q,S,C,C,C,E,E,E,O,C,4B,I,G,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,QCjBO,OAAM,EAEZ,IAAI,aAAc,CAEjB,M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C,C,C,E,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,O,C,G,E,E,O,C,G,E,E,O,C,G,E,E,O,C,E,G,E,Q,S,C,C,C,E,E,E,O,C,mB,I,GEvVO,IAAM,EAA6B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkF3C,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,yB,I,GCjFM,IAAM,EAAmC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiMjD,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,oB,I,GClMM,IAAM,EAA8B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoN5C,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,yB,I,GCjNM,IAAM,EAAmC,CAAC;;;;;;;;;;AAUjD,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,uB,I,G,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,QCWM,OAAM,EAEZ,aAAc,CAEb,IAAI,CAAC,KAAK,CAAG,IAAI,EAAA,0BAAyB,CAC1C,IAAI,CAAC,QAAQ,CAAG,IAAI,EAAA,2BAA0B,CAC9C,IAAI,CAAC,SAAS,CAAG,IAAI,EAAA,WAAU,CAC/B,IAAI,CAAC,WAAW,CAAG,IAAI,EAAA,WAAU,CACjC,IAAI,CAAC,gBAAgB,CAAG,KAExB,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAG,CAE/B,CAEA,WAAY,CAAG,CAAG,CAEjB,GAAM,CAAA,SAAE,CAAQ,CAAE,CAA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","sources":["<anon>","node_modules/three/examples/jsm/postprocessing/Pass.js","src/core/PathTracingSceneGenerator.js","node_modules/three-mesh-bvh/src/core/MeshBVH.js","node_modules/three-mesh-bvh/src/core/Constants.js","node_modules/three-mesh-bvh/src/core/build/buildTree.js","node_modules/three-mesh-bvh/src/core/build/geometryUtils.js","node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js","node_modules/three-mesh-bvh/src/core/build/splitUtils.js","node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js","node_modules/three-mesh-bvh/src/core/MeshBVHNode.js","node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js","node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js","node_modules/three-mesh-bvh/src/core/build/buildUtils.js","node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js","node_modules/three-mesh-bvh/src/math/OrientedBox.js","node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js","node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js","node_modules/three-mesh-bvh/src/math/MathUtilities.js","node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js","node_modules/three-mesh-bvh/src/utils/PrimitivePool.js","node_modules/three-mesh-bvh/src/core/cast/shapecast.js","node_modules/three-mesh-bvh/src/core/utils/BufferStack.js","node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js","node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js","node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js","node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js","node_modules/three-mesh-bvh/src/core/cast/refit.generated.js","node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js","node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js","node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js","node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js","node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js","node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js","node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js","node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js","node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js","node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js","node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js","node_modules/three-mesh-bvh/src/utils/BufferUtils.js","node_modules/three-mesh-bvh/src/core/cast/bvhcast.js","src/core/utils/StaticGeometryGenerator.js","src/core/utils/mergeGeometries.js","src/core/utils/BufferAttributeUtils.js","src/core/utils/GeometryPreparationUtils.js","src/core/utils/BakedGeometry.js","src/core/utils/MeshDiff.js","src/utils/bufferToHash.js","src/core/utils/convertToStaticGeometry.js","node_modules/three-mesh-bvh/src/gpu/BVHShaderGLSL.js","node_modules/three-mesh-bvh/src/gpu/glsl/common_functions.glsl.js","node_modules/three-mesh-bvh/src/gpu/glsl/bvh_distance_functions.glsl.js","node_modules/three-mesh-bvh/src/gpu/glsl/bvh_ray_functions.glsl.js","node_modules/three-mesh-bvh/src/gpu/glsl/bvh_struct_definitions.glsl.js","node_modules/three-mesh-bvh/src/gpu/MeshBVHUniformStruct.js","node_modules/three-mesh-bvh/src/gpu/VertexAttributeTexture.js","src/uniforms/MaterialsTexture.js","src/core/utils/sceneUpdateUtils.js","src/shader/structs/material_struct.glsl.js","src/shader/sampling/shape_sampling_functions.glsl.js","src/shader/rand/pcg.glsl.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      }\n    });\n  });\n\n  return dest;\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5b70\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5b70\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"RPVlj\", function(module, exports) {\n\n$parcel$export(module.exports, \"FullScreenQuad\", () => $0a1d3a5a6a49de03$export$3983474c8e6e978b);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $0a1d3a5a6a49de03$export$802bc10488da99c7 {\n    constructor(){\n        this.isPass = true;\n        // if set to true, the pass is processed by the composer\n        this.enabled = true;\n        // if set to true, the pass indicates to swap read and write buffer after rendering\n        this.needsSwap = true;\n        // if set to true, the pass clears its buffer before rendering\n        this.clear = false;\n        // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n        this.renderToScreen = false;\n    }\n    setSize() {}\n    render() {\n        console.error(\"THREE.Pass: .render() must be implemented in derived pass.\");\n    }\n    dispose() {}\n}\n// Helper for passes that need to fill the viewport with a single quad.\nconst $0a1d3a5a6a49de03$var$_camera = new (0, $ilwiq.OrthographicCamera)(-1, 1, 1, -1, 0, 1);\n// https://github.com/mrdoob/three.js/pull/21358\nclass $0a1d3a5a6a49de03$var$FullscreenTriangleGeometry extends (0, $ilwiq.BufferGeometry) {\n    constructor(){\n        super();\n        this.setAttribute(\"position\", new (0, $ilwiq.Float32BufferAttribute)([\n            -1,\n            3,\n            0,\n            -1,\n            -1,\n            0,\n            3,\n            -1,\n            0\n        ], 3));\n        this.setAttribute(\"uv\", new (0, $ilwiq.Float32BufferAttribute)([\n            0,\n            2,\n            0,\n            0,\n            2,\n            0\n        ], 2));\n    }\n}\nconst $0a1d3a5a6a49de03$var$_geometry = new $0a1d3a5a6a49de03$var$FullscreenTriangleGeometry();\nclass $0a1d3a5a6a49de03$export$3983474c8e6e978b {\n    constructor(material){\n        this._mesh = new (0, $ilwiq.Mesh)($0a1d3a5a6a49de03$var$_geometry, material);\n    }\n    dispose() {\n        this._mesh.geometry.dispose();\n    }\n    render(renderer) {\n        renderer.render(this._mesh, $0a1d3a5a6a49de03$var$_camera);\n    }\n    get material() {\n        return this._mesh.material;\n    }\n    set material(value) {\n        this._mesh.material = value;\n    }\n}\n\n});\n\nparcelRegister(\"hWj76\", function(module, exports) {\n\n$parcel$export(module.exports, \"PathTracingSceneGenerator\", () => $d0f6adfc7402c638$export$245b5237bb7038ea);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $6KVZ3 = parcelRequire(\"6KVZ3\");\nvar $alNGj = parcelRequire(\"alNGj\");\n\nvar $dCCOj = parcelRequire(\"dCCOj\");\n\nvar $8LUnK = parcelRequire(\"8LUnK\");\n// collect the textures from the materials\nfunction $d0f6adfc7402c638$var$getTextures(materials) {\n    const textureSet = new Set();\n    for(let i = 0, l = materials.length; i < l; i++){\n        const material = materials[i];\n        for(const key in material){\n            const value = material[key];\n            if (value && value.isTexture) textureSet.add(value);\n        }\n    }\n    return Array.from(textureSet);\n}\n// collect the lights in the scene\nfunction $d0f6adfc7402c638$var$getLights(objects) {\n    const lights = [];\n    const iesSet = new Set();\n    for(let i = 0, l = objects.length; i < l; i++)objects[i].traverse((c)=>{\n        if (c.visible) {\n            if (c.isRectAreaLight || c.isSpotLight || c.isPointLight || c.isDirectionalLight) {\n                lights.push(c);\n                if (c.iesMap) iesSet.add(c.iesMap);\n            }\n        }\n    });\n    const iesTextures = Array.from(iesSet).sort((a, b)=>{\n        if (a.uuid < b.uuid) return 1;\n        if (a.uuid > b.uuid) return -1;\n        return 0;\n    });\n    return {\n        lights: lights,\n        iesTextures: iesTextures\n    };\n}\nclass $d0f6adfc7402c638$export$245b5237bb7038ea {\n    get initialized() {\n        return Boolean(this.bvh);\n    }\n    constructor(objects){\n        // options\n        this.bvhOptions = {};\n        this.attributes = [\n            \"position\",\n            \"normal\",\n            \"tangent\",\n            \"color\",\n            \"uv\",\n            \"uv2\"\n        ];\n        this.generateBVH = true;\n        // state\n        this.bvh = null;\n        this.geometry = new (0, $ilwiq.BufferGeometry)();\n        this.staticGeometryGenerator = new (0, $dCCOj.StaticGeometryGenerator)(objects);\n        this._bvhWorker = null;\n        this._pendingGenerate = null;\n        this._buildAsync = false;\n        this._materialUuids = null;\n    }\n    setObjects(objects) {\n        this.staticGeometryGenerator.setObjects(objects);\n    }\n    setBVHWorker(bvhWorker) {\n        this._bvhWorker = bvhWorker;\n    }\n    async generateAsync(onProgress = null) {\n        if (!this._bvhWorker) throw new Error('PathTracingSceneGenerator: \"setBVHWorker\" must be called before \"generateAsync\" can be called.');\n        if (this.bvh instanceof Promise) {\n            // if a bvh is already being generated we can wait for that to finish\n            // and build another with the latest data while sharing the results.\n            if (!this._pendingGenerate) this._pendingGenerate = new Promise(async ()=>{\n                await this.bvh;\n                this._pendingGenerate = null;\n                // TODO: support multiple callbacks queued?\n                return this.generateAsync(onProgress);\n            });\n            return this._pendingGenerate;\n        } else {\n            this._buildAsync = true;\n            const result = this.generate(onProgress);\n            this._buildAsync = false;\n            result.bvh = this.bvh = await result.bvh;\n            return result;\n        }\n    }\n    generate(onProgress = null) {\n        const { staticGeometryGenerator: staticGeometryGenerator, geometry: geometry, attributes: attributes } = this;\n        const objects = staticGeometryGenerator.objects;\n        staticGeometryGenerator.attributes = attributes;\n        // update the skeleton animations in case WebGLRenderer is not running\n        // to update it.\n        objects.forEach((o)=>{\n            o.traverse((c)=>{\n                if (c.isSkinnedMesh && c.skeleton) c.skeleton.update();\n            });\n        });\n        // generate the geometry\n        const result = staticGeometryGenerator.generate(geometry);\n        const materials = result.materials;\n        let needsMaterialIndexUpdate = result.changeType !== (0, $dCCOj.NO_CHANGE) || this._materialUuids === null || this._materialUuids.length !== length;\n        if (!needsMaterialIndexUpdate) for(let i = 0, length1 = materials.length; i < length1; i++){\n            const material = materials[i];\n            if (material.uuid !== this._materialUuids[i]) {\n                needsMaterialIndexUpdate = true;\n                break;\n            }\n        }\n        const textures = $d0f6adfc7402c638$var$getTextures(materials);\n        const { lights: lights, iesTextures: iesTextures } = $d0f6adfc7402c638$var$getLights(objects);\n        if (needsMaterialIndexUpdate) {\n            (0, $8LUnK.updateMaterialIndexAttribute)(geometry, materials, materials);\n            this._materialUuids = materials.map((material)=>material.uuid);\n        }\n        // only generate a new bvh if the objects used have changed\n        if (this.generateBVH) {\n            if (this.bvh instanceof Promise) throw new Error(\"PathTracingSceneGenerator: BVH is already building asynchronously.\");\n            if (result.changeType === (0, $dCCOj.GEOMETRY_REBUILT)) {\n                const bvhOptions = {\n                    strategy: (0, $alNGj.SAH),\n                    maxLeafTris: 1,\n                    indirect: true,\n                    onProgress: onProgress,\n                    ...this.bvhOptions\n                };\n                if (this._buildAsync) this.bvh = this._bvhWorker.generate(geometry, bvhOptions);\n                else this.bvh = new (0, $6KVZ3.MeshBVH)(geometry, bvhOptions);\n            } else if (result.changeType === (0, $dCCOj.GEOMETRY_ADJUSTED)) this.bvh.refit();\n        }\n        return {\n            bvhChanged: result.changeType !== (0, $dCCOj.NO_CHANGE),\n            bvh: this.bvh,\n            needsMaterialIndexUpdate: needsMaterialIndexUpdate,\n            lights: lights,\n            iesTextures: iesTextures,\n            geometry: geometry,\n            materials: materials,\n            textures: textures,\n            objects: objects\n        };\n    }\n}\nclass $d0f6adfc7402c638$export$b42762e2bf679e84 extends $d0f6adfc7402c638$export$245b5237bb7038ea {\n    constructor(...args){\n        super(...args);\n        console.warn('DynamicPathTracingSceneGenerator has been deprecated and renamed to \"PathTracingSceneGenerator\".');\n    }\n}\nclass $d0f6adfc7402c638$export$5499aeafc5a5667b extends $d0f6adfc7402c638$export$245b5237bb7038ea {\n    constructor(...args){\n        super(...args);\n        console.warn('PathTracingSceneWorker has been deprecated and renamed to \"PathTracingSceneGenerator\".');\n    }\n}\n\n});\nparcelRegister(\"6KVZ3\", function(module, exports) {\n\n$parcel$export(module.exports, \"MeshBVH\", () => $4eb4044e12c26831$export$9d614b3bc2c4eacf);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $alNGj = parcelRequire(\"alNGj\");\n\nvar $knbvI = parcelRequire(\"knbvI\");\n\nvar $lenTA = parcelRequire(\"lenTA\");\n\nvar $eADNI = parcelRequire(\"eADNI\");\n\nvar $7EZfU = parcelRequire(\"7EZfU\");\n\nvar $8hs00 = parcelRequire(\"8hs00\");\n\nvar $8VlEg = parcelRequire(\"8VlEg\");\n\nvar $9Kyri = parcelRequire(\"9Kyri\");\n\nvar $ayHng = parcelRequire(\"ayHng\");\n\nvar $laUNa = parcelRequire(\"laUNa\");\n\nvar $1SnJR = parcelRequire(\"1SnJR\");\n\nvar $dhXUU = parcelRequire(\"dhXUU\");\n\nvar $dnRHH = parcelRequire(\"dnRHH\");\n\nvar $gDpfV = parcelRequire(\"gDpfV\");\n\nvar $iERXt = parcelRequire(\"iERXt\");\n\nvar $kNP8c = parcelRequire(\"kNP8c\");\n\nvar $ZxvHI = parcelRequire(\"ZxvHI\");\n\nvar $bD1WL = parcelRequire(\"bD1WL\");\n\nvar $gUrAj = parcelRequire(\"gUrAj\");\n\nvar $cSOJe = parcelRequire(\"cSOJe\");\n\nvar $dRxiJ = parcelRequire(\"dRxiJ\");\n\nvar $f1zUR = parcelRequire(\"f1zUR\");\nconst $4eb4044e12c26831$var$obb = /* @__PURE__ */ new (0, $lenTA.OrientedBox)();\nconst $4eb4044e12c26831$var$tempBox = /* @__PURE__ */ new (0, $ilwiq.Box3)();\nconst $4eb4044e12c26831$export$93ca5d3f8675ae4c = {\n    strategy: (0, $alNGj.CENTER),\n    maxDepth: 40,\n    maxLeafTris: 10,\n    useSharedArrayBuffer: false,\n    setBoundingBox: true,\n    onProgress: null,\n    indirect: false,\n    verbose: true\n};\nclass $4eb4044e12c26831$export$9d614b3bc2c4eacf {\n    static serialize(bvh, options = {}) {\n        options = {\n            cloneBuffers: true,\n            ...options\n        };\n        const geometry = bvh.geometry;\n        const rootData = bvh._roots;\n        const indirectBuffer = bvh._indirectBuffer;\n        const indexAttribute = geometry.getIndex();\n        let result;\n        if (options.cloneBuffers) result = {\n            roots: rootData.map((root)=>root.slice()),\n            index: indexAttribute ? indexAttribute.array.slice() : null,\n            indirectBuffer: indirectBuffer ? indirectBuffer.slice() : null\n        };\n        else result = {\n            roots: rootData,\n            index: indexAttribute ? indexAttribute.array : null,\n            indirectBuffer: indirectBuffer\n        };\n        return result;\n    }\n    static deserialize(data, geometry, options = {}) {\n        options = {\n            setIndex: true,\n            indirect: Boolean(data.indirectBuffer),\n            ...options\n        };\n        const { index: index, roots: roots, indirectBuffer: indirectBuffer } = data;\n        const bvh = new $4eb4044e12c26831$export$9d614b3bc2c4eacf(geometry, {\n            ...options,\n            [(0, $alNGj.SKIP_GENERATION)]: true\n        });\n        bvh._roots = roots;\n        bvh._indirectBuffer = indirectBuffer || null;\n        if (options.setIndex) {\n            const indexAttribute = geometry.getIndex();\n            if (indexAttribute === null) {\n                const newIndex = new (0, $ilwiq.BufferAttribute)(data.index, 1, false);\n                geometry.setIndex(newIndex);\n            } else if (indexAttribute.array !== index) {\n                indexAttribute.array.set(index);\n                indexAttribute.needsUpdate = true;\n            }\n        }\n        return bvh;\n    }\n    get indirect() {\n        return !!this._indirectBuffer;\n    }\n    constructor(geometry, options = {}){\n        if (!geometry.isBufferGeometry) throw new Error(\"MeshBVH: Only BufferGeometries are supported.\");\n        else if (geometry.index && geometry.index.isInterleavedBufferAttribute) throw new Error(\"MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.\");\n        // default options\n        options = Object.assign({\n            ...$4eb4044e12c26831$export$93ca5d3f8675ae4c,\n            // undocumented options\n            // Whether to skip generating the tree. Used for deserialization.\n            [(0, $alNGj.SKIP_GENERATION)]: false\n        }, options);\n        if (options.useSharedArrayBuffer && !(0, $cSOJe.isSharedArrayBufferSupported)()) throw new Error(\"MeshBVH: SharedArrayBuffer is not available.\");\n        // retain references to the geometry so we can use them it without having to\n        // take a geometry reference in every function.\n        this.geometry = geometry;\n        this._roots = null;\n        this._indirectBuffer = null;\n        if (!options[0, $alNGj.SKIP_GENERATION]) {\n            (0, $knbvI.buildPackedTree)(this, options);\n            if (!geometry.boundingBox && options.setBoundingBox) geometry.boundingBox = this.getBoundingBox(new (0, $ilwiq.Box3)());\n        }\n        const { _indirectBuffer: _indirectBuffer } = this;\n        this.resolveTriangleIndex = options.indirect ? (i)=>_indirectBuffer[i] : (i)=>i;\n    }\n    refit(nodeIndices = null) {\n        const refitFunc = this.indirect ? (0, $iERXt.refit_indirect) : (0, $ayHng.refit);\n        return refitFunc(this, nodeIndices);\n    }\n    traverse(callback, rootIndex = 0) {\n        const buffer = this._roots[rootIndex];\n        const uint32Array = new Uint32Array(buffer);\n        const uint16Array = new Uint16Array(buffer);\n        _traverse(0);\n        function _traverse(node32Index, depth = 0) {\n            const node16Index = node32Index * 2;\n            const isLeaf = uint16Array[node16Index + 15] === (0, $alNGj.IS_LEAFNODE_FLAG);\n            if (isLeaf) {\n                const offset = uint32Array[node32Index + 6];\n                const count = uint16Array[node16Index + 14];\n                callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n            } else {\n                // TODO: use node functions here\n                const left = node32Index + (0, $alNGj.BYTES_PER_NODE) / 4;\n                const right = uint32Array[node32Index + 6];\n                const splitAxis = uint32Array[node32Index + 7];\n                const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n                if (!stopTraversal) {\n                    _traverse(left, depth + 1);\n                    _traverse(right, depth + 1);\n                }\n            }\n        }\n    }\n    /* Core Cast Functions */ raycast(ray, materialOrSide = (0, $ilwiq.FrontSide)) {\n        const roots = this._roots;\n        const geometry = this.geometry;\n        const intersects = [];\n        const isMaterial = materialOrSide.isMaterial;\n        const isArrayMaterial = Array.isArray(materialOrSide);\n        const groups = geometry.groups;\n        const side = isMaterial ? materialOrSide.side : materialOrSide;\n        const raycastFunc = this.indirect ? (0, $kNP8c.raycast_indirect) : (0, $laUNa.raycast);\n        for(let i = 0, l = roots.length; i < l; i++){\n            const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n            const startCount = intersects.length;\n            raycastFunc(this, i, materialSide, ray, intersects);\n            if (isArrayMaterial) {\n                const materialIndex = groups[i].materialIndex;\n                for(let j = startCount, jl = intersects.length; j < jl; j++)intersects[j].face.materialIndex = materialIndex;\n            }\n        }\n        return intersects;\n    }\n    raycastFirst(ray, materialOrSide = (0, $ilwiq.FrontSide)) {\n        const roots = this._roots;\n        const geometry = this.geometry;\n        const isMaterial = materialOrSide.isMaterial;\n        const isArrayMaterial = Array.isArray(materialOrSide);\n        let closestResult = null;\n        const groups = geometry.groups;\n        const side = isMaterial ? materialOrSide.side : materialOrSide;\n        const raycastFirstFunc = this.indirect ? (0, $ZxvHI.raycastFirst_indirect) : (0, $1SnJR.raycastFirst);\n        for(let i = 0, l = roots.length; i < l; i++){\n            const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n            const result = raycastFirstFunc(this, i, materialSide, ray);\n            if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n                closestResult = result;\n                if (isArrayMaterial) result.face.materialIndex = groups[i].materialIndex;\n            }\n        }\n        return closestResult;\n    }\n    intersectsGeometry(otherGeometry, geomToMesh) {\n        let result = false;\n        const roots = this._roots;\n        const intersectsGeometryFunc = this.indirect ? (0, $bD1WL.intersectsGeometry_indirect) : (0, $dhXUU.intersectsGeometry);\n        for(let i = 0, l = roots.length; i < l; i++){\n            result = intersectsGeometryFunc(this, i, otherGeometry, geomToMesh);\n            if (result) break;\n        }\n        return result;\n    }\n    shapecast(callbacks) {\n        const triangle = (0, $7EZfU.ExtendedTrianglePool).getPrimitive();\n        const iterateFunc = this.indirect ? (0, $gDpfV.iterateOverTriangles_indirect) : (0, $9Kyri.iterateOverTriangles);\n        let { boundsTraverseOrder: boundsTraverseOrder, intersectsBounds: intersectsBounds, intersectsRange: intersectsRange, intersectsTriangle: intersectsTriangle } = callbacks;\n        // wrap the intersectsRange function\n        if (intersectsRange && intersectsTriangle) {\n            const originalIntersectsRange = intersectsRange;\n            intersectsRange = (offset, count, contained, depth, nodeIndex)=>{\n                if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle);\n                return true;\n            };\n        } else if (!intersectsRange) {\n            if (intersectsTriangle) intersectsRange = (offset, count, contained, depth)=>{\n                return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle);\n            };\n            else intersectsRange = (offset, count, contained)=>{\n                return contained;\n            };\n        }\n        // run shapecast\n        let result = false;\n        let byteOffset = 0;\n        const roots = this._roots;\n        for(let i = 0, l = roots.length; i < l; i++){\n            const root = roots[i];\n            result = (0, $8hs00.shapecast)(this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n            if (result) break;\n            byteOffset += root.byteLength;\n        }\n        (0, $7EZfU.ExtendedTrianglePool).releasePrimitive(triangle);\n        return result;\n    }\n    bvhcast(otherBvh, matrixToLocal, callbacks) {\n        let { intersectsRanges: intersectsRanges, intersectsTriangles: intersectsTriangles } = callbacks;\n        const triangle1 = (0, $7EZfU.ExtendedTrianglePool).getPrimitive();\n        const indexAttr1 = this.geometry.index;\n        const positionAttr1 = this.geometry.attributes.position;\n        const assignTriangle1 = this.indirect ? (i1)=>{\n            const ti = this.resolveTriangleIndex(i1);\n            (0, $dRxiJ.setTriangle)(triangle1, ti * 3, indexAttr1, positionAttr1);\n        } : (i1)=>{\n            (0, $dRxiJ.setTriangle)(triangle1, i1 * 3, indexAttr1, positionAttr1);\n        };\n        const triangle2 = (0, $7EZfU.ExtendedTrianglePool).getPrimitive();\n        const indexAttr2 = otherBvh.geometry.index;\n        const positionAttr2 = otherBvh.geometry.attributes.position;\n        const assignTriangle2 = otherBvh.indirect ? (i2)=>{\n            const ti2 = otherBvh.resolveTriangleIndex(i2);\n            (0, $dRxiJ.setTriangle)(triangle2, ti2 * 3, indexAttr2, positionAttr2);\n        } : (i2)=>{\n            (0, $dRxiJ.setTriangle)(triangle2, i2 * 3, indexAttr2, positionAttr2);\n        };\n        // generate triangle callback if needed\n        if (intersectsTriangles) {\n            const iterateOverDoubleTriangles = (offset1, count1, offset2, count2, depth1, index1, depth2, index2)=>{\n                for(let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++){\n                    assignTriangle2(i2);\n                    triangle2.a.applyMatrix4(matrixToLocal);\n                    triangle2.b.applyMatrix4(matrixToLocal);\n                    triangle2.c.applyMatrix4(matrixToLocal);\n                    triangle2.needsUpdate = true;\n                    for(let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++){\n                        assignTriangle1(i1);\n                        triangle1.needsUpdate = true;\n                        if (intersectsTriangles(triangle1, triangle2, i1, i2, depth1, index1, depth2, index2)) return true;\n                    }\n                }\n                return false;\n            };\n            if (intersectsRanges) {\n                const originalIntersectsRanges = intersectsRanges;\n                intersectsRanges = function(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n                    if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);\n                    return true;\n                };\n            } else intersectsRanges = iterateOverDoubleTriangles;\n        }\n        return (0, $f1zUR.bvhcast)(this, otherBvh, matrixToLocal, intersectsRanges);\n    }\n    /* Derived Cast Functions */ intersectsBox(box, boxToMesh) {\n        $4eb4044e12c26831$var$obb.set(box.min, box.max, boxToMesh);\n        $4eb4044e12c26831$var$obb.needsUpdate = true;\n        return this.shapecast({\n            intersectsBounds: (box)=>$4eb4044e12c26831$var$obb.intersectsBox(box),\n            intersectsTriangle: (tri)=>$4eb4044e12c26831$var$obb.intersectsTriangle(tri)\n        });\n    }\n    intersectsSphere(sphere) {\n        return this.shapecast({\n            intersectsBounds: (box)=>sphere.intersectsBox(box),\n            intersectsTriangle: (tri)=>tri.intersectsSphere(sphere)\n        });\n    }\n    closestPointToGeometry(otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {\n        const closestPointToGeometryFunc = this.indirect ? (0, $gUrAj.closestPointToGeometry_indirect) : (0, $dnRHH.closestPointToGeometry);\n        return closestPointToGeometryFunc(this, otherGeometry, geometryToBvh, target1, target2, minThreshold, maxThreshold);\n    }\n    closestPointToPoint(point, target = {}, minThreshold = 0, maxThreshold = Infinity) {\n        return (0, $8VlEg.closestPointToPoint)(this, point, target, minThreshold, maxThreshold);\n    }\n    getBoundingBox(target) {\n        target.makeEmpty();\n        const roots = this._roots;\n        roots.forEach((buffer)=>{\n            (0, $eADNI.arrayToBox)(0, new Float32Array(buffer), $4eb4044e12c26831$var$tempBox);\n            target.union($4eb4044e12c26831$var$tempBox);\n        });\n        return target;\n    }\n}\n\n});\nparcelRegister(\"alNGj\", function(module, exports) {\n\n$parcel$export(module.exports, \"CENTER\", () => $78926744db4a8a3e$export$91c2158bc24c63d4);\n$parcel$export(module.exports, \"AVERAGE\", () => $78926744db4a8a3e$export$d3bfe4097a2a8542);\n$parcel$export(module.exports, \"SAH\", () => $78926744db4a8a3e$export$2b2cc3fb4f03d723);\n$parcel$export(module.exports, \"CONTAINED\", () => $78926744db4a8a3e$export$82ad94f0a038b67a);\n$parcel$export(module.exports, \"TRIANGLE_INTERSECT_COST\", () => $78926744db4a8a3e$export$22e1995328fd3cd9);\n$parcel$export(module.exports, \"TRAVERSAL_COST\", () => $78926744db4a8a3e$export$f4b101accf1b23d1);\n$parcel$export(module.exports, \"BYTES_PER_NODE\", () => $78926744db4a8a3e$export$a08e7d18fbc53be5);\n$parcel$export(module.exports, \"IS_LEAFNODE_FLAG\", () => $78926744db4a8a3e$export$661fddb62bfe0e42);\n$parcel$export(module.exports, \"FLOAT32_EPSILON\", () => $78926744db4a8a3e$export$859129fb5c8f4dc1);\n$parcel$export(module.exports, \"SKIP_GENERATION\", () => $78926744db4a8a3e$export$abef70518a11a6ba);\n// Split strategy constants\nconst $78926744db4a8a3e$export$91c2158bc24c63d4 = 0;\nconst $78926744db4a8a3e$export$d3bfe4097a2a8542 = 1;\nconst $78926744db4a8a3e$export$2b2cc3fb4f03d723 = 2;\nconst $78926744db4a8a3e$export$34b5498ca69d033 = 0;\nconst $78926744db4a8a3e$export$a26e00882057cd76 = 1;\nconst $78926744db4a8a3e$export$82ad94f0a038b67a = 2;\nconst $78926744db4a8a3e$export$22e1995328fd3cd9 = 1.25;\nconst $78926744db4a8a3e$export$f4b101accf1b23d1 = 1;\nconst $78926744db4a8a3e$export$a08e7d18fbc53be5 = 32;\nconst $78926744db4a8a3e$export$661fddb62bfe0e42 = 0xFFFF;\nconst $78926744db4a8a3e$export$859129fb5c8f4dc1 = Math.pow(2, -24);\nconst $78926744db4a8a3e$export$abef70518a11a6ba = Symbol(\"SKIP_GENERATION\");\n\n});\n\nparcelRegister(\"knbvI\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildPackedTree\", () => $ed4ee2639a9fd94e$export$e63bca57f220b8e3);\n\nvar $5Gkg5 = parcelRequire(\"5Gkg5\");\n\nvar $6zZ33 = parcelRequire(\"6zZ33\");\n\nvar $4rNvL = parcelRequire(\"4rNvL\");\n\nvar $O2f62 = parcelRequire(\"O2f62\");\n\nvar $alNGj = parcelRequire(\"alNGj\");\n\nvar $8aRzr = parcelRequire(\"8aRzr\");\n\nvar $fe03E = parcelRequire(\"fe03E\");\n\nvar $8yQ90 = parcelRequire(\"8yQ90\");\nfunction $ed4ee2639a9fd94e$export$6008de7a0114426c(geometry, useSharedArrayBuffer) {\n    const triCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n    const useUint32 = triCount > 2 ** 16;\n    const byteCount = useUint32 ? 4 : 2;\n    const buffer = useSharedArrayBuffer ? new SharedArrayBuffer(triCount * byteCount) : new ArrayBuffer(triCount * byteCount);\n    const indirectBuffer = useUint32 ? new Uint32Array(buffer) : new Uint16Array(buffer);\n    for(let i = 0, l = indirectBuffer.length; i < l; i++)indirectBuffer[i] = i;\n    return indirectBuffer;\n}\nfunction $ed4ee2639a9fd94e$export$9896244d8c99a4d0(bvh, triangleBounds, offset, count, options) {\n    // epxand variables\n    const { maxDepth: maxDepth, verbose: verbose, maxLeafTris: maxLeafTris, strategy: strategy, onProgress: onProgress, indirect: indirect } = options;\n    const indirectBuffer = bvh._indirectBuffer;\n    const geometry = bvh.geometry;\n    const indexArray = geometry.index ? geometry.index.array : null;\n    const partionFunc = indirect ? (0, $fe03E.partition_indirect) : (0, $8aRzr.partition);\n    // generate intermediate variables\n    const totalTriangles = (0, $5Gkg5.getTriCount)(geometry);\n    const cacheCentroidBoundingData = new Float32Array(6);\n    let reachedMaxDepth = false;\n    const root = new (0, $O2f62.MeshBVHNode)();\n    (0, $6zZ33.getBounds)(triangleBounds, offset, count, root.boundingData, cacheCentroidBoundingData);\n    splitNode(root, offset, count, cacheCentroidBoundingData);\n    return root;\n    function triggerProgress(trianglesProcessed) {\n        if (onProgress) onProgress(trianglesProcessed / totalTriangles);\n    }\n    // either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n    // recording the offset and count of its triangles and writing them into the reordered geometry index.\n    function splitNode(node, offset, count, centroidBoundingData = null, depth = 0) {\n        if (!reachedMaxDepth && depth >= maxDepth) {\n            reachedMaxDepth = true;\n            if (verbose) {\n                console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`);\n                console.warn(geometry);\n            }\n        }\n        // early out if we've met our capacity\n        if (count <= maxLeafTris || depth >= maxDepth) {\n            triggerProgress(offset + count);\n            node.offset = offset;\n            node.count = count;\n            return node;\n        }\n        // Find where to split the volume\n        const split = (0, $4rNvL.getOptimalSplit)(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);\n        if (split.axis === -1) {\n            triggerProgress(offset + count);\n            node.offset = offset;\n            node.count = count;\n            return node;\n        }\n        const splitOffset = partionFunc(indirectBuffer, indexArray, triangleBounds, offset, count, split);\n        // create the two new child nodes\n        if (splitOffset === offset || splitOffset === offset + count) {\n            triggerProgress(offset + count);\n            node.offset = offset;\n            node.count = count;\n        } else {\n            node.splitAxis = split.axis;\n            // create the left child and compute its bounding box\n            const left = new (0, $O2f62.MeshBVHNode)();\n            const lstart = offset;\n            const lcount = splitOffset - offset;\n            node.left = left;\n            (0, $6zZ33.getBounds)(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);\n            splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);\n            // repeat for right\n            const right = new (0, $O2f62.MeshBVHNode)();\n            const rstart = splitOffset;\n            const rcount = count - lcount;\n            node.right = right;\n            (0, $6zZ33.getBounds)(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);\n            splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);\n        }\n        return node;\n    }\n}\nfunction $ed4ee2639a9fd94e$export$e63bca57f220b8e3(bvh, options) {\n    const geometry = bvh.geometry;\n    if (options.indirect) {\n        bvh._indirectBuffer = $ed4ee2639a9fd94e$export$6008de7a0114426c(geometry, options.useSharedArrayBuffer);\n        if ((0, $5Gkg5.hasGroupGaps)(geometry) && !options.verbose) console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. BVH may incorrectly report intersections on unrendered portions of the geometry.');\n    }\n    if (!bvh._indirectBuffer) (0, $5Gkg5.ensureIndex)(geometry, options);\n    const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n    const triangleBounds = (0, $6zZ33.computeTriangleBounds)(geometry);\n    const geometryRanges = options.indirect ? (0, $5Gkg5.getFullGeometryRange)(geometry) : (0, $5Gkg5.getRootIndexRanges)(geometry);\n    bvh._roots = geometryRanges.map((range)=>{\n        const root = $ed4ee2639a9fd94e$export$9896244d8c99a4d0(bvh, triangleBounds, range.offset, range.count, options);\n        const nodeCount = (0, $8yQ90.countNodes)(root);\n        const buffer = new BufferConstructor((0, $alNGj.BYTES_PER_NODE) * nodeCount);\n        (0, $8yQ90.populateBuffer)(0, root, buffer);\n        return buffer;\n    });\n}\n\n});\nparcelRegister(\"5Gkg5\", function(module, exports) {\n\n$parcel$export(module.exports, \"getVertexCount\", () => $423096e95cd96e19$export$bb010cc24ecaa644);\n$parcel$export(module.exports, \"getTriCount\", () => $423096e95cd96e19$export$c56c51fae37b2d63);\n$parcel$export(module.exports, \"getIndexArray\", () => $423096e95cd96e19$export$62808f0201824da2);\n$parcel$export(module.exports, \"ensureIndex\", () => $423096e95cd96e19$export$90fd303420808ebb);\n$parcel$export(module.exports, \"getFullGeometryRange\", () => $423096e95cd96e19$export$8c9d42783264c26e);\n$parcel$export(module.exports, \"getRootIndexRanges\", () => $423096e95cd96e19$export$fd7a16c461f5043c);\n$parcel$export(module.exports, \"hasGroupGaps\", () => $423096e95cd96e19$export$d3cf4eabab21775d);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nfunction $423096e95cd96e19$export$bb010cc24ecaa644(geo) {\n    return geo.index ? geo.index.count : geo.attributes.position.count;\n}\nfunction $423096e95cd96e19$export$c56c51fae37b2d63(geo) {\n    return $423096e95cd96e19$export$bb010cc24ecaa644(geo) / 3;\n}\nfunction $423096e95cd96e19$export$62808f0201824da2(vertexCount, BufferConstructor = ArrayBuffer) {\n    if (vertexCount > 65535) return new Uint32Array(new BufferConstructor(4 * vertexCount));\n    else return new Uint16Array(new BufferConstructor(2 * vertexCount));\n}\nfunction $423096e95cd96e19$export$90fd303420808ebb(geo, options) {\n    if (!geo.index) {\n        const vertexCount = geo.attributes.position.count;\n        const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n        const index = $423096e95cd96e19$export$62808f0201824da2(vertexCount, BufferConstructor);\n        geo.setIndex(new (0, $ilwiq.BufferAttribute)(index, 1));\n        for(let i = 0; i < vertexCount; i++)index[i] = i;\n    }\n}\nfunction $423096e95cd96e19$export$8c9d42783264c26e(geo) {\n    const triCount = $423096e95cd96e19$export$c56c51fae37b2d63(geo);\n    const drawRange = geo.drawRange;\n    const start = drawRange.start / 3;\n    const end = (drawRange.start + drawRange.count) / 3;\n    const offset = Math.max(0, start);\n    const count = Math.min(triCount, end) - offset;\n    return [\n        {\n            offset: Math.floor(offset),\n            count: Math.floor(count)\n        }\n    ];\n}\nfunction $423096e95cd96e19$export$fd7a16c461f5043c(geo) {\n    if (!geo.groups || !geo.groups.length) return $423096e95cd96e19$export$8c9d42783264c26e(geo);\n    const ranges = [];\n    const rangeBoundaries = new Set();\n    const drawRange = geo.drawRange;\n    const drawRangeStart = drawRange.start / 3;\n    const drawRangeEnd = (drawRange.start + drawRange.count) / 3;\n    for (const group of geo.groups){\n        const groupStart = group.start / 3;\n        const groupEnd = (group.start + group.count) / 3;\n        rangeBoundaries.add(Math.max(drawRangeStart, groupStart));\n        rangeBoundaries.add(Math.min(drawRangeEnd, groupEnd));\n    }\n    // note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n    const sortedBoundaries = Array.from(rangeBoundaries.values()).sort((a, b)=>a - b);\n    for(let i = 0; i < sortedBoundaries.length - 1; i++){\n        const start = sortedBoundaries[i];\n        const end = sortedBoundaries[i + 1];\n        ranges.push({\n            offset: Math.floor(start),\n            count: Math.floor(end - start)\n        });\n    }\n    return ranges;\n}\nfunction $423096e95cd96e19$export$d3cf4eabab21775d(geometry) {\n    if (geometry.groups.length === 0) return false;\n    const vertexCount = $423096e95cd96e19$export$c56c51fae37b2d63(geometry);\n    const groups = $423096e95cd96e19$export$fd7a16c461f5043c(geometry).sort((a, b)=>a.offset - b.offset);\n    const finalGroup = groups[groups.length - 1];\n    finalGroup.count = Math.min(vertexCount - finalGroup.offset, finalGroup.count);\n    let total = 0;\n    groups.forEach(({ count: count })=>total += count);\n    return vertexCount !== total;\n}\n\n});\n\nparcelRegister(\"6zZ33\", function(module, exports) {\n\n$parcel$export(module.exports, \"getBounds\", () => $4ca55de292e93eb1$export$becd1e645219fa23);\n$parcel$export(module.exports, \"computeTriangleBounds\", () => $4ca55de292e93eb1$export$b3cc4d5d5179e78c);\n\nvar $alNGj = parcelRequire(\"alNGj\");\n\nvar $5Gkg5 = parcelRequire(\"5Gkg5\");\nfunction $4ca55de292e93eb1$export$becd1e645219fa23(triangleBounds, offset, count, target, centroidTarget) {\n    let minx = Infinity;\n    let miny = Infinity;\n    let minz = Infinity;\n    let maxx = -Infinity;\n    let maxy = -Infinity;\n    let maxz = -Infinity;\n    let cminx = Infinity;\n    let cminy = Infinity;\n    let cminz = Infinity;\n    let cmaxx = -Infinity;\n    let cmaxy = -Infinity;\n    let cmaxz = -Infinity;\n    for(let i = offset * 6, end = (offset + count) * 6; i < end; i += 6){\n        const cx = triangleBounds[i + 0];\n        const hx = triangleBounds[i + 1];\n        const lx = cx - hx;\n        const rx = cx + hx;\n        if (lx < minx) minx = lx;\n        if (rx > maxx) maxx = rx;\n        if (cx < cminx) cminx = cx;\n        if (cx > cmaxx) cmaxx = cx;\n        const cy = triangleBounds[i + 2];\n        const hy = triangleBounds[i + 3];\n        const ly = cy - hy;\n        const ry = cy + hy;\n        if (ly < miny) miny = ly;\n        if (ry > maxy) maxy = ry;\n        if (cy < cminy) cminy = cy;\n        if (cy > cmaxy) cmaxy = cy;\n        const cz = triangleBounds[i + 4];\n        const hz = triangleBounds[i + 5];\n        const lz = cz - hz;\n        const rz = cz + hz;\n        if (lz < minz) minz = lz;\n        if (rz > maxz) maxz = rz;\n        if (cz < cminz) cminz = cz;\n        if (cz > cmaxz) cmaxz = cz;\n    }\n    target[0] = minx;\n    target[1] = miny;\n    target[2] = minz;\n    target[3] = maxx;\n    target[4] = maxy;\n    target[5] = maxz;\n    centroidTarget[0] = cminx;\n    centroidTarget[1] = cminy;\n    centroidTarget[2] = cminz;\n    centroidTarget[3] = cmaxx;\n    centroidTarget[4] = cmaxy;\n    centroidTarget[5] = cmaxz;\n}\nfunction $4ca55de292e93eb1$export$b3cc4d5d5179e78c(geo, target = null, offset = null, count = null) {\n    const posAttr = geo.attributes.position;\n    const index = geo.index ? geo.index.array : null;\n    const triCount = (0, $5Gkg5.getTriCount)(geo);\n    const normalized = posAttr.normalized;\n    let triangleBounds;\n    if (target === null) {\n        triangleBounds = new Float32Array(triCount * 24);\n        offset = 0;\n        count = triCount;\n    } else {\n        triangleBounds = target;\n        offset = offset || 0;\n        count = count || triCount;\n    }\n    // used for non-normalized positions\n    const posArr = posAttr.array;\n    // support for an interleaved position buffer\n    const bufferOffset = posAttr.offset || 0;\n    let stride = 3;\n    if (posAttr.isInterleavedBufferAttribute) stride = posAttr.data.stride;\n    // used for normalized positions\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\"\n    ];\n    for(let tri = offset; tri < offset + count; tri++){\n        const tri3 = tri * 3;\n        const tri6 = tri * 6;\n        let ai = tri3 + 0;\n        let bi = tri3 + 1;\n        let ci = tri3 + 2;\n        if (index) {\n            ai = index[ai];\n            bi = index[bi];\n            ci = index[ci];\n        }\n        // we add the stride and offset here since we access the array directly\n        // below for the sake of performance\n        if (!normalized) {\n            ai = ai * stride + bufferOffset;\n            bi = bi * stride + bufferOffset;\n            ci = ci * stride + bufferOffset;\n        }\n        for(let el = 0; el < 3; el++){\n            let a, b, c;\n            if (normalized) {\n                a = posAttr[getters[el]](ai);\n                b = posAttr[getters[el]](bi);\n                c = posAttr[getters[el]](ci);\n            } else {\n                a = posArr[ai + el];\n                b = posArr[bi + el];\n                c = posArr[ci + el];\n            }\n            let min = a;\n            if (b < min) min = b;\n            if (c < min) min = c;\n            let max = a;\n            if (b > max) max = b;\n            if (c > max) max = c;\n            // Increase the bounds size by float32 epsilon to avoid precision errors when\n            // converting to 32 bit float. Scale the epsilon by the size of the numbers being\n            // worked with.\n            const halfExtents = (max - min) / 2;\n            const el2 = el * 2;\n            triangleBounds[tri6 + el2 + 0] = min + halfExtents;\n            triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * (0, $alNGj.FLOAT32_EPSILON);\n        }\n    }\n    return triangleBounds;\n}\n\n});\n\nparcelRegister(\"4rNvL\", function(module, exports) {\n\n$parcel$export(module.exports, \"getOptimalSplit\", () => $33d016ef2ae8a9ff$export$9e40712018083c80);\n\nvar $eADNI = parcelRequire(\"eADNI\");\n\nvar $alNGj = parcelRequire(\"alNGj\");\nconst $33d016ef2ae8a9ff$var$BIN_COUNT = 32;\nconst $33d016ef2ae8a9ff$var$binsSort = (a, b)=>a.candidate - b.candidate;\nconst $33d016ef2ae8a9ff$var$sahBins = new Array($33d016ef2ae8a9ff$var$BIN_COUNT).fill().map(()=>{\n    return {\n        count: 0,\n        bounds: new Float32Array(6),\n        rightCacheBounds: new Float32Array(6),\n        leftCacheBounds: new Float32Array(6),\n        candidate: 0\n    };\n});\nconst $33d016ef2ae8a9ff$var$leftBounds = new Float32Array(6);\nfunction $33d016ef2ae8a9ff$export$9e40712018083c80(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {\n    let axis = -1;\n    let pos = 0;\n    // Center\n    if (strategy === (0, $alNGj.CENTER)) {\n        axis = (0, $eADNI.getLongestEdgeIndex)(centroidBoundingData);\n        if (axis !== -1) pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;\n    } else if (strategy === (0, $alNGj.AVERAGE)) {\n        axis = (0, $eADNI.getLongestEdgeIndex)(nodeBoundingData);\n        if (axis !== -1) pos = $33d016ef2ae8a9ff$var$getAverage(triangleBounds, offset, count, axis);\n    } else if (strategy === (0, $alNGj.SAH)) {\n        const rootSurfaceArea = (0, $eADNI.computeSurfaceArea)(nodeBoundingData);\n        let bestCost = (0, $alNGj.TRIANGLE_INTERSECT_COST) * count;\n        // iterate over all axes\n        const cStart = offset * 6;\n        const cEnd = (offset + count) * 6;\n        for(let a = 0; a < 3; a++){\n            const axisLeft = centroidBoundingData[a];\n            const axisRight = centroidBoundingData[a + 3];\n            const axisLength = axisRight - axisLeft;\n            const binWidth = axisLength / $33d016ef2ae8a9ff$var$BIN_COUNT;\n            // If we have fewer triangles than we're planning to split then just check all\n            // the triangle positions because it will be faster.\n            if (count < $33d016ef2ae8a9ff$var$BIN_COUNT / 4) {\n                // initialize the bin candidates\n                const truncatedBins = [\n                    ...$33d016ef2ae8a9ff$var$sahBins\n                ];\n                truncatedBins.length = count;\n                // set the candidates\n                let b = 0;\n                for(let c = cStart; c < cEnd; c += 6, b++){\n                    const bin = truncatedBins[b];\n                    bin.candidate = triangleBounds[c + 2 * a];\n                    bin.count = 0;\n                    const { bounds: bounds, leftCacheBounds: leftCacheBounds, rightCacheBounds: rightCacheBounds } = bin;\n                    for(let d = 0; d < 3; d++){\n                        rightCacheBounds[d] = Infinity;\n                        rightCacheBounds[d + 3] = -Infinity;\n                        leftCacheBounds[d] = Infinity;\n                        leftCacheBounds[d + 3] = -Infinity;\n                        bounds[d] = Infinity;\n                        bounds[d + 3] = -Infinity;\n                    }\n                    (0, $eADNI.expandByTriangleBounds)(c, triangleBounds, bounds);\n                }\n                truncatedBins.sort($33d016ef2ae8a9ff$var$binsSort);\n                // remove redundant splits\n                let splitCount = count;\n                for(let bi = 0; bi < splitCount; bi++){\n                    const bin = truncatedBins[bi];\n                    while(bi + 1 < splitCount && truncatedBins[bi + 1].candidate === bin.candidate){\n                        truncatedBins.splice(bi + 1, 1);\n                        splitCount--;\n                    }\n                }\n                // find the appropriate bin for each triangle and expand the bounds.\n                for(let c = cStart; c < cEnd; c += 6){\n                    const center = triangleBounds[c + 2 * a];\n                    for(let bi = 0; bi < splitCount; bi++){\n                        const bin = truncatedBins[bi];\n                        if (center >= bin.candidate) (0, $eADNI.expandByTriangleBounds)(c, triangleBounds, bin.rightCacheBounds);\n                        else {\n                            (0, $eADNI.expandByTriangleBounds)(c, triangleBounds, bin.leftCacheBounds);\n                            bin.count++;\n                        }\n                    }\n                }\n                // expand all the bounds\n                for(let bi = 0; bi < splitCount; bi++){\n                    const bin = truncatedBins[bi];\n                    const leftCount = bin.count;\n                    const rightCount = count - bin.count;\n                    // check the cost of this split\n                    const leftBounds = bin.leftCacheBounds;\n                    const rightBounds = bin.rightCacheBounds;\n                    let leftProb = 0;\n                    if (leftCount !== 0) leftProb = (0, $eADNI.computeSurfaceArea)(leftBounds) / rootSurfaceArea;\n                    let rightProb = 0;\n                    if (rightCount !== 0) rightProb = (0, $eADNI.computeSurfaceArea)(rightBounds) / rootSurfaceArea;\n                    const cost = (0, $alNGj.TRAVERSAL_COST) + (0, $alNGj.TRIANGLE_INTERSECT_COST) * (leftProb * leftCount + rightProb * rightCount);\n                    if (cost < bestCost) {\n                        axis = a;\n                        bestCost = cost;\n                        pos = bin.candidate;\n                    }\n                }\n            } else {\n                // reset the bins\n                for(let i = 0; i < $33d016ef2ae8a9ff$var$BIN_COUNT; i++){\n                    const bin = $33d016ef2ae8a9ff$var$sahBins[i];\n                    bin.count = 0;\n                    bin.candidate = axisLeft + binWidth + i * binWidth;\n                    const bounds = bin.bounds;\n                    for(let d = 0; d < 3; d++){\n                        bounds[d] = Infinity;\n                        bounds[d + 3] = -Infinity;\n                    }\n                }\n                // iterate over all center positions\n                for(let c = cStart; c < cEnd; c += 6){\n                    const triCenter = triangleBounds[c + 2 * a];\n                    const relativeCenter = triCenter - axisLeft;\n                    // in the partition function if the centroid lies on the split plane then it is\n                    // considered to be on the right side of the split\n                    let binIndex = ~~(relativeCenter / binWidth);\n                    if (binIndex >= $33d016ef2ae8a9ff$var$BIN_COUNT) binIndex = $33d016ef2ae8a9ff$var$BIN_COUNT - 1;\n                    const bin = $33d016ef2ae8a9ff$var$sahBins[binIndex];\n                    bin.count++;\n                    (0, $eADNI.expandByTriangleBounds)(c, triangleBounds, bin.bounds);\n                }\n                // cache the unioned bounds from right to left so we don't have to regenerate them each time\n                const lastBin = $33d016ef2ae8a9ff$var$sahBins[$33d016ef2ae8a9ff$var$BIN_COUNT - 1];\n                (0, $eADNI.copyBounds)(lastBin.bounds, lastBin.rightCacheBounds);\n                for(let i = $33d016ef2ae8a9ff$var$BIN_COUNT - 2; i >= 0; i--){\n                    const bin = $33d016ef2ae8a9ff$var$sahBins[i];\n                    const nextBin = $33d016ef2ae8a9ff$var$sahBins[i + 1];\n                    (0, $eADNI.unionBounds)(bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds);\n                }\n                let leftCount = 0;\n                for(let i = 0; i < $33d016ef2ae8a9ff$var$BIN_COUNT - 1; i++){\n                    const bin = $33d016ef2ae8a9ff$var$sahBins[i];\n                    const binCount = bin.count;\n                    const bounds = bin.bounds;\n                    const nextBin = $33d016ef2ae8a9ff$var$sahBins[i + 1];\n                    const rightBounds = nextBin.rightCacheBounds;\n                    // don't do anything with the bounds if the new bounds have no triangles\n                    if (binCount !== 0) {\n                        if (leftCount === 0) (0, $eADNI.copyBounds)(bounds, $33d016ef2ae8a9ff$var$leftBounds);\n                        else (0, $eADNI.unionBounds)(bounds, $33d016ef2ae8a9ff$var$leftBounds, $33d016ef2ae8a9ff$var$leftBounds);\n                    }\n                    leftCount += binCount;\n                    // check the cost of this split\n                    let leftProb = 0;\n                    let rightProb = 0;\n                    if (leftCount !== 0) leftProb = (0, $eADNI.computeSurfaceArea)($33d016ef2ae8a9ff$var$leftBounds) / rootSurfaceArea;\n                    const rightCount = count - leftCount;\n                    if (rightCount !== 0) rightProb = (0, $eADNI.computeSurfaceArea)(rightBounds) / rootSurfaceArea;\n                    const cost = (0, $alNGj.TRAVERSAL_COST) + (0, $alNGj.TRIANGLE_INTERSECT_COST) * (leftProb * leftCount + rightProb * rightCount);\n                    if (cost < bestCost) {\n                        axis = a;\n                        bestCost = cost;\n                        pos = bin.candidate;\n                    }\n                }\n            }\n        }\n    } else console.warn(`MeshBVH: Invalid build strategy value ${strategy} used.`);\n    return {\n        axis: axis,\n        pos: pos\n    };\n}\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction $33d016ef2ae8a9ff$var$getAverage(triangleBounds, offset, count, axis) {\n    let avg = 0;\n    for(let i = offset, end = offset + count; i < end; i++)avg += triangleBounds[i * 6 + axis * 2];\n    return avg / count;\n}\n\n});\nparcelRegister(\"eADNI\", function(module, exports) {\n\n$parcel$export(module.exports, \"arrayToBox\", () => $a9f34d1ac25848aa$export$40b9a5e446bf11e0);\n$parcel$export(module.exports, \"getLongestEdgeIndex\", () => $a9f34d1ac25848aa$export$dcdc414399b99746);\n$parcel$export(module.exports, \"copyBounds\", () => $a9f34d1ac25848aa$export$14b050a767b4a3a7);\n$parcel$export(module.exports, \"unionBounds\", () => $a9f34d1ac25848aa$export$a8a7063dce01a911);\n$parcel$export(module.exports, \"expandByTriangleBounds\", () => $a9f34d1ac25848aa$export$c989e53c4b24c2f5);\n$parcel$export(module.exports, \"computeSurfaceArea\", () => $a9f34d1ac25848aa$export$dbf4320364dc239e);\nfunction $a9f34d1ac25848aa$export$40b9a5e446bf11e0(nodeIndex32, array, target) {\n    target.min.x = array[nodeIndex32];\n    target.min.y = array[nodeIndex32 + 1];\n    target.min.z = array[nodeIndex32 + 2];\n    target.max.x = array[nodeIndex32 + 3];\n    target.max.y = array[nodeIndex32 + 4];\n    target.max.z = array[nodeIndex32 + 5];\n    return target;\n}\nfunction $a9f34d1ac25848aa$export$8737d658f04762d3(target) {\n    target[0] = target[1] = target[2] = Infinity;\n    target[3] = target[4] = target[5] = -Infinity;\n}\nfunction $a9f34d1ac25848aa$export$dcdc414399b99746(bounds) {\n    let splitDimIdx = -1;\n    let splitDist = -Infinity;\n    for(let i = 0; i < 3; i++){\n        const dist = bounds[i + 3] - bounds[i];\n        if (dist > splitDist) {\n            splitDist = dist;\n            splitDimIdx = i;\n        }\n    }\n    return splitDimIdx;\n}\nfunction $a9f34d1ac25848aa$export$14b050a767b4a3a7(source, target) {\n    target.set(source);\n}\nfunction $a9f34d1ac25848aa$export$a8a7063dce01a911(a, b, target) {\n    let aVal, bVal;\n    for(let d = 0; d < 3; d++){\n        const d3 = d + 3;\n        // set the minimum values\n        aVal = a[d];\n        bVal = b[d];\n        target[d] = aVal < bVal ? aVal : bVal;\n        // set the max values\n        aVal = a[d3];\n        bVal = b[d3];\n        target[d3] = aVal > bVal ? aVal : bVal;\n    }\n}\nfunction $a9f34d1ac25848aa$export$c989e53c4b24c2f5(startIndex, triangleBounds, bounds) {\n    for(let d = 0; d < 3; d++){\n        const tCenter = triangleBounds[startIndex + 2 * d];\n        const tHalf = triangleBounds[startIndex + 2 * d + 1];\n        const tMin = tCenter - tHalf;\n        const tMax = tCenter + tHalf;\n        if (tMin < bounds[d]) bounds[d] = tMin;\n        if (tMax > bounds[d + 3]) bounds[d + 3] = tMax;\n    }\n}\nfunction $a9f34d1ac25848aa$export$dbf4320364dc239e(bounds) {\n    const d0 = bounds[3] - bounds[0];\n    const d1 = bounds[4] - bounds[1];\n    const d2 = bounds[5] - bounds[2];\n    return 2 * (d0 * d1 + d1 * d2 + d2 * d0);\n}\n\n});\n\n\nparcelRegister(\"O2f62\", function(module, exports) {\n\n$parcel$export(module.exports, \"MeshBVHNode\", () => $096668f03fbb5645$export$6f473cc5f89b0a1c);\nclass $096668f03fbb5645$export$6f473cc5f89b0a1c {\n    constructor(){\n        // internal nodes have boundingData, left, right, and splitAxis\n        // leaf nodes have offset and count (referring to primitives in the mesh geometry)\n        this.boundingData = new Float32Array(6);\n    }\n}\n\n});\n\nparcelRegister(\"8aRzr\", function(module, exports) {\n\n$parcel$export(module.exports, \"partition\", () => $5f38cfeb5f7666c7$export$b29f828819edca8d);\n/********************************************************/ /* This file is generated from \"sortUtils.template.js\". */ /********************************************************/ // reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction $5f38cfeb5f7666c7$export$b29f828819edca8d(indirectBuffer, index, triangleBounds, offset, count, split) {\n    let left = offset;\n    let right = offset + count - 1;\n    const pos = split.pos;\n    const axisOffset = split.axis * 2;\n    // hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n    while(true){\n        while(left <= right && triangleBounds[left * 6 + axisOffset] < pos)left++;\n        // if a triangle center lies on the partition plane it is considered to be on the right side\n        while(left <= right && triangleBounds[right * 6 + axisOffset] >= pos)right--;\n        if (left < right) {\n            // we need to swap all of the information associated with the triangles at index\n            // left and right; that's the verts in the geometry index, the bounds,\n            // and perhaps the SAH planes\n            for(let i = 0; i < 3; i++){\n                let t0 = index[left * 3 + i];\n                index[left * 3 + i] = index[right * 3 + i];\n                index[right * 3 + i] = t0;\n            }\n            // swap bounds\n            for(let i = 0; i < 6; i++){\n                let tb = triangleBounds[left * 6 + i];\n                triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];\n                triangleBounds[right * 6 + i] = tb;\n            }\n            left++;\n            right--;\n        } else return left;\n    }\n}\n\n});\n\nparcelRegister(\"fe03E\", function(module, exports) {\n\n$parcel$export(module.exports, \"partition_indirect\", () => $b1583556301b54a3$export$7cee363d477551d0);\n/********************************************************/ /* This file is generated from \"sortUtils.template.js\". */ /********************************************************/ // reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction $b1583556301b54a3$export$7cee363d477551d0(indirectBuffer, index, triangleBounds, offset, count, split) {\n    let left = offset;\n    let right = offset + count - 1;\n    const pos = split.pos;\n    const axisOffset = split.axis * 2;\n    // hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n    while(true){\n        while(left <= right && triangleBounds[left * 6 + axisOffset] < pos)left++;\n        // if a triangle center lies on the partition plane it is considered to be on the right side\n        while(left <= right && triangleBounds[right * 6 + axisOffset] >= pos)right--;\n        if (left < right) {\n            // we need to swap all of the information associated with the triangles at index\n            // left and right; that's the verts in the geometry index, the bounds,\n            // and perhaps the SAH planes\n            let t = indirectBuffer[left];\n            indirectBuffer[left] = indirectBuffer[right];\n            indirectBuffer[right] = t;\n            // swap bounds\n            for(let i = 0; i < 6; i++){\n                let tb = triangleBounds[left * 6 + i];\n                triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];\n                triangleBounds[right * 6 + i] = tb;\n            }\n            left++;\n            right--;\n        } else return left;\n    }\n}\n\n});\n\nparcelRegister(\"8yQ90\", function(module, exports) {\n\n$parcel$export(module.exports, \"countNodes\", () => $63b9f27945e6e48e$export$1daf15cbaf649dad);\n$parcel$export(module.exports, \"populateBuffer\", () => $63b9f27945e6e48e$export$faac1b763a0eceb5);\n\nvar $alNGj = parcelRequire(\"alNGj\");\n\nvar $8x2iv = parcelRequire(\"8x2iv\");\nlet $63b9f27945e6e48e$var$float32Array, $63b9f27945e6e48e$var$uint32Array, $63b9f27945e6e48e$var$uint16Array, $63b9f27945e6e48e$var$uint8Array;\nconst $63b9f27945e6e48e$var$MAX_POINTER = Math.pow(2, 32);\nfunction $63b9f27945e6e48e$export$1daf15cbaf649dad(node) {\n    if (\"count\" in node) return 1;\n    else return 1 + $63b9f27945e6e48e$export$1daf15cbaf649dad(node.left) + $63b9f27945e6e48e$export$1daf15cbaf649dad(node.right);\n}\nfunction $63b9f27945e6e48e$export$faac1b763a0eceb5(byteOffset, node, buffer) {\n    $63b9f27945e6e48e$var$float32Array = new Float32Array(buffer);\n    $63b9f27945e6e48e$var$uint32Array = new Uint32Array(buffer);\n    $63b9f27945e6e48e$var$uint16Array = new Uint16Array(buffer);\n    $63b9f27945e6e48e$var$uint8Array = new Uint8Array(buffer);\n    return $63b9f27945e6e48e$var$_populateBuffer(byteOffset, node);\n}\n// pack structure\n// boundingData  \t\t\t\t: 6 float32\n// right / offset \t\t\t\t: 1 uint32\n// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\nfunction $63b9f27945e6e48e$var$_populateBuffer(byteOffset, node) {\n    const stride4Offset = byteOffset / 4;\n    const stride2Offset = byteOffset / 2;\n    const isLeaf = \"count\" in node;\n    const boundingData = node.boundingData;\n    for(let i = 0; i < 6; i++)$63b9f27945e6e48e$var$float32Array[stride4Offset + i] = boundingData[i];\n    if (isLeaf) {\n        if (node.buffer) {\n            const buffer = node.buffer;\n            $63b9f27945e6e48e$var$uint8Array.set(new Uint8Array(buffer), byteOffset);\n            for(let offset = byteOffset, l = byteOffset + buffer.byteLength; offset < l; offset += (0, $alNGj.BYTES_PER_NODE)){\n                const offset2 = offset / 2;\n                if (!(0, $8x2iv.IS_LEAF)(offset2, $63b9f27945e6e48e$var$uint16Array)) $63b9f27945e6e48e$var$uint32Array[offset / 4 + 6] += stride4Offset;\n            }\n            return byteOffset + buffer.byteLength;\n        } else {\n            const offset = node.offset;\n            const count = node.count;\n            $63b9f27945e6e48e$var$uint32Array[stride4Offset + 6] = offset;\n            $63b9f27945e6e48e$var$uint16Array[stride2Offset + 14] = count;\n            $63b9f27945e6e48e$var$uint16Array[stride2Offset + 15] = (0, $alNGj.IS_LEAFNODE_FLAG);\n            return byteOffset + (0, $alNGj.BYTES_PER_NODE);\n        }\n    } else {\n        const left = node.left;\n        const right = node.right;\n        const splitAxis = node.splitAxis;\n        let nextUnusedPointer;\n        nextUnusedPointer = $63b9f27945e6e48e$var$_populateBuffer(byteOffset + (0, $alNGj.BYTES_PER_NODE), left);\n        if (nextUnusedPointer / 4 > $63b9f27945e6e48e$var$MAX_POINTER) throw new Error(\"MeshBVH: Cannot store child pointer greater than 32 bits.\");\n        $63b9f27945e6e48e$var$uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;\n        nextUnusedPointer = $63b9f27945e6e48e$var$_populateBuffer(nextUnusedPointer, right);\n        $63b9f27945e6e48e$var$uint32Array[stride4Offset + 7] = splitAxis;\n        return nextUnusedPointer;\n    }\n}\n\n});\nparcelRegister(\"8x2iv\", function(module, exports) {\n\n$parcel$export(module.exports, \"IS_LEAF\", () => $6363300ccf15b961$export$bc7cbaf27fbe938e);\n$parcel$export(module.exports, \"OFFSET\", () => $6363300ccf15b961$export$3231e969238304f3);\n$parcel$export(module.exports, \"COUNT\", () => $6363300ccf15b961$export$d61684373eacdf61);\n$parcel$export(module.exports, \"LEFT_NODE\", () => $6363300ccf15b961$export$7a68bc00425859d);\n$parcel$export(module.exports, \"RIGHT_NODE\", () => $6363300ccf15b961$export$4f44f52d9f75fa31);\n$parcel$export(module.exports, \"SPLIT_AXIS\", () => $6363300ccf15b961$export$b43717b3ca95505);\n$parcel$export(module.exports, \"BOUNDING_DATA_INDEX\", () => $6363300ccf15b961$export$b5b7e27a1440579d);\nfunction $6363300ccf15b961$export$bc7cbaf27fbe938e(n16, uint16Array) {\n    return uint16Array[n16 + 15] === 0xFFFF;\n}\nfunction $6363300ccf15b961$export$3231e969238304f3(n32, uint32Array) {\n    return uint32Array[n32 + 6];\n}\nfunction $6363300ccf15b961$export$d61684373eacdf61(n16, uint16Array) {\n    return uint16Array[n16 + 14];\n}\nfunction $6363300ccf15b961$export$7a68bc00425859d(n32) {\n    return n32 + 8;\n}\nfunction $6363300ccf15b961$export$4f44f52d9f75fa31(n32, uint32Array) {\n    return uint32Array[n32 + 6];\n}\nfunction $6363300ccf15b961$export$b43717b3ca95505(n32, uint32Array) {\n    return uint32Array[n32 + 7];\n}\nfunction $6363300ccf15b961$export$b5b7e27a1440579d(n32) {\n    return n32;\n}\n\n});\n\n\n\nparcelRegister(\"lenTA\", function(module, exports) {\n\n$parcel$export(module.exports, \"OrientedBox\", () => $f74d70f31e44d1f9$export$4ccecd8ac6ee0e58);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $2OKGW = parcelRequire(\"2OKGW\");\n\nvar $8VYkb = parcelRequire(\"8VYkb\");\n\nvar $f56Km = parcelRequire(\"f56Km\");\nclass $f74d70f31e44d1f9$export$4ccecd8ac6ee0e58 {\n    constructor(min, max, matrix){\n        this.isOrientedBox = true;\n        this.min = new (0, $ilwiq.Vector3)();\n        this.max = new (0, $ilwiq.Vector3)();\n        this.matrix = new (0, $ilwiq.Matrix4)();\n        this.invMatrix = new (0, $ilwiq.Matrix4)();\n        this.points = new Array(8).fill().map(()=>new (0, $ilwiq.Vector3)());\n        this.satAxes = new Array(3).fill().map(()=>new (0, $ilwiq.Vector3)());\n        this.satBounds = new Array(3).fill().map(()=>new (0, $2OKGW.SeparatingAxisBounds)());\n        this.alignedSatBounds = new Array(3).fill().map(()=>new (0, $2OKGW.SeparatingAxisBounds)());\n        this.needsUpdate = false;\n        if (min) this.min.copy(min);\n        if (max) this.max.copy(max);\n        if (matrix) this.matrix.copy(matrix);\n    }\n    set(min, max, matrix) {\n        this.min.copy(min);\n        this.max.copy(max);\n        this.matrix.copy(matrix);\n        this.needsUpdate = true;\n    }\n    copy(other) {\n        this.min.copy(other.min);\n        this.max.copy(other.max);\n        this.matrix.copy(other.matrix);\n        this.needsUpdate = true;\n    }\n}\n$f74d70f31e44d1f9$export$4ccecd8ac6ee0e58.prototype.update = function() {\n    return function update() {\n        const matrix = this.matrix;\n        const min = this.min;\n        const max = this.max;\n        const points = this.points;\n        for(let x = 0; x <= 1; x++){\n            for(let y = 0; y <= 1; y++)for(let z = 0; z <= 1; z++){\n                const i = 1 * x | 2 * y | 4 * z;\n                const v = points[i];\n                v.x = x ? max.x : min.x;\n                v.y = y ? max.y : min.y;\n                v.z = z ? max.z : min.z;\n                v.applyMatrix4(matrix);\n            }\n        }\n        const satBounds = this.satBounds;\n        const satAxes = this.satAxes;\n        const minVec = points[0];\n        for(let i = 0; i < 3; i++){\n            const axis = satAxes[i];\n            const sb = satBounds[i];\n            const index = 1 << i;\n            const pi = points[index];\n            axis.subVectors(minVec, pi);\n            sb.setFromPoints(axis, points);\n        }\n        const alignedSatBounds = this.alignedSatBounds;\n        alignedSatBounds[0].setFromPointsField(points, \"x\");\n        alignedSatBounds[1].setFromPointsField(points, \"y\");\n        alignedSatBounds[2].setFromPointsField(points, \"z\");\n        this.invMatrix.copy(this.matrix).invert();\n        this.needsUpdate = false;\n    };\n}();\n$f74d70f31e44d1f9$export$4ccecd8ac6ee0e58.prototype.intersectsBox = function() {\n    const aabbBounds = new (0, $2OKGW.SeparatingAxisBounds)();\n    return function intersectsBox(box) {\n        // TODO: should this be doing SAT against the AABB?\n        if (this.needsUpdate) this.update();\n        const min = box.min;\n        const max = box.max;\n        const satBounds = this.satBounds;\n        const satAxes = this.satAxes;\n        const alignedSatBounds = this.alignedSatBounds;\n        aabbBounds.min = min.x;\n        aabbBounds.max = max.x;\n        if (alignedSatBounds[0].isSeparated(aabbBounds)) return false;\n        aabbBounds.min = min.y;\n        aabbBounds.max = max.y;\n        if (alignedSatBounds[1].isSeparated(aabbBounds)) return false;\n        aabbBounds.min = min.z;\n        aabbBounds.max = max.z;\n        if (alignedSatBounds[2].isSeparated(aabbBounds)) return false;\n        for(let i = 0; i < 3; i++){\n            const axis = satAxes[i];\n            const sb = satBounds[i];\n            aabbBounds.setFromBox(axis, box);\n            if (sb.isSeparated(aabbBounds)) return false;\n        }\n        return true;\n    };\n}();\n$f74d70f31e44d1f9$export$4ccecd8ac6ee0e58.prototype.intersectsTriangle = function() {\n    const saTri = new (0, $8VYkb.ExtendedTriangle)();\n    const pointsArr = new Array(3);\n    const cachedSatBounds = new (0, $2OKGW.SeparatingAxisBounds)();\n    const cachedSatBounds2 = new (0, $2OKGW.SeparatingAxisBounds)();\n    const cachedAxis = new (0, $ilwiq.Vector3)();\n    return function intersectsTriangle(triangle) {\n        if (this.needsUpdate) this.update();\n        if (!triangle.isExtendedTriangle) {\n            saTri.copy(triangle);\n            saTri.update();\n            triangle = saTri;\n        } else if (triangle.needsUpdate) triangle.update();\n        const satBounds = this.satBounds;\n        const satAxes = this.satAxes;\n        pointsArr[0] = triangle.a;\n        pointsArr[1] = triangle.b;\n        pointsArr[2] = triangle.c;\n        for(let i = 0; i < 3; i++){\n            const sb = satBounds[i];\n            const sa = satAxes[i];\n            cachedSatBounds.setFromPoints(sa, pointsArr);\n            if (sb.isSeparated(cachedSatBounds)) return false;\n        }\n        const triSatBounds = triangle.satBounds;\n        const triSatAxes = triangle.satAxes;\n        const points = this.points;\n        for(let i = 0; i < 3; i++){\n            const sb = triSatBounds[i];\n            const sa = triSatAxes[i];\n            cachedSatBounds.setFromPoints(sa, points);\n            if (sb.isSeparated(cachedSatBounds)) return false;\n        }\n        // check crossed axes\n        for(let i = 0; i < 3; i++){\n            const sa1 = satAxes[i];\n            for(let i2 = 0; i2 < 4; i2++){\n                const sa2 = triSatAxes[i2];\n                cachedAxis.crossVectors(sa1, sa2);\n                cachedSatBounds.setFromPoints(cachedAxis, pointsArr);\n                cachedSatBounds2.setFromPoints(cachedAxis, points);\n                if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;\n            }\n        }\n        return true;\n    };\n}();\n$f74d70f31e44d1f9$export$4ccecd8ac6ee0e58.prototype.closestPointToPoint = function() {\n    return function closestPointToPoint(point, target1) {\n        if (this.needsUpdate) this.update();\n        target1.copy(point).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix);\n        return target1;\n    };\n}();\n$f74d70f31e44d1f9$export$4ccecd8ac6ee0e58.prototype.distanceToPoint = function() {\n    const target = new (0, $ilwiq.Vector3)();\n    return function distanceToPoint(point) {\n        this.closestPointToPoint(point, target);\n        return point.distanceTo(target);\n    };\n}();\n$f74d70f31e44d1f9$export$4ccecd8ac6ee0e58.prototype.distanceToBox = function() {\n    const xyzFields = [\n        \"x\",\n        \"y\",\n        \"z\"\n    ];\n    const segments1 = new Array(12).fill().map(()=>new (0, $ilwiq.Line3)());\n    const segments2 = new Array(12).fill().map(()=>new (0, $ilwiq.Line3)());\n    const point1 = new (0, $ilwiq.Vector3)();\n    const point2 = new (0, $ilwiq.Vector3)();\n    // early out if we find a value below threshold\n    return function distanceToBox(box, threshold = 0, target1 = null, target2 = null) {\n        if (this.needsUpdate) this.update();\n        if (this.intersectsBox(box)) {\n            if (target1 || target2) {\n                box.getCenter(point2);\n                this.closestPointToPoint(point2, point1);\n                box.closestPointToPoint(point1, point2);\n                if (target1) target1.copy(point1);\n                if (target2) target2.copy(point2);\n            }\n            return 0;\n        }\n        const threshold2 = threshold * threshold;\n        const min = box.min;\n        const max = box.max;\n        const points = this.points;\n        // iterate over every edge and compare distances\n        let closestDistanceSq = Infinity;\n        // check over all these points\n        for(let i = 0; i < 8; i++){\n            const p = points[i];\n            point2.copy(p).clamp(min, max);\n            const dist = p.distanceToSquared(point2);\n            if (dist < closestDistanceSq) {\n                closestDistanceSq = dist;\n                if (target1) target1.copy(p);\n                if (target2) target2.copy(point2);\n                if (dist < threshold2) return Math.sqrt(dist);\n            }\n        }\n        // generate and check all line segment distances\n        let count = 0;\n        for(let i = 0; i < 3; i++){\n            for(let i1 = 0; i1 <= 1; i1++)for(let i2 = 0; i2 <= 1; i2++){\n                const nextIndex = (i + 1) % 3;\n                const nextIndex2 = (i + 2) % 3;\n                // get obb line segments\n                const index = i1 << nextIndex | i2 << nextIndex2;\n                const index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n                const p1 = points[index];\n                const p2 = points[index2];\n                const line1 = segments1[count];\n                line1.set(p1, p2);\n                // get aabb line segments\n                const f1 = xyzFields[i];\n                const f2 = xyzFields[nextIndex];\n                const f3 = xyzFields[nextIndex2];\n                const line2 = segments2[count];\n                const start = line2.start;\n                const end = line2.end;\n                start[f1] = min[f1];\n                start[f2] = i1 ? min[f2] : max[f2];\n                start[f3] = i2 ? min[f3] : max[f2];\n                end[f1] = max[f1];\n                end[f2] = i1 ? min[f2] : max[f2];\n                end[f3] = i2 ? min[f3] : max[f2];\n                count++;\n            }\n        }\n        // check all the other boxes point\n        for(let x = 0; x <= 1; x++){\n            for(let y = 0; y <= 1; y++)for(let z = 0; z <= 1; z++){\n                point2.x = x ? max.x : min.x;\n                point2.y = y ? max.y : min.y;\n                point2.z = z ? max.z : min.z;\n                this.closestPointToPoint(point2, point1);\n                const dist = point2.distanceToSquared(point1);\n                if (dist < closestDistanceSq) {\n                    closestDistanceSq = dist;\n                    if (target1) target1.copy(point1);\n                    if (target2) target2.copy(point2);\n                    if (dist < threshold2) return Math.sqrt(dist);\n                }\n            }\n        }\n        for(let i = 0; i < 12; i++){\n            const l1 = segments1[i];\n            for(let i2 = 0; i2 < 12; i2++){\n                const l2 = segments2[i2];\n                (0, $f56Km.closestPointsSegmentToSegment)(l1, l2, point1, point2);\n                const dist = point1.distanceToSquared(point2);\n                if (dist < closestDistanceSq) {\n                    closestDistanceSq = dist;\n                    if (target1) target1.copy(point1);\n                    if (target2) target2.copy(point2);\n                    if (dist < threshold2) return Math.sqrt(dist);\n                }\n            }\n        }\n        return Math.sqrt(closestDistanceSq);\n    };\n}();\n\n});\nparcelRegister(\"2OKGW\", function(module, exports) {\n\n$parcel$export(module.exports, \"SeparatingAxisBounds\", () => $20d478469c10be0c$export$f758e41ecdcd8e69);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $20d478469c10be0c$export$f758e41ecdcd8e69 {\n    constructor(){\n        this.min = Infinity;\n        this.max = -Infinity;\n    }\n    setFromPointsField(points, field) {\n        let min = Infinity;\n        let max = -Infinity;\n        for(let i = 0, l = points.length; i < l; i++){\n            const p = points[i];\n            const val = p[field];\n            min = val < min ? val : min;\n            max = val > max ? val : max;\n        }\n        this.min = min;\n        this.max = max;\n    }\n    setFromPoints(axis, points) {\n        let min = Infinity;\n        let max = -Infinity;\n        for(let i = 0, l = points.length; i < l; i++){\n            const p = points[i];\n            const val = axis.dot(p);\n            min = val < min ? val : min;\n            max = val > max ? val : max;\n        }\n        this.min = min;\n        this.max = max;\n    }\n    isSeparated(other) {\n        return this.min > other.max || other.min > this.max;\n    }\n}\n$20d478469c10be0c$export$f758e41ecdcd8e69.prototype.setFromBox = function() {\n    const p = new (0, $ilwiq.Vector3)();\n    return function setFromBox(axis, box) {\n        const boxMin = box.min;\n        const boxMax = box.max;\n        let min = Infinity;\n        let max = -Infinity;\n        for(let x = 0; x <= 1; x++){\n            for(let y = 0; y <= 1; y++)for(let z = 0; z <= 1; z++){\n                p.x = boxMin.x * x + boxMax.x * (1 - x);\n                p.y = boxMin.y * y + boxMax.y * (1 - y);\n                p.z = boxMin.z * z + boxMax.z * (1 - z);\n                const val = axis.dot(p);\n                min = Math.min(val, min);\n                max = Math.max(val, max);\n            }\n        }\n        this.min = min;\n        this.max = max;\n    };\n}();\nconst $20d478469c10be0c$export$e086b7be1b4d1d36 = function() {\n    const cacheSatBounds = new $20d478469c10be0c$export$f758e41ecdcd8e69();\n    return function areIntersecting(shape1, shape2) {\n        const points1 = shape1.points;\n        const satAxes1 = shape1.satAxes;\n        const satBounds1 = shape1.satBounds;\n        const points2 = shape2.points;\n        const satAxes2 = shape2.satAxes;\n        const satBounds2 = shape2.satBounds;\n        // check axes of the first shape\n        for(let i = 0; i < 3; i++){\n            const sb = satBounds1[i];\n            const sa = satAxes1[i];\n            cacheSatBounds.setFromPoints(sa, points2);\n            if (sb.isSeparated(cacheSatBounds)) return false;\n        }\n        // check axes of the second shape\n        for(let i = 0; i < 3; i++){\n            const sb = satBounds2[i];\n            const sa = satAxes2[i];\n            cacheSatBounds.setFromPoints(sa, points1);\n            if (sb.isSeparated(cacheSatBounds)) return false;\n        }\n    };\n}();\n\n});\n\nparcelRegister(\"8VYkb\", function(module, exports) {\n\n$parcel$export(module.exports, \"ExtendedTriangle\", () => $681270c6f2e9ebff$export$a37f7ec1c23dfacf);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $2OKGW = parcelRequire(\"2OKGW\");\n\nvar $f56Km = parcelRequire(\"f56Km\");\nconst $681270c6f2e9ebff$var$ZERO_EPSILON = 1e-15;\nfunction $681270c6f2e9ebff$var$isNearZero(value) {\n    return Math.abs(value) < $681270c6f2e9ebff$var$ZERO_EPSILON;\n}\nclass $681270c6f2e9ebff$export$a37f7ec1c23dfacf extends (0, $ilwiq.Triangle) {\n    constructor(...args){\n        super(...args);\n        this.isExtendedTriangle = true;\n        this.satAxes = new Array(4).fill().map(()=>new (0, $ilwiq.Vector3)());\n        this.satBounds = new Array(4).fill().map(()=>new (0, $2OKGW.SeparatingAxisBounds)());\n        this.points = [\n            this.a,\n            this.b,\n            this.c\n        ];\n        this.sphere = new (0, $ilwiq.Sphere)();\n        this.plane = new (0, $ilwiq.Plane)();\n        this.needsUpdate = true;\n    }\n    intersectsSphere(sphere) {\n        return (0, $f56Km.sphereIntersectTriangle)(sphere, this);\n    }\n    update() {\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const points = this.points;\n        const satAxes = this.satAxes;\n        const satBounds = this.satBounds;\n        const axis0 = satAxes[0];\n        const sab0 = satBounds[0];\n        this.getNormal(axis0);\n        sab0.setFromPoints(axis0, points);\n        const axis1 = satAxes[1];\n        const sab1 = satBounds[1];\n        axis1.subVectors(a, b);\n        sab1.setFromPoints(axis1, points);\n        const axis2 = satAxes[2];\n        const sab2 = satBounds[2];\n        axis2.subVectors(b, c);\n        sab2.setFromPoints(axis2, points);\n        const axis3 = satAxes[3];\n        const sab3 = satBounds[3];\n        axis3.subVectors(c, a);\n        sab3.setFromPoints(axis3, points);\n        this.sphere.setFromPoints(this.points);\n        this.plane.setFromNormalAndCoplanarPoint(axis0, a);\n        this.needsUpdate = false;\n    }\n}\n$681270c6f2e9ebff$export$a37f7ec1c23dfacf.prototype.closestPointToSegment = function() {\n    const point1 = new (0, $ilwiq.Vector3)();\n    const point2 = new (0, $ilwiq.Vector3)();\n    const edge = new (0, $ilwiq.Line3)();\n    return function distanceToSegment(segment, target1 = null, target2 = null) {\n        const { start: start, end: end } = segment;\n        const points = this.points;\n        let distSq;\n        let closestDistanceSq = Infinity;\n        // check the triangle edges\n        for(let i = 0; i < 3; i++){\n            const nexti = (i + 1) % 3;\n            edge.start.copy(points[i]);\n            edge.end.copy(points[nexti]);\n            (0, $f56Km.closestPointsSegmentToSegment)(edge, segment, point1, point2);\n            distSq = point1.distanceToSquared(point2);\n            if (distSq < closestDistanceSq) {\n                closestDistanceSq = distSq;\n                if (target1) target1.copy(point1);\n                if (target2) target2.copy(point2);\n            }\n        }\n        // check end points\n        this.closestPointToPoint(start, point1);\n        distSq = start.distanceToSquared(point1);\n        if (distSq < closestDistanceSq) {\n            closestDistanceSq = distSq;\n            if (target1) target1.copy(point1);\n            if (target2) target2.copy(start);\n        }\n        this.closestPointToPoint(end, point1);\n        distSq = end.distanceToSquared(point1);\n        if (distSq < closestDistanceSq) {\n            closestDistanceSq = distSq;\n            if (target1) target1.copy(point1);\n            if (target2) target2.copy(end);\n        }\n        return Math.sqrt(closestDistanceSq);\n    };\n}();\n$681270c6f2e9ebff$export$a37f7ec1c23dfacf.prototype.intersectsTriangle = function() {\n    const saTri2 = new $681270c6f2e9ebff$export$a37f7ec1c23dfacf();\n    const arr1 = new Array(3);\n    const arr2 = new Array(3);\n    const cachedSatBounds = new (0, $2OKGW.SeparatingAxisBounds)();\n    const cachedSatBounds2 = new (0, $2OKGW.SeparatingAxisBounds)();\n    const cachedAxis = new (0, $ilwiq.Vector3)();\n    const dir = new (0, $ilwiq.Vector3)();\n    const dir1 = new (0, $ilwiq.Vector3)();\n    const dir2 = new (0, $ilwiq.Vector3)();\n    const tempDir = new (0, $ilwiq.Vector3)();\n    const edge = new (0, $ilwiq.Line3)();\n    const edge1 = new (0, $ilwiq.Line3)();\n    const edge2 = new (0, $ilwiq.Line3)();\n    const tempPoint = new (0, $ilwiq.Vector3)();\n    function triIntersectPlane(tri, plane, targetEdge) {\n        // find the edge that intersects the other triangle plane\n        const points = tri.points;\n        let count = 0;\n        let startPointIntersection = -1;\n        for(let i = 0; i < 3; i++){\n            const { start: start, end: end } = edge;\n            start.copy(points[i]);\n            end.copy(points[(i + 1) % 3]);\n            edge.delta(dir);\n            const startIntersects = $681270c6f2e9ebff$var$isNearZero(plane.distanceToPoint(start));\n            if ($681270c6f2e9ebff$var$isNearZero(plane.normal.dot(dir)) && startIntersects) {\n                // if the edge lies on the plane then take the line\n                targetEdge.copy(edge);\n                count = 2;\n                break;\n            }\n            // check if the start point is near the plane because \"intersectLine\" is not robust to that case\n            const doesIntersect = plane.intersectLine(edge, tempPoint);\n            if (!doesIntersect && startIntersects) tempPoint.copy(start);\n            // ignore the end point\n            if ((doesIntersect || startIntersects) && !$681270c6f2e9ebff$var$isNearZero(tempPoint.distanceTo(end))) {\n                if (count <= 1) {\n                    // assign to the start or end point and save which index was snapped to\n                    // the start point if necessary\n                    const point = count === 1 ? targetEdge.start : targetEdge.end;\n                    point.copy(tempPoint);\n                    if (startIntersects) startPointIntersection = count;\n                } else if (count >= 2) {\n                    // if we're here that means that there must have been one point that had\n                    // snapped to the start point so replace it here\n                    const point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;\n                    point.copy(tempPoint);\n                    count = 2;\n                    break;\n                }\n                count++;\n                if (count === 2 && startPointIntersection === -1) break;\n            }\n        }\n        return count;\n    }\n    // TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n    // be a line contained by both triangles if not a different special case somehow represented in the return result.\n    return function intersectsTriangle(other, target = null, suppressLog = false) {\n        if (this.needsUpdate) this.update();\n        if (!other.isExtendedTriangle) {\n            saTri2.copy(other);\n            saTri2.update();\n            other = saTri2;\n        } else if (other.needsUpdate) other.update();\n        const plane1 = this.plane;\n        const plane2 = other.plane;\n        if (Math.abs(plane1.normal.dot(plane2.normal)) > 1.0 - 1e-10) {\n            // perform separating axis intersection test only for coplanar triangles\n            const satBounds1 = this.satBounds;\n            const satAxes1 = this.satAxes;\n            arr2[0] = other.a;\n            arr2[1] = other.b;\n            arr2[2] = other.c;\n            for(let i = 0; i < 4; i++){\n                const sb = satBounds1[i];\n                const sa = satAxes1[i];\n                cachedSatBounds.setFromPoints(sa, arr2);\n                if (sb.isSeparated(cachedSatBounds)) return false;\n            }\n            const satBounds2 = other.satBounds;\n            const satAxes2 = other.satAxes;\n            arr1[0] = this.a;\n            arr1[1] = this.b;\n            arr1[2] = this.c;\n            for(let i = 0; i < 4; i++){\n                const sb = satBounds2[i];\n                const sa = satAxes2[i];\n                cachedSatBounds.setFromPoints(sa, arr1);\n                if (sb.isSeparated(cachedSatBounds)) return false;\n            }\n            // check crossed axes\n            for(let i = 0; i < 4; i++){\n                const sa1 = satAxes1[i];\n                for(let i2 = 0; i2 < 4; i2++){\n                    const sa2 = satAxes2[i2];\n                    cachedAxis.crossVectors(sa1, sa2);\n                    cachedSatBounds.setFromPoints(cachedAxis, arr1);\n                    cachedSatBounds2.setFromPoints(cachedAxis, arr2);\n                    if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;\n                }\n            }\n            if (target) {\n                // TODO find two points that intersect on the edges and make that the result\n                if (!suppressLog) console.warn(\"ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.\");\n                target.start.set(0, 0, 0);\n                target.end.set(0, 0, 0);\n            }\n            return true;\n        } else {\n            // find the edge that intersects the other triangle plane\n            const count1 = triIntersectPlane(this, plane2, edge1);\n            if (count1 === 1 && other.containsPoint(edge1.end)) {\n                if (target) {\n                    target.start.copy(edge1.end);\n                    target.end.copy(edge1.end);\n                }\n                return true;\n            } else if (count1 !== 2) return false;\n            // find the other triangles edge that intersects this plane\n            const count2 = triIntersectPlane(other, plane1, edge2);\n            if (count2 === 1 && this.containsPoint(edge2.end)) {\n                if (target) {\n                    target.start.copy(edge2.end);\n                    target.end.copy(edge2.end);\n                }\n                return true;\n            } else if (count2 !== 2) return false;\n            // find swap the second edge so both lines are running the same direction\n            edge1.delta(dir1);\n            edge2.delta(dir2);\n            if (dir1.dot(dir2) < 0) {\n                let tmp = edge2.start;\n                edge2.start = edge2.end;\n                edge2.end = tmp;\n            }\n            // check if the edges are overlapping\n            const s1 = edge1.start.dot(dir1);\n            const e1 = edge1.end.dot(dir1);\n            const s2 = edge2.start.dot(dir1);\n            const e2 = edge2.end.dot(dir1);\n            const separated1 = e1 < s2;\n            const separated2 = s1 < e2;\n            if (s1 !== e2 && s2 !== e1 && separated1 === separated2) return false;\n            // assign the target output\n            if (target) {\n                tempDir.subVectors(edge1.start, edge2.start);\n                if (tempDir.dot(dir1) > 0) target.start.copy(edge1.start);\n                else target.start.copy(edge2.start);\n                tempDir.subVectors(edge1.end, edge2.end);\n                if (tempDir.dot(dir1) < 0) target.end.copy(edge1.end);\n                else target.end.copy(edge2.end);\n            }\n            return true;\n        }\n    };\n}();\n$681270c6f2e9ebff$export$a37f7ec1c23dfacf.prototype.distanceToPoint = function() {\n    const target = new (0, $ilwiq.Vector3)();\n    return function distanceToPoint(point) {\n        this.closestPointToPoint(point, target);\n        return point.distanceTo(target);\n    };\n}();\n$681270c6f2e9ebff$export$a37f7ec1c23dfacf.prototype.distanceToTriangle = function() {\n    const point = new (0, $ilwiq.Vector3)();\n    const point2 = new (0, $ilwiq.Vector3)();\n    const cornerFields = [\n        \"a\",\n        \"b\",\n        \"c\"\n    ];\n    const line1 = new (0, $ilwiq.Line3)();\n    const line2 = new (0, $ilwiq.Line3)();\n    return function distanceToTriangle(other, target1 = null, target2 = null) {\n        const lineTarget = target1 || target2 ? line1 : null;\n        if (this.intersectsTriangle(other, lineTarget)) {\n            if (target1 || target2) {\n                if (target1) lineTarget.getCenter(target1);\n                if (target2) lineTarget.getCenter(target2);\n            }\n            return 0;\n        }\n        let closestDistanceSq = Infinity;\n        // check all point distances\n        for(let i = 0; i < 3; i++){\n            let dist;\n            const field = cornerFields[i];\n            const otherVec = other[field];\n            this.closestPointToPoint(otherVec, point);\n            dist = otherVec.distanceToSquared(point);\n            if (dist < closestDistanceSq) {\n                closestDistanceSq = dist;\n                if (target1) target1.copy(point);\n                if (target2) target2.copy(otherVec);\n            }\n            const thisVec = this[field];\n            other.closestPointToPoint(thisVec, point);\n            dist = thisVec.distanceToSquared(point);\n            if (dist < closestDistanceSq) {\n                closestDistanceSq = dist;\n                if (target1) target1.copy(thisVec);\n                if (target2) target2.copy(point);\n            }\n        }\n        for(let i = 0; i < 3; i++){\n            const f11 = cornerFields[i];\n            const f12 = cornerFields[(i + 1) % 3];\n            line1.set(this[f11], this[f12]);\n            for(let i2 = 0; i2 < 3; i2++){\n                const f21 = cornerFields[i2];\n                const f22 = cornerFields[(i2 + 1) % 3];\n                line2.set(other[f21], other[f22]);\n                (0, $f56Km.closestPointsSegmentToSegment)(line1, line2, point, point2);\n                const dist = point.distanceToSquared(point2);\n                if (dist < closestDistanceSq) {\n                    closestDistanceSq = dist;\n                    if (target1) target1.copy(point);\n                    if (target2) target2.copy(point2);\n                }\n            }\n        }\n        return Math.sqrt(closestDistanceSq);\n    };\n}();\n\n});\nparcelRegister(\"f56Km\", function(module, exports) {\n\n$parcel$export(module.exports, \"closestPointsSegmentToSegment\", () => $afac8e64b68760a8$export$b09f296caca7547a);\n$parcel$export(module.exports, \"sphereIntersectTriangle\", () => $afac8e64b68760a8$export$eed3a6606b3adc41);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nconst $afac8e64b68760a8$export$479eef7c8f1b846c = function() {\n    // https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n    const dir1 = new (0, $ilwiq.Vector3)();\n    const dir2 = new (0, $ilwiq.Vector3)();\n    const v02 = new (0, $ilwiq.Vector3)();\n    return function closestPointLineToLine(l1, l2, result) {\n        const v0 = l1.start;\n        const v10 = dir1;\n        const v2 = l2.start;\n        const v32 = dir2;\n        v02.subVectors(v0, v2);\n        dir1.subVectors(l1.end, l1.start);\n        dir2.subVectors(l2.end, l2.start);\n        // float d0232 = v02.Dot(v32);\n        const d0232 = v02.dot(v32);\n        // float d3210 = v32.Dot(v10);\n        const d3210 = v32.dot(v10);\n        // float d3232 = v32.Dot(v32);\n        const d3232 = v32.dot(v32);\n        // float d0210 = v02.Dot(v10);\n        const d0210 = v02.dot(v10);\n        // float d1010 = v10.Dot(v10);\n        const d1010 = v10.dot(v10);\n        // float denom = d1010*d3232 - d3210*d3210;\n        const denom = d1010 * d3232 - d3210 * d3210;\n        let d, d2;\n        if (denom !== 0) d = (d0232 * d3210 - d0210 * d3232) / denom;\n        else d = 0;\n        d2 = (d0232 + d * d3210) / d3232;\n        result.x = d;\n        result.y = d2;\n    };\n}();\nconst $afac8e64b68760a8$export$b09f296caca7547a = function() {\n    // https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n    const paramResult = new (0, $ilwiq.Vector2)();\n    const temp1 = new (0, $ilwiq.Vector3)();\n    const temp2 = new (0, $ilwiq.Vector3)();\n    return function closestPointsSegmentToSegment(l1, l2, target1, target2) {\n        $afac8e64b68760a8$export$479eef7c8f1b846c(l1, l2, paramResult);\n        let d = paramResult.x;\n        let d2 = paramResult.y;\n        if (d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1) {\n            l1.at(d, target1);\n            l2.at(d2, target2);\n            return;\n        } else if (d >= 0 && d <= 1) {\n            // Only d2 is out of bounds.\n            if (d2 < 0) l2.at(0, target2);\n            else l2.at(1, target2);\n            l1.closestPointToPoint(target2, true, target1);\n            return;\n        } else if (d2 >= 0 && d2 <= 1) {\n            // Only d is out of bounds.\n            if (d < 0) l1.at(0, target1);\n            else l1.at(1, target1);\n            l2.closestPointToPoint(target1, true, target2);\n            return;\n        } else {\n            // Both u and u2 are out of bounds.\n            let p;\n            if (d < 0) p = l1.start;\n            else p = l1.end;\n            let p2;\n            if (d2 < 0) p2 = l2.start;\n            else p2 = l2.end;\n            const closestPoint = temp1;\n            const closestPoint2 = temp2;\n            l1.closestPointToPoint(p2, true, temp1);\n            l2.closestPointToPoint(p, true, temp2);\n            if (closestPoint.distanceToSquared(p2) <= closestPoint2.distanceToSquared(p)) {\n                target1.copy(closestPoint);\n                target2.copy(p2);\n                return;\n            } else {\n                target1.copy(p);\n                target2.copy(closestPoint2);\n                return;\n            }\n        }\n    };\n}();\nconst $afac8e64b68760a8$export$eed3a6606b3adc41 = function() {\n    // https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n    const closestPointTemp = new (0, $ilwiq.Vector3)();\n    const projectedPointTemp = new (0, $ilwiq.Vector3)();\n    const planeTemp = new (0, $ilwiq.Plane)();\n    const lineTemp = new (0, $ilwiq.Line3)();\n    return function sphereIntersectTriangle(sphere, triangle) {\n        const { radius: radius, center: center } = sphere;\n        const { a: a, b: b, c: c } = triangle;\n        // phase 1\n        lineTemp.start = a;\n        lineTemp.end = b;\n        const closestPoint1 = lineTemp.closestPointToPoint(center, true, closestPointTemp);\n        if (closestPoint1.distanceTo(center) <= radius) return true;\n        lineTemp.start = a;\n        lineTemp.end = c;\n        const closestPoint2 = lineTemp.closestPointToPoint(center, true, closestPointTemp);\n        if (closestPoint2.distanceTo(center) <= radius) return true;\n        lineTemp.start = b;\n        lineTemp.end = c;\n        const closestPoint3 = lineTemp.closestPointToPoint(center, true, closestPointTemp);\n        if (closestPoint3.distanceTo(center) <= radius) return true;\n        // phase 2\n        const plane = triangle.getPlane(planeTemp);\n        const dp = Math.abs(plane.distanceToPoint(center));\n        if (dp <= radius) {\n            const pp = plane.projectPoint(center, projectedPointTemp);\n            const cp = triangle.containsPoint(pp);\n            if (cp) return true;\n        }\n        return false;\n    };\n}();\n\n});\n\n\n\nparcelRegister(\"7EZfU\", function(module, exports) {\n\n$parcel$export(module.exports, \"ExtendedTrianglePool\", () => $593bc8ef8d1a55fc$export$2622f4315304edad);\n\nvar $8VYkb = parcelRequire(\"8VYkb\");\n\nvar $1l8b2 = parcelRequire(\"1l8b2\");\nclass $593bc8ef8d1a55fc$var$ExtendedTrianglePoolBase extends (0, $1l8b2.PrimitivePool) {\n    constructor(){\n        super(()=>new (0, $8VYkb.ExtendedTriangle)());\n    }\n}\nconst $593bc8ef8d1a55fc$export$2622f4315304edad = /* @__PURE__ */ new $593bc8ef8d1a55fc$var$ExtendedTrianglePoolBase();\n\n});\nparcelRegister(\"1l8b2\", function(module, exports) {\n\n$parcel$export(module.exports, \"PrimitivePool\", () => $0f9e1864656e7fae$export$bf300c504651112a);\nclass $0f9e1864656e7fae$export$bf300c504651112a {\n    constructor(getNewPrimitive){\n        this._getNewPrimitive = getNewPrimitive;\n        this._primitives = [];\n    }\n    getPrimitive() {\n        const primitives = this._primitives;\n        if (primitives.length === 0) return this._getNewPrimitive();\n        else return primitives.pop();\n    }\n    releasePrimitive(primitive) {\n        this._primitives.push(primitive);\n    }\n}\n\n});\n\n\nparcelRegister(\"8hs00\", function(module, exports) {\n\n$parcel$export(module.exports, \"shapecast\", () => $6075a1513b66f4c0$export$963c78622ed2c172);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $alNGj = parcelRequire(\"alNGj\");\n\nvar $eADNI = parcelRequire(\"eADNI\");\n\nvar $1l8b2 = parcelRequire(\"1l8b2\");\n\nvar $8x2iv = parcelRequire(\"8x2iv\");\n\nvar $xqrrD = parcelRequire(\"xqrrD\");\nlet $6075a1513b66f4c0$var$_box1, $6075a1513b66f4c0$var$_box2;\nconst $6075a1513b66f4c0$var$boxStack = [];\nconst $6075a1513b66f4c0$var$boxPool = /* @__PURE__ */ new (0, $1l8b2.PrimitivePool)(()=>new (0, $ilwiq.Box3)());\nfunction $6075a1513b66f4c0$export$963c78622ed2c172(bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset) {\n    // setup\n    $6075a1513b66f4c0$var$_box1 = $6075a1513b66f4c0$var$boxPool.getPrimitive();\n    $6075a1513b66f4c0$var$_box2 = $6075a1513b66f4c0$var$boxPool.getPrimitive();\n    $6075a1513b66f4c0$var$boxStack.push($6075a1513b66f4c0$var$_box1, $6075a1513b66f4c0$var$_box2);\n    (0, $xqrrD.BufferStack).setBuffer(bvh._roots[root]);\n    const result = $6075a1513b66f4c0$var$shapecastTraverse(0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n    // cleanup\n    (0, $xqrrD.BufferStack).clearBuffer();\n    $6075a1513b66f4c0$var$boxPool.releasePrimitive($6075a1513b66f4c0$var$_box1);\n    $6075a1513b66f4c0$var$boxPool.releasePrimitive($6075a1513b66f4c0$var$_box2);\n    $6075a1513b66f4c0$var$boxStack.pop();\n    $6075a1513b66f4c0$var$boxStack.pop();\n    const length = $6075a1513b66f4c0$var$boxStack.length;\n    if (length > 0) {\n        $6075a1513b66f4c0$var$_box2 = $6075a1513b66f4c0$var$boxStack[length - 1];\n        $6075a1513b66f4c0$var$_box1 = $6075a1513b66f4c0$var$boxStack[length - 2];\n    }\n    return result;\n}\nfunction $6075a1513b66f4c0$var$shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc = null, nodeIndexByteOffset = 0, depth = 0) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $xqrrD.BufferStack);\n    let nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0, $8x2iv.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0, $8x2iv.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0, $8x2iv.COUNT)(nodeIndex16, uint16Array);\n        (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(nodeIndex32), float32Array, $6075a1513b66f4c0$var$_box1);\n        return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, $6075a1513b66f4c0$var$_box1);\n    } else {\n        const left = (0, $8x2iv.LEFT_NODE)(nodeIndex32);\n        const right = (0, $8x2iv.RIGHT_NODE)(nodeIndex32, uint32Array);\n        let c1 = left;\n        let c2 = right;\n        let score1, score2;\n        let box1, box2;\n        if (nodeScoreFunc) {\n            box1 = $6075a1513b66f4c0$var$_box1;\n            box2 = $6075a1513b66f4c0$var$_box2;\n            // bounding data is not offset\n            (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(c1), float32Array, box1);\n            (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(c2), float32Array, box2);\n            score1 = nodeScoreFunc(box1);\n            score2 = nodeScoreFunc(box2);\n            if (score2 < score1) {\n                c1 = right;\n                c2 = left;\n                const temp = score1;\n                score1 = score2;\n                score2 = temp;\n                box1 = box2;\n            // box2 is always set before use below\n            }\n        }\n        // Check box 1 intersection\n        if (!box1) {\n            box1 = $6075a1513b66f4c0$var$_box1;\n            (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(c1), float32Array, box1);\n        }\n        const isC1Leaf = (0, $8x2iv.IS_LEAF)(c1 * 2, uint16Array);\n        const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);\n        let c1StopTraversal;\n        if (c1Intersection === (0, $alNGj.CONTAINED)) {\n            const offset = getLeftOffset(c1);\n            const end = getRightEndOffset(c1);\n            const count = end - offset;\n            c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1);\n        } else c1StopTraversal = c1Intersection && $6075a1513b66f4c0$var$shapecastTraverse(c1, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n        if (c1StopTraversal) return true;\n        // Check box 2 intersection\n        // cached box2 will have been overwritten by previous traversal\n        box2 = $6075a1513b66f4c0$var$_box2;\n        (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(c2), float32Array, box2);\n        const isC2Leaf = (0, $8x2iv.IS_LEAF)(c2 * 2, uint16Array);\n        const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);\n        let c2StopTraversal;\n        if (c2Intersection === (0, $alNGj.CONTAINED)) {\n            const offset = getLeftOffset(c2);\n            const end = getRightEndOffset(c2);\n            const count = end - offset;\n            c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2);\n        } else c2StopTraversal = c2Intersection && $6075a1513b66f4c0$var$shapecastTraverse(c2, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n        if (c2StopTraversal) return true;\n        return false;\n        // Define these inside the function so it has access to the local variables needed\n        // when converting to the buffer equivalents\n        function getLeftOffset(nodeIndex32) {\n            const { uint16Array: uint16Array, uint32Array: uint32Array } = (0, $xqrrD.BufferStack);\n            let nodeIndex16 = nodeIndex32 * 2;\n            // traverse until we find a leaf\n            while(!(0, $8x2iv.IS_LEAF)(nodeIndex16, uint16Array)){\n                nodeIndex32 = (0, $8x2iv.LEFT_NODE)(nodeIndex32);\n                nodeIndex16 = nodeIndex32 * 2;\n            }\n            return (0, $8x2iv.OFFSET)(nodeIndex32, uint32Array);\n        }\n        function getRightEndOffset(nodeIndex32) {\n            const { uint16Array: uint16Array, uint32Array: uint32Array } = (0, $xqrrD.BufferStack);\n            let nodeIndex16 = nodeIndex32 * 2;\n            // traverse until we find a leaf\n            while(!(0, $8x2iv.IS_LEAF)(nodeIndex16, uint16Array)){\n                // adjust offset to point to the right node\n                nodeIndex32 = (0, $8x2iv.RIGHT_NODE)(nodeIndex32, uint32Array);\n                nodeIndex16 = nodeIndex32 * 2;\n            }\n            // return the end offset of the triangle range\n            return (0, $8x2iv.OFFSET)(nodeIndex32, uint32Array) + (0, $8x2iv.COUNT)(nodeIndex16, uint16Array);\n        }\n    }\n}\n\n});\nparcelRegister(\"xqrrD\", function(module, exports) {\n\n$parcel$export(module.exports, \"BufferStack\", () => $064797f1cfb48450$export$7451c73ce907854f);\nclass $064797f1cfb48450$var$_BufferStack {\n    constructor(){\n        this.float32Array = null;\n        this.uint16Array = null;\n        this.uint32Array = null;\n        const stack = [];\n        let prevBuffer = null;\n        this.setBuffer = (buffer)=>{\n            if (prevBuffer) stack.push(prevBuffer);\n            prevBuffer = buffer;\n            this.float32Array = new Float32Array(buffer);\n            this.uint16Array = new Uint16Array(buffer);\n            this.uint32Array = new Uint32Array(buffer);\n        };\n        this.clearBuffer = ()=>{\n            prevBuffer = null;\n            this.float32Array = null;\n            this.uint16Array = null;\n            this.uint32Array = null;\n            if (stack.length !== 0) this.setBuffer(stack.pop());\n        };\n    }\n}\nconst $064797f1cfb48450$export$7451c73ce907854f = new $064797f1cfb48450$var$_BufferStack();\n\n});\n\n\nparcelRegister(\"8VlEg\", function(module, exports) {\n\n$parcel$export(module.exports, \"closestPointToPoint\", () => $67f4708097c33efc$export$96ec44700e587d99);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nconst $67f4708097c33efc$var$temp = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $67f4708097c33efc$var$temp1 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nfunction $67f4708097c33efc$export$96ec44700e587d99(bvh, point, target = {}, minThreshold = 0, maxThreshold = Infinity) {\n    // early out if under minThreshold\n    // skip checking if over maxThreshold\n    // set minThreshold = maxThreshold to quickly check if a point is within a threshold\n    // returns Infinity if no value found\n    const minThresholdSq = minThreshold * minThreshold;\n    const maxThresholdSq = maxThreshold * maxThreshold;\n    let closestDistanceSq = Infinity;\n    let closestDistanceTriIndex = null;\n    bvh.shapecast({\n        boundsTraverseOrder: (box)=>{\n            $67f4708097c33efc$var$temp.copy(point).clamp(box.min, box.max);\n            return $67f4708097c33efc$var$temp.distanceToSquared(point);\n        },\n        intersectsBounds: (box, isLeaf, score)=>{\n            return score < closestDistanceSq && score < maxThresholdSq;\n        },\n        intersectsTriangle: (tri, triIndex)=>{\n            tri.closestPointToPoint(point, $67f4708097c33efc$var$temp);\n            const distSq = point.distanceToSquared($67f4708097c33efc$var$temp);\n            if (distSq < closestDistanceSq) {\n                $67f4708097c33efc$var$temp1.copy($67f4708097c33efc$var$temp);\n                closestDistanceSq = distSq;\n                closestDistanceTriIndex = triIndex;\n            }\n            if (distSq < minThresholdSq) return true;\n            else return false;\n        }\n    });\n    if (closestDistanceSq === Infinity) return null;\n    const closestDistance = Math.sqrt(closestDistanceSq);\n    if (!target.point) target.point = $67f4708097c33efc$var$temp1.clone();\n    else target.point.copy($67f4708097c33efc$var$temp1);\n    target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;\n    return target;\n}\n\n});\n\nparcelRegister(\"9Kyri\", function(module, exports) {\n\n$parcel$export(module.exports, \"intersectTris\", () => $01d4f4206273ed95$export$6f0a8fc5d2775a51);\n$parcel$export(module.exports, \"intersectClosestTri\", () => $01d4f4206273ed95$export$4331f2604b0bca4);\n$parcel$export(module.exports, \"iterateOverTriangles\", () => $01d4f4206273ed95$export$be1391b7aa79c0f6);\n\nvar $7pS02 = parcelRequire(\"7pS02\");\n\nvar $dRxiJ = parcelRequire(\"dRxiJ\");\n/*************************************************************/ /* This file is generated from \"iterationUtils.template.js\". */ /*************************************************************/ /* eslint-disable indent */ function $01d4f4206273ed95$export$6f0a8fc5d2775a51(bvh, side, ray, offset, count, intersections) {\n    const { geometry: geometry, _indirectBuffer: _indirectBuffer } = bvh;\n    for(let i = offset, end = offset + count; i < end; i++)(0, $7pS02.intersectTri)(geometry, side, ray, i, intersections);\n}\nfunction $01d4f4206273ed95$export$4331f2604b0bca4(bvh, side, ray, offset, count) {\n    const { geometry: geometry, _indirectBuffer: _indirectBuffer } = bvh;\n    let dist = Infinity;\n    let res = null;\n    for(let i = offset, end = offset + count; i < end; i++){\n        let intersection;\n        intersection = (0, $7pS02.intersectTri)(geometry, side, ray, i);\n        if (intersection && intersection.distance < dist) {\n            res = intersection;\n            dist = intersection.distance;\n        }\n    }\n    return res;\n}\nfunction $01d4f4206273ed95$export$be1391b7aa79c0f6(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle) {\n    const { geometry: geometry } = bvh;\n    const { index: index } = geometry;\n    const pos = geometry.attributes.position;\n    for(let i = offset, l = count + offset; i < l; i++){\n        let tri;\n        tri = i;\n        (0, $dRxiJ.setTriangle)(triangle, tri * 3, index, pos);\n        triangle.needsUpdate = true;\n        if (intersectsTriangleFunc(triangle, tri, contained, depth)) return true;\n    }\n    return false;\n}\n\n});\nparcelRegister(\"7pS02\", function(module, exports) {\n\n$parcel$export(module.exports, \"intersectTri\", () => $5664c169f49816c4$export$1a557053019a130b);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst $5664c169f49816c4$var$_vA = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $5664c169f49816c4$var$_vB = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $5664c169f49816c4$var$_vC = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $5664c169f49816c4$var$_uvA = /* @__PURE__ */ new (0, $ilwiq.Vector2)();\nconst $5664c169f49816c4$var$_uvB = /* @__PURE__ */ new (0, $ilwiq.Vector2)();\nconst $5664c169f49816c4$var$_uvC = /* @__PURE__ */ new (0, $ilwiq.Vector2)();\nconst $5664c169f49816c4$var$_normalA = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $5664c169f49816c4$var$_normalB = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $5664c169f49816c4$var$_normalC = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $5664c169f49816c4$var$_intersectionPoint = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nfunction $5664c169f49816c4$var$checkIntersection(ray, pA, pB, pC, point, side) {\n    let intersect;\n    if (side === (0, $ilwiq.BackSide)) intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n    else intersect = ray.intersectTriangle(pA, pB, pC, side !== (0, $ilwiq.DoubleSide), point);\n    if (intersect === null) return null;\n    const distance = ray.origin.distanceTo(point);\n    return {\n        distance: distance,\n        point: point.clone()\n    };\n}\nfunction $5664c169f49816c4$var$checkBufferGeometryIntersection(ray, position, normal, uv, uv1, a, b, c, side) {\n    $5664c169f49816c4$var$_vA.fromBufferAttribute(position, a);\n    $5664c169f49816c4$var$_vB.fromBufferAttribute(position, b);\n    $5664c169f49816c4$var$_vC.fromBufferAttribute(position, c);\n    const intersection = $5664c169f49816c4$var$checkIntersection(ray, $5664c169f49816c4$var$_vA, $5664c169f49816c4$var$_vB, $5664c169f49816c4$var$_vC, $5664c169f49816c4$var$_intersectionPoint, side);\n    if (intersection) {\n        if (uv) {\n            $5664c169f49816c4$var$_uvA.fromBufferAttribute(uv, a);\n            $5664c169f49816c4$var$_uvB.fromBufferAttribute(uv, b);\n            $5664c169f49816c4$var$_uvC.fromBufferAttribute(uv, c);\n            intersection.uv = (0, $ilwiq.Triangle).getInterpolation($5664c169f49816c4$var$_intersectionPoint, $5664c169f49816c4$var$_vA, $5664c169f49816c4$var$_vB, $5664c169f49816c4$var$_vC, $5664c169f49816c4$var$_uvA, $5664c169f49816c4$var$_uvB, $5664c169f49816c4$var$_uvC, new (0, $ilwiq.Vector2)());\n        }\n        if (uv1) {\n            $5664c169f49816c4$var$_uvA.fromBufferAttribute(uv1, a);\n            $5664c169f49816c4$var$_uvB.fromBufferAttribute(uv1, b);\n            $5664c169f49816c4$var$_uvC.fromBufferAttribute(uv1, c);\n            intersection.uv1 = (0, $ilwiq.Triangle).getInterpolation($5664c169f49816c4$var$_intersectionPoint, $5664c169f49816c4$var$_vA, $5664c169f49816c4$var$_vB, $5664c169f49816c4$var$_vC, $5664c169f49816c4$var$_uvA, $5664c169f49816c4$var$_uvB, $5664c169f49816c4$var$_uvC, new (0, $ilwiq.Vector2)());\n        }\n        if (normal) {\n            $5664c169f49816c4$var$_normalA.fromBufferAttribute(normal, a);\n            $5664c169f49816c4$var$_normalB.fromBufferAttribute(normal, b);\n            $5664c169f49816c4$var$_normalC.fromBufferAttribute(normal, c);\n            intersection.normal = (0, $ilwiq.Triangle).getInterpolation($5664c169f49816c4$var$_intersectionPoint, $5664c169f49816c4$var$_vA, $5664c169f49816c4$var$_vB, $5664c169f49816c4$var$_vC, $5664c169f49816c4$var$_normalA, $5664c169f49816c4$var$_normalB, $5664c169f49816c4$var$_normalC, new (0, $ilwiq.Vector3)());\n            if (intersection.normal.dot(ray.direction) > 0) intersection.normal.multiplyScalar(-1);\n        }\n        const face = {\n            a: a,\n            b: b,\n            c: c,\n            normal: new (0, $ilwiq.Vector3)(),\n            materialIndex: 0\n        };\n        (0, $ilwiq.Triangle).getNormal($5664c169f49816c4$var$_vA, $5664c169f49816c4$var$_vB, $5664c169f49816c4$var$_vC, face.normal);\n        intersection.face = face;\n        intersection.faceIndex = a;\n    }\n    return intersection;\n}\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction $5664c169f49816c4$export$1a557053019a130b(geo, side, ray, tri, intersections) {\n    const triOffset = tri * 3;\n    let a = triOffset + 0;\n    let b = triOffset + 1;\n    let c = triOffset + 2;\n    const index = geo.index;\n    if (geo.index) {\n        a = index.getX(a);\n        b = index.getX(b);\n        c = index.getX(c);\n    }\n    const { position: position, normal: normal, uv: uv, uv1: uv1 } = geo.attributes;\n    const intersection = $5664c169f49816c4$var$checkBufferGeometryIntersection(ray, position, normal, uv, uv1, a, b, c, side);\n    if (intersection) {\n        intersection.faceIndex = tri;\n        if (intersections) intersections.push(intersection);\n        return intersection;\n    }\n    return null;\n}\n\n});\n\nparcelRegister(\"dRxiJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"setTriangle\", () => $a17a0e7ef0b826e6$export$32f7fa781964ae30);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nfunction $a17a0e7ef0b826e6$export$32f7fa781964ae30(tri, i, index, pos) {\n    const ta = tri.a;\n    const tb = tri.b;\n    const tc = tri.c;\n    let i0 = i;\n    let i1 = i + 1;\n    let i2 = i + 2;\n    if (index) {\n        i0 = index.getX(i0);\n        i1 = index.getX(i1);\n        i2 = index.getX(i2);\n    }\n    ta.x = pos.getX(i0);\n    ta.y = pos.getY(i0);\n    ta.z = pos.getZ(i0);\n    tb.x = pos.getX(i1);\n    tb.y = pos.getY(i1);\n    tb.z = pos.getZ(i1);\n    tc.x = pos.getX(i2);\n    tc.y = pos.getY(i2);\n    tc.z = pos.getZ(i2);\n}\nconst $a17a0e7ef0b826e6$var$tempV1 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $a17a0e7ef0b826e6$var$tempV2 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $a17a0e7ef0b826e6$var$tempV3 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $a17a0e7ef0b826e6$var$tempUV1 = /* @__PURE__ */ new (0, $ilwiq.Vector2)();\nconst $a17a0e7ef0b826e6$var$tempUV2 = /* @__PURE__ */ new (0, $ilwiq.Vector2)();\nconst $a17a0e7ef0b826e6$var$tempUV3 = /* @__PURE__ */ new (0, $ilwiq.Vector2)();\nfunction $a17a0e7ef0b826e6$export$d3cf03f2575167ef(point, geometry, triangleIndex, target) {\n    const indices = geometry.getIndex().array;\n    const positions = geometry.getAttribute(\"position\");\n    const uvs = geometry.getAttribute(\"uv\");\n    const a = indices[triangleIndex * 3];\n    const b = indices[triangleIndex * 3 + 1];\n    const c = indices[triangleIndex * 3 + 2];\n    $a17a0e7ef0b826e6$var$tempV1.fromBufferAttribute(positions, a);\n    $a17a0e7ef0b826e6$var$tempV2.fromBufferAttribute(positions, b);\n    $a17a0e7ef0b826e6$var$tempV3.fromBufferAttribute(positions, c);\n    // find the associated material index\n    let materialIndex = 0;\n    const groups = geometry.groups;\n    const firstVertexIndex = triangleIndex * 3;\n    for(let i = 0, l = groups.length; i < l; i++){\n        const group = groups[i];\n        const { start: start, count: count } = group;\n        if (firstVertexIndex >= start && firstVertexIndex < start + count) {\n            materialIndex = group.materialIndex;\n            break;\n        }\n    }\n    // extract uvs\n    let uv = null;\n    if (uvs) {\n        $a17a0e7ef0b826e6$var$tempUV1.fromBufferAttribute(uvs, a);\n        $a17a0e7ef0b826e6$var$tempUV2.fromBufferAttribute(uvs, b);\n        $a17a0e7ef0b826e6$var$tempUV3.fromBufferAttribute(uvs, c);\n        if (target && target.uv) uv = target.uv;\n        else uv = new (0, $ilwiq.Vector2)();\n        (0, $ilwiq.Triangle).getInterpolation(point, $a17a0e7ef0b826e6$var$tempV1, $a17a0e7ef0b826e6$var$tempV2, $a17a0e7ef0b826e6$var$tempV3, $a17a0e7ef0b826e6$var$tempUV1, $a17a0e7ef0b826e6$var$tempUV2, $a17a0e7ef0b826e6$var$tempUV3, uv);\n    }\n    // adjust the provided target or create a new one\n    if (target) {\n        if (!target.face) target.face = {};\n        target.face.a = a;\n        target.face.b = b;\n        target.face.c = c;\n        target.face.materialIndex = materialIndex;\n        if (!target.face.normal) target.face.normal = new (0, $ilwiq.Vector3)();\n        (0, $ilwiq.Triangle).getNormal($a17a0e7ef0b826e6$var$tempV1, $a17a0e7ef0b826e6$var$tempV2, $a17a0e7ef0b826e6$var$tempV3, target.face.normal);\n        if (uv) target.uv = uv;\n        return target;\n    } else return {\n        face: {\n            a: a,\n            b: b,\n            c: c,\n            materialIndex: materialIndex,\n            normal: (0, $ilwiq.Triangle).getNormal($a17a0e7ef0b826e6$var$tempV1, $a17a0e7ef0b826e6$var$tempV2, $a17a0e7ef0b826e6$var$tempV3, new (0, $ilwiq.Vector3)())\n        },\n        uv: uv\n    };\n}\n\n});\n\n\nparcelRegister(\"ayHng\", function(module, exports) {\n\n$parcel$export(module.exports, \"refit\", () => $7afeb992771d32d5$export$8eb1eda96b2e6d7a);\n\nvar $alNGj = parcelRequire(\"alNGj\");\n/****************************************************/ /* This file is generated from \"refit.template.js\". */ /****************************************************/ function $7afeb992771d32d5$export$8eb1eda96b2e6d7a(bvh, nodeIndices = null) {\n    if (nodeIndices && Array.isArray(nodeIndices)) nodeIndices = new Set(nodeIndices);\n    const geometry = bvh.geometry;\n    const indexArr = geometry.index ? geometry.index.array : null;\n    const posAttr = geometry.attributes.position;\n    let buffer, uint32Array, uint16Array, float32Array;\n    let byteOffset = 0;\n    const roots = bvh._roots;\n    for(let i = 0, l = roots.length; i < l; i++){\n        buffer = roots[i];\n        uint32Array = new Uint32Array(buffer);\n        uint16Array = new Uint16Array(buffer);\n        float32Array = new Float32Array(buffer);\n        _traverse(0, byteOffset);\n        byteOffset += buffer.byteLength;\n    }\n    function _traverse(node32Index, byteOffset, force = false) {\n        const node16Index = node32Index * 2;\n        const isLeaf = uint16Array[node16Index + 15] === (0, $alNGj.IS_LEAFNODE_FLAG);\n        if (isLeaf) {\n            const offset = uint32Array[node32Index + 6];\n            const count = uint16Array[node16Index + 14];\n            let minx = Infinity;\n            let miny = Infinity;\n            let minz = Infinity;\n            let maxx = -Infinity;\n            let maxy = -Infinity;\n            let maxz = -Infinity;\n            for(let i = 3 * offset, l = 3 * (offset + count); i < l; i++){\n                let index = indexArr[i];\n                const x = posAttr.getX(index);\n                const y = posAttr.getY(index);\n                const z = posAttr.getZ(index);\n                if (x < minx) minx = x;\n                if (x > maxx) maxx = x;\n                if (y < miny) miny = y;\n                if (y > maxy) maxy = y;\n                if (z < minz) minz = z;\n                if (z > maxz) maxz = z;\n            }\n            if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n                float32Array[node32Index + 0] = minx;\n                float32Array[node32Index + 1] = miny;\n                float32Array[node32Index + 2] = minz;\n                float32Array[node32Index + 3] = maxx;\n                float32Array[node32Index + 4] = maxy;\n                float32Array[node32Index + 5] = maxz;\n                return true;\n            } else return false;\n        } else {\n            const left = node32Index + 8;\n            const right = uint32Array[node32Index + 6];\n            // the identifying node indices provided by the shapecast function include offsets of all\n            // root buffers to guarantee they're unique between roots so offset left and right indices here.\n            const offsetLeft = left + byteOffset;\n            const offsetRight = right + byteOffset;\n            let forceChildren = force;\n            let includesLeft = false;\n            let includesRight = false;\n            if (nodeIndices) // if we see that neither the left or right child are included in the set that need to be updated\n            // then we assume that all children need to be updated.\n            {\n                if (!forceChildren) {\n                    includesLeft = nodeIndices.has(offsetLeft);\n                    includesRight = nodeIndices.has(offsetRight);\n                    forceChildren = !includesLeft && !includesRight;\n                }\n            } else {\n                includesLeft = true;\n                includesRight = true;\n            }\n            const traverseLeft = forceChildren || includesLeft;\n            const traverseRight = forceChildren || includesRight;\n            let leftChange = false;\n            if (traverseLeft) leftChange = _traverse(left, byteOffset, forceChildren);\n            let rightChange = false;\n            if (traverseRight) rightChange = _traverse(right, byteOffset, forceChildren);\n            const didChange = leftChange || rightChange;\n            if (didChange) for(let i = 0; i < 3; i++){\n                const lefti = left + i;\n                const righti = right + i;\n                const minLeftValue = float32Array[lefti];\n                const maxLeftValue = float32Array[lefti + 3];\n                const minRightValue = float32Array[righti];\n                const maxRightValue = float32Array[righti + 3];\n                float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n                float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n            }\n            return didChange;\n        }\n    }\n}\n\n});\n\nparcelRegister(\"laUNa\", function(module, exports) {\n\n$parcel$export(module.exports, \"raycast\", () => $f6a695dbb681b4c5$export$630e89aab3ddc1d6);\n\nvar $d4vta = parcelRequire(\"d4vta\");\n\nvar $8x2iv = parcelRequire(\"8x2iv\");\n\nvar $xqrrD = parcelRequire(\"xqrrD\");\n\nvar $9Kyri = parcelRequire(\"9Kyri\");\n\n/******************************************************/ /* This file is generated from \"raycast.template.js\". */ /******************************************************/ function $f6a695dbb681b4c5$export$630e89aab3ddc1d6(bvh, root, side, ray, intersects) {\n    (0, $xqrrD.BufferStack).setBuffer(bvh._roots[root]);\n    $f6a695dbb681b4c5$var$_raycast(0, bvh, side, ray, intersects);\n    (0, $xqrrD.BufferStack).clearBuffer();\n}\nfunction $f6a695dbb681b4c5$var$_raycast(nodeIndex32, bvh, side, ray, intersects) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $xqrrD.BufferStack);\n    const nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0, $8x2iv.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0, $8x2iv.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0, $8x2iv.COUNT)(nodeIndex16, uint16Array);\n        (0, $9Kyri.intersectTris)(bvh, side, ray, offset, count, intersects);\n    } else {\n        const leftIndex = (0, $8x2iv.LEFT_NODE)(nodeIndex32);\n        if ((0, $d4vta.intersectRay)(leftIndex, float32Array, ray)) $f6a695dbb681b4c5$var$_raycast(leftIndex, bvh, side, ray, intersects);\n        const rightIndex = (0, $8x2iv.RIGHT_NODE)(nodeIndex32, uint32Array);\n        if ((0, $d4vta.intersectRay)(rightIndex, float32Array, ray)) $f6a695dbb681b4c5$var$_raycast(rightIndex, bvh, side, ray, intersects);\n    }\n}\n\n});\nparcelRegister(\"d4vta\", function(module, exports) {\n\n$parcel$export(module.exports, \"intersectRay\", () => $98440f459aa220f3$export$d5a069a08bb68982);\n/**\n * This function performs intersection tests similar to Ray.intersectBox in three.js,\n * with the difference that the box values are read from an array to improve performance.\n */ function $98440f459aa220f3$export$d5a069a08bb68982(nodeIndex32, array, ray) {\n    let tmin, tmax, tymin, tymax, tzmin, tzmax;\n    const invdirx = 1 / ray.direction.x, invdiry = 1 / ray.direction.y, invdirz = 1 / ray.direction.z;\n    const ox = ray.origin.x;\n    const oy = ray.origin.y;\n    const oz = ray.origin.z;\n    let minx = array[nodeIndex32];\n    let maxx = array[nodeIndex32 + 3];\n    let miny = array[nodeIndex32 + 1];\n    let maxy = array[nodeIndex32 + 3 + 1];\n    let minz = array[nodeIndex32 + 2];\n    let maxz = array[nodeIndex32 + 3 + 2];\n    if (invdirx >= 0) {\n        tmin = (minx - ox) * invdirx;\n        tmax = (maxx - ox) * invdirx;\n    } else {\n        tmin = (maxx - ox) * invdirx;\n        tmax = (minx - ox) * invdirx;\n    }\n    if (invdiry >= 0) {\n        tymin = (miny - oy) * invdiry;\n        tymax = (maxy - oy) * invdiry;\n    } else {\n        tymin = (maxy - oy) * invdiry;\n        tymax = (miny - oy) * invdiry;\n    }\n    if (tmin > tymax || tymin > tmax) return false;\n    if (tymin > tmin || isNaN(tmin)) tmin = tymin;\n    if (tymax < tmax || isNaN(tmax)) tmax = tymax;\n    if (invdirz >= 0) {\n        tzmin = (minz - oz) * invdirz;\n        tzmax = (maxz - oz) * invdirz;\n    } else {\n        tzmin = (maxz - oz) * invdirz;\n        tzmax = (minz - oz) * invdirz;\n    }\n    if (tmin > tzmax || tzmin > tmax) return false;\n    // if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin; // Uncomment this line if add the distance check\n    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;\n    //return point closest to the ray (positive side)\n    if (tmax < 0) return false;\n    return true;\n}\n\n});\n\n\nparcelRegister(\"1SnJR\", function(module, exports) {\n\n$parcel$export(module.exports, \"raycastFirst\", () => $15dd3f9915d1b1ff$export$1fa457bc72ef1a2a);\n\nvar $8x2iv = parcelRequire(\"8x2iv\");\n\nvar $xqrrD = parcelRequire(\"xqrrD\");\n\nvar $d4vta = parcelRequire(\"d4vta\");\n\nvar $9Kyri = parcelRequire(\"9Kyri\");\n\n/***********************************************************/ /* This file is generated from \"raycastFirst.template.js\". */ /***********************************************************/ const $15dd3f9915d1b1ff$var$_xyzFields = [\n    \"x\",\n    \"y\",\n    \"z\"\n];\nfunction $15dd3f9915d1b1ff$export$1fa457bc72ef1a2a(bvh, root, side, ray) {\n    (0, $xqrrD.BufferStack).setBuffer(bvh._roots[root]);\n    const result = $15dd3f9915d1b1ff$var$_raycastFirst(0, bvh, side, ray);\n    (0, $xqrrD.BufferStack).clearBuffer();\n    return result;\n}\nfunction $15dd3f9915d1b1ff$var$_raycastFirst(nodeIndex32, bvh, side, ray) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $xqrrD.BufferStack);\n    let nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0, $8x2iv.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0, $8x2iv.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0, $8x2iv.COUNT)(nodeIndex16, uint16Array);\n        return (0, $9Kyri.intersectClosestTri)(bvh, side, ray, offset, count);\n    } else {\n        // consider the position of the split plane with respect to the oncoming ray; whichever direction\n        // the ray is coming from, look for an intersection among that side of the tree first\n        const splitAxis = (0, $8x2iv.SPLIT_AXIS)(nodeIndex32, uint32Array);\n        const xyzAxis = $15dd3f9915d1b1ff$var$_xyzFields[splitAxis];\n        const rayDir = ray.direction[xyzAxis];\n        const leftToRight = rayDir >= 0;\n        // c1 is the child to check first\n        let c1, c2;\n        if (leftToRight) {\n            c1 = (0, $8x2iv.LEFT_NODE)(nodeIndex32);\n            c2 = (0, $8x2iv.RIGHT_NODE)(nodeIndex32, uint32Array);\n        } else {\n            c1 = (0, $8x2iv.RIGHT_NODE)(nodeIndex32, uint32Array);\n            c2 = (0, $8x2iv.LEFT_NODE)(nodeIndex32);\n        }\n        const c1Intersection = (0, $d4vta.intersectRay)(c1, float32Array, ray);\n        const c1Result = c1Intersection ? $15dd3f9915d1b1ff$var$_raycastFirst(c1, bvh, side, ray) : null;\n        // if we got an intersection in the first node and it's closer than the second node's bounding\n        // box, we don't need to consider the second node because it couldn't possibly be a better result\n        if (c1Result) {\n            // check if the point is within the second bounds\n            // \"point\" is in the local frame of the bvh\n            const point = c1Result.point[xyzAxis];\n            const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : point >= float32Array[c2 + splitAxis + 3]; // max bounding data\n            if (isOutside) return c1Result;\n        }\n        // either there was no intersection in the first node, or there could still be a closer\n        // intersection in the second, so check the second node and then take the better of the two\n        const c2Intersection = (0, $d4vta.intersectRay)(c2, float32Array, ray);\n        const c2Result = c2Intersection ? $15dd3f9915d1b1ff$var$_raycastFirst(c2, bvh, side, ray) : null;\n        if (c1Result && c2Result) return c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n        else return c1Result || c2Result || null;\n    }\n}\n\n});\n\nparcelRegister(\"dhXUU\", function(module, exports) {\n\n$parcel$export(module.exports, \"intersectsGeometry\", () => $9acb57256233c065$export$b2f96b0abaf94e0a);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $lenTA = parcelRequire(\"lenTA\");\n\nvar $8VYkb = parcelRequire(\"8VYkb\");\n\nvar $dRxiJ = parcelRequire(\"dRxiJ\");\n\nvar $eADNI = parcelRequire(\"eADNI\");\n\nvar $8x2iv = parcelRequire(\"8x2iv\");\n\nvar $xqrrD = parcelRequire(\"xqrrD\");\n/*****************************************************************/ /* This file is generated from \"intersectsGeometry.template.js\". */ /*****************************************************************/ /* eslint-disable indent */ const $9acb57256233c065$var$boundingBox = /* @__PURE__ */ new (0, $ilwiq.Box3)();\nconst $9acb57256233c065$var$triangle = /* @__PURE__ */ new (0, $8VYkb.ExtendedTriangle)();\nconst $9acb57256233c065$var$triangle2 = /* @__PURE__ */ new (0, $8VYkb.ExtendedTriangle)();\nconst $9acb57256233c065$var$invertedMat = /* @__PURE__ */ new (0, $ilwiq.Matrix4)();\nconst $9acb57256233c065$var$obb = /* @__PURE__ */ new (0, $lenTA.OrientedBox)();\nconst $9acb57256233c065$var$obb2 = /* @__PURE__ */ new (0, $lenTA.OrientedBox)();\nfunction $9acb57256233c065$export$b2f96b0abaf94e0a(bvh, root, otherGeometry, geometryToBvh) {\n    (0, $xqrrD.BufferStack).setBuffer(bvh._roots[root]);\n    const result = $9acb57256233c065$var$_intersectsGeometry(0, bvh, otherGeometry, geometryToBvh);\n    (0, $xqrrD.BufferStack).clearBuffer();\n    return result;\n}\nfunction $9acb57256233c065$var$_intersectsGeometry(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $xqrrD.BufferStack);\n    let nodeIndex16 = nodeIndex32 * 2;\n    if (cachedObb === null) {\n        if (!otherGeometry.boundingBox) otherGeometry.computeBoundingBox();\n        $9acb57256233c065$var$obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n        cachedObb = $9acb57256233c065$var$obb;\n    }\n    const isLeaf = (0, $8x2iv.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const thisGeometry = bvh.geometry;\n        const thisIndex = thisGeometry.index;\n        const thisPos = thisGeometry.attributes.position;\n        const index = otherGeometry.index;\n        const pos = otherGeometry.attributes.position;\n        const offset = (0, $8x2iv.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0, $8x2iv.COUNT)(nodeIndex16, uint16Array);\n        // get the inverse of the geometry matrix so we can transform our triangles into the\n        // geometry space we're trying to test. We assume there are fewer triangles being checked\n        // here.\n        $9acb57256233c065$var$invertedMat.copy(geometryToBvh).invert();\n        if (otherGeometry.boundsTree) {\n            // if there's a bounds tree\n            (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(nodeIndex32), float32Array, $9acb57256233c065$var$obb2);\n            $9acb57256233c065$var$obb2.matrix.copy($9acb57256233c065$var$invertedMat);\n            $9acb57256233c065$var$obb2.needsUpdate = true;\n            // TODO: use a triangle iteration function here\n            const res = otherGeometry.boundsTree.shapecast({\n                intersectsBounds: (box)=>$9acb57256233c065$var$obb2.intersectsBox(box),\n                intersectsTriangle: (tri)=>{\n                    tri.a.applyMatrix4(geometryToBvh);\n                    tri.b.applyMatrix4(geometryToBvh);\n                    tri.c.applyMatrix4(geometryToBvh);\n                    tri.needsUpdate = true;\n                    for(let i = offset * 3, l = (count + offset) * 3; i < l; i += 3){\n                        // this triangle needs to be transformed into the current BVH coordinate frame\n                        (0, $dRxiJ.setTriangle)($9acb57256233c065$var$triangle2, i, thisIndex, thisPos);\n                        $9acb57256233c065$var$triangle2.needsUpdate = true;\n                        if (tri.intersectsTriangle($9acb57256233c065$var$triangle2)) return true;\n                    }\n                    return false;\n                }\n            });\n            return res;\n        } else // if we're just dealing with raw geometry\n        for(let i = offset * 3, l = (count + offset) * 3; i < l; i += 3){\n            // this triangle needs to be transformed into the current BVH coordinate frame\n            (0, $dRxiJ.setTriangle)($9acb57256233c065$var$triangle, i, thisIndex, thisPos);\n            $9acb57256233c065$var$triangle.a.applyMatrix4($9acb57256233c065$var$invertedMat);\n            $9acb57256233c065$var$triangle.b.applyMatrix4($9acb57256233c065$var$invertedMat);\n            $9acb57256233c065$var$triangle.c.applyMatrix4($9acb57256233c065$var$invertedMat);\n            $9acb57256233c065$var$triangle.needsUpdate = true;\n            for(let i2 = 0, l2 = index.count; i2 < l2; i2 += 3){\n                (0, $dRxiJ.setTriangle)($9acb57256233c065$var$triangle2, i2, index, pos);\n                $9acb57256233c065$var$triangle2.needsUpdate = true;\n                if ($9acb57256233c065$var$triangle.intersectsTriangle($9acb57256233c065$var$triangle2)) return true;\n            }\n        }\n    } else {\n        const left = nodeIndex32 + 8;\n        const right = uint32Array[nodeIndex32 + 6];\n        (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(left), float32Array, $9acb57256233c065$var$boundingBox);\n        const leftIntersection = cachedObb.intersectsBox($9acb57256233c065$var$boundingBox) && $9acb57256233c065$var$_intersectsGeometry(left, bvh, otherGeometry, geometryToBvh, cachedObb);\n        if (leftIntersection) return true;\n        (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(right), float32Array, $9acb57256233c065$var$boundingBox);\n        const rightIntersection = cachedObb.intersectsBox($9acb57256233c065$var$boundingBox) && $9acb57256233c065$var$_intersectsGeometry(right, bvh, otherGeometry, geometryToBvh, cachedObb);\n        if (rightIntersection) return true;\n        return false;\n    }\n}\n\n});\n\nparcelRegister(\"dnRHH\", function(module, exports) {\n\n$parcel$export(module.exports, \"closestPointToGeometry\", () => $9be714d2e19cc068$export$5912902c175a555e);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $lenTA = parcelRequire(\"lenTA\");\n\nvar $dRxiJ = parcelRequire(\"dRxiJ\");\n\nvar $5Gkg5 = parcelRequire(\"5Gkg5\");\n\nvar $7EZfU = parcelRequire(\"7EZfU\");\n/*********************************************************************/ /* This file is generated from \"closestPointToGeometry.template.js\". */ /*********************************************************************/ const $9be714d2e19cc068$var$tempMatrix = /* @__PURE__ */ new (0, $ilwiq.Matrix4)();\nconst $9be714d2e19cc068$var$obb = /* @__PURE__ */ new (0, $lenTA.OrientedBox)();\nconst $9be714d2e19cc068$var$obb2 = /* @__PURE__ */ new (0, $lenTA.OrientedBox)();\nconst $9be714d2e19cc068$var$temp1 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $9be714d2e19cc068$var$temp2 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $9be714d2e19cc068$var$temp3 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $9be714d2e19cc068$var$temp4 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nfunction $9be714d2e19cc068$export$5912902c175a555e(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {\n    if (!otherGeometry.boundingBox) otherGeometry.computeBoundingBox();\n    $9be714d2e19cc068$var$obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n    $9be714d2e19cc068$var$obb.needsUpdate = true;\n    const geometry = bvh.geometry;\n    const pos = geometry.attributes.position;\n    const index = geometry.index;\n    const otherPos = otherGeometry.attributes.position;\n    const otherIndex = otherGeometry.index;\n    const triangle = (0, $7EZfU.ExtendedTrianglePool).getPrimitive();\n    const triangle2 = (0, $7EZfU.ExtendedTrianglePool).getPrimitive();\n    let tempTarget1 = $9be714d2e19cc068$var$temp1;\n    let tempTargetDest1 = $9be714d2e19cc068$var$temp2;\n    let tempTarget2 = null;\n    let tempTargetDest2 = null;\n    if (target2) {\n        tempTarget2 = $9be714d2e19cc068$var$temp3;\n        tempTargetDest2 = $9be714d2e19cc068$var$temp4;\n    }\n    let closestDistance = Infinity;\n    let closestDistanceTriIndex = null;\n    let closestDistanceOtherTriIndex = null;\n    $9be714d2e19cc068$var$tempMatrix.copy(geometryToBvh).invert();\n    $9be714d2e19cc068$var$obb2.matrix.copy($9be714d2e19cc068$var$tempMatrix);\n    bvh.shapecast({\n        boundsTraverseOrder: (box)=>{\n            return $9be714d2e19cc068$var$obb.distanceToBox(box);\n        },\n        intersectsBounds: (box, isLeaf, score)=>{\n            if (score < closestDistance && score < maxThreshold) {\n                // if we know the triangles of this bounds will be intersected next then\n                // save the bounds to use during triangle checks.\n                if (isLeaf) {\n                    $9be714d2e19cc068$var$obb2.min.copy(box.min);\n                    $9be714d2e19cc068$var$obb2.max.copy(box.max);\n                    $9be714d2e19cc068$var$obb2.needsUpdate = true;\n                }\n                return true;\n            }\n            return false;\n        },\n        intersectsRange: (offset, count)=>{\n            if (otherGeometry.boundsTree) {\n                // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n                // the closest bounds in the other geometry to check.\n                const otherBvh = otherGeometry.boundsTree;\n                return otherBvh.shapecast({\n                    boundsTraverseOrder: (box)=>{\n                        return $9be714d2e19cc068$var$obb2.distanceToBox(box);\n                    },\n                    intersectsBounds: (box, isLeaf, score)=>{\n                        return score < closestDistance && score < maxThreshold;\n                    },\n                    intersectsRange: (otherOffset, otherCount)=>{\n                        for(let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++){\n                            (0, $dRxiJ.setTriangle)(triangle2, 3 * i2, otherIndex, otherPos);\n                            triangle2.a.applyMatrix4(geometryToBvh);\n                            triangle2.b.applyMatrix4(geometryToBvh);\n                            triangle2.c.applyMatrix4(geometryToBvh);\n                            triangle2.needsUpdate = true;\n                            for(let i = offset, l = offset + count; i < l; i++){\n                                (0, $dRxiJ.setTriangle)(triangle, 3 * i, index, pos);\n                                triangle.needsUpdate = true;\n                                const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                                if (dist < closestDistance) {\n                                    tempTargetDest1.copy(tempTarget1);\n                                    if (tempTargetDest2) tempTargetDest2.copy(tempTarget2);\n                                    closestDistance = dist;\n                                    closestDistanceTriIndex = i;\n                                    closestDistanceOtherTriIndex = i2;\n                                }\n                                // stop traversal if we find a point that's under the given threshold\n                                if (dist < minThreshold) return true;\n                            }\n                        }\n                    }\n                });\n            } else {\n                // If no bounds tree then we'll just check every triangle.\n                const triCount = (0, $5Gkg5.getTriCount)(otherGeometry);\n                for(let i2 = 0, l2 = triCount; i2 < l2; i2++){\n                    (0, $dRxiJ.setTriangle)(triangle2, 3 * i2, otherIndex, otherPos);\n                    triangle2.a.applyMatrix4(geometryToBvh);\n                    triangle2.b.applyMatrix4(geometryToBvh);\n                    triangle2.c.applyMatrix4(geometryToBvh);\n                    triangle2.needsUpdate = true;\n                    for(let i = offset, l = offset + count; i < l; i++){\n                        (0, $dRxiJ.setTriangle)(triangle, 3 * i, index, pos);\n                        triangle.needsUpdate = true;\n                        const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                        if (dist < closestDistance) {\n                            tempTargetDest1.copy(tempTarget1);\n                            if (tempTargetDest2) tempTargetDest2.copy(tempTarget2);\n                            closestDistance = dist;\n                            closestDistanceTriIndex = i;\n                            closestDistanceOtherTriIndex = i2;\n                        }\n                        // stop traversal if we find a point that's under the given threshold\n                        if (dist < minThreshold) return true;\n                    }\n                }\n            }\n        }\n    });\n    (0, $7EZfU.ExtendedTrianglePool).releasePrimitive(triangle);\n    (0, $7EZfU.ExtendedTrianglePool).releasePrimitive(triangle2);\n    if (closestDistance === Infinity) return null;\n    if (!target1.point) target1.point = tempTargetDest1.clone();\n    else target1.point.copy(tempTargetDest1);\n    target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;\n    if (target2) {\n        if (!target2.point) target2.point = tempTargetDest2.clone();\n        else target2.point.copy(tempTargetDest2);\n        target2.point.applyMatrix4($9be714d2e19cc068$var$tempMatrix);\n        tempTargetDest1.applyMatrix4($9be714d2e19cc068$var$tempMatrix);\n        target2.distance = tempTargetDest1.sub(target2.point).length();\n        target2.faceIndex = closestDistanceOtherTriIndex;\n    }\n    return target1;\n}\n\n});\n\nparcelRegister(\"gDpfV\", function(module, exports) {\n\n$parcel$export(module.exports, \"intersectTris_indirect\", () => $c1c3e12524864241$export$7e7412b9f4f11a5c);\n$parcel$export(module.exports, \"intersectClosestTri_indirect\", () => $c1c3e12524864241$export$dddff414156655a1);\n$parcel$export(module.exports, \"iterateOverTriangles_indirect\", () => $c1c3e12524864241$export$dae1f8efdced590b);\n\nvar $7pS02 = parcelRequire(\"7pS02\");\n\nvar $dRxiJ = parcelRequire(\"dRxiJ\");\n/*************************************************************/ /* This file is generated from \"iterationUtils.template.js\". */ /*************************************************************/ /* eslint-disable indent */ function $c1c3e12524864241$export$7e7412b9f4f11a5c(bvh, side, ray, offset, count, intersections) {\n    const { geometry: geometry, _indirectBuffer: _indirectBuffer } = bvh;\n    for(let i = offset, end = offset + count; i < end; i++){\n        let vi = _indirectBuffer ? _indirectBuffer[i] : i;\n        (0, $7pS02.intersectTri)(geometry, side, ray, vi, intersections);\n    }\n}\nfunction $c1c3e12524864241$export$dddff414156655a1(bvh, side, ray, offset, count) {\n    const { geometry: geometry, _indirectBuffer: _indirectBuffer } = bvh;\n    let dist = Infinity;\n    let res = null;\n    for(let i = offset, end = offset + count; i < end; i++){\n        let intersection;\n        intersection = (0, $7pS02.intersectTri)(geometry, side, ray, _indirectBuffer ? _indirectBuffer[i] : i);\n        if (intersection && intersection.distance < dist) {\n            res = intersection;\n            dist = intersection.distance;\n        }\n    }\n    return res;\n}\nfunction $c1c3e12524864241$export$dae1f8efdced590b(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle) {\n    const { geometry: geometry } = bvh;\n    const { index: index } = geometry;\n    const pos = geometry.attributes.position;\n    for(let i = offset, l = count + offset; i < l; i++){\n        let tri;\n        tri = bvh.resolveTriangleIndex(i);\n        (0, $dRxiJ.setTriangle)(triangle, tri * 3, index, pos);\n        triangle.needsUpdate = true;\n        if (intersectsTriangleFunc(triangle, tri, contained, depth)) return true;\n    }\n    return false;\n}\n\n});\n\nparcelRegister(\"iERXt\", function(module, exports) {\n\n$parcel$export(module.exports, \"refit_indirect\", () => $d955d16ddee6d2e4$export$40f4af49b81ca898);\n\nvar $alNGj = parcelRequire(\"alNGj\");\n/****************************************************/ /* This file is generated from \"refit.template.js\". */ /****************************************************/ function $d955d16ddee6d2e4$export$40f4af49b81ca898(bvh, nodeIndices = null) {\n    if (nodeIndices && Array.isArray(nodeIndices)) nodeIndices = new Set(nodeIndices);\n    const geometry = bvh.geometry;\n    const indexArr = geometry.index ? geometry.index.array : null;\n    const posAttr = geometry.attributes.position;\n    let buffer, uint32Array, uint16Array, float32Array;\n    let byteOffset = 0;\n    const roots = bvh._roots;\n    for(let i = 0, l = roots.length; i < l; i++){\n        buffer = roots[i];\n        uint32Array = new Uint32Array(buffer);\n        uint16Array = new Uint16Array(buffer);\n        float32Array = new Float32Array(buffer);\n        _traverse(0, byteOffset);\n        byteOffset += buffer.byteLength;\n    }\n    function _traverse(node32Index, byteOffset, force = false) {\n        const node16Index = node32Index * 2;\n        const isLeaf = uint16Array[node16Index + 15] === (0, $alNGj.IS_LEAFNODE_FLAG);\n        if (isLeaf) {\n            const offset = uint32Array[node32Index + 6];\n            const count = uint16Array[node16Index + 14];\n            let minx = Infinity;\n            let miny = Infinity;\n            let minz = Infinity;\n            let maxx = -Infinity;\n            let maxy = -Infinity;\n            let maxz = -Infinity;\n            for(let i = offset, l = offset + count; i < l; i++){\n                const t = 3 * bvh.resolveTriangleIndex(i);\n                for(let j = 0; j < 3; j++){\n                    let index = t + j;\n                    index = indexArr ? indexArr[index] : index;\n                    const x = posAttr.getX(index);\n                    const y = posAttr.getY(index);\n                    const z = posAttr.getZ(index);\n                    if (x < minx) minx = x;\n                    if (x > maxx) maxx = x;\n                    if (y < miny) miny = y;\n                    if (y > maxy) maxy = y;\n                    if (z < minz) minz = z;\n                    if (z > maxz) maxz = z;\n                }\n            }\n            if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n                float32Array[node32Index + 0] = minx;\n                float32Array[node32Index + 1] = miny;\n                float32Array[node32Index + 2] = minz;\n                float32Array[node32Index + 3] = maxx;\n                float32Array[node32Index + 4] = maxy;\n                float32Array[node32Index + 5] = maxz;\n                return true;\n            } else return false;\n        } else {\n            const left = node32Index + 8;\n            const right = uint32Array[node32Index + 6];\n            // the identifying node indices provided by the shapecast function include offsets of all\n            // root buffers to guarantee they're unique between roots so offset left and right indices here.\n            const offsetLeft = left + byteOffset;\n            const offsetRight = right + byteOffset;\n            let forceChildren = force;\n            let includesLeft = false;\n            let includesRight = false;\n            if (nodeIndices) // if we see that neither the left or right child are included in the set that need to be updated\n            // then we assume that all children need to be updated.\n            {\n                if (!forceChildren) {\n                    includesLeft = nodeIndices.has(offsetLeft);\n                    includesRight = nodeIndices.has(offsetRight);\n                    forceChildren = !includesLeft && !includesRight;\n                }\n            } else {\n                includesLeft = true;\n                includesRight = true;\n            }\n            const traverseLeft = forceChildren || includesLeft;\n            const traverseRight = forceChildren || includesRight;\n            let leftChange = false;\n            if (traverseLeft) leftChange = _traverse(left, byteOffset, forceChildren);\n            let rightChange = false;\n            if (traverseRight) rightChange = _traverse(right, byteOffset, forceChildren);\n            const didChange = leftChange || rightChange;\n            if (didChange) for(let i = 0; i < 3; i++){\n                const lefti = left + i;\n                const righti = right + i;\n                const minLeftValue = float32Array[lefti];\n                const maxLeftValue = float32Array[lefti + 3];\n                const minRightValue = float32Array[righti];\n                const maxRightValue = float32Array[righti + 3];\n                float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n                float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n            }\n            return didChange;\n        }\n    }\n}\n\n});\n\nparcelRegister(\"kNP8c\", function(module, exports) {\n\n$parcel$export(module.exports, \"raycast_indirect\", () => $f2500bdd73784d92$export$1999205ebe856279);\n\nvar $d4vta = parcelRequire(\"d4vta\");\n\nvar $8x2iv = parcelRequire(\"8x2iv\");\n\nvar $xqrrD = parcelRequire(\"xqrrD\");\n\n\nvar $gDpfV = parcelRequire(\"gDpfV\");\n/******************************************************/ /* This file is generated from \"raycast.template.js\". */ /******************************************************/ function $f2500bdd73784d92$export$1999205ebe856279(bvh, root, side, ray, intersects) {\n    (0, $xqrrD.BufferStack).setBuffer(bvh._roots[root]);\n    $f2500bdd73784d92$var$_raycast(0, bvh, side, ray, intersects);\n    (0, $xqrrD.BufferStack).clearBuffer();\n}\nfunction $f2500bdd73784d92$var$_raycast(nodeIndex32, bvh, side, ray, intersects) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $xqrrD.BufferStack);\n    const nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0, $8x2iv.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0, $8x2iv.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0, $8x2iv.COUNT)(nodeIndex16, uint16Array);\n        (0, $gDpfV.intersectTris_indirect)(bvh, side, ray, offset, count, intersects);\n    } else {\n        const leftIndex = (0, $8x2iv.LEFT_NODE)(nodeIndex32);\n        if ((0, $d4vta.intersectRay)(leftIndex, float32Array, ray)) $f2500bdd73784d92$var$_raycast(leftIndex, bvh, side, ray, intersects);\n        const rightIndex = (0, $8x2iv.RIGHT_NODE)(nodeIndex32, uint32Array);\n        if ((0, $d4vta.intersectRay)(rightIndex, float32Array, ray)) $f2500bdd73784d92$var$_raycast(rightIndex, bvh, side, ray, intersects);\n    }\n}\n\n});\n\nparcelRegister(\"ZxvHI\", function(module, exports) {\n\n$parcel$export(module.exports, \"raycastFirst_indirect\", () => $0b8fb114025d9d97$export$44e48d4cf2fe0609);\n\nvar $8x2iv = parcelRequire(\"8x2iv\");\n\nvar $xqrrD = parcelRequire(\"xqrrD\");\n\nvar $d4vta = parcelRequire(\"d4vta\");\n\n\nvar $gDpfV = parcelRequire(\"gDpfV\");\n/***********************************************************/ /* This file is generated from \"raycastFirst.template.js\". */ /***********************************************************/ const $0b8fb114025d9d97$var$_xyzFields = [\n    \"x\",\n    \"y\",\n    \"z\"\n];\nfunction $0b8fb114025d9d97$export$44e48d4cf2fe0609(bvh, root, side, ray) {\n    (0, $xqrrD.BufferStack).setBuffer(bvh._roots[root]);\n    const result = $0b8fb114025d9d97$var$_raycastFirst(0, bvh, side, ray);\n    (0, $xqrrD.BufferStack).clearBuffer();\n    return result;\n}\nfunction $0b8fb114025d9d97$var$_raycastFirst(nodeIndex32, bvh, side, ray) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $xqrrD.BufferStack);\n    let nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0, $8x2iv.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0, $8x2iv.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0, $8x2iv.COUNT)(nodeIndex16, uint16Array);\n        return (0, $gDpfV.intersectClosestTri_indirect)(bvh, side, ray, offset, count);\n    } else {\n        // consider the position of the split plane with respect to the oncoming ray; whichever direction\n        // the ray is coming from, look for an intersection among that side of the tree first\n        const splitAxis = (0, $8x2iv.SPLIT_AXIS)(nodeIndex32, uint32Array);\n        const xyzAxis = $0b8fb114025d9d97$var$_xyzFields[splitAxis];\n        const rayDir = ray.direction[xyzAxis];\n        const leftToRight = rayDir >= 0;\n        // c1 is the child to check first\n        let c1, c2;\n        if (leftToRight) {\n            c1 = (0, $8x2iv.LEFT_NODE)(nodeIndex32);\n            c2 = (0, $8x2iv.RIGHT_NODE)(nodeIndex32, uint32Array);\n        } else {\n            c1 = (0, $8x2iv.RIGHT_NODE)(nodeIndex32, uint32Array);\n            c2 = (0, $8x2iv.LEFT_NODE)(nodeIndex32);\n        }\n        const c1Intersection = (0, $d4vta.intersectRay)(c1, float32Array, ray);\n        const c1Result = c1Intersection ? $0b8fb114025d9d97$var$_raycastFirst(c1, bvh, side, ray) : null;\n        // if we got an intersection in the first node and it's closer than the second node's bounding\n        // box, we don't need to consider the second node because it couldn't possibly be a better result\n        if (c1Result) {\n            // check if the point is within the second bounds\n            // \"point\" is in the local frame of the bvh\n            const point = c1Result.point[xyzAxis];\n            const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : point >= float32Array[c2 + splitAxis + 3]; // max bounding data\n            if (isOutside) return c1Result;\n        }\n        // either there was no intersection in the first node, or there could still be a closer\n        // intersection in the second, so check the second node and then take the better of the two\n        const c2Intersection = (0, $d4vta.intersectRay)(c2, float32Array, ray);\n        const c2Result = c2Intersection ? $0b8fb114025d9d97$var$_raycastFirst(c2, bvh, side, ray) : null;\n        if (c1Result && c2Result) return c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n        else return c1Result || c2Result || null;\n    }\n}\n\n});\n\nparcelRegister(\"bD1WL\", function(module, exports) {\n\n$parcel$export(module.exports, \"intersectsGeometry_indirect\", () => $8774d8cede10b4d0$export$80dca0df80ee0084);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $lenTA = parcelRequire(\"lenTA\");\n\nvar $8VYkb = parcelRequire(\"8VYkb\");\n\nvar $dRxiJ = parcelRequire(\"dRxiJ\");\n\nvar $eADNI = parcelRequire(\"eADNI\");\n\nvar $8x2iv = parcelRequire(\"8x2iv\");\n\nvar $xqrrD = parcelRequire(\"xqrrD\");\n/*****************************************************************/ /* This file is generated from \"intersectsGeometry.template.js\". */ /*****************************************************************/ /* eslint-disable indent */ const $8774d8cede10b4d0$var$boundingBox = /* @__PURE__ */ new (0, $ilwiq.Box3)();\nconst $8774d8cede10b4d0$var$triangle = /* @__PURE__ */ new (0, $8VYkb.ExtendedTriangle)();\nconst $8774d8cede10b4d0$var$triangle2 = /* @__PURE__ */ new (0, $8VYkb.ExtendedTriangle)();\nconst $8774d8cede10b4d0$var$invertedMat = /* @__PURE__ */ new (0, $ilwiq.Matrix4)();\nconst $8774d8cede10b4d0$var$obb = /* @__PURE__ */ new (0, $lenTA.OrientedBox)();\nconst $8774d8cede10b4d0$var$obb2 = /* @__PURE__ */ new (0, $lenTA.OrientedBox)();\nfunction $8774d8cede10b4d0$export$80dca0df80ee0084(bvh, root, otherGeometry, geometryToBvh) {\n    (0, $xqrrD.BufferStack).setBuffer(bvh._roots[root]);\n    const result = $8774d8cede10b4d0$var$_intersectsGeometry(0, bvh, otherGeometry, geometryToBvh);\n    (0, $xqrrD.BufferStack).clearBuffer();\n    return result;\n}\nfunction $8774d8cede10b4d0$var$_intersectsGeometry(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $xqrrD.BufferStack);\n    let nodeIndex16 = nodeIndex32 * 2;\n    if (cachedObb === null) {\n        if (!otherGeometry.boundingBox) otherGeometry.computeBoundingBox();\n        $8774d8cede10b4d0$var$obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n        cachedObb = $8774d8cede10b4d0$var$obb;\n    }\n    const isLeaf = (0, $8x2iv.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const thisGeometry = bvh.geometry;\n        const thisIndex = thisGeometry.index;\n        const thisPos = thisGeometry.attributes.position;\n        const index = otherGeometry.index;\n        const pos = otherGeometry.attributes.position;\n        const offset = (0, $8x2iv.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0, $8x2iv.COUNT)(nodeIndex16, uint16Array);\n        // get the inverse of the geometry matrix so we can transform our triangles into the\n        // geometry space we're trying to test. We assume there are fewer triangles being checked\n        // here.\n        $8774d8cede10b4d0$var$invertedMat.copy(geometryToBvh).invert();\n        if (otherGeometry.boundsTree) {\n            // if there's a bounds tree\n            (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(nodeIndex32), float32Array, $8774d8cede10b4d0$var$obb2);\n            $8774d8cede10b4d0$var$obb2.matrix.copy($8774d8cede10b4d0$var$invertedMat);\n            $8774d8cede10b4d0$var$obb2.needsUpdate = true;\n            // TODO: use a triangle iteration function here\n            const res = otherGeometry.boundsTree.shapecast({\n                intersectsBounds: (box)=>$8774d8cede10b4d0$var$obb2.intersectsBox(box),\n                intersectsTriangle: (tri)=>{\n                    tri.a.applyMatrix4(geometryToBvh);\n                    tri.b.applyMatrix4(geometryToBvh);\n                    tri.c.applyMatrix4(geometryToBvh);\n                    tri.needsUpdate = true;\n                    for(let i = offset, l = count + offset; i < l; i++){\n                        // this triangle needs to be transformed into the current BVH coordinate frame\n                        (0, $dRxiJ.setTriangle)($8774d8cede10b4d0$var$triangle2, 3 * bvh.resolveTriangleIndex(i), thisIndex, thisPos);\n                        $8774d8cede10b4d0$var$triangle2.needsUpdate = true;\n                        if (tri.intersectsTriangle($8774d8cede10b4d0$var$triangle2)) return true;\n                    }\n                    return false;\n                }\n            });\n            return res;\n        } else // if we're just dealing with raw geometry\n        for(let i = offset, l = count + offset; i < l; i++){\n            // this triangle needs to be transformed into the current BVH coordinate frame\n            const ti = bvh.resolveTriangleIndex(i);\n            (0, $dRxiJ.setTriangle)($8774d8cede10b4d0$var$triangle, 3 * ti, thisIndex, thisPos);\n            $8774d8cede10b4d0$var$triangle.a.applyMatrix4($8774d8cede10b4d0$var$invertedMat);\n            $8774d8cede10b4d0$var$triangle.b.applyMatrix4($8774d8cede10b4d0$var$invertedMat);\n            $8774d8cede10b4d0$var$triangle.c.applyMatrix4($8774d8cede10b4d0$var$invertedMat);\n            $8774d8cede10b4d0$var$triangle.needsUpdate = true;\n            for(let i2 = 0, l2 = index.count; i2 < l2; i2 += 3){\n                (0, $dRxiJ.setTriangle)($8774d8cede10b4d0$var$triangle2, i2, index, pos);\n                $8774d8cede10b4d0$var$triangle2.needsUpdate = true;\n                if ($8774d8cede10b4d0$var$triangle.intersectsTriangle($8774d8cede10b4d0$var$triangle2)) return true;\n            }\n        }\n    } else {\n        const left = nodeIndex32 + 8;\n        const right = uint32Array[nodeIndex32 + 6];\n        (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(left), float32Array, $8774d8cede10b4d0$var$boundingBox);\n        const leftIntersection = cachedObb.intersectsBox($8774d8cede10b4d0$var$boundingBox) && $8774d8cede10b4d0$var$_intersectsGeometry(left, bvh, otherGeometry, geometryToBvh, cachedObb);\n        if (leftIntersection) return true;\n        (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(right), float32Array, $8774d8cede10b4d0$var$boundingBox);\n        const rightIntersection = cachedObb.intersectsBox($8774d8cede10b4d0$var$boundingBox) && $8774d8cede10b4d0$var$_intersectsGeometry(right, bvh, otherGeometry, geometryToBvh, cachedObb);\n        if (rightIntersection) return true;\n        return false;\n    }\n}\n\n});\n\nparcelRegister(\"gUrAj\", function(module, exports) {\n\n$parcel$export(module.exports, \"closestPointToGeometry_indirect\", () => $c4f746093678aa23$export$334b669407b5ec06);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $lenTA = parcelRequire(\"lenTA\");\n\nvar $dRxiJ = parcelRequire(\"dRxiJ\");\n\nvar $5Gkg5 = parcelRequire(\"5Gkg5\");\n\nvar $7EZfU = parcelRequire(\"7EZfU\");\n/*********************************************************************/ /* This file is generated from \"closestPointToGeometry.template.js\". */ /*********************************************************************/ const $c4f746093678aa23$var$tempMatrix = /* @__PURE__ */ new (0, $ilwiq.Matrix4)();\nconst $c4f746093678aa23$var$obb = /* @__PURE__ */ new (0, $lenTA.OrientedBox)();\nconst $c4f746093678aa23$var$obb2 = /* @__PURE__ */ new (0, $lenTA.OrientedBox)();\nconst $c4f746093678aa23$var$temp1 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $c4f746093678aa23$var$temp2 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $c4f746093678aa23$var$temp3 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $c4f746093678aa23$var$temp4 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nfunction $c4f746093678aa23$export$334b669407b5ec06(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {\n    if (!otherGeometry.boundingBox) otherGeometry.computeBoundingBox();\n    $c4f746093678aa23$var$obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n    $c4f746093678aa23$var$obb.needsUpdate = true;\n    const geometry = bvh.geometry;\n    const pos = geometry.attributes.position;\n    const index = geometry.index;\n    const otherPos = otherGeometry.attributes.position;\n    const otherIndex = otherGeometry.index;\n    const triangle = (0, $7EZfU.ExtendedTrianglePool).getPrimitive();\n    const triangle2 = (0, $7EZfU.ExtendedTrianglePool).getPrimitive();\n    let tempTarget1 = $c4f746093678aa23$var$temp1;\n    let tempTargetDest1 = $c4f746093678aa23$var$temp2;\n    let tempTarget2 = null;\n    let tempTargetDest2 = null;\n    if (target2) {\n        tempTarget2 = $c4f746093678aa23$var$temp3;\n        tempTargetDest2 = $c4f746093678aa23$var$temp4;\n    }\n    let closestDistance = Infinity;\n    let closestDistanceTriIndex = null;\n    let closestDistanceOtherTriIndex = null;\n    $c4f746093678aa23$var$tempMatrix.copy(geometryToBvh).invert();\n    $c4f746093678aa23$var$obb2.matrix.copy($c4f746093678aa23$var$tempMatrix);\n    bvh.shapecast({\n        boundsTraverseOrder: (box)=>{\n            return $c4f746093678aa23$var$obb.distanceToBox(box);\n        },\n        intersectsBounds: (box, isLeaf, score)=>{\n            if (score < closestDistance && score < maxThreshold) {\n                // if we know the triangles of this bounds will be intersected next then\n                // save the bounds to use during triangle checks.\n                if (isLeaf) {\n                    $c4f746093678aa23$var$obb2.min.copy(box.min);\n                    $c4f746093678aa23$var$obb2.max.copy(box.max);\n                    $c4f746093678aa23$var$obb2.needsUpdate = true;\n                }\n                return true;\n            }\n            return false;\n        },\n        intersectsRange: (offset, count)=>{\n            if (otherGeometry.boundsTree) {\n                // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n                // the closest bounds in the other geometry to check.\n                const otherBvh = otherGeometry.boundsTree;\n                return otherBvh.shapecast({\n                    boundsTraverseOrder: (box)=>{\n                        return $c4f746093678aa23$var$obb2.distanceToBox(box);\n                    },\n                    intersectsBounds: (box, isLeaf, score)=>{\n                        return score < closestDistance && score < maxThreshold;\n                    },\n                    intersectsRange: (otherOffset, otherCount)=>{\n                        for(let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++){\n                            const ti2 = otherBvh.resolveTriangleIndex(i2);\n                            (0, $dRxiJ.setTriangle)(triangle2, 3 * ti2, otherIndex, otherPos);\n                            triangle2.a.applyMatrix4(geometryToBvh);\n                            triangle2.b.applyMatrix4(geometryToBvh);\n                            triangle2.c.applyMatrix4(geometryToBvh);\n                            triangle2.needsUpdate = true;\n                            for(let i = offset, l = offset + count; i < l; i++){\n                                const ti = bvh.resolveTriangleIndex(i);\n                                (0, $dRxiJ.setTriangle)(triangle, 3 * ti, index, pos);\n                                triangle.needsUpdate = true;\n                                const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                                if (dist < closestDistance) {\n                                    tempTargetDest1.copy(tempTarget1);\n                                    if (tempTargetDest2) tempTargetDest2.copy(tempTarget2);\n                                    closestDistance = dist;\n                                    closestDistanceTriIndex = i;\n                                    closestDistanceOtherTriIndex = i2;\n                                }\n                                // stop traversal if we find a point that's under the given threshold\n                                if (dist < minThreshold) return true;\n                            }\n                        }\n                    }\n                });\n            } else {\n                // If no bounds tree then we'll just check every triangle.\n                const triCount = (0, $5Gkg5.getTriCount)(otherGeometry);\n                for(let i2 = 0, l2 = triCount; i2 < l2; i2++){\n                    (0, $dRxiJ.setTriangle)(triangle2, 3 * i2, otherIndex, otherPos);\n                    triangle2.a.applyMatrix4(geometryToBvh);\n                    triangle2.b.applyMatrix4(geometryToBvh);\n                    triangle2.c.applyMatrix4(geometryToBvh);\n                    triangle2.needsUpdate = true;\n                    for(let i = offset, l = offset + count; i < l; i++){\n                        const ti = bvh.resolveTriangleIndex(i);\n                        (0, $dRxiJ.setTriangle)(triangle, 3 * ti, index, pos);\n                        triangle.needsUpdate = true;\n                        const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                        if (dist < closestDistance) {\n                            tempTargetDest1.copy(tempTarget1);\n                            if (tempTargetDest2) tempTargetDest2.copy(tempTarget2);\n                            closestDistance = dist;\n                            closestDistanceTriIndex = i;\n                            closestDistanceOtherTriIndex = i2;\n                        }\n                        // stop traversal if we find a point that's under the given threshold\n                        if (dist < minThreshold) return true;\n                    }\n                }\n            }\n        }\n    });\n    (0, $7EZfU.ExtendedTrianglePool).releasePrimitive(triangle);\n    (0, $7EZfU.ExtendedTrianglePool).releasePrimitive(triangle2);\n    if (closestDistance === Infinity) return null;\n    if (!target1.point) target1.point = tempTargetDest1.clone();\n    else target1.point.copy(tempTargetDest1);\n    target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;\n    if (target2) {\n        if (!target2.point) target2.point = tempTargetDest2.clone();\n        else target2.point.copy(tempTargetDest2);\n        target2.point.applyMatrix4($c4f746093678aa23$var$tempMatrix);\n        tempTargetDest1.applyMatrix4($c4f746093678aa23$var$tempMatrix);\n        target2.distance = tempTargetDest1.sub(target2.point).length();\n        target2.faceIndex = closestDistanceOtherTriIndex;\n    }\n    return target1;\n}\n\n});\n\nparcelRegister(\"cSOJe\", function(module, exports) {\n\n$parcel$export(module.exports, \"isSharedArrayBufferSupported\", () => $9611e0cfae405faf$export$9c28fa8114adc339);\n$parcel$export(module.exports, \"convertToBufferType\", () => $9611e0cfae405faf$export$fadff02e9aa23f60);\nfunction $9611e0cfae405faf$export$9c28fa8114adc339() {\n    return typeof SharedArrayBuffer !== \"undefined\";\n}\nfunction $9611e0cfae405faf$export$fadff02e9aa23f60(array, BufferConstructor) {\n    if (array === null) return array;\n    else if (array.buffer) {\n        const buffer = array.buffer;\n        if (buffer.constructor === BufferConstructor) return array;\n        const ArrayConstructor = array.constructor;\n        const result = new ArrayConstructor(new BufferConstructor(buffer.byteLength));\n        result.set(array);\n        return result;\n    } else {\n        if (array.constructor === BufferConstructor) return array;\n        const result = new BufferConstructor(array.byteLength);\n        new Uint8Array(result).set(new Uint8Array(array));\n        return result;\n    }\n}\n\n});\n\nparcelRegister(\"f1zUR\", function(module, exports) {\n\n$parcel$export(module.exports, \"bvhcast\", () => $af02cf38ee8e10da$export$a2253c6980b92559);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $xqrrD = parcelRequire(\"xqrrD\");\n\nvar $8x2iv = parcelRequire(\"8x2iv\");\n\nvar $eADNI = parcelRequire(\"eADNI\");\n\nvar $1l8b2 = parcelRequire(\"1l8b2\");\nconst $af02cf38ee8e10da$var$_bufferStack1 = new (0, $xqrrD.BufferStack).constructor();\nconst $af02cf38ee8e10da$var$_bufferStack2 = new (0, $xqrrD.BufferStack).constructor();\nconst $af02cf38ee8e10da$var$_boxPool = new (0, $1l8b2.PrimitivePool)(()=>new (0, $ilwiq.Box3)());\nconst $af02cf38ee8e10da$var$_leftBox1 = new (0, $ilwiq.Box3)();\nconst $af02cf38ee8e10da$var$_rightBox1 = new (0, $ilwiq.Box3)();\nconst $af02cf38ee8e10da$var$_leftBox2 = new (0, $ilwiq.Box3)();\nconst $af02cf38ee8e10da$var$_rightBox2 = new (0, $ilwiq.Box3)();\nlet $af02cf38ee8e10da$var$_active = false;\nfunction $af02cf38ee8e10da$export$a2253c6980b92559(bvh, otherBvh, matrixToLocal, intersectsRanges) {\n    if ($af02cf38ee8e10da$var$_active) throw new Error(\"MeshBVH: Recursive calls to bvhcast not supported.\");\n    $af02cf38ee8e10da$var$_active = true;\n    const roots = bvh._roots;\n    const otherRoots = otherBvh._roots;\n    let result;\n    let offset1 = 0;\n    let offset2 = 0;\n    const invMat = new (0, $ilwiq.Matrix4)().copy(matrixToLocal).invert();\n    // iterate over the first set of roots\n    for(let i = 0, il = roots.length; i < il; i++){\n        $af02cf38ee8e10da$var$_bufferStack1.setBuffer(roots[i]);\n        offset2 = 0;\n        // prep the initial root box\n        const localBox = $af02cf38ee8e10da$var$_boxPool.getPrimitive();\n        (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(0), $af02cf38ee8e10da$var$_bufferStack1.float32Array, localBox);\n        localBox.applyMatrix4(invMat);\n        // iterate over the second set of roots\n        for(let j = 0, jl = otherRoots.length; j < jl; j++){\n            $af02cf38ee8e10da$var$_bufferStack2.setBuffer(otherRoots[i]);\n            result = $af02cf38ee8e10da$var$_traverse(0, 0, matrixToLocal, invMat, intersectsRanges, offset1, offset2, 0, 0, localBox);\n            $af02cf38ee8e10da$var$_bufferStack2.clearBuffer();\n            offset2 += otherRoots[j].length;\n            if (result) break;\n        }\n        // release stack info\n        $af02cf38ee8e10da$var$_boxPool.releasePrimitive(localBox);\n        $af02cf38ee8e10da$var$_bufferStack1.clearBuffer();\n        offset1 += roots[i].length;\n        if (result) break;\n    }\n    $af02cf38ee8e10da$var$_active = false;\n    return result;\n}\nfunction $af02cf38ee8e10da$var$_traverse(node1Index32, node2Index32, matrix2to1, matrix1to2, intersectsRangesFunc, // offsets for ids\nnode1IndexByteOffset = 0, node2IndexByteOffset = 0, // tree depth\ndepth1 = 0, depth2 = 0, currBox = null, reversed = false) {\n    // get the buffer stacks associated with the current indices\n    let bufferStack1, bufferStack2;\n    if (reversed) {\n        bufferStack1 = $af02cf38ee8e10da$var$_bufferStack2;\n        bufferStack2 = $af02cf38ee8e10da$var$_bufferStack1;\n    } else {\n        bufferStack1 = $af02cf38ee8e10da$var$_bufferStack1;\n        bufferStack2 = $af02cf38ee8e10da$var$_bufferStack2;\n    }\n    // get the local instances of the typed buffers\n    const float32Array1 = bufferStack1.float32Array, uint32Array1 = bufferStack1.uint32Array, uint16Array1 = bufferStack1.uint16Array, float32Array2 = bufferStack2.float32Array, uint32Array2 = bufferStack2.uint32Array, uint16Array2 = bufferStack2.uint16Array;\n    const node1Index16 = node1Index32 * 2;\n    const node2Index16 = node2Index32 * 2;\n    const isLeaf1 = (0, $8x2iv.IS_LEAF)(node1Index16, uint16Array1);\n    const isLeaf2 = (0, $8x2iv.IS_LEAF)(node2Index16, uint16Array2);\n    let result = false;\n    if (isLeaf2 && isLeaf1) {\n        // if both bounds are leaf nodes then fire the callback if the boxes intersect\n        if (reversed) result = intersectsRangesFunc((0, $8x2iv.OFFSET)(node2Index32, uint32Array2), (0, $8x2iv.COUNT)(node2Index32 * 2, uint16Array2), (0, $8x2iv.OFFSET)(node1Index32, uint32Array1), (0, $8x2iv.COUNT)(node1Index32 * 2, uint16Array1), depth2, node2IndexByteOffset + node2Index32, depth1, node1IndexByteOffset + node1Index32);\n        else result = intersectsRangesFunc((0, $8x2iv.OFFSET)(node1Index32, uint32Array1), (0, $8x2iv.COUNT)(node1Index32 * 2, uint16Array1), (0, $8x2iv.OFFSET)(node2Index32, uint32Array2), (0, $8x2iv.COUNT)(node2Index32 * 2, uint16Array2), depth1, node1IndexByteOffset + node1Index32, depth2, node2IndexByteOffset + node2Index32);\n    } else if (isLeaf2) {\n        // SWAP\n        // If we've traversed to the leaf node on the other bvh then we need to swap over\n        // to traverse down the first one\n        // get the new box to use\n        const newBox = $af02cf38ee8e10da$var$_boxPool.getPrimitive();\n        (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(node2Index32), float32Array2, newBox);\n        newBox.applyMatrix4(matrix2to1);\n        // get the child bounds to check before traversal\n        const cl1 = (0, $8x2iv.LEFT_NODE)(node1Index32);\n        const cr1 = (0, $8x2iv.RIGHT_NODE)(node1Index32, uint32Array1);\n        (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(cl1), float32Array1, $af02cf38ee8e10da$var$_leftBox1);\n        (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(cr1), float32Array1, $af02cf38ee8e10da$var$_rightBox1);\n        // precompute the intersections otherwise the global boxes will be modified during traversal\n        const intersectCl1 = newBox.intersectsBox($af02cf38ee8e10da$var$_leftBox1);\n        const intersectCr1 = newBox.intersectsBox($af02cf38ee8e10da$var$_rightBox1);\n        result = intersectCl1 && $af02cf38ee8e10da$var$_traverse(node2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed) || intersectCr1 && $af02cf38ee8e10da$var$_traverse(node2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed);\n        $af02cf38ee8e10da$var$_boxPool.releasePrimitive(newBox);\n    } else {\n        // if neither are leaves then we should swap if one of the children does not\n        // intersect with the current bounds\n        // get the child bounds to check\n        const cl2 = (0, $8x2iv.LEFT_NODE)(node2Index32);\n        const cr2 = (0, $8x2iv.RIGHT_NODE)(node2Index32, uint32Array2);\n        (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(cl2), float32Array2, $af02cf38ee8e10da$var$_leftBox2);\n        (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(cr2), float32Array2, $af02cf38ee8e10da$var$_rightBox2);\n        const leftIntersects = currBox.intersectsBox($af02cf38ee8e10da$var$_leftBox2);\n        const rightIntersects = currBox.intersectsBox($af02cf38ee8e10da$var$_rightBox2);\n        if (leftIntersects && rightIntersects) // continue to traverse both children if they both intersect\n        result = $af02cf38ee8e10da$var$_traverse(node1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed) || $af02cf38ee8e10da$var$_traverse(node1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed);\n        else if (leftIntersects) {\n            if (isLeaf1) // if the current box is a leaf then just continue\n            result = $af02cf38ee8e10da$var$_traverse(node1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed);\n            else {\n                // SWAP\n                // if only one box intersects then we have to swap to the other bvh to continue\n                const newBox = $af02cf38ee8e10da$var$_boxPool.getPrimitive();\n                newBox.copy($af02cf38ee8e10da$var$_leftBox2).applyMatrix4(matrix2to1);\n                const cl1 = (0, $8x2iv.LEFT_NODE)(node1Index32);\n                const cr1 = (0, $8x2iv.RIGHT_NODE)(node1Index32, uint32Array1);\n                (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(cl1), float32Array1, $af02cf38ee8e10da$var$_leftBox1);\n                (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(cr1), float32Array1, $af02cf38ee8e10da$var$_rightBox1);\n                // precompute the intersections otherwise the global boxes will be modified during traversal\n                const intersectCl1 = newBox.intersectsBox($af02cf38ee8e10da$var$_leftBox1);\n                const intersectCr1 = newBox.intersectsBox($af02cf38ee8e10da$var$_rightBox1);\n                result = intersectCl1 && $af02cf38ee8e10da$var$_traverse(cl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed) || intersectCr1 && $af02cf38ee8e10da$var$_traverse(cl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed);\n                $af02cf38ee8e10da$var$_boxPool.releasePrimitive(newBox);\n            }\n        } else if (rightIntersects) {\n            if (isLeaf1) // if the current box is a leaf then just continue\n            result = $af02cf38ee8e10da$var$_traverse(node1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed);\n            else {\n                // SWAP\n                // if only one box intersects then we have to swap to the other bvh to continue\n                const newBox = $af02cf38ee8e10da$var$_boxPool.getPrimitive();\n                newBox.copy($af02cf38ee8e10da$var$_rightBox2).applyMatrix4(matrix2to1);\n                const cl1 = (0, $8x2iv.LEFT_NODE)(node1Index32);\n                const cr1 = (0, $8x2iv.RIGHT_NODE)(node1Index32, uint32Array1);\n                (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(cl1), float32Array1, $af02cf38ee8e10da$var$_leftBox1);\n                (0, $eADNI.arrayToBox)((0, $8x2iv.BOUNDING_DATA_INDEX)(cr1), float32Array1, $af02cf38ee8e10da$var$_rightBox1);\n                // precompute the intersections otherwise the global boxes will be modified during traversal\n                const intersectCl1 = newBox.intersectsBox($af02cf38ee8e10da$var$_leftBox1);\n                const intersectCr1 = newBox.intersectsBox($af02cf38ee8e10da$var$_rightBox1);\n                result = intersectCl1 && $af02cf38ee8e10da$var$_traverse(cr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed) || intersectCr1 && $af02cf38ee8e10da$var$_traverse(cr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed);\n                $af02cf38ee8e10da$var$_boxPool.releasePrimitive(newBox);\n            }\n        }\n    }\n    return result;\n}\n\n});\n\n\nparcelRegister(\"dCCOj\", function(module, exports) {\n\n$parcel$export(module.exports, \"NO_CHANGE\", () => $9eacedee756f73b0$export$ddc917fcb8a0cb5e);\n$parcel$export(module.exports, \"GEOMETRY_ADJUSTED\", () => $9eacedee756f73b0$export$9d0dec2f433c8a42);\n$parcel$export(module.exports, \"GEOMETRY_REBUILT\", () => $9eacedee756f73b0$export$855d2b1d3a353384);\n$parcel$export(module.exports, \"StaticGeometryGenerator\", () => $9eacedee756f73b0$export$3516980c1ea07296);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $7V7xb = parcelRequire(\"7V7xb\");\n\nvar $8LUnK = parcelRequire(\"8LUnK\");\n\nvar $2b74x = parcelRequire(\"2b74x\");\nconst $9eacedee756f73b0$export$ddc917fcb8a0cb5e = 0;\nconst $9eacedee756f73b0$export$9d0dec2f433c8a42 = 1;\nconst $9eacedee756f73b0$export$855d2b1d3a353384 = 2;\n// iterate over only the meshes in the provided objects\nfunction $9eacedee756f73b0$var$flatTraverseMeshes(objects, cb) {\n    for(let i = 0, l = objects.length; i < l; i++){\n        const object = objects[i];\n        object.traverseVisible((o)=>{\n            if (o.isMesh) cb(o);\n        });\n    }\n}\n// return the set of materials used by the provided meshes\nfunction $9eacedee756f73b0$var$getMaterials(meshes) {\n    const materials = [];\n    for(let i = 0, l = meshes.length; i < l; i++){\n        const mesh = meshes[i];\n        if (Array.isArray(mesh.material)) materials.push(...mesh.material);\n        else materials.push(mesh.material);\n    }\n    return materials;\n}\nfunction $9eacedee756f73b0$var$mergeGeometryList(geometries, target, options) {\n    // If we have no geometry to merge then provide an empty geometry.\n    if (geometries.length === 0) {\n        // if there are no geometries then just create a fake empty geometry to provide\n        target.setIndex(null);\n        // remove all geometry\n        const attrs = target.attributes;\n        for(const key in attrs)target.deleteAttribute(key);\n        // create dummy attributes\n        for(const key in options.attributes)target.setAttribute(options.attributes[key], new (0, $ilwiq.BufferAttribute)(new Float32Array(0), 4, false));\n    } else (0, $7V7xb.mergeGeometries)(geometries, options, target);\n    // Mark all attributes as needing an update\n    for(const key in target.attributes)target.attributes[key].needsUpdate = true;\n}\nclass $9eacedee756f73b0$export$3516980c1ea07296 {\n    constructor(objects){\n        this.objects = null;\n        this.useGroups = true;\n        this.applyWorldTransforms = true;\n        this.generateMissingAttributes = true;\n        this.overwriteIndex = true;\n        this.attributes = [\n            \"position\",\n            \"normal\",\n            \"color\",\n            \"tangent\",\n            \"uv\",\n            \"uv2\"\n        ];\n        this._intermediateGeometry = new Map();\n        this._geometryMergeSets = new WeakMap();\n        this._mergeOrder = [];\n        this._dummyMesh = null;\n        this.setObjects(objects || []);\n    }\n    _getDummyMesh() {\n        // return a consistent dummy mesh\n        if (!this._dummyMesh) {\n            const dummyMaterial = new (0, $ilwiq.MeshBasicMaterial)();\n            const emptyGeometry = new (0, $ilwiq.BufferGeometry)();\n            emptyGeometry.setAttribute(\"position\", new (0, $ilwiq.BufferAttribute)(new Float32Array(9), 3));\n            this._dummyMesh = new (0, $ilwiq.Mesh)(emptyGeometry, dummyMaterial);\n        }\n        return this._dummyMesh;\n    }\n    _getMeshes() {\n        // iterate over only the meshes in the provided objects\n        const meshes = [];\n        $9eacedee756f73b0$var$flatTraverseMeshes(this.objects, (mesh)=>{\n            meshes.push(mesh);\n        });\n        // Sort the geometry so it's in a reliable order\n        meshes.sort((a, b)=>{\n            if (a.uuid > b.uuid) return 1;\n            if (a.uuid < b.uuid) return -1;\n            return 0;\n        });\n        if (meshes.length === 0) meshes.push(this._getDummyMesh());\n        return meshes;\n    }\n    _updateIntermediateGeometries() {\n        const { _intermediateGeometry: _intermediateGeometry } = this;\n        const meshes = this._getMeshes();\n        const unusedMeshKeys = new Set(_intermediateGeometry.keys());\n        const convertOptions = {\n            attributes: this.attributes,\n            applyWorldTransforms: this.applyWorldTransforms\n        };\n        for(let i = 0, l = meshes.length; i < l; i++){\n            const mesh = meshes[i];\n            const meshKey = mesh.uuid;\n            unusedMeshKeys.delete(meshKey);\n            // initialize the intermediate geometry\n            // if the mesh and source geometry have changed in such a way that they are no longer\n            // compatible then regenerate the baked geometry from scratch\n            let geom = _intermediateGeometry.get(meshKey);\n            if (!geom || !geom.isCompatible(mesh, this.attributes)) {\n                if (geom) geom.dispose();\n                geom = new (0, $2b74x.BakedGeometry)();\n                _intermediateGeometry.set(meshKey, geom);\n            }\n            // transform the geometry into the intermediate buffer geometry, saving whether\n            // or not it changed.\n            if (geom.updateFrom(mesh, convertOptions)) // TODO: provide option for only generating the set of attributes that are present\n            // and are in the attributes array\n            {\n                if (this.generateMissingAttributes) (0, $8LUnK.setCommonAttributes)(geom, this.attributes);\n            }\n        }\n        unusedMeshKeys.forEach((key)=>{\n            _intermediateGeometry.delete(key);\n        });\n    }\n    setObjects(objects) {\n        if (Array.isArray(objects)) this.objects = [\n            ...objects\n        ];\n        else this.objects = [\n            objects\n        ];\n    }\n    generate(targetGeometry = new (0, $ilwiq.BufferGeometry)()) {\n        // track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n        const { useGroups: useGroups, overwriteIndex: overwriteIndex, _intermediateGeometry: _intermediateGeometry, _geometryMergeSets: _geometryMergeSets } = this;\n        const meshes = this._getMeshes();\n        const skipAssigningAttributes = [];\n        const mergeGeometry = [];\n        const previousMergeInfo = _geometryMergeSets.get(targetGeometry) || [];\n        // update all the intermediate static geometry representations\n        this._updateIntermediateGeometries();\n        // get the list of geometries to merge\n        let forceUpdate = false;\n        if (meshes.length !== previousMergeInfo.length) forceUpdate = true;\n        for(let i = 0, l = meshes.length; i < l; i++){\n            const mesh = meshes[i];\n            const geom = _intermediateGeometry.get(mesh.uuid);\n            mergeGeometry.push(geom);\n            const info = previousMergeInfo[i];\n            if (!info || info.uuid !== geom.uuid) {\n                skipAssigningAttributes.push(false);\n                forceUpdate = true;\n            } else if (info.version !== geom.version) skipAssigningAttributes.push(false);\n            else skipAssigningAttributes.push(true);\n        }\n        // If we have no geometry to merge then provide an empty geometry.\n        $9eacedee756f73b0$var$mergeGeometryList(mergeGeometry, targetGeometry, {\n            useGroups: useGroups,\n            forceUpdate: forceUpdate,\n            skipAssigningAttributes: skipAssigningAttributes,\n            overwriteIndex: overwriteIndex\n        });\n        // force update means the attribute buffer lengths have changed\n        if (forceUpdate) targetGeometry.dispose();\n        _geometryMergeSets.set(targetGeometry, mergeGeometry.map((g)=>({\n                version: g.version,\n                uuid: g.uuid\n            })));\n        let changeType = $9eacedee756f73b0$export$ddc917fcb8a0cb5e;\n        if (forceUpdate) changeType = $9eacedee756f73b0$export$855d2b1d3a353384;\n        else if (skipAssigningAttributes.includes(false)) changeType = $9eacedee756f73b0$export$9d0dec2f433c8a42;\n        return {\n            changeType: changeType,\n            materials: $9eacedee756f73b0$var$getMaterials(meshes),\n            geometry: targetGeometry\n        };\n    }\n}\n\n});\nparcelRegister(\"7V7xb\", function(module, exports) {\n\n$parcel$export(module.exports, \"mergeGeometries\", () => $5c43b36cecf64594$export$f06f69b3bf41d25c);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $iYpwh = parcelRequire(\"iYpwh\");\nfunction $5c43b36cecf64594$var$validateMergeability(geometries) {\n    const isIndexed = geometries[0].index !== null;\n    const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n    if (!geometries[0].getAttribute(\"position\")) throw new Error(\"StaticGeometryGenerator: position attribute is required.\");\n    for(let i = 0; i < geometries.length; ++i){\n        const geometry = geometries[i];\n        let attributesCount = 0;\n        // ensure that all geometries are indexed, or none\n        if (isIndexed !== (geometry.index !== null)) throw new Error(\"StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\");\n        // gather attributes, exit early if they're different\n        for(const name in geometry.attributes){\n            if (!attributesUsed.has(name)) throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n            attributesCount++;\n        }\n        // ensure geometries have the same number of attributes\n        if (attributesCount !== attributesUsed.size) throw new Error(\"StaticGeometryGenerator: All geometries must have the same number of attributes.\");\n    }\n}\nfunction $5c43b36cecf64594$var$getTotalIndexCount(geometries) {\n    let result = 0;\n    for(let i = 0, l = geometries.length; i < l; i++)result += geometries[i].getIndex().count;\n    return result;\n}\nfunction $5c43b36cecf64594$var$getTotalAttributeCount(geometries) {\n    let result = 0;\n    for(let i = 0, l = geometries.length; i < l; i++)result += geometries[i].getAttribute(\"position\").count;\n    return result;\n}\nfunction $5c43b36cecf64594$var$trimMismatchedAttributes(target, indexCount, attrCount) {\n    if (target.index && target.index.count !== indexCount) target.setIndex(null);\n    const attributes = target.attributes;\n    for(const key in attributes){\n        const attr = attributes[key];\n        if (attr.count !== attrCount) target.deleteAttribute(key);\n    }\n}\nfunction $5c43b36cecf64594$export$f06f69b3bf41d25c(geometries, options = {}, targetGeometry = new (0, $ilwiq.BufferGeometry)()) {\n    const { useGroups: useGroups = false, forceUpdate: forceUpdate = false, skipAssigningAttributes: skipAssigningAttributes = [], overwriteIndex: overwriteIndex = true } = options;\n    // check if we can merge these geometries\n    $5c43b36cecf64594$var$validateMergeability(geometries);\n    const isIndexed = geometries[0].index !== null;\n    const totalIndexCount = isIndexed ? $5c43b36cecf64594$var$getTotalIndexCount(geometries) : -1;\n    const totalAttributeCount = $5c43b36cecf64594$var$getTotalAttributeCount(geometries);\n    $5c43b36cecf64594$var$trimMismatchedAttributes(targetGeometry, totalIndexCount, totalAttributeCount);\n    // set up groups\n    if (useGroups) {\n        let offset = 0;\n        for(let i = 0, l = geometries.length; i < l; i++){\n            const geometry = geometries[i];\n            let primitiveCount;\n            if (isIndexed) primitiveCount = geometry.getIndex().count;\n            else primitiveCount = geometry.getAttribute(\"position\").count;\n            targetGeometry.addGroup(offset, primitiveCount, i);\n            offset += primitiveCount;\n        }\n    }\n    // generate the final geometry\n    // skip the assigning any attributes for items in the above array\n    if (isIndexed) {\n        // set up the index if it doesn't exist\n        let forceUpdateIndex = false;\n        if (!targetGeometry.index) {\n            targetGeometry.setIndex(new (0, $ilwiq.BufferAttribute)(new Uint32Array(totalIndexCount), 1, false));\n            forceUpdateIndex = true;\n        }\n        if (forceUpdateIndex || overwriteIndex) {\n            // copy the index data to the target geometry\n            let targetOffset = 0;\n            let indexOffset = 0;\n            const targetIndex = targetGeometry.getIndex();\n            for(let i = 0, l = geometries.length; i < l; i++){\n                const geometry = geometries[i];\n                const index = geometry.getIndex();\n                const skip = !forceUpdate && !forceUpdateIndex && skipAssigningAttributes[i];\n                if (!skip) for(let j = 0; j < index.count; ++j)targetIndex.setX(targetOffset + j, index.getX(j) + indexOffset);\n                targetOffset += index.count;\n                indexOffset += geometry.getAttribute(\"position\").count;\n            }\n        }\n    }\n    // copy all the attribute data over\n    const attributes = Object.keys(geometries[0].attributes);\n    for(let i = 0, l = attributes.length; i < l; i++){\n        let forceUpdateAttr = false;\n        const key = attributes[i];\n        if (!targetGeometry.getAttribute(key)) {\n            const firstAttr = geometries[0].getAttribute(key);\n            targetGeometry.setAttribute(key, (0, $iYpwh.createAttributeClone)(firstAttr, totalAttributeCount));\n            forceUpdateAttr = true;\n        }\n        let offset = 0;\n        const targetAttribute = targetGeometry.getAttribute(key);\n        for(let g = 0, l = geometries.length; g < l; g++){\n            const geometry = geometries[g];\n            const skip = !forceUpdate && !forceUpdateAttr && skipAssigningAttributes[g];\n            const attr = geometry.getAttribute(key);\n            if (!skip) {\n                if (key === \"color\" && targetAttribute.itemSize !== attr.itemSize) // make sure the color attribute is aligned with itemSize 3 to 4\n                for(let index = offset, l = attr.count; index < l; index++)attr.setXYZW(index, targetAttribute.getX(index), targetAttribute.getY(index), targetAttribute.getZ(index), 1.0);\n                else (0, $iYpwh.copyAttributeContents)(attr, targetAttribute, offset);\n            }\n            offset += attr.count;\n        }\n    }\n}\n\n});\nparcelRegister(\"iYpwh\", function(module, exports) {\n\n$parcel$export(module.exports, \"copyAttributeContents\", () => $dd01a0424002e6a9$export$16ecced3bb0ee496);\n$parcel$export(module.exports, \"createAttributeClone\", () => $dd01a0424002e6a9$export$f129ac5b0a0bbb35);\n$parcel$export(module.exports, \"validateAttributes\", () => $dd01a0424002e6a9$export$87f0ba9cb6ea9964);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nfunction $dd01a0424002e6a9$export$16ecced3bb0ee496(attr, target, targetOffset = 0) {\n    if (attr.isInterleavedBufferAttribute) {\n        const itemSize = attr.itemSize;\n        for(let i = 0, l = attr.count; i < l; i++){\n            const io = i + targetOffset;\n            target.setX(io, attr.getX(i));\n            if (itemSize >= 2) target.setY(io, attr.getY(i));\n            if (itemSize >= 3) target.setZ(io, attr.getZ(i));\n            if (itemSize >= 4) target.setW(io, attr.getW(i));\n        }\n    } else {\n        const array = target.array;\n        const cons = array.constructor;\n        const byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n        const temp = new cons(array.buffer, byteOffset, attr.array.length);\n        temp.set(attr.array);\n    }\n}\nfunction $dd01a0424002e6a9$export$f129ac5b0a0bbb35(attr, countOverride = null) {\n    const cons = attr.array.constructor;\n    const normalized = attr.normalized;\n    const itemSize = attr.itemSize;\n    const count = countOverride === null ? attr.count : countOverride;\n    return new (0, $ilwiq.BufferAttribute)(new cons(itemSize * count), itemSize, normalized);\n}\nfunction $dd01a0424002e6a9$export$87f0ba9cb6ea9964(attr1, attr2) {\n    if (!attr1 && !attr2) return true;\n    if (Boolean(attr1) !== Boolean(attr2)) return false;\n    const sameCount = attr1.count === attr2.count;\n    const sameNormalized = attr1.normalized === attr2.normalized;\n    const sameType = attr1.array.constructor === attr2.array.constructor;\n    const sameItemSize = attr1.itemSize === attr2.itemSize;\n    if (!sameCount || !sameNormalized || !sameType || !sameItemSize) return false;\n    return true;\n}\n\n});\n\n\nparcelRegister(\"8LUnK\", function(module, exports) {\n\n$parcel$export(module.exports, \"updateMaterialIndexAttribute\", () => $662e72ceb18db3d0$export$e7c7cc0a9714fa82);\n$parcel$export(module.exports, \"setCommonAttributes\", () => $662e72ceb18db3d0$export$f5a01205d395aca);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nfunction $662e72ceb18db3d0$export$e7c7cc0a9714fa82(geometry, materials, allMaterials) {\n    const indexAttr = geometry.index;\n    const posAttr = geometry.attributes.position;\n    const vertCount = posAttr.count;\n    const totalCount = indexAttr ? indexAttr.count : vertCount;\n    let groups = geometry.groups;\n    if (groups.length === 0) groups = [\n        {\n            count: totalCount,\n            start: 0,\n            materialIndex: 0\n        }\n    ];\n    let materialIndexAttribute = geometry.getAttribute(\"materialIndex\");\n    if (!materialIndexAttribute || materialIndexAttribute.count !== vertCount) {\n        // use an array with the minimum precision required to store all material id references.\n        let array;\n        if (allMaterials.length <= 255) array = new Uint8Array(vertCount);\n        else array = new Uint16Array(vertCount);\n        materialIndexAttribute = new (0, $ilwiq.BufferAttribute)(array, 1, false);\n        geometry.deleteAttribute(\"materialIndex\");\n        geometry.setAttribute(\"materialIndex\", materialIndexAttribute);\n    }\n    const materialArray = materialIndexAttribute.array;\n    for(let i = 0; i < groups.length; i++){\n        const group = groups[i];\n        const start = group.start;\n        const count = group.count;\n        const endCount = Math.min(count, totalCount - start);\n        const mat = Array.isArray(materials) ? materials[group.materialIndex] : materials;\n        const materialIndex = allMaterials.indexOf(mat);\n        for(let j = 0; j < endCount; j++){\n            let index = start + j;\n            if (indexAttr) index = indexAttr.getX(index);\n            materialArray[index] = materialIndex;\n        }\n    }\n}\nfunction $662e72ceb18db3d0$export$f5a01205d395aca(geometry, attributes) {\n    if (!geometry.index) {\n        // TODO: compute a typed array\n        const indexCount = geometry.attributes.position.count;\n        const array = new Array(indexCount);\n        for(let i = 0; i < indexCount; i++)array[i] = i;\n        geometry.setIndex(array);\n    }\n    if (!geometry.attributes.normal && attributes && attributes.includes(\"normal\")) geometry.computeVertexNormals();\n    if (!geometry.attributes.uv && attributes && attributes.includes(\"uv\")) {\n        const vertCount = geometry.attributes.position.count;\n        geometry.setAttribute(\"uv\", new (0, $ilwiq.BufferAttribute)(new Float32Array(vertCount * 2), 2, false));\n    }\n    if (!geometry.attributes.uv2 && attributes && attributes.includes(\"uv2\")) {\n        const vertCount = geometry.attributes.position.count;\n        geometry.setAttribute(\"uv2\", new (0, $ilwiq.BufferAttribute)(new Float32Array(vertCount * 2), 2, false));\n    }\n    if (!geometry.attributes.tangent && attributes && attributes.includes(\"tangent\")) {\n        // compute tangents requires a uv and normal buffer\n        if (geometry.attributes.uv && geometry.attributes.normal) geometry.computeTangents();\n        else {\n            const vertCount = geometry.attributes.position.count;\n            geometry.setAttribute(\"tangent\", new (0, $ilwiq.BufferAttribute)(new Float32Array(vertCount * 4), 4, false));\n        }\n    }\n    if (!geometry.attributes.color && attributes && attributes.includes(\"color\")) {\n        const vertCount = geometry.attributes.position.count;\n        const array = new Float32Array(vertCount * 4);\n        array.fill(1.0);\n        geometry.setAttribute(\"color\", new (0, $ilwiq.BufferAttribute)(array, 4));\n    }\n}\n\n});\n\nparcelRegister(\"2b74x\", function(module, exports) {\n\n$parcel$export(module.exports, \"BakedGeometry\", () => $1962183cefca0848$export$93d9a3230423d56b);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $ddiur = parcelRequire(\"ddiur\");\n\nvar $gz5pJ = parcelRequire(\"gz5pJ\");\n\nvar $iYpwh = parcelRequire(\"iYpwh\");\nclass $1962183cefca0848$export$93d9a3230423d56b extends (0, $ilwiq.BufferGeometry) {\n    constructor(){\n        super();\n        this.version = 0;\n        this.hash = null;\n        this._diff = new (0, $ddiur.MeshDiff)();\n    }\n    // returns whether the passed mesh is compatible with this baked geometry\n    // such that it can be updated without resizing attributes\n    isCompatible(mesh, attributes) {\n        const geometry = mesh.geometry;\n        for(let i = 0; i < attributes.length; i++){\n            const key = attributes[i];\n            const attr1 = geometry.attributes[key];\n            const attr2 = this.attributes[key];\n            if (attr1 && !(0, $iYpwh.validateAttributes)(attr1, attr2)) return false;\n        }\n        return true;\n    }\n    updateFrom(mesh, options) {\n        const diff = this._diff;\n        if (diff.didChange(mesh)) {\n            (0, $gz5pJ.convertToStaticGeometry)(mesh, options, this);\n            diff.updateFrom(mesh);\n            this.version++;\n            this.hash = `${this.uuid}_${this.version}`;\n            return true;\n        } else return false;\n    }\n}\n\n});\nparcelRegister(\"ddiur\", function(module, exports) {\n\n$parcel$export(module.exports, \"MeshDiff\", () => $99ead4f72dcbbc3d$export$507d8b359822d42d);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $6ply6 = parcelRequire(\"6ply6\");\nfunction $99ead4f72dcbbc3d$var$getGeometryHash(geometry) {\n    let hash = geometry.uuid;\n    const attributes = Object.values(geometry.attributes);\n    if (geometry.index) {\n        attributes.push(geometry.index);\n        hash += `index|${geometry.index.version}`;\n    }\n    const keys = Object.keys(attributes).sort();\n    for (const key of keys){\n        const attr = attributes[key];\n        hash += `${key}_${attr.version}|`;\n    }\n    return hash;\n}\nfunction $99ead4f72dcbbc3d$var$getSkeletonHash(mesh) {\n    const skeleton = mesh.skeleton;\n    if (skeleton) {\n        if (!skeleton.boneTexture) skeleton.computeBoneTexture();\n        // we can't use the texture version here because it will change even\n        // when the bones haven't\n        const dataHash = (0, $6ply6.bufferToHash)(skeleton.boneTexture.image.data.buffer);\n        return `${dataHash}_${skeleton.boneTexture.uuid}`;\n    } else return null;\n}\nclass $99ead4f72dcbbc3d$export$507d8b359822d42d {\n    constructor(mesh = null){\n        this.matrixWorld = new (0, $ilwiq.Matrix4)();\n        this.geometryHash = null;\n        this.skeletonHash = null;\n        this.primitiveCount = -1;\n        if (mesh !== null) this.updateFrom(mesh);\n    }\n    updateFrom(mesh) {\n        const geometry = mesh.geometry;\n        const primitiveCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n        this.matrixWorld.copy(mesh.matrixWorld);\n        this.geometryHash = $99ead4f72dcbbc3d$var$getGeometryHash(geometry);\n        this.primitiveCount = primitiveCount;\n        this.skeletonHash = $99ead4f72dcbbc3d$var$getSkeletonHash(mesh);\n    }\n    didChange(mesh) {\n        const geometry = mesh.geometry;\n        const primitiveCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n        const identical = this.matrixWorld.equals(mesh.matrixWorld) && this.geometryHash === $99ead4f72dcbbc3d$var$getGeometryHash(geometry) && this.skeletonHash === $99ead4f72dcbbc3d$var$getSkeletonHash(mesh) && this.primitiveCount === primitiveCount;\n        return !identical;\n    }\n}\n\n});\nparcelRegister(\"6ply6\", function(module, exports) {\n\n$parcel$export(module.exports, \"bufferToHash\", () => $4aa5cb15510fc60f$export$d10cf98ed3bc976d);\n// https://www.geeksforgeeks.org/how-to-create-hash-from-string-in-javascript/\n// https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\nfunction $4aa5cb15510fc60f$export$d10cf98ed3bc976d(buffer) {\n    let hash = 0;\n    if (buffer.byteLength !== 0) {\n        const uintArray = new Uint8Array(buffer);\n        for(let i = 0; i < buffer.byteLength; i++){\n            const byte = uintArray[i];\n            hash = (hash << 5) - hash + byte;\n            hash |= 0;\n        }\n    }\n    return hash;\n}\n\n});\n\n\nparcelRegister(\"gz5pJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"convertToStaticGeometry\", () => $c0f41d5980ac4a7a$export$8ed71501c410233d);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $iYpwh = parcelRequire(\"iYpwh\");\nconst $c0f41d5980ac4a7a$var$_positionVector = /*@__PURE__*/ new (0, $ilwiq.Vector3)();\nconst $c0f41d5980ac4a7a$var$_normalVector = /*@__PURE__*/ new (0, $ilwiq.Vector3)();\nconst $c0f41d5980ac4a7a$var$_tangentVector = /*@__PURE__*/ new (0, $ilwiq.Vector3)();\nconst $c0f41d5980ac4a7a$var$_tangentVector4 = /*@__PURE__*/ new (0, $ilwiq.Vector4)();\nconst $c0f41d5980ac4a7a$var$_morphVector = /*@__PURE__*/ new (0, $ilwiq.Vector3)();\nconst $c0f41d5980ac4a7a$var$_temp = /*@__PURE__*/ new (0, $ilwiq.Vector3)();\nconst $c0f41d5980ac4a7a$var$_skinIndex = /*@__PURE__*/ new (0, $ilwiq.Vector4)();\nconst $c0f41d5980ac4a7a$var$_skinWeight = /*@__PURE__*/ new (0, $ilwiq.Vector4)();\nconst $c0f41d5980ac4a7a$var$_matrix = /*@__PURE__*/ new (0, $ilwiq.Matrix4)();\nconst $c0f41d5980ac4a7a$var$_boneMatrix = /*@__PURE__*/ new (0, $ilwiq.Matrix4)();\n// A version of \"SkinnedMesh.boneTransform\" for normals\nfunction $c0f41d5980ac4a7a$var$boneNormalTransform(mesh, index, target) {\n    const skeleton = mesh.skeleton;\n    const geometry = mesh.geometry;\n    const bones = skeleton.bones;\n    const boneInverses = skeleton.boneInverses;\n    $c0f41d5980ac4a7a$var$_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);\n    $c0f41d5980ac4a7a$var$_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);\n    $c0f41d5980ac4a7a$var$_matrix.elements.fill(0);\n    for(let i = 0; i < 4; i++){\n        const weight = $c0f41d5980ac4a7a$var$_skinWeight.getComponent(i);\n        if (weight !== 0) {\n            const boneIndex = $c0f41d5980ac4a7a$var$_skinIndex.getComponent(i);\n            $c0f41d5980ac4a7a$var$_boneMatrix.multiplyMatrices(bones[boneIndex].matrixWorld, boneInverses[boneIndex]);\n            $c0f41d5980ac4a7a$var$addScaledMatrix($c0f41d5980ac4a7a$var$_matrix, $c0f41d5980ac4a7a$var$_boneMatrix, weight);\n        }\n    }\n    $c0f41d5980ac4a7a$var$_matrix.multiply(mesh.bindMatrix).premultiply(mesh.bindMatrixInverse);\n    target.transformDirection($c0f41d5980ac4a7a$var$_matrix);\n    return target;\n}\n// Applies the morph target data to the target vector\nfunction $c0f41d5980ac4a7a$var$applyMorphTarget(morphData, morphInfluences, morphTargetsRelative, i, target) {\n    $c0f41d5980ac4a7a$var$_morphVector.set(0, 0, 0);\n    for(let j = 0, jl = morphData.length; j < jl; j++){\n        const influence = morphInfluences[j];\n        const morphAttribute = morphData[j];\n        if (influence === 0) continue;\n        $c0f41d5980ac4a7a$var$_temp.fromBufferAttribute(morphAttribute, i);\n        if (morphTargetsRelative) $c0f41d5980ac4a7a$var$_morphVector.addScaledVector($c0f41d5980ac4a7a$var$_temp, influence);\n        else $c0f41d5980ac4a7a$var$_morphVector.addScaledVector($c0f41d5980ac4a7a$var$_temp.sub(target), influence);\n    }\n    target.add($c0f41d5980ac4a7a$var$_morphVector);\n}\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\nfunction $c0f41d5980ac4a7a$var$addScaledMatrix(target, matrix, scale) {\n    const targetArray = target.elements;\n    const matrixArray = matrix.elements;\n    for(let i = 0, l = matrixArray.length; i < l; i++)targetArray[i] += matrixArray[i] * scale;\n}\n// inverts the geometry in place\nfunction $c0f41d5980ac4a7a$var$invertGeometry(geometry) {\n    const { index: index, attributes: attributes } = geometry;\n    if (index) for(let i = 0, l = index.count; i < l; i += 3){\n        const v0 = index.getX(i);\n        const v2 = index.getX(i + 2);\n        index.setX(i, v2);\n        index.setX(i + 2, v0);\n    }\n    else for(const key in attributes){\n        const attr = attributes[key];\n        const itemSize = attr.itemSize;\n        for(let i = 0, l = attr.count; i < l; i += 3)for(let j = 0; j < itemSize; j++){\n            const v0 = attr.getComponent(i, j);\n            const v2 = attr.getComponent(i + 2, j);\n            attr.setComponent(i, j, v2);\n            attr.setComponent(i + 2, j, v0);\n        }\n    }\n    return geometry;\n}\nfunction $c0f41d5980ac4a7a$export$8ed71501c410233d(mesh, options = {}, targetGeometry = new (0, $ilwiq.BufferGeometry)()) {\n    options = {\n        applyWorldTransforms: true,\n        attributes: [],\n        ...options\n    };\n    const geometry = mesh.geometry;\n    const applyWorldTransforms = options.applyWorldTransforms;\n    const includeNormal = options.attributes.includes(\"normal\");\n    const includeTangent = options.attributes.includes(\"tangent\");\n    const attributes = geometry.attributes;\n    const targetAttributes = targetGeometry.attributes;\n    // strip any unused and unneeded attributes\n    for(const key in targetGeometry.attributes)if (!options.attributes.includes(key) || !(key in geometry.attributes)) targetGeometry.deleteAttribute(key);\n    // initialize the attributes if they don't exist\n    if (!targetGeometry.index && geometry.index) targetGeometry.index = geometry.index.clone();\n    if (!targetAttributes.position) targetGeometry.setAttribute(\"position\", (0, $iYpwh.createAttributeClone)(attributes.position));\n    if (includeNormal && !targetAttributes.normal && attributes.normal) targetGeometry.setAttribute(\"normal\", (0, $iYpwh.createAttributeClone)(attributes.normal));\n    if (includeTangent && !targetAttributes.tangent && attributes.tangent) targetGeometry.setAttribute(\"tangent\", (0, $iYpwh.createAttributeClone)(attributes.tangent));\n    // ensure the attributes are consistent\n    (0, $iYpwh.validateAttributes)(geometry.index, targetGeometry.index);\n    (0, $iYpwh.validateAttributes)(attributes.position, targetAttributes.position);\n    if (includeNormal) (0, $iYpwh.validateAttributes)(attributes.normal, targetAttributes.normal);\n    if (includeTangent) (0, $iYpwh.validateAttributes)(attributes.tangent, targetAttributes.tangent);\n    // generate transformed vertex attribute data\n    const position = attributes.position;\n    const normal = includeNormal ? attributes.normal : null;\n    const tangent = includeTangent ? attributes.tangent : null;\n    const morphPosition = geometry.morphAttributes.position;\n    const morphNormal = geometry.morphAttributes.normal;\n    const morphTangent = geometry.morphAttributes.tangent;\n    const morphTargetsRelative = geometry.morphTargetsRelative;\n    const morphInfluences = mesh.morphTargetInfluences;\n    const normalMatrix = new (0, $ilwiq.Matrix3)();\n    normalMatrix.getNormalMatrix(mesh.matrixWorld);\n    // copy the index\n    if (geometry.index) targetGeometry.index.array.set(geometry.index.array);\n    // copy and apply other attributes\n    for(let i = 0, l = attributes.position.count; i < l; i++){\n        $c0f41d5980ac4a7a$var$_positionVector.fromBufferAttribute(position, i);\n        if (normal) $c0f41d5980ac4a7a$var$_normalVector.fromBufferAttribute(normal, i);\n        if (tangent) {\n            $c0f41d5980ac4a7a$var$_tangentVector4.fromBufferAttribute(tangent, i);\n            $c0f41d5980ac4a7a$var$_tangentVector.fromBufferAttribute(tangent, i);\n        }\n        // apply morph target transform\n        if (morphInfluences) {\n            if (morphPosition) $c0f41d5980ac4a7a$var$applyMorphTarget(morphPosition, morphInfluences, morphTargetsRelative, i, $c0f41d5980ac4a7a$var$_positionVector);\n            if (morphNormal) $c0f41d5980ac4a7a$var$applyMorphTarget(morphNormal, morphInfluences, morphTargetsRelative, i, $c0f41d5980ac4a7a$var$_normalVector);\n            if (morphTangent) $c0f41d5980ac4a7a$var$applyMorphTarget(morphTangent, morphInfluences, morphTargetsRelative, i, $c0f41d5980ac4a7a$var$_tangentVector);\n        }\n        // apply bone transform\n        if (mesh.isSkinnedMesh) {\n            mesh.applyBoneTransform(i, $c0f41d5980ac4a7a$var$_positionVector);\n            if (normal) $c0f41d5980ac4a7a$var$boneNormalTransform(mesh, i, $c0f41d5980ac4a7a$var$_normalVector);\n            if (tangent) $c0f41d5980ac4a7a$var$boneNormalTransform(mesh, i, $c0f41d5980ac4a7a$var$_tangentVector);\n        }\n        // update the vectors of the attributes\n        if (applyWorldTransforms) $c0f41d5980ac4a7a$var$_positionVector.applyMatrix4(mesh.matrixWorld);\n        targetAttributes.position.setXYZ(i, $c0f41d5980ac4a7a$var$_positionVector.x, $c0f41d5980ac4a7a$var$_positionVector.y, $c0f41d5980ac4a7a$var$_positionVector.z);\n        if (normal) {\n            if (applyWorldTransforms) $c0f41d5980ac4a7a$var$_normalVector.applyNormalMatrix(normalMatrix);\n            targetAttributes.normal.setXYZ(i, $c0f41d5980ac4a7a$var$_normalVector.x, $c0f41d5980ac4a7a$var$_normalVector.y, $c0f41d5980ac4a7a$var$_normalVector.z);\n        }\n        if (tangent) {\n            if (applyWorldTransforms) $c0f41d5980ac4a7a$var$_tangentVector.transformDirection(mesh.matrixWorld);\n            targetAttributes.tangent.setXYZW(i, $c0f41d5980ac4a7a$var$_tangentVector.x, $c0f41d5980ac4a7a$var$_tangentVector.y, $c0f41d5980ac4a7a$var$_tangentVector.z, $c0f41d5980ac4a7a$var$_tangentVector4.w);\n        }\n    }\n    // copy other attributes over\n    for(const i in options.attributes){\n        const key = options.attributes[i];\n        if (key === \"position\" || key === \"tangent\" || key === \"normal\" || !(key in attributes)) continue;\n        if (!targetAttributes[key]) targetGeometry.setAttribute(key, (0, $iYpwh.createAttributeClone)(attributes[key]));\n        (0, $iYpwh.validateAttributes)(attributes[key], targetAttributes[key]);\n        (0, $iYpwh.copyAttributeContents)(attributes[key], targetAttributes[key]);\n    }\n    if (mesh.matrixWorld.determinant() < 0) $c0f41d5980ac4a7a$var$invertGeometry(targetGeometry);\n    return targetGeometry;\n}\n\n});\n\n\n\n\nparcelRegister(\"2vjHu\", function(module, exports) {\n\nvar $7rn9W = parcelRequire(\"7rn9W\");\n\nvar $b78om = parcelRequire(\"b78om\");\n\nvar $eL5d2 = parcelRequire(\"eL5d2\");\n\nvar $fFvuX = parcelRequire(\"fFvuX\");\n$parcel$exportWildcard(module.exports, $7rn9W);\n$parcel$exportWildcard(module.exports, $b78om);\n$parcel$exportWildcard(module.exports, $eL5d2);\n$parcel$exportWildcard(module.exports, $fFvuX);\n\n});\nparcelRegister(\"7rn9W\", function(module, exports) {\n\n$parcel$export(module.exports, \"common_functions\", () => $56ad0500f946240e$export$25a1e84cdffa9fe9);\nconst $56ad0500f946240e$export$25a1e84cdffa9fe9 = /* glsl */ `\n\n// A stack of uint32 indices can can store the indices for\n// a perfectly balanced tree with a depth up to 31. Lower stack\n// depth gets higher performance.\n//\n// However not all trees are balanced. Best value to set this to\n// is the trees max depth.\n#ifndef BVH_STACK_DEPTH\n#define BVH_STACK_DEPTH 60\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n`;\n\n});\n\nparcelRegister(\"b78om\", function(module, exports) {\n\n$parcel$export(module.exports, \"bvh_distance_functions\", () => $8176db9d094041c0$export$ae4e12e8c7af5f08);\n// Distance to Point\nconst $8176db9d094041c0$export$ae4e12e8c7af5f08 = /* glsl */ `\n\nfloat dot2( vec3 v ) {\n\n\treturn dot( v, v );\n\n}\n\n// https://www.shadertoy.com/view/ttfGWl\nvec3 closestPointToTriangle( vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 barycoord ) {\n\n    vec3 v10 = v1 - v0;\n    vec3 v21 = v2 - v1;\n    vec3 v02 = v0 - v2;\n\n\tvec3 p0 = p - v0;\n\tvec3 p1 = p - v1;\n\tvec3 p2 = p - v2;\n\n    vec3 nor = cross( v10, v02 );\n\n    // method 2, in barycentric space\n    vec3  q = cross( nor, p0 );\n    float d = 1.0 / dot2( nor );\n    float u = d * dot( q, v02 );\n    float v = d * dot( q, v10 );\n    float w = 1.0 - u - v;\n\n\tif( u < 0.0 ) {\n\n\t\tw = clamp( dot( p2, v02 ) / dot2( v02 ), 0.0, 1.0 );\n\t\tu = 0.0;\n\t\tv = 1.0 - w;\n\n\t} else if( v < 0.0 ) {\n\n\t\tu = clamp( dot( p0, v10 ) / dot2( v10 ), 0.0, 1.0 );\n\t\tv = 0.0;\n\t\tw = 1.0 - u;\n\n\t} else if( w < 0.0 ) {\n\n\t\tv = clamp( dot( p1, v21 ) / dot2( v21 ), 0.0, 1.0 );\n\t\tw = 0.0;\n\t\tu = 1.0-v;\n\n\t}\n\n\tbarycoord = vec3( u, v, w );\n    return u * v1 + v * v2 + w * v0;\n\n}\n\nfloat distanceToTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// point and cut off range\n\tvec3 point, float closestDistanceSquared,\n\n\t// outputs\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord, inout float side, inout vec3 outPoint\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\t// get the closest point and barycoord\n\t\tvec3 closestPoint = closestPointToTriangle( point, a, b, c, localBarycoord );\n\t\tvec3 delta = point - closestPoint;\n\t\tfloat sqDist = dot2( delta );\n\t\tif ( sqDist < closestDistanceSquared ) {\n\n\t\t\t// set the output results\n\t\t\tclosestDistanceSquared = sqDist;\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = normalize( cross( a - b, b - c ) );\n\t\t\tbarycoord = localBarycoord;\n\t\t\toutPoint = closestPoint;\n\t\t\tside = sign( dot( faceNormal, delta ) );\n\n\t\t}\n\n\t}\n\n\treturn closestDistanceSquared;\n\n}\n\nfloat distanceSqToBounds( vec3 point, vec3 boundsMin, vec3 boundsMax ) {\n\n\tvec3 clampedPoint = clamp( point, boundsMin, boundsMax );\n\tvec3 delta = point - clampedPoint;\n\treturn dot( delta, delta );\n\n}\n\nfloat distanceSqToBVHNodeBoundsPoint( vec3 point, sampler2D bvhBounds, uint currNodeIndex ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn distanceSqToBounds( point, boundsMin, boundsMax );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhClosestPointToPoint(\\\n\t\tbvh,\\\n\t\tpoint, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\\\n\t_bvhClosestPointToPoint(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\tpoint, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\n\nfloat _bvhClosestPointToPoint(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// point to check\n\tvec3 point,\n\n\t// output variables\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout vec3 outPoint\n ) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat closestDistanceSquared = pow( 100000.0, 2.0 );\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, currNodeIndex );\n\t\tif ( boundsHitDistance > closestDistanceSquared ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\t\t\tclosestDistanceSquared = distanceToTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count, point, closestDistanceSquared,\n\n\t\t\t\t// outputs\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, outPoint\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\t\t\tbool leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, rightIndex );//rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn sqrt( closestDistanceSquared );\n\n}\n`;\n\n});\n\nparcelRegister(\"eL5d2\", function(module, exports) {\n\n$parcel$export(module.exports, \"bvh_ray_functions\", () => $abe97ef051d4d2c5$export$3c2bc5470251fe4a);\nconst $abe97ef051d4d2c5$export$3c2bc5470251fe4a = /* glsl */ `\n\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n// Raycasting\nbool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tdist = max( t0, 0.0 );\n\n\treturn t1 >= dist;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// outputs\n\tinout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nbool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhIntersectFirstHit(\\\n\t\tbvh,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\\\n\t_bvhIntersectFirstHit(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\n\nbool _bvhIntersectFirstHit(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables split into separate variables due to output precision\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = INFINITY;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance;\n\t\tif (\n\t\t\t! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )\n\t\t\t|| boundsHitDistance > triangleDistance\n\t\t) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count,\n\t\t\t\trayOrigin, rayDirection, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n`;\n\n});\n\nparcelRegister(\"fFvuX\", function(module, exports) {\n\n$parcel$export(module.exports, \"bvh_struct_definitions\", () => $b6831e42db74378f$export$5e276bbaa046dbad);\n// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\n// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\n// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\nconst $b6831e42db74378f$export$5e276bbaa046dbad = /* glsl */ `\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n`;\n\n});\n\n\nparcelRegister(\"3mzmA\", function(module, exports) {\n\n$parcel$export(module.exports, \"MeshBVHUniformStruct\", () => $272edb95ce0a48ac$export$4dc20da53fccce35);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $hN8zD = parcelRequire(\"hN8zD\");\n\nvar $alNGj = parcelRequire(\"alNGj\");\n\nvar $8x2iv = parcelRequire(\"8x2iv\");\n\nvar $5Gkg5 = parcelRequire(\"5Gkg5\");\nclass $272edb95ce0a48ac$export$4dc20da53fccce35 {\n    constructor(){\n        this.index = new (0, $hN8zD.UIntVertexAttributeTexture)();\n        this.position = new (0, $hN8zD.FloatVertexAttributeTexture)();\n        this.bvhBounds = new (0, $ilwiq.DataTexture)();\n        this.bvhContents = new (0, $ilwiq.DataTexture)();\n        this._cachedIndexAttr = null;\n        this.index.overrideItemSize = 3;\n    }\n    updateFrom(bvh) {\n        const { geometry: geometry } = bvh;\n        $272edb95ce0a48ac$var$bvhToTextures(bvh, this.bvhBounds, this.bvhContents);\n        this.position.updateFrom(geometry.attributes.position);\n        // dereference a new index attribute if we're using indirect storage\n        if (bvh.indirect) {\n            const indirectBuffer = bvh._indirectBuffer;\n            if (this._cachedIndexAttr === null || this._cachedIndexAttr.count !== indirectBuffer.length) {\n                if (geometry.index) this._cachedIndexAttr = geometry.index.clone();\n                else {\n                    const array = (0, $5Gkg5.getIndexArray)((0, $5Gkg5.getVertexCount)(geometry));\n                    this._cachedIndexAttr = new (0, $ilwiq.BufferAttribute)(array, 1, false);\n                }\n            }\n            $272edb95ce0a48ac$var$dereferenceIndex(geometry, indirectBuffer, this._cachedIndexAttr);\n            this.index.updateFrom(this._cachedIndexAttr);\n        } else this.index.updateFrom(geometry.index);\n    }\n    dispose() {\n        const { index: index, position: position, bvhBounds: bvhBounds, bvhContents: bvhContents } = this;\n        if (index) index.dispose();\n        if (position) position.dispose();\n        if (bvhBounds) bvhBounds.dispose();\n        if (bvhContents) bvhContents.dispose();\n    }\n}\nfunction $272edb95ce0a48ac$var$dereferenceIndex(geometry, indirectBuffer, target) {\n    const unpacked = target.array;\n    const indexArray = geometry.index ? geometry.index.array : null;\n    for(let i = 0, l = indirectBuffer.length; i < l; i++){\n        const i3 = 3 * i;\n        const v3 = 3 * indirectBuffer[i];\n        for(let c = 0; c < 3; c++)unpacked[i3 + c] = indexArray ? indexArray[v3 + c] : v3 + c;\n    }\n}\nfunction $272edb95ce0a48ac$var$bvhToTextures(bvh, boundsTexture, contentsTexture) {\n    const roots = bvh._roots;\n    if (roots.length !== 1) throw new Error(\"MeshBVHUniformStruct: Multi-root BVHs not supported.\");\n    const root = roots[0];\n    const uint16Array = new Uint16Array(root);\n    const uint32Array = new Uint32Array(root);\n    const float32Array = new Float32Array(root);\n    // Both bounds need two elements per node so compute the height so it's twice as long as\n    // the width so we can expand the row by two and still have a square texture\n    const nodeCount = root.byteLength / (0, $alNGj.BYTES_PER_NODE);\n    const boundsDimension = 2 * Math.ceil(Math.sqrt(nodeCount / 2));\n    const boundsArray = new Float32Array(4 * boundsDimension * boundsDimension);\n    const contentsDimension = Math.ceil(Math.sqrt(nodeCount));\n    const contentsArray = new Uint32Array(2 * contentsDimension * contentsDimension);\n    for(let i = 0; i < nodeCount; i++){\n        const nodeIndex32 = i * (0, $alNGj.BYTES_PER_NODE) / 4;\n        const nodeIndex16 = nodeIndex32 * 2;\n        const boundsIndex = (0, $8x2iv.BOUNDING_DATA_INDEX)(nodeIndex32);\n        for(let b = 0; b < 3; b++){\n            boundsArray[8 * i + 0 + b] = float32Array[boundsIndex + 0 + b];\n            boundsArray[8 * i + 4 + b] = float32Array[boundsIndex + 3 + b];\n        }\n        if ((0, $8x2iv.IS_LEAF)(nodeIndex16, uint16Array)) {\n            const count = (0, $8x2iv.COUNT)(nodeIndex16, uint16Array);\n            const offset = (0, $8x2iv.OFFSET)(nodeIndex32, uint32Array);\n            const mergedLeafCount = 0xffff0000 | count;\n            contentsArray[i * 2 + 0] = mergedLeafCount;\n            contentsArray[i * 2 + 1] = offset;\n        } else {\n            const rightIndex = 4 * (0, $8x2iv.RIGHT_NODE)(nodeIndex32, uint32Array) / (0, $alNGj.BYTES_PER_NODE);\n            const splitAxis = (0, $8x2iv.SPLIT_AXIS)(nodeIndex32, uint32Array);\n            contentsArray[i * 2 + 0] = splitAxis;\n            contentsArray[i * 2 + 1] = rightIndex;\n        }\n    }\n    boundsTexture.image.data = boundsArray;\n    boundsTexture.image.width = boundsDimension;\n    boundsTexture.image.height = boundsDimension;\n    boundsTexture.format = (0, $ilwiq.RGBAFormat);\n    boundsTexture.type = (0, $ilwiq.FloatType);\n    boundsTexture.internalFormat = \"RGBA32F\";\n    boundsTexture.minFilter = (0, $ilwiq.NearestFilter);\n    boundsTexture.magFilter = (0, $ilwiq.NearestFilter);\n    boundsTexture.generateMipmaps = false;\n    boundsTexture.needsUpdate = true;\n    boundsTexture.dispose();\n    contentsTexture.image.data = contentsArray;\n    contentsTexture.image.width = contentsDimension;\n    contentsTexture.image.height = contentsDimension;\n    contentsTexture.format = (0, $ilwiq.RGIntegerFormat);\n    contentsTexture.type = (0, $ilwiq.UnsignedIntType);\n    contentsTexture.internalFormat = \"RG32UI\";\n    contentsTexture.minFilter = (0, $ilwiq.NearestFilter);\n    contentsTexture.magFilter = (0, $ilwiq.NearestFilter);\n    contentsTexture.generateMipmaps = false;\n    contentsTexture.needsUpdate = true;\n    contentsTexture.dispose();\n}\n\n});\nparcelRegister(\"hN8zD\", function(module, exports) {\n\n$parcel$export(module.exports, \"UIntVertexAttributeTexture\", () => $cf3da9d49bbdbfb4$export$de036370a093ef);\n$parcel$export(module.exports, \"FloatVertexAttributeTexture\", () => $cf3da9d49bbdbfb4$export$5444fd0f1815741f);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nfunction $cf3da9d49bbdbfb4$var$countToStringFormat(count) {\n    switch(count){\n        case 1:\n            return \"R\";\n        case 2:\n            return \"RG\";\n        case 3:\n            return \"RGBA\";\n        case 4:\n            return \"RGBA\";\n    }\n    throw new Error();\n}\nfunction $cf3da9d49bbdbfb4$var$countToFormat(count) {\n    switch(count){\n        case 1:\n            return 0, $ilwiq.RedFormat;\n        case 2:\n            return 0, $ilwiq.RGFormat;\n        case 3:\n            return 0, $ilwiq.RGBAFormat;\n        case 4:\n            return 0, $ilwiq.RGBAFormat;\n    }\n}\nfunction $cf3da9d49bbdbfb4$var$countToIntFormat(count) {\n    switch(count){\n        case 1:\n            return 0, $ilwiq.RedIntegerFormat;\n        case 2:\n            return 0, $ilwiq.RGIntegerFormat;\n        case 3:\n            return 0, $ilwiq.RGBAIntegerFormat;\n        case 4:\n            return 0, $ilwiq.RGBAIntegerFormat;\n    }\n}\nclass $cf3da9d49bbdbfb4$export$2ba8de89bc26b001 extends (0, $ilwiq.DataTexture) {\n    constructor(){\n        super();\n        this.minFilter = (0, $ilwiq.NearestFilter);\n        this.magFilter = (0, $ilwiq.NearestFilter);\n        this.generateMipmaps = false;\n        this.overrideItemSize = null;\n        this._forcedType = null;\n    }\n    updateFrom(attr) {\n        const overrideItemSize = this.overrideItemSize;\n        const originalItemSize = attr.itemSize;\n        const originalCount = attr.count;\n        if (overrideItemSize !== null) {\n            if (originalItemSize * originalCount % overrideItemSize !== 0.0) throw new Error(\"VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.\");\n            attr.itemSize = overrideItemSize;\n            attr.count = originalCount * originalItemSize / overrideItemSize;\n        }\n        const itemSize = attr.itemSize;\n        const count = attr.count;\n        const normalized = attr.normalized;\n        const originalBufferCons = attr.array.constructor;\n        const byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n        let targetType = this._forcedType;\n        let finalStride = itemSize;\n        // derive the type of texture this should be in the shader\n        if (targetType === null) switch(originalBufferCons){\n            case Float32Array:\n                targetType = (0, $ilwiq.FloatType);\n                break;\n            case Uint8Array:\n            case Uint16Array:\n            case Uint32Array:\n                targetType = (0, $ilwiq.UnsignedIntType);\n                break;\n            case Int8Array:\n            case Int16Array:\n            case Int32Array:\n                targetType = (0, $ilwiq.IntType);\n                break;\n        }\n        // get the target format to store the texture as\n        let type, format, normalizeValue, targetBufferCons;\n        let internalFormat = $cf3da9d49bbdbfb4$var$countToStringFormat(itemSize);\n        switch(targetType){\n            case 0, $ilwiq.FloatType:\n                normalizeValue = 1.0;\n                format = $cf3da9d49bbdbfb4$var$countToFormat(itemSize);\n                if (normalized && byteCount === 1) {\n                    targetBufferCons = originalBufferCons;\n                    internalFormat += \"8\";\n                    if (originalBufferCons === Uint8Array) type = (0, $ilwiq.UnsignedByteType);\n                    else {\n                        type = (0, $ilwiq.ByteType);\n                        internalFormat += \"_SNORM\";\n                    }\n                } else {\n                    targetBufferCons = Float32Array;\n                    internalFormat += \"32F\";\n                    type = (0, $ilwiq.FloatType);\n                }\n                break;\n            case 0, $ilwiq.IntType:\n                internalFormat += byteCount * 8 + \"I\";\n                normalizeValue = normalized ? Math.pow(2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1) : 1.0;\n                format = $cf3da9d49bbdbfb4$var$countToIntFormat(itemSize);\n                if (byteCount === 1) {\n                    targetBufferCons = Int8Array;\n                    type = (0, $ilwiq.ByteType);\n                } else if (byteCount === 2) {\n                    targetBufferCons = Int16Array;\n                    type = (0, $ilwiq.ShortType);\n                } else {\n                    targetBufferCons = Int32Array;\n                    type = (0, $ilwiq.IntType);\n                }\n                break;\n            case 0, $ilwiq.UnsignedIntType:\n                internalFormat += byteCount * 8 + \"UI\";\n                normalizeValue = normalized ? Math.pow(2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1) : 1.0;\n                format = $cf3da9d49bbdbfb4$var$countToIntFormat(itemSize);\n                if (byteCount === 1) {\n                    targetBufferCons = Uint8Array;\n                    type = (0, $ilwiq.UnsignedByteType);\n                } else if (byteCount === 2) {\n                    targetBufferCons = Uint16Array;\n                    type = (0, $ilwiq.UnsignedShortType);\n                } else {\n                    targetBufferCons = Uint32Array;\n                    type = (0, $ilwiq.UnsignedIntType);\n                }\n                break;\n        }\n        // there will be a mismatch between format length and final length because\n        // RGBFormat and RGBIntegerFormat was removed\n        if (finalStride === 3 && (format === (0, $ilwiq.RGBAFormat) || format === (0, $ilwiq.RGBAIntegerFormat))) finalStride = 4;\n        // copy the data over to the new texture array\n        const dimension = Math.ceil(Math.sqrt(count)) || 1;\n        const length = finalStride * dimension * dimension;\n        const dataArray = new targetBufferCons(length);\n        // temporarily set the normalized state to false since we have custom normalization logic\n        const originalNormalized = attr.normalized;\n        attr.normalized = false;\n        for(let i = 0; i < count; i++){\n            const ii = finalStride * i;\n            dataArray[ii] = attr.getX(i) / normalizeValue;\n            if (itemSize >= 2) dataArray[ii + 1] = attr.getY(i) / normalizeValue;\n            if (itemSize >= 3) {\n                dataArray[ii + 2] = attr.getZ(i) / normalizeValue;\n                if (finalStride === 4) dataArray[ii + 3] = 1.0;\n            }\n            if (itemSize >= 4) dataArray[ii + 3] = attr.getW(i) / normalizeValue;\n        }\n        attr.normalized = originalNormalized;\n        this.internalFormat = internalFormat;\n        this.format = format;\n        this.type = type;\n        this.image.width = dimension;\n        this.image.height = dimension;\n        this.image.data = dataArray;\n        this.needsUpdate = true;\n        this.dispose();\n        attr.itemSize = originalItemSize;\n        attr.count = originalCount;\n    }\n}\nclass $cf3da9d49bbdbfb4$export$de036370a093ef extends $cf3da9d49bbdbfb4$export$2ba8de89bc26b001 {\n    constructor(){\n        super();\n        this._forcedType = (0, $ilwiq.UnsignedIntType);\n    }\n}\nclass $cf3da9d49bbdbfb4$export$7a0619b1bafd353c extends $cf3da9d49bbdbfb4$export$2ba8de89bc26b001 {\n    constructor(){\n        super();\n        this._forcedType = (0, $ilwiq.IntType);\n    }\n}\nclass $cf3da9d49bbdbfb4$export$5444fd0f1815741f extends $cf3da9d49bbdbfb4$export$2ba8de89bc26b001 {\n    constructor(){\n        super();\n        this._forcedType = (0, $ilwiq.FloatType);\n    }\n}\n\n});\n\n\nparcelRegister(\"laA5G\", function(module, exports) {\n\n$parcel$export(module.exports, \"MATERIAL_PIXELS\", () => $f69686fae5159582$export$c4a81a0bfb84e9fe);\n$parcel$export(module.exports, \"MaterialsTexture\", () => $f69686fae5159582$export$ae96f3619813ce17);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $9wqOU = parcelRequire(\"9wqOU\");\n\nvar $6ply6 = parcelRequire(\"6ply6\");\nconst $f69686fae5159582$export$c4a81a0bfb84e9fe = 47;\nconst $f69686fae5159582$var$MATERIAL_STRIDE = $f69686fae5159582$export$c4a81a0bfb84e9fe * 4;\nclass $f69686fae5159582$var$MaterialFeatures {\n    constructor(){\n        this._features = {};\n    }\n    isUsed(feature) {\n        return feature in this._features;\n    }\n    setUsed(feature, used = true) {\n        if (used === false) delete this._features[feature];\n        else this._features[feature] = true;\n    }\n    reset() {\n        this._features = {};\n    }\n}\nclass $f69686fae5159582$export$ae96f3619813ce17 extends (0, $ilwiq.DataTexture) {\n    constructor(){\n        super(new Float32Array(4), 1, 1);\n        this.format = (0, $ilwiq.RGBAFormat);\n        this.type = (0, $ilwiq.FloatType);\n        this.wrapS = (0, $ilwiq.ClampToEdgeWrapping);\n        this.wrapT = (0, $ilwiq.ClampToEdgeWrapping);\n        this.minFilter = (0, $ilwiq.NearestFilter);\n        this.magFilter = (0, $ilwiq.NearestFilter);\n        this.generateMipmaps = false;\n        this.features = new $f69686fae5159582$var$MaterialFeatures();\n    }\n    updateFrom(materials, textures) {\n        function getTexture(material, key, def = -1) {\n            if (key in material && material[key]) {\n                const hash = (0, $9wqOU.getTextureHash)(material[key]);\n                return textureLookUp[hash];\n            } else return def;\n        }\n        function getField(material, key, def) {\n            return key in material ? material[key] : def;\n        }\n        function writeTextureMatrixToArray(material, textureKey, array, offset) {\n            const texture = material[textureKey] && material[textureKey].isTexture ? material[textureKey] : null;\n            // check if texture exists\n            if (texture) {\n                if (texture.matrixAutoUpdate) texture.updateMatrix();\n                const elements = texture.matrix.elements;\n                let i = 0;\n                // first row\n                array[offset + i++] = elements[0];\n                array[offset + i++] = elements[3];\n                array[offset + i++] = elements[6];\n                i++;\n                // second row\n                array[offset + i++] = elements[1];\n                array[offset + i++] = elements[4];\n                array[offset + i++] = elements[7];\n                i++;\n            }\n            return 8;\n        }\n        let index = 0;\n        const pixelCount = materials.length * $f69686fae5159582$export$c4a81a0bfb84e9fe;\n        const dimension = Math.ceil(Math.sqrt(pixelCount)) || 1;\n        const { image: image, features: features } = this;\n        // index the list of textures based on shareable source\n        const textureLookUp = {};\n        for(let i = 0, l = textures.length; i < l; i++)textureLookUp[(0, $9wqOU.getTextureHash)(textures[i])] = i;\n        if (image.width !== dimension) {\n            this.dispose();\n            image.data = new Float32Array(dimension * dimension * 4);\n            image.width = dimension;\n            image.height = dimension;\n        }\n        const floatArray = image.data;\n        // on some devices (Google Pixel 6) the \"floatBitsToInt\" function does not work correctly so we\n        // can't encode texture ids that way.\n        // const intArray = new Int32Array( floatArray.buffer );\n        features.reset();\n        for(let i = 0, l = materials.length; i < l; i++){\n            const m = materials[i];\n            if (m.isFogVolumeMaterial) {\n                features.setUsed(\"FOG\");\n                for(let j = 0; j < $f69686fae5159582$var$MATERIAL_STRIDE; j++)floatArray[index + j] = 0;\n                // sample 0 .rgb\n                floatArray[index + 0 + 0] = m.color.r;\n                floatArray[index + 0 + 1] = m.color.g;\n                floatArray[index + 0 + 2] = m.color.b;\n                // sample 2 .a\n                floatArray[index + 8 + 3] = getField(m, \"emissiveIntensity\", 0.0);\n                // sample 3 .rgb\n                floatArray[index + 12 + 0] = m.emissive.r;\n                floatArray[index + 12 + 1] = m.emissive.g;\n                floatArray[index + 12 + 2] = m.emissive.b;\n                // sample 13 .g\n                // reusing opacity field\n                floatArray[index + 52 + 1] = m.density;\n                // side\n                floatArray[index + 52 + 3] = 0.0;\n                // sample 14 .b\n                floatArray[index + 56 + 2] = 4;\n                index += $f69686fae5159582$var$MATERIAL_STRIDE;\n                continue;\n            }\n            // sample 0\n            // color\n            floatArray[index++] = m.color.r;\n            floatArray[index++] = m.color.g;\n            floatArray[index++] = m.color.b;\n            floatArray[index++] = getTexture(m, \"map\");\n            // sample 1\n            // metalness & roughness\n            floatArray[index++] = getField(m, \"metalness\", 0.0);\n            floatArray[index++] = getTexture(m, \"metalnessMap\");\n            floatArray[index++] = getField(m, \"roughness\", 0.0);\n            floatArray[index++] = getTexture(m, \"roughnessMap\");\n            // sample 2\n            // transmission & emissiveIntensity\n            // three.js assumes a default f0 of 0.04 if no ior is provided which equates to an ior of 1.5\n            floatArray[index++] = getField(m, \"ior\", 1.5);\n            floatArray[index++] = getField(m, \"transmission\", 0.0);\n            floatArray[index++] = getTexture(m, \"transmissionMap\");\n            floatArray[index++] = getField(m, \"emissiveIntensity\", 0.0);\n            // sample 3\n            // emission\n            if (\"emissive\" in m) {\n                floatArray[index++] = m.emissive.r;\n                floatArray[index++] = m.emissive.g;\n                floatArray[index++] = m.emissive.b;\n            } else {\n                floatArray[index++] = 0.0;\n                floatArray[index++] = 0.0;\n                floatArray[index++] = 0.0;\n            }\n            floatArray[index++] = getTexture(m, \"emissiveMap\");\n            // sample 4\n            // normals\n            floatArray[index++] = getTexture(m, \"normalMap\");\n            if (\"normalScale\" in m) {\n                floatArray[index++] = m.normalScale.x;\n                floatArray[index++] = m.normalScale.y;\n            } else {\n                floatArray[index++] = 1;\n                floatArray[index++] = 1;\n            }\n            // clearcoat\n            floatArray[index++] = getField(m, \"clearcoat\", 0.0);\n            floatArray[index++] = getTexture(m, \"clearcoatMap\"); // sample 5\n            floatArray[index++] = getField(m, \"clearcoatRoughness\", 0.0);\n            floatArray[index++] = getTexture(m, \"clearcoatRoughnessMap\");\n            floatArray[index++] = getTexture(m, \"clearcoatNormalMap\");\n            // sample 6\n            if (\"clearcoatNormalScale\" in m) {\n                floatArray[index++] = m.clearcoatNormalScale.x;\n                floatArray[index++] = m.clearcoatNormalScale.y;\n            } else {\n                floatArray[index++] = 1;\n                floatArray[index++] = 1;\n            }\n            index++;\n            floatArray[index++] = getField(m, \"sheen\", 0.0);\n            // sample 7\n            // sheen\n            if (\"sheenColor\" in m) {\n                floatArray[index++] = m.sheenColor.r;\n                floatArray[index++] = m.sheenColor.g;\n                floatArray[index++] = m.sheenColor.b;\n            } else {\n                floatArray[index++] = 0.0;\n                floatArray[index++] = 0.0;\n                floatArray[index++] = 0.0;\n            }\n            floatArray[index++] = getTexture(m, \"sheenColorMap\");\n            // sample 8\n            floatArray[index++] = getField(m, \"sheenRoughness\", 0.0);\n            floatArray[index++] = getTexture(m, \"sheenRoughnessMap\");\n            // iridescence\n            floatArray[index++] = getTexture(m, \"iridescenceMap\");\n            floatArray[index++] = getTexture(m, \"iridescenceThicknessMap\");\n            // sample 9\n            floatArray[index++] = getField(m, \"iridescence\", 0.0);\n            floatArray[index++] = getField(m, \"iridescenceIOR\", 1.3);\n            const iridescenceThicknessRange = getField(m, \"iridescenceThicknessRange\", [\n                100,\n                400\n            ]);\n            floatArray[index++] = iridescenceThicknessRange[0];\n            floatArray[index++] = iridescenceThicknessRange[1];\n            // sample 10\n            // specular color\n            if (\"specularColor\" in m) {\n                floatArray[index++] = m.specularColor.r;\n                floatArray[index++] = m.specularColor.g;\n                floatArray[index++] = m.specularColor.b;\n            } else {\n                floatArray[index++] = 1.0;\n                floatArray[index++] = 1.0;\n                floatArray[index++] = 1.0;\n            }\n            floatArray[index++] = getTexture(m, \"specularColorMap\");\n            // sample 11\n            // specular intensity\n            floatArray[index++] = getField(m, \"specularIntensity\", 1.0);\n            floatArray[index++] = getTexture(m, \"specularIntensityMap\");\n            // isThinFilm\n            const isThinFilm = getField(m, \"thickness\", 0.0) === 0.0 && getField(m, \"attenuationDistance\", Infinity) === Infinity;\n            floatArray[index++] = Number(isThinFilm);\n            index++;\n            // sample 12\n            if (\"attenuationColor\" in m) {\n                floatArray[index++] = m.attenuationColor.r;\n                floatArray[index++] = m.attenuationColor.g;\n                floatArray[index++] = m.attenuationColor.b;\n            } else {\n                floatArray[index++] = 1.0;\n                floatArray[index++] = 1.0;\n                floatArray[index++] = 1.0;\n            }\n            floatArray[index++] = getField(m, \"attenuationDistance\", Infinity);\n            // sample 13\n            // alphaMap\n            floatArray[index++] = getTexture(m, \"alphaMap\");\n            // side & matte\n            floatArray[index++] = m.opacity;\n            floatArray[index++] = m.alphaTest;\n            if (!isThinFilm && m.transmission > 0.0) floatArray[index++] = 0;\n            else switch(m.side){\n                case 0, $ilwiq.FrontSide:\n                    floatArray[index++] = 1;\n                    break;\n                case 0, $ilwiq.BackSide:\n                    floatArray[index++] = -1;\n                    break;\n                case 0, $ilwiq.DoubleSide:\n                    floatArray[index++] = 0;\n                    break;\n            }\n            // sample 14\n            floatArray[index++] = Number(getField(m, \"matte\", false)); // matte\n            floatArray[index++] = Number(getField(m, \"castShadow\", true)); // shadow\n            floatArray[index++] = Number(m.vertexColors) | Number(m.flatShading) << 1; // vertexColors & flatShading\n            floatArray[index++] = Number(m.transparent); // transparent\n            // map transform 15\n            index += writeTextureMatrixToArray(m, \"map\", floatArray, index);\n            // metalnessMap transform 17\n            index += writeTextureMatrixToArray(m, \"metalnessMap\", floatArray, index);\n            // roughnessMap transform 19\n            index += writeTextureMatrixToArray(m, \"roughnessMap\", floatArray, index);\n            // transmissionMap transform 21\n            index += writeTextureMatrixToArray(m, \"transmissionMap\", floatArray, index);\n            // emissiveMap transform 22\n            index += writeTextureMatrixToArray(m, \"emissiveMap\", floatArray, index);\n            // normalMap transform 25\n            index += writeTextureMatrixToArray(m, \"normalMap\", floatArray, index);\n            // clearcoatMap transform 27\n            index += writeTextureMatrixToArray(m, \"clearcoatMap\", floatArray, index);\n            // clearcoatNormalMap transform 29\n            index += writeTextureMatrixToArray(m, \"clearcoatNormalMap\", floatArray, index);\n            // clearcoatRoughnessMap transform 31\n            index += writeTextureMatrixToArray(m, \"clearcoatRoughnessMap\", floatArray, index);\n            // sheenColorMap transform 33\n            index += writeTextureMatrixToArray(m, \"sheenColorMap\", floatArray, index);\n            // sheenRoughnessMap transform 35\n            index += writeTextureMatrixToArray(m, \"sheenRoughnessMap\", floatArray, index);\n            // iridescenceMap transform 37\n            index += writeTextureMatrixToArray(m, \"iridescenceMap\", floatArray, index);\n            // iridescenceThicknessMap transform 39\n            index += writeTextureMatrixToArray(m, \"iridescenceThicknessMap\", floatArray, index);\n            // specularColorMap transform 41\n            index += writeTextureMatrixToArray(m, \"specularColorMap\", floatArray, index);\n            // specularIntensityMap transform 43\n            index += writeTextureMatrixToArray(m, \"specularIntensityMap\", floatArray, index);\n            // alphaMap transform 45\n            index += writeTextureMatrixToArray(m, \"alphaMap\", floatArray, index);\n        }\n        // check if the contents have changed\n        const hash = (0, $6ply6.bufferToHash)(floatArray.buffer);\n        if (this.hash !== hash) {\n            this.hash = hash;\n            this.needsUpdate = true;\n            return true;\n        }\n        return false;\n    }\n}\n\n});\nparcelRegister(\"9wqOU\", function(module, exports) {\n\n$parcel$export(module.exports, \"getTextureHash\", () => $6eebe81d767f0e44$export$62c3d260e4e2abca);\n$parcel$export(module.exports, \"getIesTextures\", () => $6eebe81d767f0e44$export$b22c535c66112848);\n$parcel$export(module.exports, \"getTextures\", () => $6eebe81d767f0e44$export$560c941db545ef55);\n$parcel$export(module.exports, \"getLights\", () => $6eebe81d767f0e44$export$3ae1ccb94aa877f9);\nfunction $6eebe81d767f0e44$var$uuidSort(a, b) {\n    if (a.uuid < b.uuid) return 1;\n    if (a.uuid > b.uuid) return -1;\n    return 0;\n}\nfunction $6eebe81d767f0e44$export$62c3d260e4e2abca(t) {\n    return `${t.source.uuid}:${t.colorSpace}`;\n}\n// reduce the set of textures to just those with a unique source while retaining\n// the order of the textures.\nfunction $6eebe81d767f0e44$var$reduceTexturesToUniqueSources(textures) {\n    const sourceSet = new Set();\n    const result = [];\n    for(let i = 0, l = textures.length; i < l; i++){\n        const tex = textures[i];\n        const hash = $6eebe81d767f0e44$export$62c3d260e4e2abca(tex);\n        if (!sourceSet.has(hash)) {\n            sourceSet.add(hash);\n            result.push(tex);\n        }\n    }\n    return result;\n}\nfunction $6eebe81d767f0e44$export$b22c535c66112848(lights) {\n    const textures = lights.map((l)=>l.iesMap || null).filter((t)=>t);\n    const textureSet = new Set(textures);\n    return Array.from(textureSet).sort($6eebe81d767f0e44$var$uuidSort);\n}\nfunction $6eebe81d767f0e44$export$560c941db545ef55(materials) {\n    const textureSet = new Set();\n    for(let i = 0, l = materials.length; i < l; i++){\n        const material = materials[i];\n        for(const key in material){\n            const value = material[key];\n            if (value && value.isTexture) textureSet.add(value);\n        }\n    }\n    const textureArray = Array.from(textureSet);\n    return $6eebe81d767f0e44$var$reduceTexturesToUniqueSources(textureArray).sort($6eebe81d767f0e44$var$uuidSort);\n}\nfunction $6eebe81d767f0e44$export$3ae1ccb94aa877f9(scene) {\n    const lights = [];\n    scene.traverse((c)=>{\n        if (c.visible) {\n            if (c.isRectAreaLight || c.isSpotLight || c.isPointLight || c.isDirectionalLight) lights.push(c);\n        }\n    });\n    return lights.sort($6eebe81d767f0e44$var$uuidSort);\n}\n\n});\n\n\nparcelRegister(\"1r4sY\", function(module, exports) {\n\n$parcel$export(module.exports, \"material_struct\", () => $10bbc6f618708662$export$f47304f32d084e8b);\nconst $10bbc6f618708662$export$f47304f32d084e8b = /* glsl */ `\n\n\tstruct Material {\n\n\t\tvec3 color;\n\t\tint map;\n\n\t\tfloat metalness;\n\t\tint metalnessMap;\n\n\t\tfloat roughness;\n\t\tint roughnessMap;\n\n\t\tfloat ior;\n\t\tfloat transmission;\n\t\tint transmissionMap;\n\n\t\tfloat emissiveIntensity;\n\t\tvec3 emissive;\n\t\tint emissiveMap;\n\n\t\tint normalMap;\n\t\tvec2 normalScale;\n\n\t\tfloat clearcoat;\n\t\tint clearcoatMap;\n\t\tint clearcoatNormalMap;\n\t\tvec2 clearcoatNormalScale;\n\t\tfloat clearcoatRoughness;\n\t\tint clearcoatRoughnessMap;\n\n\t\tint iridescenceMap;\n\t\tint iridescenceThicknessMap;\n\t\tfloat iridescence;\n\t\tfloat iridescenceIor;\n\t\tfloat iridescenceThicknessMinimum;\n\t\tfloat iridescenceThicknessMaximum;\n\n\t\tvec3 specularColor;\n\t\tint specularColorMap;\n\n\t\tfloat specularIntensity;\n\t\tint specularIntensityMap;\n\t\tbool thinFilm;\n\n\t\tvec3 attenuationColor;\n\t\tfloat attenuationDistance;\n\n\t\tint alphaMap;\n\n\t\tbool castShadow;\n\t\tfloat opacity;\n\t\tfloat alphaTest;\n\n\t\tfloat side;\n\t\tbool matte;\n\n\t\tfloat sheen;\n\t\tvec3 sheenColor;\n\t\tint sheenColorMap;\n\t\tfloat sheenRoughness;\n\t\tint sheenRoughnessMap;\n\n\t\tbool vertexColors;\n\t\tbool flatShading;\n\t\tbool transparent;\n\t\tbool fogVolume;\n\n\t\tmat3 mapTransform;\n\t\tmat3 metalnessMapTransform;\n\t\tmat3 roughnessMapTransform;\n\t\tmat3 transmissionMapTransform;\n\t\tmat3 emissiveMapTransform;\n\t\tmat3 normalMapTransform;\n\t\tmat3 clearcoatMapTransform;\n\t\tmat3 clearcoatNormalMapTransform;\n\t\tmat3 clearcoatRoughnessMapTransform;\n\t\tmat3 sheenColorMapTransform;\n\t\tmat3 sheenRoughnessMapTransform;\n\t\tmat3 iridescenceMapTransform;\n\t\tmat3 iridescenceThicknessMapTransform;\n\t\tmat3 specularColorMapTransform;\n\t\tmat3 specularIntensityMapTransform;\n\t\tmat3 alphaMapTransform;\n\n\t};\n\n\tmat3 readTextureTransform( sampler2D tex, uint index ) {\n\n\t\tmat3 textureTransform;\n\n\t\tvec4 row1 = texelFetch1D( tex, index );\n\t\tvec4 row2 = texelFetch1D( tex, index + 1u );\n\n\t\ttextureTransform[0] = vec3(row1.r, row2.r, 0.0);\n\t\ttextureTransform[1] = vec3(row1.g, row2.g, 0.0);\n\t\ttextureTransform[2] = vec3(row1.b, row2.b, 1.0);\n\n\t\treturn textureTransform;\n\n\t}\n\n\tMaterial readMaterialInfo( sampler2D tex, uint index ) {\n\n\t\tuint i = index * uint( MATERIAL_PIXELS );\n\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\n\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\n\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\n\t\tvec4 s6 = texelFetch1D( tex, i + 6u );\n\t\tvec4 s7 = texelFetch1D( tex, i + 7u );\n\t\tvec4 s8 = texelFetch1D( tex, i + 8u );\n\t\tvec4 s9 = texelFetch1D( tex, i + 9u );\n\t\tvec4 s10 = texelFetch1D( tex, i + 10u );\n\t\tvec4 s11 = texelFetch1D( tex, i + 11u );\n\t\tvec4 s12 = texelFetch1D( tex, i + 12u );\n\t\tvec4 s13 = texelFetch1D( tex, i + 13u );\n\t\tvec4 s14 = texelFetch1D( tex, i + 14u );\n\n\t\tMaterial m;\n\t\tm.color = s0.rgb;\n\t\tm.map = int( round( s0.a ) );\n\n\t\tm.metalness = s1.r;\n\t\tm.metalnessMap = int( round( s1.g ) );\n\t\tm.roughness = s1.b;\n\t\tm.roughnessMap = int( round( s1.a ) );\n\n\t\tm.ior = s2.r;\n\t\tm.transmission = s2.g;\n\t\tm.transmissionMap = int( round( s2.b ) );\n\t\tm.emissiveIntensity = s2.a;\n\n\t\tm.emissive = s3.rgb;\n\t\tm.emissiveMap = int( round( s3.a ) );\n\n\t\tm.normalMap = int( round( s4.r ) );\n\t\tm.normalScale = s4.gb;\n\n\t\tm.clearcoat = s4.a;\n\t\tm.clearcoatMap = int( round( s5.r ) );\n\t\tm.clearcoatRoughness = s5.g;\n\t\tm.clearcoatRoughnessMap = int( round( s5.b ) );\n\t\tm.clearcoatNormalMap = int( round( s5.a ) );\n\t\tm.clearcoatNormalScale = s6.rg;\n\n\t\tm.sheen = s6.a;\n\t\tm.sheenColor = s7.rgb;\n\t\tm.sheenColorMap = int( round( s7.a ) );\n\t\tm.sheenRoughness = s8.r;\n\t\tm.sheenRoughnessMap = int( round( s8.g ) );\n\n\t\tm.iridescenceMap = int( round( s8.b ) );\n\t\tm.iridescenceThicknessMap = int( round( s8.a ) );\n\t\tm.iridescence = s9.r;\n\t\tm.iridescenceIor = s9.g;\n\t\tm.iridescenceThicknessMinimum = s9.b;\n\t\tm.iridescenceThicknessMaximum = s9.a;\n\n\t\tm.specularColor = s10.rgb;\n\t\tm.specularColorMap = int( round( s10.a ) );\n\n\t\tm.specularIntensity = s11.r;\n\t\tm.specularIntensityMap = int( round( s11.g ) );\n\t\tm.thinFilm = bool( s11.b );\n\n\t\tm.attenuationColor = s12.rgb;\n\t\tm.attenuationDistance = s12.a;\n\n\t\tm.alphaMap = int( round( s13.r ) );\n\n\t\tm.opacity = s13.g;\n\t\tm.alphaTest = s13.b;\n\t\tm.side = s13.a;\n\n\t\tm.matte = bool( s14.r );\n\t\tm.castShadow = bool( s14.g );\n\t\tm.vertexColors = bool( int( s14.b ) & 1 );\n\t\tm.flatShading = bool( int( s14.b ) & 2 );\n\t\tm.fogVolume = bool( int( s14.b ) & 4 );\n\t\tm.transparent = bool( s14.a );\n\n\t\tuint firstTextureTransformIdx = i + 15u;\n\n\t\t// mat3( 1.0 ) is an identity matrix\n\t\tm.mapTransform = m.map == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx );\n\t\tm.metalnessMapTransform = m.metalnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 2u );\n\t\tm.roughnessMapTransform = m.roughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 4u );\n\t\tm.transmissionMapTransform = m.transmissionMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 6u );\n\t\tm.emissiveMapTransform = m.emissiveMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 8u );\n\t\tm.normalMapTransform = m.normalMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 10u );\n\t\tm.clearcoatMapTransform = m.clearcoatMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 12u );\n\t\tm.clearcoatNormalMapTransform = m.clearcoatNormalMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 14u );\n\t\tm.clearcoatRoughnessMapTransform = m.clearcoatRoughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 16u );\n\t\tm.sheenColorMapTransform = m.sheenColorMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 18u );\n\t\tm.sheenRoughnessMapTransform = m.sheenRoughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 20u );\n\t\tm.iridescenceMapTransform = m.iridescenceMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 22u );\n\t\tm.iridescenceThicknessMapTransform = m.iridescenceThicknessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 24u );\n\t\tm.specularColorMapTransform = m.specularColorMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 26u );\n\t\tm.specularIntensityMapTransform = m.specularIntensityMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 28u );\n\t\tm.alphaMapTransform = m.alphaMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 30u );\n\n\t\treturn m;\n\n\t}\n\n`;\n\n});\n\nparcelRegister(\"cp6U0\", function(module, exports) {\n\n$parcel$export(module.exports, \"shape_sampling_functions\", () => $907d2c82b3e6ae31$export$4d6021b7971af115);\nconst $907d2c82b3e6ae31$export$4d6021b7971af115 = /* glsl */ `\n\n\tvec3 sampleHemisphere( vec3 n, vec2 uv ) {\n\n\t\t// https://www.rorydriscoll.com/2009/01/07/better-sampling/\n\t\t// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n\t\tfloat sign = n.z == 0.0 ? 1.0 : sign( n.z );\n\t\tfloat a = - 1.0 / ( sign + n.z );\n\t\tfloat b = n.x * n.y * a;\n\t\tvec3 b1 = vec3( 1.0 + sign * n.x * n.x * a, sign * b, - sign * n.x );\n\t\tvec3 b2 = vec3( b, sign + n.y * n.y * a, - n.y );\n\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat theta = 2.0 * PI * uv.y;\n\t\tfloat x = r * cos( theta );\n\t\tfloat y = r * sin( theta );\n\t\treturn x * b1 + y * b2 + sqrt( 1.0 - uv.x ) * n;\n\n\t}\n\n\tvec2 sampleTriangle( vec2 a, vec2 b, vec2 c, vec2 r ) {\n\n\t\t// get the edges of the triangle and the diagonal across the\n\t\t// center of the parallelogram\n\t\tvec2 e1 = a - b;\n\t\tvec2 e2 = c - b;\n\t\tvec2 diag = normalize( e1 + e2 );\n\n\t\t// pick the point in the parallelogram\n\t\tif ( r.x + r.y > 1.0 ) {\n\n\t\t\tr = vec2( 1.0 ) - r;\n\n\t\t}\n\n\t\treturn e1 * r.x + e2 * r.y;\n\n\t}\n\n\tvec2 sampleCircle( vec2 uv ) {\n\n\t\tfloat angle = 2.0 * PI * uv.x;\n\t\tfloat radius = sqrt( uv.y );\n\t\treturn vec2( cos( angle ), sin( angle ) ) * radius;\n\n\t}\n\n\tvec3 sampleSphere( vec2 uv ) {\n\n\t\tfloat u = ( uv.x - 0.5 ) * 2.0;\n\t\tfloat t = uv.y * PI * 2.0;\n\t\tfloat f = sqrt( 1.0 - u * u );\n\n\t\treturn vec3( f * cos( t ), f * sin( t ), u );\n\n\t}\n\n\tvec2 sampleRegularPolygon( int sides, vec3 uvw ) {\n\n\t\tsides = max( sides, 3 );\n\n\t\tvec3 r = uvw;\n\t\tfloat anglePerSegment = 2.0 * PI / float( sides );\n\t\tfloat segment = floor( float( sides ) * r.x );\n\n\t\tfloat angle1 = anglePerSegment * segment;\n\t\tfloat angle2 = angle1 + anglePerSegment;\n\t\tvec2 a = vec2( sin( angle1 ), cos( angle1 ) );\n\t\tvec2 b = vec2( 0.0, 0.0 );\n\t\tvec2 c = vec2( sin( angle2 ), cos( angle2 ) );\n\n\t\treturn sampleTriangle( a, b, c, r.yz );\n\n\t}\n\n\t// samples an aperture shape with the given number of sides. 0 means circle\n\tvec2 sampleAperture( int blades, vec3 uvw ) {\n\n\t\treturn blades == 0 ?\n\t\t\tsampleCircle( uvw.xy ) :\n\t\t\tsampleRegularPolygon( blades, uvw );\n\n\t}\n\n\n`;\n\n});\n\nparcelRegister(\"kmALz\", function(module, exports) {\n\n$parcel$export(module.exports, \"pcg_functions\", () => $ed3261c1debf969a$export$c7fd8b12fd4f43be);\nconst $ed3261c1debf969a$export$c7fd8b12fd4f43be = /* glsl */ `\n\n\t// https://www.shadertoy.com/view/wltcRS\n\tuvec4 WHITE_NOISE_SEED;\n\n\tvoid rng_initialize( vec2 p, int frame ) {\n\n\t\t// white noise seed\n\t\tWHITE_NOISE_SEED = uvec4( p, uint( frame ), uint( p.x ) + uint( p.y ) );\n\n\t}\n\n\t// https://www.pcg-random.org/\n\tvoid pcg4d( inout uvec4 v ) {\n\n\t\tv = v * 1664525u + 1013904223u;\n\t\tv.x += v.y * v.w;\n\t\tv.y += v.z * v.x;\n\t\tv.z += v.x * v.y;\n\t\tv.w += v.y * v.z;\n\t\tv = v ^ ( v >> 16u );\n\t\tv.x += v.y*v.w;\n\t\tv.y += v.z*v.x;\n\t\tv.z += v.x*v.y;\n\t\tv.w += v.y*v.z;\n\n\t}\n\n\t// returns [ 0, 1 ]\n\tfloat pcgRand() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn float( WHITE_NOISE_SEED.x ) / float( 0xffffffffu );\n\n\t}\n\n\tvec2 pcgRand2() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec2( WHITE_NOISE_SEED.xy ) / float(0xffffffffu);\n\n\t}\n\n\tvec3 pcgRand3() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec3( WHITE_NOISE_SEED.xyz ) / float( 0xffffffffu );\n\n\t}\n\n\tvec4 pcgRand4() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec4( WHITE_NOISE_SEED ) / float( 0xffffffffu );\n\n\t}\n`;\n\n});\n\n\n//# sourceMappingURL=aoRender.d33f21b3.js.map\n","import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tOrthographicCamera,\n\tMesh\n} from 'three';\n\nclass Pass {\n\n\tconstructor() {\n\n\t\tthis.isPass = true;\n\n\t\t// if set to true, the pass is processed by the composer\n\t\tthis.enabled = true;\n\n\t\t// if set to true, the pass indicates to swap read and write buffer after rendering\n\t\tthis.needsSwap = true;\n\n\t\t// if set to true, the pass clears its buffer before rendering\n\t\tthis.clear = false;\n\n\t\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n\t\tthis.renderToScreen = false;\n\n\t}\n\n\tsetSize( /* width, height */ ) {}\n\n\trender( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n\tdispose() {}\n\n}\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nconst _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n// https://github.com/mrdoob/three.js/pull/21358\n\nclass FullscreenTriangleGeometry extends BufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );\n\n\t}\n\n}\n\nconst _geometry = new FullscreenTriangleGeometry();\n\nclass FullScreenQuad {\n\n\tconstructor( material ) {\n\n\t\tthis._mesh = new Mesh( _geometry, material );\n\n\t}\n\n\tdispose() {\n\n\t\tthis._mesh.geometry.dispose();\n\n\t}\n\n\trender( renderer ) {\n\n\t\trenderer.render( this._mesh, _camera );\n\n\t}\n\n\tget material() {\n\n\t\treturn this._mesh.material;\n\n\t}\n\n\tset material( value ) {\n\n\t\tthis._mesh.material = value;\n\n\t}\n\n}\n\nexport { Pass, FullScreenQuad };\n","import { BufferGeometry } from 'three';\nimport { MeshBVH, SAH } from 'three-mesh-bvh';\nimport { StaticGeometryGenerator, NO_CHANGE, GEOMETRY_ADJUSTED, GEOMETRY_REBUILT } from './utils/StaticGeometryGenerator.js';\nimport { updateMaterialIndexAttribute } from './utils/GeometryPreparationUtils.js';\n\n// collect the textures from the materials\nfunction getTextures( materials ) {\n\n\tconst textureSet = new Set();\n\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\tconst material = materials[ i ];\n\t\tfor ( const key in material ) {\n\n\t\t\tconst value = material[ key ];\n\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\ttextureSet.add( value );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn Array.from( textureSet );\n\n}\n\n// collect the lights in the scene\nfunction getLights( objects ) {\n\n\tconst lights = [];\n\tconst iesSet = new Set();\n\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\tobjects[ i ].traverse( c => {\n\n\t\t\tif ( c.visible ) {\n\n\t\t\t\tif (\n\t\t\t\t\tc.isRectAreaLight ||\n\t\t\t\t\tc.isSpotLight ||\n\t\t\t\t\tc.isPointLight ||\n\t\t\t\t\tc.isDirectionalLight\n\t\t\t\t) {\n\n\t\t\t\t\tlights.push( c );\n\n\t\t\t\t\tif ( c.iesMap ) {\n\n\t\t\t\t\t\tiesSet.add( c.iesMap );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tconst iesTextures = Array.from( iesSet ).sort( ( a, b ) => {\n\n\t\tif ( a.uuid < b.uuid ) return 1;\n\t\tif ( a.uuid > b.uuid ) return - 1;\n\t\treturn 0;\n\n\t} );\n\n\treturn { lights, iesTextures };\n\n}\n\nexport class PathTracingSceneGenerator {\n\n\tget initialized() {\n\n\t\treturn Boolean( this.bvh );\n\n\t}\n\n\tconstructor( objects ) {\n\n\t\t// options\n\t\tthis.bvhOptions = {};\n\t\tthis.attributes = [ 'position', 'normal', 'tangent', 'color', 'uv', 'uv2' ];\n\t\tthis.generateBVH = true;\n\n\t\t// state\n\t\tthis.bvh = null;\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.staticGeometryGenerator = new StaticGeometryGenerator( objects );\n\t\tthis._bvhWorker = null;\n\t\tthis._pendingGenerate = null;\n\t\tthis._buildAsync = false;\n\t\tthis._materialUuids = null;\n\n\t}\n\n\tsetObjects( objects ) {\n\n\t\tthis.staticGeometryGenerator.setObjects( objects );\n\n\t}\n\n\tsetBVHWorker( bvhWorker ) {\n\n\t\tthis._bvhWorker = bvhWorker;\n\n\t}\n\n\tasync generateAsync( onProgress = null ) {\n\n\t\tif ( ! this._bvhWorker ) {\n\n\t\t\tthrow new Error( 'PathTracingSceneGenerator: \"setBVHWorker\" must be called before \"generateAsync\" can be called.' );\n\n\t\t}\n\n\t\tif ( this.bvh instanceof Promise ) {\n\n\t\t\t// if a bvh is already being generated we can wait for that to finish\n\t\t\t// and build another with the latest data while sharing the results.\n\t\t\tif ( ! this._pendingGenerate ) {\n\n\t\t\t\tthis._pendingGenerate = new Promise( async () => {\n\n\t\t\t\t\tawait this.bvh;\n\t\t\t\t\tthis._pendingGenerate = null;\n\n\t\t\t\t\t// TODO: support multiple callbacks queued?\n\t\t\t\t\treturn this.generateAsync( onProgress );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn this._pendingGenerate;\n\n\t\t} else {\n\n\t\t\tthis._buildAsync = true;\n\t\t\tconst result = this.generate( onProgress );\n\t\t\tthis._buildAsync = false;\n\n\t\t\tresult.bvh = this.bvh = await result.bvh;\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n\tgenerate( onProgress = null ) {\n\n\t\tconst { staticGeometryGenerator, geometry, attributes } = this;\n\t\tconst objects = staticGeometryGenerator.objects;\n\t\tstaticGeometryGenerator.attributes = attributes;\n\n\t\t// update the skeleton animations in case WebGLRenderer is not running\n\t\t// to update it.\n\t\tobjects.forEach( o => {\n\n\t\t\to.traverse( c => {\n\n\t\t\t\tif ( c.isSkinnedMesh && c.skeleton ) {\n\n\t\t\t\t\tc.skeleton.update();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t// generate the geometry\n\t\tconst result = staticGeometryGenerator.generate( geometry );\n\t\tconst materials = result.materials;\n\t\tlet needsMaterialIndexUpdate = result.changeType !== NO_CHANGE || this._materialUuids === null || this._materialUuids.length !== length;\n\t\tif ( ! needsMaterialIndexUpdate ) {\n\n\t\t\tfor ( let i = 0, length = materials.length; i < length; i ++ ) {\n\n\t\t\t\tconst material = materials[ i ];\n\t\t\t\tif ( material.uuid !== this._materialUuids[ i ] ) {\n\n\t\t\t\t\tneedsMaterialIndexUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst textures = getTextures( materials );\n\t\tconst { lights, iesTextures } = getLights( objects );\n\t\tif ( needsMaterialIndexUpdate ) {\n\n\t\t\tupdateMaterialIndexAttribute( geometry, materials, materials );\n\t\t\tthis._materialUuids = materials.map( material => material.uuid );\n\n\t\t}\n\n\t\t// only generate a new bvh if the objects used have changed\n\t\tif ( this.generateBVH ) {\n\n\t\t\tif ( this.bvh instanceof Promise ) {\n\n\t\t\t\tthrow new Error( 'PathTracingSceneGenerator: BVH is already building asynchronously.' );\n\n\t\t\t}\n\n\t\t\tif ( result.changeType === GEOMETRY_REBUILT ) {\n\n\t\t\t\tconst bvhOptions = {\n\t\t\t\t\tstrategy: SAH,\n\t\t\t\t\tmaxLeafTris: 1,\n\t\t\t\t\tindirect: true,\n\t\t\t\t\tonProgress,\n\t\t\t\t\t...this.bvhOptions,\n\t\t\t\t};\n\n\t\t\t\tif ( this._buildAsync ) {\n\n\t\t\t\t\tthis.bvh = this._bvhWorker.generate( geometry, bvhOptions );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.bvh = new MeshBVH( geometry, bvhOptions );\n\n\t\t\t\t}\n\n\t\t\t} else if ( result.changeType === GEOMETRY_ADJUSTED ) {\n\n\t\t\t\tthis.bvh.refit();\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\tbvhChanged: result.changeType !== NO_CHANGE,\n\t\t\tbvh: this.bvh,\n\t\t\tneedsMaterialIndexUpdate,\n\t\t\tlights,\n\t\t\tiesTextures,\n\t\t\tgeometry,\n\t\t\tmaterials,\n\t\t\ttextures,\n\t\t\tobjects,\n\t\t};\n\n\t}\n\n}\n\nexport class DynamicPathTracingSceneGenerator extends PathTracingSceneGenerator {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tconsole.warn( 'DynamicPathTracingSceneGenerator has been deprecated and renamed to \"PathTracingSceneGenerator\".' );\n\n\t}\n\n}\n\nexport class PathTracingSceneWorker extends PathTracingSceneGenerator {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tconsole.warn( 'PathTracingSceneWorker has been deprecated and renamed to \"PathTracingSceneGenerator\".' );\n\n\t}\n\n}\n","import { BufferAttribute, Box3, FrontSide } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG, SKIP_GENERATION } from './Constants.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { shapecast } from './cast/shapecast.js';\nimport { closestPointToPoint } from './cast/closestPointToPoint.js';\n\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit } from './cast/refit.generated.js';\nimport { raycast } from './cast/raycast.generated.js';\nimport { raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\n\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { bvhcast } from './cast/bvhcast.js';\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst tempBox = /* @__PURE__ */ new Box3();\nexport const DEFAULT_OPTIONS = {\n\tstrategy: CENTER,\n\tmaxDepth: 40,\n\tmaxLeafTris: 10,\n\tuseSharedArrayBuffer: false,\n\tsetBoundingBox: true,\n\tonProgress: null,\n\tindirect: false,\n\tverbose: true,\n};\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute ? indexAttribute.array.slice() : null,\n\t\t\t\tindirectBuffer: indirectBuffer ? indirectBuffer.slice() : null,\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute ? indexAttribute.array : null,\n\t\t\t\tindirectBuffer: indirectBuffer,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\tindirect: Boolean( data.indirectBuffer ),\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots, indirectBuffer } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\t\tbvh._indirectBuffer = indirectBuffer || null;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tget indirect() {\n\n\t\treturn ! ! this._indirectBuffer;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\t...DEFAULT_OPTIONS,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\t\tthis._roots = null;\n\t\tthis._indirectBuffer = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tbuildPackedTree( this, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst { _indirectBuffer } = this;\n\t\tthis.resolveTriangleIndex = options.indirect ? i => _indirectBuffer[ i ] : i => i;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\n\t\treturn refitFunc( this, nodeIndices );\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\traycastFunc( this, i, materialSide, ray, intersects );\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst result = raycastFirstFunc( this, i, materialSide, ray );\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tlet result = false;\n\t\tconst roots = this._roots;\n\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks ) {\n\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\t// wrap the intersectsRange function\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t// run shapecast\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst root = roots[ i ];\n\t\t\tresult = shapecast( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst triangle1 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr1 = this.geometry.index;\n\t\tconst positionAttr1 = this.geometry.attributes.position;\n\t\tconst assignTriangle1 = this.indirect ?\n\t\t\ti1 => {\n\n\n\t\t\t\tconst ti = this.resolveTriangleIndex( i1 );\n\t\t\t\tsetTriangle( triangle1, ti * 3, indexAttr1, positionAttr1 );\n\n\t\t\t} :\n\t\t\ti1 => {\n\n\t\t\t\tsetTriangle( triangle1, i1 * 3, indexAttr1, positionAttr1 );\n\n\t\t\t};\n\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr2 = otherBvh.geometry.index;\n\t\tconst positionAttr2 = otherBvh.geometry.attributes.position;\n\t\tconst assignTriangle2 = otherBvh.indirect ?\n\t\t\ti2 => {\n\n\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\tsetTriangle( triangle2, ti2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t} :\n\t\t\ti2 => {\n\n\t\t\t\tsetTriangle( triangle2, i2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t};\n\n\t\t// generate triangle callback if needed\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) => {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tassignTriangle2( i2 );\n\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tassignTriangle1( i1 );\n\n\t\t\t\t\t\ttriangle1.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle1, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvhcast( this, otherBvh, matrixToLocal, intersectsRanges );\n\n\t}\n\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n\t\treturn closestPointToGeometryFunc(\n\t\t\tthis,\n\t\t\totherGeometry,\n\t\t\tgeometryToBvh,\n\t\t\ttarget1,\n\t\t\ttarget2,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\treturn closestPointToPoint(\n\t\t\tthis,\n\t\t\tpoint,\n\t\t\ttarget,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n","// Split strategy constants\nexport const CENTER = 0;\nexport const AVERAGE = 1;\nexport const SAH = 2;\n\n// Traversal constants\nexport const NOT_INTERSECTED = 0;\nexport const INTERSECTED = 1;\nexport const CONTAINED = 2;\n\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a triangle intersection vs traversing\n// bounds.\nexport const TRIANGLE_INTERSECT_COST = 1.25;\nexport const TRAVERSAL_COST = 1;\n\n\n// Build constants\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\nexport const SKIP_GENERATION = Symbol( 'SKIP_GENERATION' );\n","import { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps, } from './geometryUtils.js';\nimport { getBounds, computeTriangleBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { MeshBVHNode } from '../MeshBVHNode.js';\nimport { BYTES_PER_NODE } from '../Constants.js';\n\nimport { partition } from './sortUtils.generated.js';\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\nimport { countNodes, populateBuffer } from './buildUtils.js';\n\nexport function generateIndirectBuffer( geometry, useSharedArrayBuffer ) {\n\n\tconst triCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\tconst useUint32 = triCount > 2 ** 16;\n\tconst byteCount = useUint32 ? 4 : 2;\n\n\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( triCount * byteCount ) : new ArrayBuffer( triCount * byteCount );\n\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\tindirectBuffer[ i ] = i;\n\n\t}\n\n\treturn indirectBuffer;\n\n}\n\nexport function buildTree( bvh, triangleBounds, offset, count, options ) {\n\n\t// epxand variables\n\tconst {\n\t\tmaxDepth,\n\t\tverbose,\n\t\tmaxLeafTris,\n\t\tstrategy,\n\t\tonProgress,\n\t\tindirect,\n\t} = options;\n\tconst indirectBuffer = bvh._indirectBuffer;\n\tconst geometry = bvh.geometry;\n\tconst indexArray = geometry.index ? geometry.index.array : null;\n\tconst partionFunc = indirect ? partition_indirect : partition;\n\n\t// generate intermediate variables\n\tconst totalTriangles = getTriCount( geometry );\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tlet reachedMaxDepth = false;\n\n\tconst root = new MeshBVHNode();\n\tgetBounds( triangleBounds, offset, count, root.boundingData, cacheCentroidBoundingData );\n\tsplitNode( root, offset, count, cacheCentroidBoundingData );\n\treturn root;\n\n\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\tconsole.warn( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partionFunc( indirectBuffer, indexArray, triangleBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new MeshBVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new MeshBVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nexport function buildPackedTree( bvh, options ) {\n\n\tconst geometry = bvh.geometry;\n\tif ( options.indirect ) {\n\n\t\tbvh._indirectBuffer = generateIndirectBuffer( geometry, options.useSharedArrayBuffer );\n\n\t\tif ( hasGroupGaps( geometry ) && ! options.verbose ) {\n\n\t\t\tconsole.warn(\n\t\t\t\t'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. ' +\n\t\t\t\t'BVH may incorrectly report intersections on unrendered portions of the geometry.'\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\tif ( ! bvh._indirectBuffer ) {\n\n\t\tensureIndex( geometry, options );\n\n\t}\n\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\n\tconst triangleBounds = computeTriangleBounds( geometry );\n\tconst geometryRanges = options.indirect ? getFullGeometryRange( geometry ) : getRootIndexRanges( geometry );\n\tbvh._roots = geometryRanges.map( range => {\n\n\t\tconst root = buildTree( bvh, triangleBounds, range.offset, range.count, options );\n\t\tconst nodeCount = countNodes( root );\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tpopulateBuffer( 0, root, buffer );\n\t\treturn buffer;\n\n\t} );\n\n}\n","import { BufferAttribute } from 'three';\n\nexport function getVertexCount( geo ) {\n\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n}\n\nexport function getTriCount( geo ) {\n\n\treturn getVertexCount( geo ) / 3;\n\n}\n\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\tif ( vertexCount > 65535 ) {\n\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t} else {\n\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t}\n\n}\n\n// ensures that an index is present on the geometry\nexport function ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nexport function getFullGeometryRange( geo ) {\n\n\tconst triCount = getTriCount( geo );\n\tconst drawRange = geo.drawRange;\n\tconst start = drawRange.start / 3;\n\tconst end = ( drawRange.start + drawRange.count ) / 3;\n\n\tconst offset = Math.max( 0, start );\n\tconst count = Math.min( triCount, end ) - offset;\n\treturn [ {\n\t\toffset: Math.floor( offset ),\n\t\tcount: Math.floor( count ),\n\t} ];\n\n}\n\nexport function getRootIndexRanges( geo ) {\n\n\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\treturn getFullGeometryRange( geo );\n\n\t}\n\n\tconst ranges = [];\n\tconst rangeBoundaries = new Set();\n\n\tconst drawRange = geo.drawRange;\n\tconst drawRangeStart = drawRange.start / 3;\n\tconst drawRangeEnd = ( drawRange.start + drawRange.count ) / 3;\n\tfor ( const group of geo.groups ) {\n\n\t\tconst groupStart = group.start / 3;\n\t\tconst groupEnd = ( group.start + group.count ) / 3;\n\t\trangeBoundaries.add( Math.max( drawRangeStart, groupStart ) );\n\t\trangeBoundaries.add( Math.min( drawRangeEnd, groupEnd ) );\n\n\t}\n\n\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\tconst start = sortedBoundaries[ i ];\n\t\tconst end = sortedBoundaries[ i + 1 ];\n\n\t\tranges.push( {\n\t\t\toffset: Math.floor( start ),\n\t\t\tcount: Math.floor( end - start ),\n\t\t} );\n\n\t}\n\n\treturn ranges;\n\n}\n\nexport function hasGroupGaps( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\treturn false;\n\n\t}\n\n\tconst vertexCount = getTriCount( geometry );\n\tconst groups = getRootIndexRanges( geometry )\n\t\t.sort( ( a, b ) => a.offset - b.offset );\n\n\tconst finalGroup = groups[ groups.length - 1 ];\n\tfinalGroup.count = Math.min( vertexCount - finalGroup.offset, finalGroup.count );\n\n\tlet total = 0;\n\tgroups.forEach( ( { count } ) => total += count );\n\treturn vertexCount !== total;\n\n}\n","import { FLOAT32_EPSILON } from '../Constants.js';\nimport { getTriCount } from './geometryUtils.js';\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in \"target\".\n// A bounding box is computed for the centroids of the triangles, as well, and placed in \"centroidTarget\".\n// These are computed together to avoid redundant accesses to bounds array.\nexport function getBounds( triangleBounds, offset, count, target, centroidTarget ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tconst hx = triangleBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tconst hy = triangleBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tconst hz = triangleBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nexport function computeTriangleBounds( geo, target = null, offset = null, count = null ) {\n\n\tconst posAttr = geo.attributes.position;\n\tconst index = geo.index ? geo.index.array : null;\n\tconst triCount = getTriCount( geo );\n\tconst normalized = posAttr.normalized;\n\tlet triangleBounds;\n\tif ( target === null ) {\n\n\t\ttriangleBounds = new Float32Array( triCount * 6 * 4 );\n\t\toffset = 0;\n\t\tcount = triCount;\n\n\t} else {\n\n\t\ttriangleBounds = target;\n\t\toffset = offset || 0;\n\t\tcount = count || triCount;\n\n\t}\n\n\t// used for non-normalized positions\n\tconst posArr = posAttr.array;\n\n\t// support for an interleaved position buffer\n\tconst bufferOffset = posAttr.offset || 0;\n\tlet stride = 3;\n\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\tstride = posAttr.data.stride;\n\n\t}\n\n\t// used for normalized positions\n\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\tfor ( let tri = offset; tri < offset + count; tri ++ ) {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst tri6 = tri * 6;\n\n\t\tlet ai = tri3 + 0;\n\t\tlet bi = tri3 + 1;\n\t\tlet ci = tri3 + 2;\n\n\t\tif ( index ) {\n\n\t\t\tai = index[ ai ];\n\t\t\tbi = index[ bi ];\n\t\t\tci = index[ ci ];\n\n\t\t}\n\n\t\t// we add the stride and offset here since we access the array directly\n\t\t// below for the sake of performance\n\t\tif ( ! normalized ) {\n\n\t\t\tai = ai * stride + bufferOffset;\n\t\t\tbi = bi * stride + bufferOffset;\n\t\t\tci = ci * stride + bufferOffset;\n\n\t\t}\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tlet a, b, c;\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t} else {\n\n\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t}\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t// worked with.\n\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\tconst el2 = el * 2;\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t}\n\n\t}\n\n\treturn triangleBounds;\n\n}\n","import { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST } from '../Constants.js';\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = new Float32Array( 6 );\n\nexport function getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst cStart = offset * 6;\n\t\tconst cEnd = ( offset + count ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t// the triangle positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n","export function arrayToBox( nodeIndex32, array, target ) {\n\n\ttarget.min.x = array[ nodeIndex32 ];\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\treturn target;\n\n}\n\nexport function makeEmptyBounds( target ) {\n\n\ttarget[ 0 ] = target[ 1 ] = target[ 2 ] = Infinity;\n\ttarget[ 3 ] = target[ 4 ] = target[ 5 ] = - Infinity;\n\n}\n\nexport function getLongestEdgeIndex( bounds ) {\n\n\tlet splitDimIdx = - 1;\n\tlet splitDist = - Infinity;\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\tif ( dist > splitDist ) {\n\n\t\t\tsplitDist = dist;\n\t\t\tsplitDimIdx = i;\n\n\t\t}\n\n\t}\n\n\treturn splitDimIdx;\n\n}\n\n// copies bounds a into bounds b\nexport function copyBounds( source, target ) {\n\n\ttarget.set( source );\n\n}\n\n// sets bounds target to the union of bounds a and b\nexport function unionBounds( a, b, target ) {\n\n\tlet aVal, bVal;\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst d3 = d + 3;\n\n\t\t// set the minimum values\n\t\taVal = a[ d ];\n\t\tbVal = b[ d ];\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t// set the max values\n\t\taVal = a[ d3 ];\n\t\tbVal = b[ d3 ];\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t}\n\n}\n\n// expands the given bounds by the provided triangle bounds\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\tconst tMin = tCenter - tHalf;\n\t\tconst tMax = tCenter + tHalf;\n\n\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\tbounds[ d ] = tMin;\n\n\t\t}\n\n\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t}\n\n\t}\n\n}\n\n// compute bounds surface area\nexport function computeSurfaceArea( bounds ) {\n\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n}\n","export class MeshBVHNode {\n\n\tconstructor() {\n\n\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t\tthis.boundingData = new Float32Array( 6 );\n\n\t}\n\n}\n","/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t}\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition };\n","/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition_indirect( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\t\t\tlet t = indirectBuffer[ left ];\n\t\t\tindirectBuffer[ left ] = indirectBuffer[ right ];\n\t\t\tindirectBuffer[ right ] = t;\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition_indirect };\n","import { BYTES_PER_NODE, IS_LEAFNODE_FLAG } from '../Constants.js';\nimport { IS_LEAF } from '../utils/nodeBufferUtils.js';\n\nlet float32Array, uint32Array, uint16Array, uint8Array;\nconst MAX_POINTER = Math.pow( 2, 32 );\n\nexport function countNodes( node ) {\n\n\tif ( 'count' in node ) {\n\n\t\treturn 1;\n\n\t} else {\n\n\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t}\n\n}\n\nexport function populateBuffer( byteOffset, node, buffer ) {\n\n\tfloat32Array = new Float32Array( buffer );\n\tuint32Array = new Uint32Array( buffer );\n\tuint16Array = new Uint16Array( buffer );\n\tuint8Array = new Uint8Array( buffer );\n\n\treturn _populateBuffer( byteOffset, node );\n\n}\n\n// pack structure\n// boundingData  \t\t\t\t: 6 float32\n// right / offset \t\t\t\t: 1 uint32\n// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\nfunction _populateBuffer( byteOffset, node ) {\n\n\tconst stride4Offset = byteOffset / 4;\n\tconst stride2Offset = byteOffset / 2;\n\tconst isLeaf = 'count' in node;\n\tconst boundingData = node.boundingData;\n\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t}\n\n\tif ( isLeaf ) {\n\n\t\tif ( node.buffer ) {\n\n\t\t\tconst buffer = node.buffer;\n\t\t\tuint8Array.set( new Uint8Array( buffer ), byteOffset );\n\n\t\t\tfor ( let offset = byteOffset, l = byteOffset + buffer.byteLength; offset < l; offset += BYTES_PER_NODE ) {\n\n\t\t\t\tconst offset2 = offset / 2;\n\t\t\t\tif ( ! IS_LEAF( offset2, uint16Array ) ) {\n\n\t\t\t\t\tuint32Array[ ( offset / 4 ) + 6 ] += stride4Offset;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn byteOffset + buffer.byteLength;\n\n\t\t} else {\n\n\t\t\tconst offset = node.offset;\n\t\t\tconst count = node.count;\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = node.left;\n\t\tconst right = node.right;\n\t\tconst splitAxis = node.splitAxis;\n\n\t\tlet nextUnusedPointer;\n\t\tnextUnusedPointer = _populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\tif ( ( nextUnusedPointer / 4 ) > MAX_POINTER ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t}\n\n\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\tnextUnusedPointer = _populateBuffer( nextUnusedPointer, right );\n\n\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\treturn nextUnusedPointer;\n\n\t}\n\n}\n","export function IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n}\n\nexport function OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function COUNT( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 14 ];\n\n}\n\nexport function LEFT_NODE( n32 ) {\n\n\treturn n32 + 8;\n\n}\n\nexport function RIGHT_NODE( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nexport function BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n","import { Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox {\n\n\tconstructor( min, max, matrix ) {\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.min = new Vector3();\n\t\tthis.max = new Vector3();\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.needsUpdate = false;\n\n\t\tif ( min ) this.min.copy( min );\n\t\tif ( max ) this.max.copy( max );\n\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\t\tthis.matrix.copy( matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.min.copy( other.min );\n\t\tthis.max.copy( other.max );\n\t\tthis.matrix.copy( other.matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\tthis.needsUpdate = false;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\t// TODO: should this be doing SAT against the AABB?\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = new ExtendedTriangle();\n\tconst pointsArr = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\n\t// early out if we find a value below threshold\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { Vector3 } from 'three';\n\nexport class SeparatingAxisBounds {\n\n\tconstructor() {\n\n\t\tthis.min = Infinity;\n\t\tthis.max = - Infinity;\n\n\t}\n\n\tsetFromPointsField( points, field ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = p[ field ];\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tsetFromPoints( axis, points ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = axis.dot( p );\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tisSeparated( other ) {\n\n\t\treturn this.min > other.max || other.min > this.max;\n\n\t}\n\n}\n\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\tconst p = new Vector3();\n\treturn function setFromBox( axis, box ) {\n\n\t\tconst boxMin = box.min;\n\t\tconst boxMax = box.max;\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t};\n\n} )();\n\nexport const areIntersecting = ( function () {\n\n\tconst cacheSatBounds = new SeparatingAxisBounds();\n\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\tconst points1 = shape1.points;\n\t\tconst satAxes1 = shape1.satAxes;\n\t\tconst satBounds1 = shape1.satBounds;\n\n\t\tconst points2 = shape2.points;\n\t\tconst satAxes2 = shape2.satAxes;\n\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t// check axes of the first shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds1[ i ];\n\t\t\tconst sa = satAxes1[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check axes of the second shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds2[ i ];\n\t\t\tconst sa = satAxes2[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t};\n\n} )();\n","import { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\n\nconst ZERO_EPSILON = 1e-15;\nfunction isNearZero( value ) {\n\n\treturn Math.abs( value ) < ZERO_EPSILON;\n\n}\n\nexport class ExtendedTriangle extends Triangle {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isExtendedTriangle = true;\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.points = [ this.a, this.b, this.c ];\n\t\tthis.sphere = new Sphere();\n\t\tthis.plane = new Plane();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst a = this.a;\n\t\tconst b = this.b;\n\t\tconst c = this.c;\n\t\tconst points = this.points;\n\n\t\tconst satAxes = this.satAxes;\n\t\tconst satBounds = this.satBounds;\n\n\t\tconst axis0 = satAxes[ 0 ];\n\t\tconst sab0 = satBounds[ 0 ];\n\t\tthis.getNormal( axis0 );\n\t\tsab0.setFromPoints( axis0, points );\n\n\t\tconst axis1 = satAxes[ 1 ];\n\t\tconst sab1 = satBounds[ 1 ];\n\t\taxis1.subVectors( a, b );\n\t\tsab1.setFromPoints( axis1, points );\n\n\t\tconst axis2 = satAxes[ 2 ];\n\t\tconst sab2 = satBounds[ 2 ];\n\t\taxis2.subVectors( b, c );\n\t\tsab2.setFromPoints( axis2, points );\n\n\t\tconst axis3 = satAxes[ 3 ];\n\t\tconst sab3 = satBounds[ 3 ];\n\t\taxis3.subVectors( c, a );\n\t\tsab3.setFromPoints( axis3, points );\n\n\t\tthis.sphere.setFromPoints( this.points );\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\t\tthis.needsUpdate = false;\n\n\t}\n\n}\n\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\tconst edge = new Line3();\n\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\tconst { start, end } = segment;\n\t\tconst points = this.points;\n\t\tlet distSq;\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check the triangle edges\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\tedge.start.copy( points[ i ] );\n\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check end points\n\t\tthis.closestPointToPoint( start, point1 );\n\t\tdistSq = start.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t}\n\n\t\tthis.closestPointToPoint( end, point1 );\n\t\tdistSq = end.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri2 = new ExtendedTriangle();\n\tconst arr1 = new Array( 3 );\n\tconst arr2 = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\tconst dir = new Vector3();\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst tempDir = new Vector3();\n\tconst edge = new Line3();\n\tconst edge1 = new Line3();\n\tconst edge2 = new Line3();\n\tconst tempPoint = new Vector3();\n\n\tfunction triIntersectPlane( tri, plane, targetEdge ) {\n\n\t\t// find the edge that intersects the other triangle plane\n\t\tconst points = tri.points;\n\t\tlet count = 0;\n\t\tlet startPointIntersection = - 1;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst { start, end } = edge;\n\t\t\tstart.copy( points[ i ] );\n\t\t\tend.copy( points[ ( i + 1 ) % 3 ] );\n\t\t\tedge.delta( dir );\n\n\t\t\tconst startIntersects = isNearZero( plane.distanceToPoint( start ) );\n\t\t\tif ( isNearZero( plane.normal.dot( dir ) ) && startIntersects ) {\n\n\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\ttargetEdge.copy( edge );\n\t\t\t\tcount = 2;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\tconst doesIntersect = plane.intersectLine( edge, tempPoint );\n\t\t\tif ( ! doesIntersect && startIntersects ) {\n\n\t\t\t\ttempPoint.copy( start );\n\n\t\t\t}\n\n\t\t\t// ignore the end point\n\t\t\tif ( ( doesIntersect || startIntersects ) && ! isNearZero( tempPoint.distanceTo( end ) ) ) {\n\n\t\t\t\tif ( count <= 1 ) {\n\n\t\t\t\t\t// assign to the start or end point and save which index was snapped to\n\t\t\t\t\t// the start point if necessary\n\t\t\t\t\tconst point = count === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\tif ( startIntersects ) {\n\n\t\t\t\t\t\tstartPointIntersection = count;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( count >= 2 ) {\n\n\t\t\t\t\t// if we're here that means that there must have been one point that had\n\t\t\t\t\t// snapped to the start point so replace it here\n\t\t\t\t\tconst point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\tcount = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tcount ++;\n\t\t\t\tif ( count === 2 && startPointIntersection === - 1 ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\n\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\tsaTri2.copy( other );\n\t\t\tsaTri2.update();\n\t\t\tother = saTri2;\n\n\t\t} else if ( other.needsUpdate ) {\n\n\t\t\tother.update();\n\n\t\t}\n\n\t\tconst plane1 = this.plane;\n\t\tconst plane2 = other.plane;\n\n\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\n\n\t\t\t// perform separating axis intersection test only for coplanar triangles\n\t\t\tconst satBounds1 = this.satBounds;\n\t\t\tconst satAxes1 = this.satAxes;\n\t\t\tarr2[ 0 ] = other.a;\n\t\t\tarr2[ 1 ] = other.b;\n\t\t\tarr2[ 2 ] = other.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\tconst satBounds2 = other.satBounds;\n\t\t\tconst satAxes2 = other.satAxes;\n\t\t\tarr1[ 0 ] = this.a;\n\t\t\tarr1[ 1 ] = this.b;\n\t\t\tarr1[ 2 ] = this.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check crossed axes\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sa1 = satAxes1[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( target ) {\n\n\t\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\t\tif ( ! suppressLog ) {\n\n\t\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t\t}\n\n\t\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\t// find the edge that intersects the other triangle plane\n\t\t\tconst count1 = triIntersectPlane( this, plane2, edge1 );\n\t\t\tif ( count1 === 1 && other.containsPoint( edge1.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.end );\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count1 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find the other triangles edge that intersects this plane\n\t\t\tconst count2 = triIntersectPlane( other, plane1, edge2 );\n\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge2.end );\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count2 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find swap the second edge so both lines are running the same direction\n\t\t\tedge1.delta( dir1 );\n\t\t\tedge2.delta( dir2 );\n\n\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\n\n\t\t\t\tlet tmp = edge2.start;\n\t\t\t\tedge2.start = edge2.end;\n\t\t\t\tedge2.end = tmp;\n\n\t\t\t}\n\n\t\t\t// check if the edges are overlapping\n\t\t\tconst s1 = edge1.start.dot( dir1 );\n\t\t\tconst e1 = edge1.end.dot( dir1 );\n\t\t\tconst s2 = edge2.start.dot( dir1 );\n\t\t\tconst e2 = edge2.end.dot( dir1 );\n\t\t\tconst separated1 = e1 < s2;\n\t\t\tconst separated2 = s1 < e2;\n\n\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// assign the target output\n\t\t\tif ( target ) {\n\n\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\n\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t\t}\n\n\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\n\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\n\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\tconst point = new Vector3();\n\tconst point2 = new Vector3();\n\tconst cornerFields = [ 'a', 'b', 'c' ];\n\tconst line1 = new Line3();\n\tconst line2 = new Line3();\n\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check all point distances\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tlet dist;\n\t\t\tconst field = cornerFields[ i ];\n\t\t\tconst otherVec = other[ field ];\n\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t}\n\n\n\t\t\tconst thisVec = this[ field ];\n\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst f11 = cornerFields[ i ];\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { Vector3, Vector2, Plane, Line3 } from 'three';\n\nexport const closestPointLineToLine = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst v02 = new Vector3();\n\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\tconst v0 = l1.start;\n\t\tconst v10 = dir1;\n\t\tconst v2 = l2.start;\n\t\tconst v32 = dir2;\n\n\t\tv02.subVectors( v0, v2 );\n\t\tdir1.subVectors( l1.end, l1.start );\n\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t// float d0232 = v02.Dot(v32);\n\t\tconst d0232 = v02.dot( v32 );\n\n\t\t// float d3210 = v32.Dot(v10);\n\t\tconst d3210 = v32.dot( v10 );\n\n\t\t// float d3232 = v32.Dot(v32);\n\t\tconst d3232 = v32.dot( v32 );\n\n\t\t// float d0210 = v02.Dot(v10);\n\t\tconst d0210 = v02.dot( v10 );\n\n\t\t// float d1010 = v10.Dot(v10);\n\t\tconst d1010 = v10.dot( v10 );\n\n\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\tlet d, d2;\n\t\tif ( denom !== 0 ) {\n\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t} else {\n\n\t\t\td = 0;\n\n\t\t}\n\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\tresult.x = d;\n\t\tresult.y = d2;\n\n\t};\n\n} )();\n\nexport const closestPointsSegmentToSegment = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\tconst paramResult = new Vector2();\n\tconst temp1 = new Vector3();\n\tconst temp2 = new Vector3();\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\tlet d = paramResult.x;\n\t\tlet d2 = paramResult.y;\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\tl1.at( d, target1 );\n\t\t\tl2.at( d2, target2 );\n\n\t\t\treturn;\n\n\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t// Only d2 is out of bounds.\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t} else {\n\n\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t}\n\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\treturn;\n\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t// Only d is out of bounds.\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t} else {\n\n\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t}\n\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// Both u and u2 are out of bounds.\n\t\t\tlet p;\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tp = l1.start;\n\n\t\t\t} else {\n\n\t\t\t\tp = l1.end;\n\n\t\t\t}\n\n\t\t\tlet p2;\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tp2 = l2.start;\n\n\t\t\t} else {\n\n\t\t\t\tp2 = l2.end;\n\n\t\t\t}\n\n\t\t\tconst closestPoint = temp1;\n\t\t\tconst closestPoint2 = temp2;\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\ttarget2.copy( p2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\ttarget1.copy( p );\n\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n} )();\n\n\nexport const sphereIntersectTriangle = ( function () {\n\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\tconst closestPointTemp = new Vector3();\n\tconst projectedPointTemp = new Vector3();\n\tconst planeTemp = new Plane();\n\tconst lineTemp = new Line3();\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\tconst { radius, center } = sphere;\n\t\tconst { a, b, c } = triangle;\n\n\t\t// phase 1\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = b;\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = b;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t// phase 2\n\t\tconst plane = triangle.getPlane( planeTemp );\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\tif ( dp <= radius ) {\n\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\tif ( cp ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n} )();\n","import { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from './PrimitivePool.js';\n\nclass ExtendedTrianglePoolBase extends PrimitivePool {\n\n\tconstructor() {\n\n\t\tsuper( () => new ExtendedTriangle() );\n\n\t}\n\n}\n\nexport const ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();\n","export class PrimitivePool {\n\n\tconstructor( getNewPrimitive ) {\n\n\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\tthis._primitives = [];\n\n\t}\n\n\tgetPrimitive() {\n\n\t\tconst primitives = this._primitives;\n\t\tif ( primitives.length === 0 ) {\n\n\t\t\treturn this._getNewPrimitive();\n\n\t\t} else {\n\n\t\t\treturn primitives.pop();\n\n\t\t}\n\n\t}\n\n\treleasePrimitive( primitive ) {\n\n\t\tthis._primitives.push( primitive );\n\n\t}\n\n}\n","import { Box3 } from 'three';\nimport { CONTAINED } from '../Constants.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\nlet _box1, _box2;\nconst boxStack = [];\nconst boxPool = /* @__PURE__ */ new PrimitivePool( () => new Box3() );\n\nexport function shapecast( bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset ) {\n\n\t// setup\n\t_box1 = boxPool.getPrimitive();\n\t_box2 = boxPool.getPrimitive();\n\tboxStack.push( _box1, _box2 );\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\n\tconst result = shapecastTraverse( 0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t// cleanup\n\tBufferStack.clearBuffer();\n\tboxPool.releasePrimitive( _box1 );\n\tboxPool.releasePrimitive( _box2 );\n\tboxStack.pop();\n\tboxStack.pop();\n\n\tconst length = boxStack.length;\n\tif ( length > 0 ) {\n\n\t\t_box2 = boxStack[ length - 1 ];\n\t\t_box1 = boxStack[ length - 2 ];\n\n\t}\n\n\treturn result;\n\n}\n\nfunction shapecastTraverse(\n\tnodeIndex32,\n\tgeometry,\n\tintersectsBoundsFunc,\n\tintersectsRangeFunc,\n\tnodeScoreFunc = null,\n\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\tdepth = 0\n) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tlet c1 = left;\n\t\tlet c2 = right;\n\n\t\tlet score1, score2;\n\t\tlet box1, box2;\n\t\tif ( nodeScoreFunc ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tbox2 = _box2;\n\n\t\t\t// bounding data is not offset\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\tc1 = right;\n\t\t\t\tc2 = left;\n\n\t\t\t\tconst temp = score1;\n\t\t\t\tscore1 = score2;\n\t\t\t\tscore2 = temp;\n\n\t\t\t\tbox1 = box2;\n\t\t\t\t// box2 is always set before use below\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Check box 1 intersection\n\t\tif ( ! box1 ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t}\n\n\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\tlet c1StopTraversal;\n\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t} else {\n\n\t\t\tc1StopTraversal =\n\t\t\t\tc1Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc1,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c1StopTraversal ) return true;\n\n\t\t// Check box 2 intersection\n\t\t// cached box2 will have been overwritten by previous traversal\n\t\tbox2 = _box2;\n\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\tlet c2StopTraversal;\n\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t} else {\n\n\t\t\tc2StopTraversal =\n\t\t\t\tc2Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc2,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c2StopTraversal ) return true;\n\n\t\treturn false;\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t}\n\n}\n","class _BufferStack {\n\n\tconstructor() {\n\n\t\tthis.float32Array = null;\n\t\tthis.uint16Array = null;\n\t\tthis.uint32Array = null;\n\n\t\tconst stack = [];\n\t\tlet prevBuffer = null;\n\t\tthis.setBuffer = buffer => {\n\n\t\t\tif ( prevBuffer ) {\n\n\t\t\t\tstack.push( prevBuffer );\n\n\t\t\t}\n\n\t\t\tprevBuffer = buffer;\n\t\t\tthis.float32Array = new Float32Array( buffer );\n\t\t\tthis.uint16Array = new Uint16Array( buffer );\n\t\t\tthis.uint32Array = new Uint32Array( buffer );\n\n\t\t};\n\n\t\tthis.clearBuffer = () => {\n\n\t\t\tprevBuffer = null;\n\t\t\tthis.float32Array = null;\n\t\t\tthis.uint16Array = null;\n\t\t\tthis.uint32Array = null;\n\n\t\t\tif ( stack.length !== 0 ) {\n\n\t\t\t\tthis.setBuffer( stack.pop() );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n\nexport const BufferStack = new _BufferStack();\n","import { Vector3 } from 'three';\n\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\n\nexport function closestPointToPoint(\n\tbvh,\n\tpoint,\n\ttarget = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\t// early out if under minThreshold\n\t// skip checking if over maxThreshold\n\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t// returns Infinity if no value found\n\tconst minThresholdSq = minThreshold * minThreshold;\n\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\tlet closestDistanceSq = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tbvh.shapecast(\n\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t},\n\n\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tif ( closestDistanceSq === Infinity ) return null;\n\n\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\tif ( ! target.point ) target.point = temp1.clone();\n\telse target.point.copy( temp1 );\n\ttarget.distance = closestDistance,\n\ttarget.faceIndex = closestDistanceTriIndex;\n\n\treturn target;\n\n}\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris( bvh, side, ray, offset, count, intersections ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\n\t\tintersectTri( geometry, side, ray, i, intersections );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri( bvh, side, ray, offset, count ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\n\t\tintersection = intersectTri( geometry, side, ray, i );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\n\t\ttri = i;\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri, intersectTris, iterateOverTriangles };\n","import { Vector3, Vector2, Triangle, DoubleSide, BackSide } from 'three';\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst _vA = /* @__PURE__ */ new Vector3();\nconst _vB = /* @__PURE__ */ new Vector3();\nconst _vC = /* @__PURE__ */ new Vector3();\n\nconst _uvA = /* @__PURE__ */ new Vector2();\nconst _uvB = /* @__PURE__ */ new Vector2();\nconst _uvC = /* @__PURE__ */ new Vector2();\n\nconst _normalA = /* @__PURE__ */ new Vector3();\nconst _normalB = /* @__PURE__ */ new Vector3();\nconst _normalC = /* @__PURE__ */ new Vector3();\n\nconst _intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection( ray, pA, pB, pC, point, side ) {\n\n\tlet intersect;\n\tif ( side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\tconst distance = ray.origin.distanceTo( point );\n\n\treturn {\n\n\t\tdistance: distance,\n\t\tpoint: point.clone(),\n\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side ) {\n\n\t_vA.fromBufferAttribute( position, a );\n\t_vB.fromBufferAttribute( position, b );\n\t_vC.fromBufferAttribute( position, c );\n\n\tconst intersection = checkIntersection( ray, _vA, _vB, _vC, _intersectionPoint, side );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv1, a );\n\t\t\t_uvB.fromBufferAttribute( uv1, b );\n\t\t\t_uvC.fromBufferAttribute( uv1, c );\n\n\t\t\tintersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\tintersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3() );\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.faceIndex = a;\n\n\t}\n\n\treturn intersection;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction intersectTri( geo, side, ray, tri, intersections ) {\n\n\tconst triOffset = tri * 3;\n\tlet a = triOffset + 0;\n\tlet b = triOffset + 1;\n\tlet c = triOffset + 2;\n\n\tconst index = geo.index;\n\tif ( geo.index ) {\n\n\t\ta = index.getX( a );\n\t\tb = index.getX( b );\n\t\tc = index.getX( c );\n\n\t}\n\n\tconst { position, normal, uv, uv1 } = geo.attributes;\n\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side );\n\n\tif ( intersection ) {\n\n\t\tintersection.faceIndex = tri;\n\t\tif ( intersections ) intersections.push( intersection );\n\t\treturn intersection;\n\n\t}\n\n\treturn null;\n\n}\n\nexport { intersectTri };\n","\nimport { Vector2, Vector3, Triangle } from 'three';\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nexport function setTriangle( tri, i, index, pos ) {\n\n\tconst ta = tri.a;\n\tconst tb = tri.b;\n\tconst tc = tri.c;\n\n\tlet i0 = i;\n\tlet i1 = i + 1;\n\tlet i2 = i + 2;\n\tif ( index ) {\n\n\t\ti0 = index.getX( i0 );\n\t\ti1 = index.getX( i1 );\n\t\ti2 = index.getX( i2 );\n\n\t}\n\n\tta.x = pos.getX( i0 );\n\tta.y = pos.getY( i0 );\n\tta.z = pos.getZ( i0 );\n\n\ttb.x = pos.getX( i1 );\n\ttb.y = pos.getY( i1 );\n\ttb.z = pos.getZ( i1 );\n\n\ttc.x = pos.getX( i2 );\n\ttc.y = pos.getY( i2 );\n\ttc.z = pos.getZ( i2 );\n\n}\n\nconst tempV1 = /* @__PURE__ */ new Vector3();\nconst tempV2 = /* @__PURE__ */ new Vector3();\nconst tempV3 = /* @__PURE__ */ new Vector3();\nconst tempUV1 = /* @__PURE__ */ new Vector2();\nconst tempUV2 = /* @__PURE__ */ new Vector2();\nconst tempUV3 = /* @__PURE__ */ new Vector2();\n\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\tconst indices = geometry.getIndex().array;\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst uvs = geometry.getAttribute( 'uv' );\n\n\tconst a = indices[ triangleIndex * 3 ];\n\tconst b = indices[ triangleIndex * 3 + 1 ];\n\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\ttempV1.fromBufferAttribute( positions, a );\n\ttempV2.fromBufferAttribute( positions, b );\n\ttempV3.fromBufferAttribute( positions, c );\n\n\t// find the associated material index\n\tlet materialIndex = 0;\n\tconst groups = geometry.groups;\n\tconst firstVertexIndex = triangleIndex * 3;\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst { start, count } = group;\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\tmaterialIndex = group.materialIndex;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// extract uvs\n\tlet uv = null;\n\tif ( uvs ) {\n\n\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\tif ( target && target.uv ) uv = target.uv;\n\t\telse uv = new Vector2();\n\n\t\tTriangle.getInterpolation( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t}\n\n\t// adjust the provided target or create a new one\n\tif ( target ) {\n\n\t\tif ( ! target.face ) target.face = { };\n\t\ttarget.face.a = a;\n\t\ttarget.face.b = b;\n\t\ttarget.face.c = c;\n\t\ttarget.face.materialIndex = materialIndex;\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\tif ( uv ) target.uv = uv;\n\n\t\treturn target;\n\n\t} else {\n\n\t\treturn {\n\t\t\tface: {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\n\t\t\t},\n\t\t\tuv: uv\n\t\t};\n\n\t}\n\n}\n","import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\n\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\tlet index = indexArr[ i ];\n\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit };\n","import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectTris } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast( bvh, root, side, ray, intersects ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\tintersectTris( bvh, side, ray, offset, count, intersects );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast };\n","/**\n * This function performs intersection tests similar to Ray.intersectBox in three.js,\n * with the difference that the box values are read from an array to improve performance.\n */\nexport function intersectRay( nodeIndex32, array, ray ) {\n\n\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\tconst invdirx = 1 / ray.direction.x,\n\t\tinvdiry = 1 / ray.direction.y,\n\t\tinvdirz = 1 / ray.direction.z;\n\n\tconst ox = ray.origin.x;\n\tconst oy = ray.origin.y;\n\tconst oz = ray.origin.z;\n\n\tlet minx = array[ nodeIndex32 ];\n\tlet maxx = array[ nodeIndex32 + 3 ];\n\n\tlet miny = array[ nodeIndex32 + 1 ];\n\tlet maxy = array[ nodeIndex32 + 3 + 1 ];\n\n\tlet minz = array[ nodeIndex32 + 2 ];\n\tlet maxz = array[ nodeIndex32 + 3 + 2 ];\n\n\tif ( invdirx >= 0 ) {\n\n\t\ttmin = ( minx - ox ) * invdirx;\n\t\ttmax = ( maxx - ox ) * invdirx;\n\n\t} else {\n\n\t\ttmin = ( maxx - ox ) * invdirx;\n\t\ttmax = ( minx - ox ) * invdirx;\n\n\t}\n\n\tif ( invdiry >= 0 ) {\n\n\t\ttymin = ( miny - oy ) * invdiry;\n\t\ttymax = ( maxy - oy ) * invdiry;\n\n\t} else {\n\n\t\ttymin = ( maxy - oy ) * invdiry;\n\t\ttymax = ( miny - oy ) * invdiry;\n\n\t}\n\n\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return false;\n\n\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\tif ( invdirz >= 0 ) {\n\n\t\ttzmin = ( minz - oz ) * invdirz;\n\t\ttzmax = ( maxz - oz ) * invdirz;\n\n\t} else {\n\n\t\ttzmin = ( maxz - oz ) * invdirz;\n\t\ttzmax = ( minz - oz ) * invdirz;\n\n\t}\n\n\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false;\n\n\t// if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin; // Uncomment this line if add the distance check\n\n\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t//return point closest to the ray (positive side)\n\n\tif ( tmax < 0 ) return false;\n\n\treturn true;\n\n}\n","import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { intersectClosestTri } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst( bvh, root, side, ray ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\treturn intersectClosestTri( bvh, side, ray, offset, count );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\n\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\n\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry };\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris_indirect( bvh, side, ray, offset, count, intersections ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet vi = _indirectBuffer ? _indirectBuffer[ i ] : i;\n\t\tintersectTri( geometry, side, ray, vi, intersections );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri_indirect( bvh, side, ray, offset, count ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\t\tintersection = intersectTri( geometry, side, ray, _indirectBuffer ? _indirectBuffer[ i ] : i );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles_indirect(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\t\ttri = bvh.resolveTriangleIndex( i );\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri_indirect, intersectTris_indirect, iterateOverTriangles_indirect };\n","import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit_indirect( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\tconst t = 3 * bvh.resolveTriangleIndex( i );\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tlet index = t + j;\n\t\t\t\t\tindex = indexArr ? indexArr[ index ] : index;\n\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit_indirect };\n","import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectTris_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast_indirect( bvh, root, side, ray, intersects ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris_indirect( bvh, side, ray, offset, count, intersects );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast_indirect };\n","import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectClosestTri_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst_indirect( bvh, root, side, ray ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\treturn intersectClosestTri_indirect( bvh, side, ray, offset, count );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst_indirect };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry_indirect( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * bvh.resolveTriangleIndex( i ), thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\tsetTriangle( triangle, 3 * ti, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry_indirect };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry_indirect(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * ti2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry_indirect };\n","export function isSharedArrayBufferSupported() {\n\n\treturn typeof SharedArrayBuffer !== 'undefined';\n\n}\n\nexport function convertToBufferType( array, BufferConstructor ) {\n\n\tif ( array === null ) {\n\n\t\treturn array;\n\n\t} else if ( array.buffer ) {\n\n\t\tconst buffer = array.buffer;\n\t\tif ( buffer.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst ArrayConstructor = array.constructor;\n\t\tconst result = new ArrayConstructor( new BufferConstructor( buffer.byteLength ) );\n\t\tresult.set( array );\n\t\treturn result;\n\n\t} else {\n\n\t\tif ( array.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst result = new BufferConstructor( array.byteLength );\n\t\tnew Uint8Array( result ).set( new Uint8Array( array ) );\n\t\treturn result;\n\n\t}\n\n}\n","import { Box3, Matrix4 } from 'three';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, LEFT_NODE, OFFSET, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\n\nconst _bufferStack1 = new BufferStack.constructor();\nconst _bufferStack2 = new BufferStack.constructor();\nconst _boxPool = new PrimitivePool( () => new Box3() );\nconst _leftBox1 = new Box3();\nconst _rightBox1 = new Box3();\n\nconst _leftBox2 = new Box3();\nconst _rightBox2 = new Box3();\n\nlet _active = false;\n\nexport function bvhcast( bvh, otherBvh, matrixToLocal, intersectsRanges ) {\n\n\tif ( _active ) {\n\n\t\tthrow new Error( 'MeshBVH: Recursive calls to bvhcast not supported.' );\n\n\t}\n\n\t_active = true;\n\n\tconst roots = bvh._roots;\n\tconst otherRoots = otherBvh._roots;\n\tlet result;\n\tlet offset1 = 0;\n\tlet offset2 = 0;\n\tconst invMat = new Matrix4().copy( matrixToLocal ).invert();\n\n\t// iterate over the first set of roots\n\tfor ( let i = 0, il = roots.length; i < il; i ++ ) {\n\n\t\t_bufferStack1.setBuffer( roots[ i ] );\n\t\toffset2 = 0;\n\n\t\t// prep the initial root box\n\t\tconst localBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( 0 ), _bufferStack1.float32Array, localBox );\n\t\tlocalBox.applyMatrix4( invMat );\n\n\t\t// iterate over the second set of roots\n\t\tfor ( let j = 0, jl = otherRoots.length; j < jl; j ++ ) {\n\n\t\t\t_bufferStack2.setBuffer( otherRoots[ i ] );\n\n\t\t\tresult = _traverse(\n\t\t\t\t0, 0, matrixToLocal, invMat, intersectsRanges,\n\t\t\t\toffset1, offset2, 0, 0,\n\t\t\t\tlocalBox,\n\t\t\t);\n\n\t\t\t_bufferStack2.clearBuffer();\n\t\t\toffset2 += otherRoots[ j ].length;\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// release stack info\n\t\t_boxPool.releasePrimitive( localBox );\n\t\t_bufferStack1.clearBuffer();\n\t\toffset1 += roots[ i ].length;\n\n\t\tif ( result ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t_active = false;\n\treturn result;\n\n}\n\nfunction _traverse(\n\tnode1Index32,\n\tnode2Index32,\n\tmatrix2to1,\n\tmatrix1to2,\n\tintersectsRangesFunc,\n\n\t// offsets for ids\n\tnode1IndexByteOffset = 0,\n\tnode2IndexByteOffset = 0,\n\n\t// tree depth\n\tdepth1 = 0,\n\tdepth2 = 0,\n\n\tcurrBox = null,\n\treversed = false,\n\n) {\n\n\t// get the buffer stacks associated with the current indices\n\tlet bufferStack1, bufferStack2;\n\tif ( reversed ) {\n\n\t\tbufferStack1 = _bufferStack2;\n\t\tbufferStack2 = _bufferStack1;\n\n\t} else {\n\n\t\tbufferStack1 = _bufferStack1;\n\t\tbufferStack2 = _bufferStack2;\n\n\t}\n\n\t// get the local instances of the typed buffers\n\tconst\n\t\tfloat32Array1 = bufferStack1.float32Array,\n\t\tuint32Array1 = bufferStack1.uint32Array,\n\t\tuint16Array1 = bufferStack1.uint16Array,\n\t\tfloat32Array2 = bufferStack2.float32Array,\n\t\tuint32Array2 = bufferStack2.uint32Array,\n\t\tuint16Array2 = bufferStack2.uint16Array;\n\n\tconst node1Index16 = node1Index32 * 2;\n\tconst node2Index16 = node2Index32 * 2;\n\tconst isLeaf1 = IS_LEAF( node1Index16, uint16Array1 );\n\tconst isLeaf2 = IS_LEAF( node2Index16, uint16Array2 );\n\tlet result = false;\n\tif ( isLeaf2 && isLeaf1 ) {\n\n\t\t// if both bounds are leaf nodes then fire the callback if the boxes intersect\n\t\tif ( reversed ) {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t);\n\n\t\t}\n\n\t} else if ( isLeaf2 ) {\n\n\t\t// SWAP\n\t\t// If we've traversed to the leaf node on the other bvh then we need to swap over\n\t\t// to traverse down the first one\n\n\t\t// get the new box to use\n\t\tconst newBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( node2Index32 ), float32Array2, newBox );\n\t\tnewBox.applyMatrix4( matrix2to1 );\n\n\t\t// get the child bounds to check before traversal\n\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\tresult = (\n\t\t\tintersectCl1 && _traverse(\n\t\t\t\tnode2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t) || (\n\t\t\tintersectCr1 && _traverse(\n\t\t\t\tnode2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t);\n\n\t\t_boxPool.releasePrimitive( newBox );\n\n\t} else {\n\n\t\t// if neither are leaves then we should swap if one of the children does not\n\t\t// intersect with the current bounds\n\n\t\t// get the child bounds to check\n\t\tconst cl2 = LEFT_NODE( node2Index32 );\n\t\tconst cr2 = RIGHT_NODE( node2Index32, uint32Array2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl2 ), float32Array2, _leftBox2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr2 ), float32Array2, _rightBox2 );\n\n\t\tconst leftIntersects = currBox.intersectsBox( _leftBox2 );\n\t\tconst rightIntersects = currBox.intersectsBox( _rightBox2 );\n\t\tif ( leftIntersects && rightIntersects ) {\n\n\t\t\t// continue to traverse both children if they both intersect\n\t\t\tresult = _traverse(\n\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t) || _traverse(\n\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t);\n\n\t\t} else if ( leftIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _leftBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t} else if ( rightIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _rightBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n","import { BufferAttribute, BufferGeometry, Mesh, MeshBasicMaterial } from 'three';\nimport { mergeGeometries } from './mergeGeometries.js';\nimport { setCommonAttributes } from './GeometryPreparationUtils.js';\nimport { BakedGeometry } from './BakedGeometry.js';\n\nexport const NO_CHANGE = 0;\nexport const GEOMETRY_ADJUSTED = 1;\nexport const GEOMETRY_REBUILT = 2;\n\n// iterate over only the meshes in the provided objects\nfunction flatTraverseMeshes( objects, cb ) {\n\n\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\tconst object = objects[ i ];\n\t\tobject.traverseVisible( o => {\n\n\t\t\tif ( o.isMesh ) {\n\n\t\t\t\tcb( o );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n\n// return the set of materials used by the provided meshes\nfunction getMaterials( meshes ) {\n\n\tconst materials = [];\n\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\tconst mesh = meshes[ i ];\n\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\tmaterials.push( ...mesh.material );\n\n\t\t} else {\n\n\t\t\tmaterials.push( mesh.material );\n\n\t\t}\n\n\t}\n\n\treturn materials;\n\n}\n\nfunction mergeGeometryList( geometries, target, options ) {\n\n\t// If we have no geometry to merge then provide an empty geometry.\n\tif ( geometries.length === 0 ) {\n\n\t\t// if there are no geometries then just create a fake empty geometry to provide\n\t\ttarget.setIndex( null );\n\n\t\t// remove all geometry\n\t\tconst attrs = target.attributes;\n\t\tfor ( const key in attrs ) {\n\n\t\t\ttarget.deleteAttribute( key );\n\n\t\t}\n\n\t\t// create dummy attributes\n\t\tfor ( const key in options.attributes ) {\n\n\t\t\ttarget.setAttribute( options.attributes[ key ], new BufferAttribute( new Float32Array( 0 ), 4, false ) );\n\n\t\t}\n\n\t} else {\n\n\t\tmergeGeometries( geometries, options, target );\n\n\t}\n\n\t// Mark all attributes as needing an update\n\tfor ( const key in target.attributes ) {\n\n\t\ttarget.attributes[ key ].needsUpdate = true;\n\n\t}\n\n}\n\n\nexport class StaticGeometryGenerator {\n\n\tconstructor( objects ) {\n\n\t\tthis.objects = null;\n\t\tthis.useGroups = true;\n\t\tthis.applyWorldTransforms = true;\n\t\tthis.generateMissingAttributes = true;\n\t\tthis.overwriteIndex = true;\n\t\tthis.attributes = [ 'position', 'normal', 'color', 'tangent', 'uv', 'uv2' ];\n\t\tthis._intermediateGeometry = new Map();\n\t\tthis._geometryMergeSets = new WeakMap();\n\t\tthis._mergeOrder = [];\n\t\tthis._dummyMesh = null;\n\n\t\tthis.setObjects( objects || [] );\n\n\t}\n\n\t_getDummyMesh() {\n\n\t\t// return a consistent dummy mesh\n\t\tif ( ! this._dummyMesh ) {\n\n\t\t\tconst dummyMaterial = new MeshBasicMaterial();\n\t\t\tconst emptyGeometry = new BufferGeometry();\n\t\t\temptyGeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( 9 ), 3 ) );\n\t\t\tthis._dummyMesh = new Mesh( emptyGeometry, dummyMaterial );\n\n\t\t}\n\n\t\treturn this._dummyMesh;\n\n\t}\n\n\t_getMeshes() {\n\n\t\t// iterate over only the meshes in the provided objects\n\t\tconst meshes = [];\n\t\tflatTraverseMeshes( this.objects, mesh => {\n\n\t\t\tmeshes.push( mesh );\n\n\t\t} );\n\n\t\t// Sort the geometry so it's in a reliable order\n\t\tmeshes.sort( ( a, b ) => {\n\n\t\t\tif ( a.uuid > b.uuid ) return 1;\n\t\t\tif ( a.uuid < b.uuid ) return - 1;\n\t\t\treturn 0;\n\n\t\t} );\n\n\t\tif ( meshes.length === 0 ) {\n\n\t\t\tmeshes.push( this._getDummyMesh() );\n\n\t\t}\n\n\t\treturn meshes;\n\n\t}\n\n\t_updateIntermediateGeometries() {\n\n\t\tconst { _intermediateGeometry } = this;\n\n\t\tconst meshes = this._getMeshes();\n\t\tconst unusedMeshKeys = new Set( _intermediateGeometry.keys() );\n\t\tconst convertOptions = {\n\t\t\tattributes: this.attributes,\n\t\t\tapplyWorldTransforms: this.applyWorldTransforms,\n\t\t};\n\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\tconst mesh = meshes[ i ];\n\t\t\tconst meshKey = mesh.uuid;\n\t\t\tunusedMeshKeys.delete( meshKey );\n\n\t\t\t// initialize the intermediate geometry\n\t\t\t// if the mesh and source geometry have changed in such a way that they are no longer\n\t\t\t// compatible then regenerate the baked geometry from scratch\n\t\t\tlet geom = _intermediateGeometry.get( meshKey );\n\t\t\tif ( ! geom || ! geom.isCompatible( mesh, this.attributes ) ) {\n\n\t\t\t\tif ( geom ) {\n\n\t\t\t\t\tgeom.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tgeom = new BakedGeometry();\n\t\t\t\t_intermediateGeometry.set( meshKey, geom );\n\n\t\t\t}\n\n\t\t\t// transform the geometry into the intermediate buffer geometry, saving whether\n\t\t\t// or not it changed.\n\t\t\tif ( geom.updateFrom( mesh, convertOptions ) ) {\n\n\t\t\t\t// TODO: provide option for only generating the set of attributes that are present\n\t\t\t\t// and are in the attributes array\n\t\t\t\tif ( this.generateMissingAttributes ) {\n\n\t\t\t\t\tsetCommonAttributes( geom, this.attributes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tunusedMeshKeys.forEach( key => {\n\n\t\t\t_intermediateGeometry.delete( key );\n\n\t\t} );\n\n\t}\n\n\tsetObjects( objects ) {\n\n\t\tif ( Array.isArray( objects ) ) {\n\n\t\t\tthis.objects = [ ...objects ];\n\n\t\t} else {\n\n\t\t\tthis.objects = [ objects ];\n\n\t\t}\n\n\t}\n\n\tgenerate( targetGeometry = new BufferGeometry() ) {\n\n\t\t// track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n\t\tconst { useGroups, overwriteIndex, _intermediateGeometry, _geometryMergeSets } = this;\n\n\t\tconst meshes = this._getMeshes();\n\t\tconst skipAssigningAttributes = [];\n\t\tconst mergeGeometry = [];\n\t\tconst previousMergeInfo = _geometryMergeSets.get( targetGeometry ) || [];\n\n\t\t// update all the intermediate static geometry representations\n\t\tthis._updateIntermediateGeometries();\n\n\t\t// get the list of geometries to merge\n\t\tlet forceUpdate = false;\n\t\tif ( meshes.length !== previousMergeInfo.length ) {\n\n\t\t\tforceUpdate = true;\n\n\t\t}\n\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\tconst mesh = meshes[ i ];\n\t\t\tconst geom = _intermediateGeometry.get( mesh.uuid );\n\t\t\tmergeGeometry.push( geom );\n\n\t\t\tconst info = previousMergeInfo[ i ];\n\t\t\tif ( ! info || info.uuid !== geom.uuid ) {\n\n\t\t\t\tskipAssigningAttributes.push( false );\n\t\t\t\tforceUpdate = true;\n\n\t\t\t} else if ( info.version !== geom.version ) {\n\n\t\t\t\tskipAssigningAttributes.push( false );\n\n\t\t\t} else {\n\n\t\t\t\tskipAssigningAttributes.push( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// If we have no geometry to merge then provide an empty geometry.\n\t\tmergeGeometryList( mergeGeometry, targetGeometry, { useGroups, forceUpdate, skipAssigningAttributes, overwriteIndex } );\n\n\t\t// force update means the attribute buffer lengths have changed\n\t\tif ( forceUpdate ) {\n\n\t\t\ttargetGeometry.dispose();\n\n\t\t}\n\n\t\t_geometryMergeSets.set( targetGeometry, mergeGeometry.map( g => ( {\n\t\t\tversion: g.version,\n\t\t\tuuid: g.uuid,\n\t\t} ) ) );\n\n\t\tlet changeType = NO_CHANGE;\n\t\tif ( forceUpdate ) changeType = GEOMETRY_REBUILT;\n\t\telse if ( skipAssigningAttributes.includes( false ) ) changeType = GEOMETRY_ADJUSTED;\n\n\t\treturn {\n\t\t\tchangeType,\n\t\t\tmaterials: getMaterials( meshes ),\n\t\t\tgeometry: targetGeometry,\n\t\t};\n\n\t}\n\n}\n","import { BufferAttribute, BufferGeometry } from 'three';\nimport { copyAttributeContents, createAttributeClone } from './BufferAttributeUtils.js';\n\nfunction validateMergeability( geometries ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tif ( ! geometries[ 0 ].getAttribute( 'position' ) ) {\n\n\t\tthrow new Error( 'StaticGeometryGenerator: position attribute is required.' );\n\n\t}\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\n\t\t\t}\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have the same number of attributes.' );\n\n\t\t}\n\n\t}\n\n}\n\nfunction getTotalIndexCount( geometries ) {\n\n\tlet result = 0;\n\tfor ( let i = 0, l = geometries.length; i < l; i ++ ) {\n\n\t\tresult += geometries[ i ].getIndex().count;\n\n\t}\n\n\treturn result;\n\n}\n\nfunction getTotalAttributeCount( geometries ) {\n\n\tlet result = 0;\n\tfor ( let i = 0, l = geometries.length; i < l; i ++ ) {\n\n\t\tresult += geometries[ i ].getAttribute( 'position' ).count;\n\n\t}\n\n\treturn result;\n\n}\n\nfunction trimMismatchedAttributes( target, indexCount, attrCount ) {\n\n\tif ( target.index && target.index.count !== indexCount ) {\n\n\t\ttarget.setIndex( null );\n\n\t}\n\n\tconst attributes = target.attributes;\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.count !== attrCount ) {\n\n\t\t\ttarget.deleteAttribute( key );\n\n\t\t}\n\n\t}\n\n}\n\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\nexport function mergeGeometries( geometries, options = {}, targetGeometry = new BufferGeometry() ) {\n\n\tconst {\n\t\tuseGroups = false,\n\t\tforceUpdate = false,\n\t\tskipAssigningAttributes = [],\n\t\toverwriteIndex = true,\n\t} = options;\n\n\t// check if we can merge these geometries\n\tvalidateMergeability( geometries );\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\tconst totalIndexCount = isIndexed ? getTotalIndexCount( geometries ) : - 1;\n\tconst totalAttributeCount = getTotalAttributeCount( geometries );\n\ttrimMismatchedAttributes( targetGeometry, totalIndexCount, totalAttributeCount );\n\n\t// set up groups\n\tif ( useGroups ) {\n\n\t\tlet offset = 0;\n\t\tfor ( let i = 0, l = geometries.length; i < l; i ++ ) {\n\n\t\t\tconst geometry = geometries[ i ];\n\n\t\t\tlet primitiveCount;\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tprimitiveCount = geometry.getIndex().count;\n\n\t\t\t} else {\n\n\t\t\t\tprimitiveCount = geometry.getAttribute( 'position' ).count;\n\n\t\t\t}\n\n\t\t\ttargetGeometry.addGroup( offset, primitiveCount, i );\n\t\t\toffset += primitiveCount;\n\n\t\t}\n\n\t}\n\n\t// generate the final geometry\n\t// skip the assigning any attributes for items in the above array\n\tif ( isIndexed ) {\n\n\t\t// set up the index if it doesn't exist\n\t\tlet forceUpdateIndex = false;\n\t\tif ( ! targetGeometry.index ) {\n\n\t\t\ttargetGeometry.setIndex( new BufferAttribute( new Uint32Array( totalIndexCount ), 1, false ) );\n\t\t\tforceUpdateIndex = true;\n\n\t\t}\n\n\t\tif ( forceUpdateIndex || overwriteIndex ) {\n\n\t\t\t// copy the index data to the target geometry\n\t\t\tlet targetOffset = 0;\n\t\t\tlet indexOffset = 0;\n\t\t\tconst targetIndex = targetGeometry.getIndex();\n\t\t\tfor ( let i = 0, l = geometries.length; i < l; i ++ ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst index = geometry.getIndex();\n\t\t\t\tconst skip = ! forceUpdate && ! forceUpdateIndex && skipAssigningAttributes[ i ];\n\t\t\t\tif ( ! skip ) {\n\n\t\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\t\ttargetIndex.setX( targetOffset + j, index.getX( j ) + indexOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttargetOffset += index.count;\n\t\t\t\tindexOffset += geometry.getAttribute( 'position' ).count;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// copy all the attribute data over\n\tconst attributes = Object.keys( geometries[ 0 ].attributes );\n\tfor ( let i = 0, l = attributes.length; i < l; i ++ ) {\n\n\t\tlet forceUpdateAttr = false;\n\t\tconst key = attributes[ i ];\n\t\tif ( ! targetGeometry.getAttribute( key ) ) {\n\n\t\t\tconst firstAttr = geometries[ 0 ].getAttribute( key );\n\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( firstAttr, totalAttributeCount ) );\n\t\t\tforceUpdateAttr = true;\n\n\t\t}\n\n\t\tlet offset = 0;\n\t\tconst targetAttribute = targetGeometry.getAttribute( key );\n\t\tfor ( let g = 0, l = geometries.length; g < l; g ++ ) {\n\n\t\t\tconst geometry = geometries[ g ];\n\t\t\tconst skip = ! forceUpdate && ! forceUpdateAttr && skipAssigningAttributes[ g ];\n\t\t\tconst attr = geometry.getAttribute( key );\n \t\t\tif ( ! skip ) {\n\n\t\t\t\tif ( key === 'color' && targetAttribute.itemSize !== attr.itemSize ) {\n\n\t\t\t\t\t// make sure the color attribute is aligned with itemSize 3 to 4\n\t\t\t\t\tfor ( let index = offset, l = attr.count; index < l; index ++ ) {\n\n\t\t\t\t\t\tattr.setXYZW( index, targetAttribute.getX( index ), targetAttribute.getY( index ), targetAttribute.getZ( index ), 1.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\toffset += attr.count;\n\n\t\t}\n\n\t}\n\n}\n","import { BufferAttribute } from 'three';\n\n// target offset is the number of elements in the target buffer stride to skip before copying the\n// attributes contents in to.\nexport function copyAttributeContents( attr, target, targetOffset = 0 ) {\n\n\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\tconst itemSize = attr.itemSize;\n\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\tconst io = i + targetOffset;\n\t\t\ttarget.setX( io, attr.getX( i ) );\n\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\n\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\n\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\n\n\t\t}\n\n\t} else {\n\n\t\tconst array = target.array;\n\t\tconst cons = array.constructor;\n\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\n\t\ttemp.set( attr.array );\n\n\t}\n\n}\n\n// Clones the given attribute with a new compatible buffer attribute but no data\nexport function createAttributeClone( attr, countOverride = null ) {\n\n\tconst cons = attr.array.constructor;\n\tconst normalized = attr.normalized;\n\tconst itemSize = attr.itemSize;\n\tconst count = countOverride === null ? attr.count : countOverride;\n\n\treturn new BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\n\n}\n\n// Confirms that the two provided attributes are compatible. Returns false if they are not.\nexport function validateAttributes( attr1, attr2 ) {\n\n\tif ( ! attr1 && ! attr2 ) {\n\n\t\treturn true;\n\n\t}\n\n\tif ( Boolean( attr1 ) !== Boolean( attr2 ) ) {\n\n\t\treturn false;\n\n\t}\n\n\tconst sameCount = attr1.count === attr2.count;\n\tconst sameNormalized = attr1.normalized === attr2.normalized;\n\tconst sameType = attr1.array.constructor === attr2.array.constructor;\n\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\n\n\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\n\n\t\treturn false;\n\n\t}\n\n\treturn true;\n\n}\n","import { BufferAttribute } from 'three';\n\nexport function updateMaterialIndexAttribute( geometry, materials, allMaterials ) {\n\n\tconst indexAttr = geometry.index;\n\tconst posAttr = geometry.attributes.position;\n\tconst vertCount = posAttr.count;\n\tconst totalCount = indexAttr ? indexAttr.count : vertCount;\n\tlet groups = geometry.groups;\n\tif ( groups.length === 0 ) {\n\n\t\tgroups = [ { count: totalCount, start: 0, materialIndex: 0 } ];\n\n\t}\n\n\tlet materialIndexAttribute = geometry.getAttribute( 'materialIndex' );\n\tif ( ! materialIndexAttribute || materialIndexAttribute.count !== vertCount ) {\n\n\t\t// use an array with the minimum precision required to store all material id references.\n\t\tlet array;\n\t\tif ( allMaterials.length <= 255 ) {\n\n\t\t\tarray = new Uint8Array( vertCount );\n\n\t\t} else {\n\n\t\t\tarray = new Uint16Array( vertCount );\n\n\t\t}\n\n\t\tmaterialIndexAttribute = new BufferAttribute( array, 1, false );\n\t\tgeometry.deleteAttribute( 'materialIndex' );\n\t\tgeometry.setAttribute( 'materialIndex', materialIndexAttribute );\n\n\t}\n\n\tconst materialArray = materialIndexAttribute.array;\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst start = group.start;\n\t\tconst count = group.count;\n\t\tconst endCount = Math.min( count, totalCount - start );\n\n\t\tconst mat = Array.isArray( materials ) ? materials[ group.materialIndex ] : materials;\n\t\tconst materialIndex = allMaterials.indexOf( mat );\n\n\t\tfor ( let j = 0; j < endCount; j ++ ) {\n\n\t\t\tlet index = start + j;\n\t\t\tif ( indexAttr ) {\n\n\t\t\t\tindex = indexAttr.getX( index );\n\n\t\t\t}\n\n\t\t\tmaterialArray[ index ] = materialIndex;\n\n\t\t}\n\n\t}\n\n}\n\nexport function setCommonAttributes( geometry, attributes ) {\n\n\tif ( ! geometry.index ) {\n\n\t\t// TODO: compute a typed array\n\t\tconst indexCount = geometry.attributes.position.count;\n\t\tconst array = new Array( indexCount );\n\t\tfor ( let i = 0; i < indexCount; i ++ ) {\n\n\t\t\tarray[ i ] = i;\n\n\t\t}\n\n\t\tgeometry.setIndex( array );\n\n\t}\n\n\tif ( ! geometry.attributes.normal && ( attributes && attributes.includes( 'normal' ) ) ) {\n\n\t\tgeometry.computeVertexNormals();\n\n\t}\n\n\tif ( ! geometry.attributes.uv && ( attributes && attributes.includes( 'uv' ) ) ) {\n\n\t\tconst vertCount = geometry.attributes.position.count;\n\t\tgeometry.setAttribute( 'uv', new BufferAttribute( new Float32Array( vertCount * 2 ), 2, false ) );\n\n\t}\n\n\tif ( ! geometry.attributes.uv2 && ( attributes && attributes.includes( 'uv2' ) ) ) {\n\n\t\tconst vertCount = geometry.attributes.position.count;\n\t\tgeometry.setAttribute( 'uv2', new BufferAttribute( new Float32Array( vertCount * 2 ), 2, false ) );\n\n\t}\n\n\tif ( ! geometry.attributes.tangent && ( attributes && attributes.includes( 'tangent' ) ) ) {\n\n\t\t// compute tangents requires a uv and normal buffer\n\t\tif ( geometry.attributes.uv && geometry.attributes.normal ) {\n\n\t\t\tgeometry.computeTangents();\n\n\t\t} else {\n\n\t\t\tconst vertCount = geometry.attributes.position.count;\n\t\t\tgeometry.setAttribute( 'tangent', new BufferAttribute( new Float32Array( vertCount * 4 ), 4, false ) );\n\n\t\t}\n\n\t}\n\n\tif ( ! geometry.attributes.color && ( attributes && attributes.includes( 'color' ) ) ) {\n\n\t\tconst vertCount = geometry.attributes.position.count;\n\t\tconst array = new Float32Array( vertCount * 4 );\n\t\tarray.fill( 1.0 );\n\t\tgeometry.setAttribute( 'color', new BufferAttribute( array, 4 ) );\n\n\t}\n\n}\n","import { BufferGeometry } from 'three';\nimport { MeshDiff } from './MeshDiff.js';\nimport { convertToStaticGeometry } from './convertToStaticGeometry.js';\nimport { validateAttributes } from './BufferAttributeUtils.js';\n\nexport class BakedGeometry extends BufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.version = 0;\n\t\tthis.hash = null;\n\t\tthis._diff = new MeshDiff();\n\n\t}\n\n\t// returns whether the passed mesh is compatible with this baked geometry\n\t// such that it can be updated without resizing attributes\n\tisCompatible( mesh, attributes ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tfor ( let i = 0; i < attributes.length; i ++ ) {\n\n\t\t\tconst key = attributes[ i ];\n\t\t\tconst attr1 = geometry.attributes[ key ];\n\t\t\tconst attr2 = this.attributes[ key ];\n\t\t\tif ( attr1 && ! validateAttributes( attr1, attr2 ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tupdateFrom( mesh, options ) {\n\n\t\tconst diff = this._diff;\n\t\tif ( diff.didChange( mesh ) ) {\n\n\t\t\tconvertToStaticGeometry( mesh, options, this );\n\t\t\tdiff.updateFrom( mesh );\n\t\t\tthis.version ++;\n\t\t\tthis.hash = `${ this.uuid }_${ this.version }`;\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n}\n","import { Matrix4 } from 'three';\nimport { bufferToHash } from '../../utils/bufferToHash.js';\n\nfunction getGeometryHash( geometry ) {\n\n\tlet hash = geometry.uuid;\n\tconst attributes = Object.values( geometry.attributes );\n\tif ( geometry.index ) {\n\n\t\tattributes.push( geometry.index );\n\t\thash += `index|${ geometry.index.version }`;\n\n\t}\n\n\tconst keys = Object.keys( attributes ).sort();\n\tfor ( const key of keys ) {\n\n\t\tconst attr = attributes[ key ];\n\t\thash += `${ key }_${ attr.version }|`;\n\n\t}\n\n\treturn hash;\n\n}\n\nfunction getSkeletonHash( mesh ) {\n\n\tconst skeleton = mesh.skeleton;\n\tif ( skeleton ) {\n\n\t\tif ( ! skeleton.boneTexture ) {\n\n\t\t\tskeleton.computeBoneTexture();\n\n\t\t}\n\n\t\t// we can't use the texture version here because it will change even\n\t\t// when the bones haven't\n\t\tconst dataHash = bufferToHash( skeleton.boneTexture.image.data.buffer );\n\t\treturn `${ dataHash }_${ skeleton.boneTexture.uuid }`;\n\n\t} else {\n\n\t\treturn null;\n\n\t}\n\n}\n\n// Checks whether the geometry changed between this and last evaluation\nexport class MeshDiff {\n\n\tconstructor( mesh = null ) {\n\n\t\tthis.matrixWorld = new Matrix4();\n\t\tthis.geometryHash = null;\n\t\tthis.skeletonHash = null;\n\t\tthis.primitiveCount = - 1;\n\n\t\tif ( mesh !== null ) {\n\n\t\t\tthis.updateFrom( mesh );\n\n\t\t}\n\n\t}\n\n\tupdateFrom( mesh ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tthis.matrixWorld.copy( mesh.matrixWorld );\n\t\tthis.geometryHash = getGeometryHash( geometry );\n\t\tthis.primitiveCount = primitiveCount;\n\t\tthis.skeletonHash = getSkeletonHash( mesh );\n\n\t}\n\n\tdidChange( mesh ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\n\t\tconst identical =\n\t\t\tthis.matrixWorld.equals( mesh.matrixWorld ) &&\n\t\t\tthis.geometryHash === getGeometryHash( geometry ) &&\n\t\t\tthis.skeletonHash === getSkeletonHash( mesh ) &&\n\t\t\tthis.primitiveCount === primitiveCount;\n\n\t\treturn ! identical;\n\n\t}\n\n}\n","// https://www.geeksforgeeks.org/how-to-create-hash-from-string-in-javascript/\n// https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\nexport function bufferToHash( buffer ) {\n\n\tlet hash = 0;\n\n\tif ( buffer.byteLength !== 0 ) {\n\n\t\tconst uintArray = new Uint8Array( buffer );\n\t\tfor ( let i = 0; i < buffer.byteLength; i ++ ) {\n\n\t\t\tconst byte = uintArray[ i ];\n\t\t\thash = ( ( hash << 5 ) - hash ) + byte;\n\t\t\thash |= 0;\n\n\t\t}\n\n\t}\n\n\treturn hash;\n\n}\n","import { BufferGeometry, Matrix3, Matrix4, Vector3, Vector4 } from 'three';\nimport { copyAttributeContents, createAttributeClone, validateAttributes } from './BufferAttributeUtils.js';\n\nconst _positionVector = /*@__PURE__*/ new Vector3();\nconst _normalVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector4 = /*@__PURE__*/ new Vector4();\n\nconst _morphVector = /*@__PURE__*/ new Vector3();\nconst _temp = /*@__PURE__*/ new Vector3();\n\nconst _skinIndex = /*@__PURE__*/ new Vector4();\nconst _skinWeight = /*@__PURE__*/ new Vector4();\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\n\n// A version of \"SkinnedMesh.boneTransform\" for normals\nfunction boneNormalTransform( mesh, index, target ) {\n\n\tconst skeleton = mesh.skeleton;\n\tconst geometry = mesh.geometry;\n\tconst bones = skeleton.bones;\n\tconst boneInverses = skeleton.boneInverses;\n\n\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t_matrix.elements.fill( 0 );\n\n\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\tif ( weight !== 0 ) {\n\n\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\t\t\t_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );\n\n\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\n\n\t\t}\n\n\t}\n\n\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\n\ttarget.transformDirection( _matrix );\n\n\treturn target;\n\n}\n\n// Applies the morph target data to the target vector\nfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\n\n\t_morphVector.set( 0, 0, 0 );\n\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\n\n\t\tconst influence = morphInfluences[ j ];\n\t\tconst morphAttribute = morphData[ j ];\n\n\t\tif ( influence === 0 ) continue;\n\n\t\t_temp.fromBufferAttribute( morphAttribute, i );\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\t_morphVector.addScaledVector( _temp, influence );\n\n\t\t} else {\n\n\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\n\n\t\t}\n\n\t}\n\n\ttarget.add( _morphVector );\n\n}\n\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\nfunction addScaledMatrix( target, matrix, scale ) {\n\n\tconst targetArray = target.elements;\n\tconst matrixArray = matrix.elements;\n\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\n\n\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\n\n\t}\n\n}\n\n// inverts the geometry in place\nfunction invertGeometry( geometry ) {\n\n\tconst { index, attributes } = geometry;\n\tif ( index ) {\n\n\t\tfor ( let i = 0, l = index.count; i < l; i += 3 ) {\n\n\t\t\tconst v0 = index.getX( i );\n\t\t\tconst v2 = index.getX( i + 2 );\n\t\t\tindex.setX( i, v2 );\n\t\t\tindex.setX( i + 2, v0 );\n\n\t\t}\n\n\t} else {\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attr = attributes[ key ];\n\t\t\tconst itemSize = attr.itemSize;\n\t\t\tfor ( let i = 0, l = attr.count; i < l; i += 3 ) {\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tconst v0 = attr.getComponent( i, j );\n\t\t\t\t\tconst v2 = attr.getComponent( i + 2, j );\n\t\t\t\t\tattr.setComponent( i, j, v2 );\n\t\t\t\t\tattr.setComponent( i + 2, j, v0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\nexport function convertToStaticGeometry( mesh, options = {}, targetGeometry = new BufferGeometry() ) {\n\n\toptions = {\n\t\tapplyWorldTransforms: true,\n\t\tattributes: [],\n\t\t...options\n\t};\n\n\tconst geometry = mesh.geometry;\n\tconst applyWorldTransforms = options.applyWorldTransforms;\n\tconst includeNormal = options.attributes.includes( 'normal' );\n\tconst includeTangent = options.attributes.includes( 'tangent' );\n\tconst attributes = geometry.attributes;\n\tconst targetAttributes = targetGeometry.attributes;\n\n\t// strip any unused and unneeded attributes\n\tfor ( const key in targetGeometry.attributes ) {\n\n\t\tif ( ! options.attributes.includes( key ) || ! ( key in geometry.attributes ) ) {\n\n\t\t\ttargetGeometry.deleteAttribute( key );\n\n\t\t}\n\n\t}\n\n\t// initialize the attributes if they don't exist\n\tif ( ! targetGeometry.index && geometry.index ) {\n\n\t\ttargetGeometry.index = geometry.index.clone();\n\n\t}\n\n\tif ( ! targetAttributes.position ) {\n\n\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\n\n\t}\n\n\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\n\n\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\n\n\t}\n\n\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\n\n\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\n\n\t}\n\n\t// ensure the attributes are consistent\n\tvalidateAttributes( geometry.index, targetGeometry.index );\n\tvalidateAttributes( attributes.position, targetAttributes.position );\n\n\tif ( includeNormal ) {\n\n\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\n\n\t}\n\n\tif ( includeTangent ) {\n\n\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\n\n\t}\n\n\t// generate transformed vertex attribute data\n\tconst position = attributes.position;\n\tconst normal = includeNormal ? attributes.normal : null;\n\tconst tangent = includeTangent ? attributes.tangent : null;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphNormal = geometry.morphAttributes.normal;\n\tconst morphTangent = geometry.morphAttributes.tangent;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst morphInfluences = mesh.morphTargetInfluences;\n\tconst normalMatrix = new Matrix3();\n\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\n\n\t// copy the index\n\tif ( geometry.index ) {\n\n\t\ttargetGeometry.index.array.set( geometry.index.array );\n\n\t}\n\n\t// copy and apply other attributes\n\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\n\n\t\t_positionVector.fromBufferAttribute( position, i );\n\t\tif ( normal ) {\n\n\t\t\t_normalVector.fromBufferAttribute( normal, i );\n\n\t\t}\n\n\t\tif ( tangent ) {\n\n\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\n\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\n\n\t\t}\n\n\t\t// apply morph target transform\n\t\tif ( morphInfluences ) {\n\n\t\t\tif ( morphPosition ) {\n\n\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\n\n\t\t\t}\n\n\t\t\tif ( morphNormal ) {\n\n\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\n\n\t\t\t}\n\n\t\t\tif ( morphTangent ) {\n\n\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// apply bone transform\n\t\tif ( mesh.isSkinnedMesh ) {\n\n\t\t\tmesh.applyBoneTransform( i, _positionVector );\n\t\t\tif ( normal ) {\n\n\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\n\n\t\t\t}\n\n\t\t\tif ( tangent ) {\n\n\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// update the vectors of the attributes\n\t\tif ( applyWorldTransforms ) {\n\n\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\n\n\t\t}\n\n\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\n\n\t\tif ( normal ) {\n\n\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\n\n\t\t\t}\n\n\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\n\n\t\t}\n\n\t\tif ( tangent ) {\n\n\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\n\n\t\t}\n\n\t}\n\n\t// copy other attributes over\n\tfor ( const i in options.attributes ) {\n\n\t\tconst key = options.attributes[ i ];\n\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tif ( ! targetAttributes[ key ] ) {\n\n\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\n\n\t\t}\n\n\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\n\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\n\n\t}\n\n\tif ( mesh.matrixWorld.determinant() < 0 ) {\n\n\t\tinvertGeometry( targetGeometry );\n\n\t}\n\n\treturn targetGeometry;\n\n}\n","export * from './glsl/common_functions.glsl.js';\nexport * from './glsl/bvh_distance_functions.glsl.js';\nexport * from './glsl/bvh_ray_functions.glsl.js';\nexport * from './glsl/bvh_struct_definitions.glsl.js';\n","export const common_functions = /* glsl */`\n\n// A stack of uint32 indices can can store the indices for\n// a perfectly balanced tree with a depth up to 31. Lower stack\n// depth gets higher performance.\n//\n// However not all trees are balanced. Best value to set this to\n// is the trees max depth.\n#ifndef BVH_STACK_DEPTH\n#define BVH_STACK_DEPTH 60\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n`;\n","// Distance to Point\nexport const bvh_distance_functions = /* glsl */`\n\nfloat dot2( vec3 v ) {\n\n\treturn dot( v, v );\n\n}\n\n// https://www.shadertoy.com/view/ttfGWl\nvec3 closestPointToTriangle( vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 barycoord ) {\n\n    vec3 v10 = v1 - v0;\n    vec3 v21 = v2 - v1;\n    vec3 v02 = v0 - v2;\n\n\tvec3 p0 = p - v0;\n\tvec3 p1 = p - v1;\n\tvec3 p2 = p - v2;\n\n    vec3 nor = cross( v10, v02 );\n\n    // method 2, in barycentric space\n    vec3  q = cross( nor, p0 );\n    float d = 1.0 / dot2( nor );\n    float u = d * dot( q, v02 );\n    float v = d * dot( q, v10 );\n    float w = 1.0 - u - v;\n\n\tif( u < 0.0 ) {\n\n\t\tw = clamp( dot( p2, v02 ) / dot2( v02 ), 0.0, 1.0 );\n\t\tu = 0.0;\n\t\tv = 1.0 - w;\n\n\t} else if( v < 0.0 ) {\n\n\t\tu = clamp( dot( p0, v10 ) / dot2( v10 ), 0.0, 1.0 );\n\t\tv = 0.0;\n\t\tw = 1.0 - u;\n\n\t} else if( w < 0.0 ) {\n\n\t\tv = clamp( dot( p1, v21 ) / dot2( v21 ), 0.0, 1.0 );\n\t\tw = 0.0;\n\t\tu = 1.0-v;\n\n\t}\n\n\tbarycoord = vec3( u, v, w );\n    return u * v1 + v * v2 + w * v0;\n\n}\n\nfloat distanceToTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// point and cut off range\n\tvec3 point, float closestDistanceSquared,\n\n\t// outputs\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord, inout float side, inout vec3 outPoint\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\t// get the closest point and barycoord\n\t\tvec3 closestPoint = closestPointToTriangle( point, a, b, c, localBarycoord );\n\t\tvec3 delta = point - closestPoint;\n\t\tfloat sqDist = dot2( delta );\n\t\tif ( sqDist < closestDistanceSquared ) {\n\n\t\t\t// set the output results\n\t\t\tclosestDistanceSquared = sqDist;\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = normalize( cross( a - b, b - c ) );\n\t\t\tbarycoord = localBarycoord;\n\t\t\toutPoint = closestPoint;\n\t\t\tside = sign( dot( faceNormal, delta ) );\n\n\t\t}\n\n\t}\n\n\treturn closestDistanceSquared;\n\n}\n\nfloat distanceSqToBounds( vec3 point, vec3 boundsMin, vec3 boundsMax ) {\n\n\tvec3 clampedPoint = clamp( point, boundsMin, boundsMax );\n\tvec3 delta = point - clampedPoint;\n\treturn dot( delta, delta );\n\n}\n\nfloat distanceSqToBVHNodeBoundsPoint( vec3 point, sampler2D bvhBounds, uint currNodeIndex ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn distanceSqToBounds( point, boundsMin, boundsMax );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhClosestPointToPoint(\\\n\t\tbvh,\\\n\t\tpoint, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\\\n\t_bvhClosestPointToPoint(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\tpoint, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\n\nfloat _bvhClosestPointToPoint(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// point to check\n\tvec3 point,\n\n\t// output variables\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout vec3 outPoint\n ) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat closestDistanceSquared = pow( 100000.0, 2.0 );\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, currNodeIndex );\n\t\tif ( boundsHitDistance > closestDistanceSquared ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\t\t\tclosestDistanceSquared = distanceToTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count, point, closestDistanceSquared,\n\n\t\t\t\t// outputs\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, outPoint\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\t\t\tbool leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, rightIndex );//rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn sqrt( closestDistanceSquared );\n\n}\n`;\n","export const bvh_ray_functions = /* glsl */`\n\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n// Raycasting\nbool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tdist = max( t0, 0.0 );\n\n\treturn t1 >= dist;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// outputs\n\tinout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nbool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhIntersectFirstHit(\\\n\t\tbvh,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\\\n\t_bvhIntersectFirstHit(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\n\nbool _bvhIntersectFirstHit(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables split into separate variables due to output precision\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = INFINITY;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance;\n\t\tif (\n\t\t\t! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )\n\t\t\t|| boundsHitDistance > triangleDistance\n\t\t) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count,\n\t\t\t\trayOrigin, rayDirection, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n`;\n","// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\n// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\n// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\nexport const bvh_struct_definitions = /* glsl */`\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n`;\n","import {\n\tDataTexture,\n\tFloatType,\n\tUnsignedIntType,\n\tRGBAFormat,\n\tRGIntegerFormat,\n\tNearestFilter,\n\tBufferAttribute,\n} from 'three';\nimport {\n\tFloatVertexAttributeTexture,\n\tUIntVertexAttributeTexture,\n} from './VertexAttributeTexture.js';\nimport { BYTES_PER_NODE } from '../core/Constants.js';\nimport {\n\tBOUNDING_DATA_INDEX,\n\tCOUNT,\n\tIS_LEAF,\n\tRIGHT_NODE,\n\tOFFSET,\n\tSPLIT_AXIS,\n} from '../core/utils/nodeBufferUtils.js';\nimport { getIndexArray, getVertexCount } from '../core/build/geometryUtils.js';\n\nexport class MeshBVHUniformStruct {\n\n\tconstructor() {\n\n\t\tthis.index = new UIntVertexAttributeTexture();\n\t\tthis.position = new FloatVertexAttributeTexture();\n\t\tthis.bvhBounds = new DataTexture();\n\t\tthis.bvhContents = new DataTexture();\n\t\tthis._cachedIndexAttr = null;\n\n\t\tthis.index.overrideItemSize = 3;\n\n\t}\n\n\tupdateFrom( bvh ) {\n\n\t\tconst { geometry } = bvh;\n\t\tbvhToTextures( bvh, this.bvhBounds, this.bvhContents );\n\n\t\tthis.position.updateFrom( geometry.attributes.position );\n\n\t\t// dereference a new index attribute if we're using indirect storage\n\t\tif ( bvh.indirect ) {\n\n\t\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\t\tif (\n\t\t\t\tthis._cachedIndexAttr === null ||\n\t\t\t\tthis._cachedIndexAttr.count !== indirectBuffer.length\n\t\t\t) {\n\n\t\t\t\tif ( geometry.index ) {\n\n\t\t\t\t\tthis._cachedIndexAttr = geometry.index.clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst array = getIndexArray( getVertexCount( geometry ) );\n\t\t\t\t\tthis._cachedIndexAttr = new BufferAttribute( array, 1, false );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdereferenceIndex( geometry, indirectBuffer, this._cachedIndexAttr );\n\t\t\tthis.index.updateFrom( this._cachedIndexAttr );\n\n\t\t} else {\n\n\t\t\tthis.index.updateFrom( geometry.index );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tconst { index, position, bvhBounds, bvhContents } = this;\n\n\t\tif ( index ) index.dispose();\n\t\tif ( position ) position.dispose();\n\t\tif ( bvhBounds ) bvhBounds.dispose();\n\t\tif ( bvhContents ) bvhContents.dispose();\n\n\t}\n\n}\n\nfunction dereferenceIndex( geometry, indirectBuffer, target ) {\n\n\tconst unpacked = target.array;\n\tconst indexArray = geometry.index ? geometry.index.array : null;\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst v3 = 3 * indirectBuffer[ i ];\n\t\tfor ( let c = 0; c < 3; c ++ ) {\n\n\t\t\tunpacked[ i3 + c ] = indexArray ? indexArray[ v3 + c ] : v3 + c;\n\n\t\t}\n\n\t}\n\n}\n\nfunction bvhToTextures( bvh, boundsTexture, contentsTexture ) {\n\n\tconst roots = bvh._roots;\n\n\tif ( roots.length !== 1 ) {\n\n\t\tthrow new Error( 'MeshBVHUniformStruct: Multi-root BVHs not supported.' );\n\n\t}\n\n\tconst root = roots[ 0 ];\n\tconst uint16Array = new Uint16Array( root );\n\tconst uint32Array = new Uint32Array( root );\n\tconst float32Array = new Float32Array( root );\n\n\t// Both bounds need two elements per node so compute the height so it's twice as long as\n\t// the width so we can expand the row by two and still have a square texture\n\tconst nodeCount = root.byteLength / BYTES_PER_NODE;\n\tconst boundsDimension = 2 * Math.ceil( Math.sqrt( nodeCount / 2 ) );\n\tconst boundsArray = new Float32Array( 4 * boundsDimension * boundsDimension );\n\n\tconst contentsDimension = Math.ceil( Math.sqrt( nodeCount ) );\n\tconst contentsArray = new Uint32Array( 2 * contentsDimension * contentsDimension );\n\n\tfor ( let i = 0; i < nodeCount; i ++ ) {\n\n\t\tconst nodeIndex32 = i * BYTES_PER_NODE / 4;\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tconst boundsIndex = BOUNDING_DATA_INDEX( nodeIndex32 );\n\t\tfor ( let b = 0; b < 3; b ++ ) {\n\n\t\t\tboundsArray[ 8 * i + 0 + b ] = float32Array[ boundsIndex + 0 + b ];\n\t\t\tboundsArray[ 8 * i + 4 + b ] = float32Array[ boundsIndex + 3 + b ];\n\n\t\t}\n\n\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\n\t\t\tconst mergedLeafCount = 0xffff0000 | count;\n\t\t\tcontentsArray[ i * 2 + 0 ] = mergedLeafCount;\n\t\t\tcontentsArray[ i * 2 + 1 ] = offset;\n\n\t\t} else {\n\n\t\t\tconst rightIndex = 4 * RIGHT_NODE( nodeIndex32, uint32Array ) / BYTES_PER_NODE;\n\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\n\t\t\tcontentsArray[ i * 2 + 0 ] = splitAxis;\n\t\t\tcontentsArray[ i * 2 + 1 ] = rightIndex;\n\n\t\t}\n\n\t}\n\n\tboundsTexture.image.data = boundsArray;\n\tboundsTexture.image.width = boundsDimension;\n\tboundsTexture.image.height = boundsDimension;\n\tboundsTexture.format = RGBAFormat;\n\tboundsTexture.type = FloatType;\n\tboundsTexture.internalFormat = 'RGBA32F';\n\tboundsTexture.minFilter = NearestFilter;\n\tboundsTexture.magFilter = NearestFilter;\n\tboundsTexture.generateMipmaps = false;\n\tboundsTexture.needsUpdate = true;\n\tboundsTexture.dispose();\n\n\tcontentsTexture.image.data = contentsArray;\n\tcontentsTexture.image.width = contentsDimension;\n\tcontentsTexture.image.height = contentsDimension;\n\tcontentsTexture.format = RGIntegerFormat;\n\tcontentsTexture.type = UnsignedIntType;\n\tcontentsTexture.internalFormat = 'RG32UI';\n\tcontentsTexture.minFilter = NearestFilter;\n\tcontentsTexture.magFilter = NearestFilter;\n\tcontentsTexture.generateMipmaps = false;\n\tcontentsTexture.needsUpdate = true;\n\tcontentsTexture.dispose();\n\n}\n","import {\n\tDataTexture,\n\tFloatType,\n\tIntType,\n\tUnsignedIntType,\n\tByteType,\n\tUnsignedByteType,\n\tShortType,\n\tUnsignedShortType,\n\n\tRedFormat,\n\tRGFormat,\n\tRGBAFormat,\n\n\tRedIntegerFormat,\n\tRGIntegerFormat,\n\tRGBAIntegerFormat,\n\n\tNearestFilter,\n} from 'three';\n\nfunction countToStringFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return 'R';\n\t\tcase 2: return 'RG';\n\t\tcase 3: return 'RGBA';\n\t\tcase 4: return 'RGBA';\n\n\t}\n\n\tthrow new Error();\n\n}\n\nfunction countToFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedFormat;\n\t\tcase 2: return RGFormat;\n\t\tcase 3: return RGBAFormat;\n\t\tcase 4: return RGBAFormat;\n\n\t}\n\n}\n\nfunction countToIntFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedIntegerFormat;\n\t\tcase 2: return RGIntegerFormat;\n\t\tcase 3: return RGBAIntegerFormat;\n\t\tcase 4: return RGBAIntegerFormat;\n\n\t}\n\n}\n\nexport class VertexAttributeTexture extends DataTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.minFilter = NearestFilter;\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.generateMipmaps = false;\n\t\tthis.overrideItemSize = null;\n\t\tthis._forcedType = null;\n\n\t}\n\n\tupdateFrom( attr ) {\n\n\t\tconst overrideItemSize = this.overrideItemSize;\n\t\tconst originalItemSize = attr.itemSize;\n\t\tconst originalCount = attr.count;\n\t\tif ( overrideItemSize !== null ) {\n\n\t\t\tif ( ( originalItemSize * originalCount ) % overrideItemSize !== 0.0 ) {\n\n\t\t\t\tthrow new Error( 'VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.' );\n\n\t\t\t}\n\n\t\t\tattr.itemSize = overrideItemSize;\n\t\t\tattr.count = originalCount * originalItemSize / overrideItemSize;\n\n\t\t}\n\n\t\tconst itemSize = attr.itemSize;\n\t\tconst count = attr.count;\n\t\tconst normalized = attr.normalized;\n\t\tconst originalBufferCons = attr.array.constructor;\n\t\tconst byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n\t\tlet targetType = this._forcedType;\n\t\tlet finalStride = itemSize;\n\n\t\t// derive the type of texture this should be in the shader\n\t\tif ( targetType === null ) {\n\n\t\t\tswitch ( originalBufferCons ) {\n\n\t\t\t\tcase Float32Array:\n\t\t\t\t\ttargetType = FloatType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Uint8Array:\n\t\t\t\tcase Uint16Array:\n\t\t\t\tcase Uint32Array:\n\t\t\t\t\ttargetType = UnsignedIntType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Int8Array:\n\t\t\t\tcase Int16Array:\n\t\t\t\tcase Int32Array:\n\t\t\t\t\ttargetType = IntType;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get the target format to store the texture as\n\t\tlet type, format, normalizeValue, targetBufferCons;\n\t\tlet internalFormat = countToStringFormat( itemSize );\n\t\tswitch ( targetType ) {\n\n\t\t\tcase FloatType:\n\t\t\t\tnormalizeValue = 1.0;\n\t\t\t\tformat = countToFormat( itemSize );\n\n\t\t\t\tif ( normalized && byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = originalBufferCons;\n\t\t\t\t\tinternalFormat += '8';\n\n\t\t\t\t\tif ( originalBufferCons === Uint8Array ) {\n\n\t\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttype = ByteType;\n\t\t\t\t\t\tinternalFormat += '_SNORM';\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Float32Array;\n\t\t\t\t\tinternalFormat += '32F';\n\t\t\t\t\ttype = FloatType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase IntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'I';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Int8Array;\n\t\t\t\t\ttype = ByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Int16Array;\n\t\t\t\t\ttype = ShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Int32Array;\n\t\t\t\t\ttype = IntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase UnsignedIntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'UI';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint8Array;\n\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint16Array;\n\t\t\t\t\ttype = UnsignedShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Uint32Array;\n\t\t\t\t\ttype = UnsignedIntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t// there will be a mismatch between format length and final length because\n\t\t// RGBFormat and RGBIntegerFormat was removed\n\t\tif ( finalStride === 3 && ( format === RGBAFormat || format === RGBAIntegerFormat ) ) {\n\n\t\t\tfinalStride = 4;\n\n\t\t}\n\n\t\t// copy the data over to the new texture array\n\t\tconst dimension = Math.ceil( Math.sqrt( count ) ) || 1;\n\t\tconst length = finalStride * dimension * dimension;\n\t\tconst dataArray = new targetBufferCons( length );\n\n\t\t// temporarily set the normalized state to false since we have custom normalization logic\n\t\tconst originalNormalized = attr.normalized;\n\t\tattr.normalized = false;\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tconst ii = finalStride * i;\n\t\t\tdataArray[ ii ] = attr.getX( i ) / normalizeValue;\n\n\t\t\tif ( itemSize >= 2 ) {\n\n\t\t\t\tdataArray[ ii + 1 ] = attr.getY( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 3 ) {\n\n\t\t\t\tdataArray[ ii + 2 ] = attr.getZ( i ) / normalizeValue;\n\n\t\t\t\tif ( finalStride === 4 ) {\n\n\t\t\t\t\tdataArray[ ii + 3 ] = 1.0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 4 ) {\n\n\t\t\t\tdataArray[ ii + 3 ] = attr.getW( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t}\n\n\t\tattr.normalized = originalNormalized;\n\n\t\tthis.internalFormat = internalFormat;\n\t\tthis.format = format;\n\t\tthis.type = type;\n\t\tthis.image.width = dimension;\n\t\tthis.image.height = dimension;\n\t\tthis.image.data = dataArray;\n\t\tthis.needsUpdate = true;\n\t\tthis.dispose();\n\n\t\tattr.itemSize = originalItemSize;\n\t\tattr.count = originalCount;\n\n\t}\n\n}\n\nexport class UIntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = UnsignedIntType;\n\n\t}\n\n}\n\nexport class IntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = IntType;\n\n\t}\n\n\n}\n\nexport class FloatVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = FloatType;\n\n\t}\n\n}\n","import { DataTexture, RGBAFormat, ClampToEdgeWrapping, FloatType, FrontSide, BackSide, DoubleSide, NearestFilter } from 'three';\nimport { getTextureHash } from '../core/utils/sceneUpdateUtils.js';\nimport { bufferToHash } from '../utils/bufferToHash.js';\n\nexport const MATERIAL_PIXELS = 47;\nconst MATERIAL_STRIDE = MATERIAL_PIXELS * 4;\n\nclass MaterialFeatures {\n\n\tconstructor() {\n\n\t\tthis._features = {};\n\n\t}\n\n\tisUsed( feature ) {\n\n\t\treturn feature in this._features;\n\n\t}\n\n\tsetUsed( feature, used = true ) {\n\n\t\tif ( used === false ) {\n\n\t\t\tdelete this._features[ feature ];\n\n\t\t} else {\n\n\t\t\tthis._features[ feature ] = true;\n\n\t\t}\n\n\t}\n\n\treset() {\n\n\t\tthis._features = {};\n\n\t}\n\n}\n\nexport class MaterialsTexture extends DataTexture {\n\n\tconstructor() {\n\n\t\tsuper( new Float32Array( 4 ), 1, 1 );\n\n\t\tthis.format = RGBAFormat;\n\t\tthis.type = FloatType;\n\t\tthis.wrapS = ClampToEdgeWrapping;\n\t\tthis.wrapT = ClampToEdgeWrapping;\n\t\tthis.minFilter = NearestFilter;\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.generateMipmaps = false;\n\t\tthis.features = new MaterialFeatures();\n\n\t}\n\n\tupdateFrom( materials, textures ) {\n\n\t\tfunction getTexture( material, key, def = - 1 ) {\n\n\t\t\tif ( key in material && material[ key ] ) {\n\n\t\t\t\tconst hash = getTextureHash( material[ key ] );\n\t\t\t\treturn textureLookUp[ hash ];\n\n\t\t\t} else {\n\n\t\t\t\treturn def;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getField( material, key, def ) {\n\n\t\t\treturn key in material ? material[ key ] : def;\n\n\t\t}\n\n\t\tfunction writeTextureMatrixToArray( material, textureKey, array, offset ) {\n\n\t\t\tconst texture = material[ textureKey ] && material[ textureKey ].isTexture ? material[ textureKey ] : null;\n\n\t\t\t// check if texture exists\n\t\t\tif ( texture ) {\n\n\t\t\t\tif ( texture.matrixAutoUpdate ) {\n\n\t\t\t\t\ttexture.updateMatrix();\n\n\t\t\t\t}\n\n\t\t\t\tconst elements = texture.matrix.elements;\n\n\t\t\t\tlet i = 0;\n\n\t\t\t\t// first row\n\t\t\t\tarray[ offset + i ++ ] = elements[ 0 ];\n\t\t\t\tarray[ offset + i ++ ] = elements[ 3 ];\n\t\t\t\tarray[ offset + i ++ ] = elements[ 6 ];\n\t\t\t\ti ++;\n\n\t\t\t\t// second row\n\t\t\t\tarray[ offset + i ++ ] = elements[ 1 ];\n\t\t\t\tarray[ offset + i ++ ] = elements[ 4 ];\n\t\t\t\tarray[ offset + i ++ ] = elements[ 7 ];\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn 8;\n\n\t\t}\n\n\t\tlet index = 0;\n\t\tconst pixelCount = materials.length * MATERIAL_PIXELS;\n\t\tconst dimension = Math.ceil( Math.sqrt( pixelCount ) ) || 1;\n\t\tconst { image, features } = this;\n\n\t\t// index the list of textures based on shareable source\n\t\tconst textureLookUp = {};\n\t\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\n\n\t\t\ttextureLookUp[ getTextureHash( textures[ i ] ) ] = i;\n\n\t\t}\n\n\t\tif ( image.width !== dimension ) {\n\n\t\t\tthis.dispose();\n\n\t\t\timage.data = new Float32Array( dimension * dimension * 4 );\n\t\t\timage.width = dimension;\n\t\t\timage.height = dimension;\n\n\t\t}\n\n\t\tconst floatArray = image.data;\n\n\t\t// on some devices (Google Pixel 6) the \"floatBitsToInt\" function does not work correctly so we\n\t\t// can't encode texture ids that way.\n\t\t// const intArray = new Int32Array( floatArray.buffer );\n\n\t\tfeatures.reset();\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tconst m = materials[ i ];\n\n\t\t\tif ( m.isFogVolumeMaterial ) {\n\n\t\t\t\tfeatures.setUsed( 'FOG' );\n\n\t\t\t\tfor ( let j = 0; j < MATERIAL_STRIDE; j ++ ) {\n\n\t\t\t\t\tfloatArray[ index + j ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// sample 0 .rgb\n\t\t\t\tfloatArray[ index + 0 * 4 + 0 ] = m.color.r;\n\t\t\t\tfloatArray[ index + 0 * 4 + 1 ] = m.color.g;\n\t\t\t\tfloatArray[ index + 0 * 4 + 2 ] = m.color.b;\n\n\t\t\t\t// sample 2 .a\n\t\t\t\tfloatArray[ index + 2 * 4 + 3 ] = getField( m, 'emissiveIntensity', 0.0 );\n\n\t\t\t\t// sample 3 .rgb\n\t\t\t\tfloatArray[ index + 3 * 4 + 0 ] = m.emissive.r;\n\t\t\t\tfloatArray[ index + 3 * 4 + 1 ] = m.emissive.g;\n\t\t\t\tfloatArray[ index + 3 * 4 + 2 ] = m.emissive.b;\n\n\t\t\t\t// sample 13 .g\n\t\t\t\t// reusing opacity field\n\t\t\t\tfloatArray[ index + 13 * 4 + 1 ] = m.density;\n\n\t\t\t\t// side\n\t\t\t\tfloatArray[ index + 13 * 4 + 3 ] = 0.0;\n\n\t\t\t\t// sample 14 .b\n\t\t\t\tfloatArray[ index + 14 * 4 + 2 ] = 1 << 2;\n\n\t\t\t\tindex += MATERIAL_STRIDE;\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// sample 0\n\t\t\t// color\n\t\t\tfloatArray[ index ++ ] = m.color.r;\n\t\t\tfloatArray[ index ++ ] = m.color.g;\n\t\t\tfloatArray[ index ++ ] = m.color.b;\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'map' );\n\n\t\t\t// sample 1\n\t\t\t// metalness & roughness\n\t\t\tfloatArray[ index ++ ] = getField( m, 'metalness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'metalnessMap' );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'roughness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'roughnessMap' );\n\n\t\t\t// sample 2\n\t\t\t// transmission & emissiveIntensity\n\t\t\t// three.js assumes a default f0 of 0.04 if no ior is provided which equates to an ior of 1.5\n\t\t\tfloatArray[ index ++ ] = getField( m, 'ior', 1.5 );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'transmission', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'transmissionMap' );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'emissiveIntensity', 0.0 );\n\n\t\t\t// sample 3\n\t\t\t// emission\n\t\t\tif ( 'emissive' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.r;\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.g;\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.b;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\n\t\t\t}\n\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'emissiveMap' );\n\n\t\t\t// sample 4\n\t\t\t// normals\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'normalMap' );\n\t\t\tif ( 'normalScale' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.normalScale.x;\n\t\t\t\tfloatArray[ index ++ ] = m.normalScale.y;\n\n \t\t\t} else {\n\n \t\t\t\tfloatArray[ index ++ ] = 1;\n \t\t\t\tfloatArray[ index ++ ] = 1;\n\n \t\t\t}\n\n\t\t\t// clearcoat\n\t\t\tfloatArray[ index ++ ] = getField( m, 'clearcoat', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatMap' ); // sample 5\n\n\t\t\tfloatArray[ index ++ ] = getField( m, 'clearcoatRoughness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatRoughnessMap' );\n\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatNormalMap' );\n\n\t\t\t// sample 6\n\t\t\tif ( 'clearcoatNormalScale' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.clearcoatNormalScale.x;\n\t\t\t\tfloatArray[ index ++ ] = m.clearcoatNormalScale.y;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 1;\n\t\t\t\tfloatArray[ index ++ ] = 1;\n\n\t\t\t}\n\n\t\t\tindex ++;\n\t\t\tfloatArray[ index ++ ] = getField( m, 'sheen', 0.0 );\n\n\t\t\t// sample 7\n\t\t\t// sheen\n\t\t\tif ( 'sheenColor' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.r;\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.g;\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.b;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\n\t\t\t}\n\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'sheenColorMap' );\n\n\t\t\t// sample 8\n\t\t\tfloatArray[ index ++ ] = getField( m, 'sheenRoughness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'sheenRoughnessMap' );\n\n\t\t\t// iridescence\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'iridescenceMap' );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'iridescenceThicknessMap' );\n\n\t\t\t// sample 9\n\t\t\tfloatArray[ index ++ ] = getField( m, 'iridescence', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'iridescenceIOR', 1.3 );\n\n\t\t\tconst iridescenceThicknessRange = getField( m, 'iridescenceThicknessRange', [ 100, 400 ] );\n\t\t\tfloatArray[ index ++ ] = iridescenceThicknessRange[ 0 ];\n\t\t\tfloatArray[ index ++ ] = iridescenceThicknessRange[ 1 ];\n\n\t\t\t// sample 10\n\t\t\t// specular color\n\t\t\tif ( 'specularColor' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.r;\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.g;\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.b;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\n\t\t\t}\n\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'specularColorMap' );\n\n\t\t\t// sample 11\n\t\t\t// specular intensity\n\t\t\tfloatArray[ index ++ ] = getField( m, 'specularIntensity', 1.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'specularIntensityMap' );\n\n\t\t\t// isThinFilm\n\t\t\tconst isThinFilm = getField( m, 'thickness', 0.0 ) === 0.0 && getField( m, 'attenuationDistance', Infinity ) === Infinity;\n\t\t\tfloatArray[ index ++ ] = Number( isThinFilm );\n\t\t\tindex ++;\n\n\t\t\t// sample 12\n\t\t\tif ( 'attenuationColor' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.r;\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.g;\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.b;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\n\t\t\t}\n\n\t\t\tfloatArray[ index ++ ] = getField( m, 'attenuationDistance', Infinity );\n\n\t\t\t// sample 13\n\t\t\t// alphaMap\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'alphaMap' );\n\n\t\t\t// side & matte\n\t\t\tfloatArray[ index ++ ] = m.opacity;\n\t\t\tfloatArray[ index ++ ] = m.alphaTest;\n\t\t\tif ( ! isThinFilm && m.transmission > 0.0 ) {\n\n\t\t\t\tfloatArray[ index ++ ] = 0;\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( m.side ) {\n\n\t\t\t\tcase FrontSide:\n\t\t\t\t\tfloatArray[ index ++ ] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BackSide:\n\t\t\t\t\tfloatArray[ index ++ ] = - 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DoubleSide:\n\t\t\t\t\tfloatArray[ index ++ ] = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// sample 14\n\t\t\tfloatArray[ index ++ ] = Number( getField( m, 'matte', false ) ); // matte\n\t\t\tfloatArray[ index ++ ] = Number( getField( m, 'castShadow', true ) ); // shadow\n\t\t\tfloatArray[ index ++ ] = Number( m.vertexColors ) | ( Number( m.flatShading ) << 1 ); // vertexColors & flatShading\n\t\t\tfloatArray[ index ++ ] = Number( m.transparent ); // transparent\n\n\t\t\t// map transform 15\n\t\t\tindex += writeTextureMatrixToArray( m, 'map', floatArray, index );\n\n\t\t\t// metalnessMap transform 17\n\t\t\tindex += writeTextureMatrixToArray( m, 'metalnessMap', floatArray, index );\n\n\t\t\t// roughnessMap transform 19\n\t\t\tindex += writeTextureMatrixToArray( m, 'roughnessMap', floatArray, index );\n\n\t\t\t// transmissionMap transform 21\n\t\t\tindex += writeTextureMatrixToArray( m, 'transmissionMap', floatArray, index );\n\n\t\t\t// emissiveMap transform 22\n\t\t\tindex += writeTextureMatrixToArray( m, 'emissiveMap', floatArray, index );\n\n\t\t\t// normalMap transform 25\n\t\t\tindex += writeTextureMatrixToArray( m, 'normalMap', floatArray, index );\n\n\t\t\t// clearcoatMap transform 27\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatMap', floatArray, index );\n\n\t\t\t// clearcoatNormalMap transform 29\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatNormalMap', floatArray, index );\n\n\t\t\t// clearcoatRoughnessMap transform 31\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatRoughnessMap', floatArray, index );\n\n\t\t\t// sheenColorMap transform 33\n\t\t\tindex += writeTextureMatrixToArray( m, 'sheenColorMap', floatArray, index );\n\n\t\t\t// sheenRoughnessMap transform 35\n\t\t\tindex += writeTextureMatrixToArray( m, 'sheenRoughnessMap', floatArray, index );\n\n\t\t\t// iridescenceMap transform 37\n\t\t\tindex += writeTextureMatrixToArray( m, 'iridescenceMap', floatArray, index );\n\n\t\t\t// iridescenceThicknessMap transform 39\n\t\t\tindex += writeTextureMatrixToArray( m, 'iridescenceThicknessMap', floatArray, index );\n\n\t\t\t// specularColorMap transform 41\n\t\t\tindex += writeTextureMatrixToArray( m, 'specularColorMap', floatArray, index );\n\n\t\t\t// specularIntensityMap transform 43\n\t\t\tindex += writeTextureMatrixToArray( m, 'specularIntensityMap', floatArray, index );\n\n\t\t\t// alphaMap transform 45\n\t\t\tindex += writeTextureMatrixToArray( m, 'alphaMap', floatArray, index );\n\n\t\t}\n\n\t\t// check if the contents have changed\n\t\tconst hash = bufferToHash( floatArray.buffer );\n\t\tif ( this.hash !== hash ) {\n\n\t\t\tthis.hash = hash;\n\t\t\tthis.needsUpdate = true;\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n}\n","function uuidSort( a, b ) {\n\n\tif ( a.uuid < b.uuid ) return 1;\n\tif ( a.uuid > b.uuid ) return - 1;\n\treturn 0;\n\n}\n\n// we must hash the texture to determine uniqueness using the encoding, as well, because the\n// when rendering each texture to the texture array they must have a consistent color space.\nexport function getTextureHash( t ) {\n\n\treturn `${ t.source.uuid }:${ t.colorSpace }`;\n\n}\n\n// reduce the set of textures to just those with a unique source while retaining\n// the order of the textures.\nfunction reduceTexturesToUniqueSources( textures ) {\n\n\tconst sourceSet = new Set();\n\tconst result = [];\n\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\n\n\t\tconst tex = textures[ i ];\n\t\tconst hash = getTextureHash( tex );\n\t\tif ( ! sourceSet.has( hash ) ) {\n\n\t\t\tsourceSet.add( hash );\n\t\t\tresult.push( tex );\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\nexport function getIesTextures( lights ) {\n\n\tconst textures = lights.map( l => l.iesMap || null ).filter( t => t );\n\tconst textureSet = new Set( textures );\n\treturn Array.from( textureSet ).sort( uuidSort );\n\n}\n\nexport function getTextures( materials ) {\n\n\tconst textureSet = new Set();\n\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\tconst material = materials[ i ];\n\t\tfor ( const key in material ) {\n\n\t\t\tconst value = material[ key ];\n\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\ttextureSet.add( value );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst textureArray = Array.from( textureSet );\n\treturn reduceTexturesToUniqueSources( textureArray ).sort( uuidSort );\n\n}\n\nexport function getLights( scene ) {\n\n\tconst lights = [];\n\tscene.traverse( c => {\n\n\t\tif ( c.visible ) {\n\n\t\t\tif (\n\t\t\t\tc.isRectAreaLight ||\n\t\t\t\tc.isSpotLight ||\n\t\t\t\tc.isPointLight ||\n\t\t\t\tc.isDirectionalLight\n\t\t\t) {\n\n\t\t\t\tlights.push( c );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn lights.sort( uuidSort );\n\n}\n","export const material_struct = /* glsl */ `\n\n\tstruct Material {\n\n\t\tvec3 color;\n\t\tint map;\n\n\t\tfloat metalness;\n\t\tint metalnessMap;\n\n\t\tfloat roughness;\n\t\tint roughnessMap;\n\n\t\tfloat ior;\n\t\tfloat transmission;\n\t\tint transmissionMap;\n\n\t\tfloat emissiveIntensity;\n\t\tvec3 emissive;\n\t\tint emissiveMap;\n\n\t\tint normalMap;\n\t\tvec2 normalScale;\n\n\t\tfloat clearcoat;\n\t\tint clearcoatMap;\n\t\tint clearcoatNormalMap;\n\t\tvec2 clearcoatNormalScale;\n\t\tfloat clearcoatRoughness;\n\t\tint clearcoatRoughnessMap;\n\n\t\tint iridescenceMap;\n\t\tint iridescenceThicknessMap;\n\t\tfloat iridescence;\n\t\tfloat iridescenceIor;\n\t\tfloat iridescenceThicknessMinimum;\n\t\tfloat iridescenceThicknessMaximum;\n\n\t\tvec3 specularColor;\n\t\tint specularColorMap;\n\n\t\tfloat specularIntensity;\n\t\tint specularIntensityMap;\n\t\tbool thinFilm;\n\n\t\tvec3 attenuationColor;\n\t\tfloat attenuationDistance;\n\n\t\tint alphaMap;\n\n\t\tbool castShadow;\n\t\tfloat opacity;\n\t\tfloat alphaTest;\n\n\t\tfloat side;\n\t\tbool matte;\n\n\t\tfloat sheen;\n\t\tvec3 sheenColor;\n\t\tint sheenColorMap;\n\t\tfloat sheenRoughness;\n\t\tint sheenRoughnessMap;\n\n\t\tbool vertexColors;\n\t\tbool flatShading;\n\t\tbool transparent;\n\t\tbool fogVolume;\n\n\t\tmat3 mapTransform;\n\t\tmat3 metalnessMapTransform;\n\t\tmat3 roughnessMapTransform;\n\t\tmat3 transmissionMapTransform;\n\t\tmat3 emissiveMapTransform;\n\t\tmat3 normalMapTransform;\n\t\tmat3 clearcoatMapTransform;\n\t\tmat3 clearcoatNormalMapTransform;\n\t\tmat3 clearcoatRoughnessMapTransform;\n\t\tmat3 sheenColorMapTransform;\n\t\tmat3 sheenRoughnessMapTransform;\n\t\tmat3 iridescenceMapTransform;\n\t\tmat3 iridescenceThicknessMapTransform;\n\t\tmat3 specularColorMapTransform;\n\t\tmat3 specularIntensityMapTransform;\n\t\tmat3 alphaMapTransform;\n\n\t};\n\n\tmat3 readTextureTransform( sampler2D tex, uint index ) {\n\n\t\tmat3 textureTransform;\n\n\t\tvec4 row1 = texelFetch1D( tex, index );\n\t\tvec4 row2 = texelFetch1D( tex, index + 1u );\n\n\t\ttextureTransform[0] = vec3(row1.r, row2.r, 0.0);\n\t\ttextureTransform[1] = vec3(row1.g, row2.g, 0.0);\n\t\ttextureTransform[2] = vec3(row1.b, row2.b, 1.0);\n\n\t\treturn textureTransform;\n\n\t}\n\n\tMaterial readMaterialInfo( sampler2D tex, uint index ) {\n\n\t\tuint i = index * uint( MATERIAL_PIXELS );\n\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\n\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\n\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\n\t\tvec4 s6 = texelFetch1D( tex, i + 6u );\n\t\tvec4 s7 = texelFetch1D( tex, i + 7u );\n\t\tvec4 s8 = texelFetch1D( tex, i + 8u );\n\t\tvec4 s9 = texelFetch1D( tex, i + 9u );\n\t\tvec4 s10 = texelFetch1D( tex, i + 10u );\n\t\tvec4 s11 = texelFetch1D( tex, i + 11u );\n\t\tvec4 s12 = texelFetch1D( tex, i + 12u );\n\t\tvec4 s13 = texelFetch1D( tex, i + 13u );\n\t\tvec4 s14 = texelFetch1D( tex, i + 14u );\n\n\t\tMaterial m;\n\t\tm.color = s0.rgb;\n\t\tm.map = int( round( s0.a ) );\n\n\t\tm.metalness = s1.r;\n\t\tm.metalnessMap = int( round( s1.g ) );\n\t\tm.roughness = s1.b;\n\t\tm.roughnessMap = int( round( s1.a ) );\n\n\t\tm.ior = s2.r;\n\t\tm.transmission = s2.g;\n\t\tm.transmissionMap = int( round( s2.b ) );\n\t\tm.emissiveIntensity = s2.a;\n\n\t\tm.emissive = s3.rgb;\n\t\tm.emissiveMap = int( round( s3.a ) );\n\n\t\tm.normalMap = int( round( s4.r ) );\n\t\tm.normalScale = s4.gb;\n\n\t\tm.clearcoat = s4.a;\n\t\tm.clearcoatMap = int( round( s5.r ) );\n\t\tm.clearcoatRoughness = s5.g;\n\t\tm.clearcoatRoughnessMap = int( round( s5.b ) );\n\t\tm.clearcoatNormalMap = int( round( s5.a ) );\n\t\tm.clearcoatNormalScale = s6.rg;\n\n\t\tm.sheen = s6.a;\n\t\tm.sheenColor = s7.rgb;\n\t\tm.sheenColorMap = int( round( s7.a ) );\n\t\tm.sheenRoughness = s8.r;\n\t\tm.sheenRoughnessMap = int( round( s8.g ) );\n\n\t\tm.iridescenceMap = int( round( s8.b ) );\n\t\tm.iridescenceThicknessMap = int( round( s8.a ) );\n\t\tm.iridescence = s9.r;\n\t\tm.iridescenceIor = s9.g;\n\t\tm.iridescenceThicknessMinimum = s9.b;\n\t\tm.iridescenceThicknessMaximum = s9.a;\n\n\t\tm.specularColor = s10.rgb;\n\t\tm.specularColorMap = int( round( s10.a ) );\n\n\t\tm.specularIntensity = s11.r;\n\t\tm.specularIntensityMap = int( round( s11.g ) );\n\t\tm.thinFilm = bool( s11.b );\n\n\t\tm.attenuationColor = s12.rgb;\n\t\tm.attenuationDistance = s12.a;\n\n\t\tm.alphaMap = int( round( s13.r ) );\n\n\t\tm.opacity = s13.g;\n\t\tm.alphaTest = s13.b;\n\t\tm.side = s13.a;\n\n\t\tm.matte = bool( s14.r );\n\t\tm.castShadow = bool( s14.g );\n\t\tm.vertexColors = bool( int( s14.b ) & 1 );\n\t\tm.flatShading = bool( int( s14.b ) & 2 );\n\t\tm.fogVolume = bool( int( s14.b ) & 4 );\n\t\tm.transparent = bool( s14.a );\n\n\t\tuint firstTextureTransformIdx = i + 15u;\n\n\t\t// mat3( 1.0 ) is an identity matrix\n\t\tm.mapTransform = m.map == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx );\n\t\tm.metalnessMapTransform = m.metalnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 2u );\n\t\tm.roughnessMapTransform = m.roughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 4u );\n\t\tm.transmissionMapTransform = m.transmissionMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 6u );\n\t\tm.emissiveMapTransform = m.emissiveMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 8u );\n\t\tm.normalMapTransform = m.normalMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 10u );\n\t\tm.clearcoatMapTransform = m.clearcoatMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 12u );\n\t\tm.clearcoatNormalMapTransform = m.clearcoatNormalMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 14u );\n\t\tm.clearcoatRoughnessMapTransform = m.clearcoatRoughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 16u );\n\t\tm.sheenColorMapTransform = m.sheenColorMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 18u );\n\t\tm.sheenRoughnessMapTransform = m.sheenRoughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 20u );\n\t\tm.iridescenceMapTransform = m.iridescenceMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 22u );\n\t\tm.iridescenceThicknessMapTransform = m.iridescenceThicknessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 24u );\n\t\tm.specularColorMapTransform = m.specularColorMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 26u );\n\t\tm.specularIntensityMapTransform = m.specularIntensityMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 28u );\n\t\tm.alphaMapTransform = m.alphaMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 30u );\n\n\t\treturn m;\n\n\t}\n\n`;\n","export const shape_sampling_functions = /* glsl */`\n\n\tvec3 sampleHemisphere( vec3 n, vec2 uv ) {\n\n\t\t// https://www.rorydriscoll.com/2009/01/07/better-sampling/\n\t\t// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n\t\tfloat sign = n.z == 0.0 ? 1.0 : sign( n.z );\n\t\tfloat a = - 1.0 / ( sign + n.z );\n\t\tfloat b = n.x * n.y * a;\n\t\tvec3 b1 = vec3( 1.0 + sign * n.x * n.x * a, sign * b, - sign * n.x );\n\t\tvec3 b2 = vec3( b, sign + n.y * n.y * a, - n.y );\n\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat theta = 2.0 * PI * uv.y;\n\t\tfloat x = r * cos( theta );\n\t\tfloat y = r * sin( theta );\n\t\treturn x * b1 + y * b2 + sqrt( 1.0 - uv.x ) * n;\n\n\t}\n\n\tvec2 sampleTriangle( vec2 a, vec2 b, vec2 c, vec2 r ) {\n\n\t\t// get the edges of the triangle and the diagonal across the\n\t\t// center of the parallelogram\n\t\tvec2 e1 = a - b;\n\t\tvec2 e2 = c - b;\n\t\tvec2 diag = normalize( e1 + e2 );\n\n\t\t// pick the point in the parallelogram\n\t\tif ( r.x + r.y > 1.0 ) {\n\n\t\t\tr = vec2( 1.0 ) - r;\n\n\t\t}\n\n\t\treturn e1 * r.x + e2 * r.y;\n\n\t}\n\n\tvec2 sampleCircle( vec2 uv ) {\n\n\t\tfloat angle = 2.0 * PI * uv.x;\n\t\tfloat radius = sqrt( uv.y );\n\t\treturn vec2( cos( angle ), sin( angle ) ) * radius;\n\n\t}\n\n\tvec3 sampleSphere( vec2 uv ) {\n\n\t\tfloat u = ( uv.x - 0.5 ) * 2.0;\n\t\tfloat t = uv.y * PI * 2.0;\n\t\tfloat f = sqrt( 1.0 - u * u );\n\n\t\treturn vec3( f * cos( t ), f * sin( t ), u );\n\n\t}\n\n\tvec2 sampleRegularPolygon( int sides, vec3 uvw ) {\n\n\t\tsides = max( sides, 3 );\n\n\t\tvec3 r = uvw;\n\t\tfloat anglePerSegment = 2.0 * PI / float( sides );\n\t\tfloat segment = floor( float( sides ) * r.x );\n\n\t\tfloat angle1 = anglePerSegment * segment;\n\t\tfloat angle2 = angle1 + anglePerSegment;\n\t\tvec2 a = vec2( sin( angle1 ), cos( angle1 ) );\n\t\tvec2 b = vec2( 0.0, 0.0 );\n\t\tvec2 c = vec2( sin( angle2 ), cos( angle2 ) );\n\n\t\treturn sampleTriangle( a, b, c, r.yz );\n\n\t}\n\n\t// samples an aperture shape with the given number of sides. 0 means circle\n\tvec2 sampleAperture( int blades, vec3 uvw ) {\n\n\t\treturn blades == 0 ?\n\t\t\tsampleCircle( uvw.xy ) :\n\t\t\tsampleRegularPolygon( blades, uvw );\n\n\t}\n\n\n`;\n","export const pcg_functions = /* glsl */`\n\n\t// https://www.shadertoy.com/view/wltcRS\n\tuvec4 WHITE_NOISE_SEED;\n\n\tvoid rng_initialize( vec2 p, int frame ) {\n\n\t\t// white noise seed\n\t\tWHITE_NOISE_SEED = uvec4( p, uint( frame ), uint( p.x ) + uint( p.y ) );\n\n\t}\n\n\t// https://www.pcg-random.org/\n\tvoid pcg4d( inout uvec4 v ) {\n\n\t\tv = v * 1664525u + 1013904223u;\n\t\tv.x += v.y * v.w;\n\t\tv.y += v.z * v.x;\n\t\tv.z += v.x * v.y;\n\t\tv.w += v.y * v.z;\n\t\tv = v ^ ( v >> 16u );\n\t\tv.x += v.y*v.w;\n\t\tv.y += v.z*v.x;\n\t\tv.z += v.x*v.y;\n\t\tv.w += v.y*v.z;\n\n\t}\n\n\t// returns [ 0, 1 ]\n\tfloat pcgRand() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn float( WHITE_NOISE_SEED.x ) / float( 0xffffffffu );\n\n\t}\n\n\tvec2 pcgRand2() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec2( WHITE_NOISE_SEED.xy ) / float(0xffffffffu);\n\n\t}\n\n\tvec3 pcgRand3() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec3( WHITE_NOISE_SEED.xyz ) / float( 0xffffffffu );\n\n\t}\n\n\tvec4 pcgRand4() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec4( WHITE_NOISE_SEED ) / float( 0xffffffffu );\n\n\t}\n`;\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$exportWildcard","dest","source","keys","forEach","key","prototype","hasOwnProperty","call","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","err","Error","code","register","parcelRegister","$0a1d3a5a6a49de03$export$3983474c8e6e978b","$ilwiq","$0a1d3a5a6a49de03$var$_camera","OrthographicCamera","$0a1d3a5a6a49de03$var$FullscreenTriangleGeometry","BufferGeometry","constructor","setAttribute","Float32BufferAttribute","$0a1d3a5a6a49de03$var$_geometry","material","_mesh","Mesh","dispose","geometry","render","renderer","value","$d0f6adfc7402c638$export$245b5237bb7038ea","$6KVZ3","$alNGj","$dCCOj","$8LUnK","initialized","Boolean","bvh","objects","bvhOptions","attributes","generateBVH","staticGeometryGenerator","StaticGeometryGenerator","_bvhWorker","_pendingGenerate","_buildAsync","_materialUuids","setObjects","setBVHWorker","bvhWorker","generateAsync","onProgress","Promise","result","generate","o","traverse","c","isSkinnedMesh","skeleton","update","materials","needsMaterialIndexUpdate","changeType","NO_CHANGE","length","i","length1","uuid","textures","$d0f6adfc7402c638$var$getTextures","textureSet","Set","l","isTexture","add","Array","from","lights","iesTextures","$d0f6adfc7402c638$var$getLights","iesSet","visible","isRectAreaLight","isSpotLight","isPointLight","isDirectionalLight","push","iesMap","sort","a","b","updateMaterialIndexAttribute","map","GEOMETRY_REBUILT","strategy","SAH","maxLeafTris","indirect","MeshBVH","GEOMETRY_ADJUSTED","refit","bvhChanged","$4eb4044e12c26831$export$9d614b3bc2c4eacf","$knbvI","$lenTA","$eADNI","$7EZfU","$8hs00","$8VlEg","$9Kyri","$ayHng","$laUNa","$1SnJR","$dhXUU","$dnRHH","$gDpfV","$iERXt","$kNP8c","$ZxvHI","$bD1WL","$gUrAj","$cSOJe","$dRxiJ","$f1zUR","$4eb4044e12c26831$var$obb","OrientedBox","$4eb4044e12c26831$var$tempBox","Box3","$4eb4044e12c26831$export$93ca5d3f8675ae4c","CENTER","maxDepth","useSharedArrayBuffer","setBoundingBox","verbose","serialize","options","cloneBuffers","rootData","_roots","indirectBuffer","_indirectBuffer","indexAttribute","getIndex","roots","root","slice","index","array","deserialize","data","setIndex","SKIP_GENERATION","newIndex","BufferAttribute","needsUpdate","isBufferGeometry","isInterleavedBufferAttribute","assign","isSharedArrayBufferSupported","buildPackedTree","boundingBox","getBoundingBox","resolveTriangleIndex","nodeIndices","refitFunc","refit_indirect","callback","rootIndex","buffer","uint32Array","Uint32Array","uint16Array","Uint16Array","_traverse","node32Index","depth","node16Index","isLeaf","IS_LEAFNODE_FLAG","offset","count","Float32Array","left","BYTES_PER_NODE","right","splitAxis","raycast","ray","materialOrSide","FrontSide","intersects","isMaterial","isArrayMaterial","isArray","groups","side","raycastFunc","raycast_indirect","materialSide","materialIndex","startCount","j","jl","face","raycastFirst","closestResult","raycastFirstFunc","raycastFirst_indirect","distance","intersectsGeometry","otherGeometry","geomToMesh","intersectsGeometryFunc","intersectsGeometry_indirect","shapecast","callbacks","triangle","ExtendedTrianglePool","getPrimitive","iterateFunc","iterateOverTriangles_indirect","iterateOverTriangles","boundsTraverseOrder","intersectsBounds","intersectsRange","intersectsTriangle","originalIntersectsRange","contained","nodeIndex","byteOffset","byteLength","releasePrimitive","bvhcast","otherBvh","matrixToLocal","intersectsRanges","intersectsTriangles","triangle1","indexAttr1","positionAttr1","position","assignTriangle1","i1","ti","setTriangle","triangle2","indexAttr2","positionAttr2","assignTriangle2","i2","ti2","iterateOverDoubleTriangles","offset1","count1","offset2","count2","depth1","index1","depth2","index2","l2","applyMatrix4","l1","originalIntersectsRanges","intersectsBox","box","boxToMesh","min","max","tri","intersectsSphere","sphere","closestPointToGeometry","geometryToBvh","target1","target2","minThreshold","maxThreshold","Infinity","closestPointToGeometryFunc","closestPointToGeometry_indirect","closestPointToPoint","point","target","makeEmpty","arrayToBox","union","$78926744db4a8a3e$export$91c2158bc24c63d4","$78926744db4a8a3e$export$d3bfe4097a2a8542","$78926744db4a8a3e$export$2b2cc3fb4f03d723","$78926744db4a8a3e$export$82ad94f0a038b67a","$78926744db4a8a3e$export$22e1995328fd3cd9","$78926744db4a8a3e$export$f4b101accf1b23d1","$78926744db4a8a3e$export$a08e7d18fbc53be5","$78926744db4a8a3e$export$661fddb62bfe0e42","$78926744db4a8a3e$export$859129fb5c8f4dc1","$78926744db4a8a3e$export$abef70518a11a6ba","Math","Symbol","$ed4ee2639a9fd94e$export$e63bca57f220b8e3","$5Gkg5","$6zZ33","$4rNvL","$O2f62","$8aRzr","$fe03E","$8yQ90","$ed4ee2639a9fd94e$export$6008de7a0114426c","triCount","useUint32","byteCount","SharedArrayBuffer","ArrayBuffer","hasGroupGaps","console","warn","ensureIndex","BufferConstructor","triangleBounds","computeTriangleBounds","geometryRanges","getFullGeometryRange","getRootIndexRanges","range","$ed4ee2639a9fd94e$export$9896244d8c99a4d0","indexArray","partionFunc","partition_indirect","partition","totalTriangles","getTriCount","cacheCentroidBoundingData","reachedMaxDepth","MeshBVHNode","getBounds","boundingData","splitNode","node","centroidBoundingData","triggerProgress","split","getOptimalSplit","axis","splitOffset","lcount","rcount","trianglesProcessed","nodeCount","countNodes","populateBuffer","$423096e95cd96e19$export$bb010cc24ecaa644","$423096e95cd96e19$export$c56c51fae37b2d63","$423096e95cd96e19$export$62808f0201824da2","$423096e95cd96e19$export$90fd303420808ebb","$423096e95cd96e19$export$8c9d42783264c26e","$423096e95cd96e19$export$fd7a16c461f5043c","$423096e95cd96e19$export$d3cf4eabab21775d","geo","vertexCount","drawRange","start","end","floor","ranges","rangeBoundaries","drawRangeStart","drawRangeEnd","group","groupStart","groupEnd","sortedBoundaries","values","finalGroup","total","$4ca55de292e93eb1$export$becd1e645219fa23","$4ca55de292e93eb1$export$b3cc4d5d5179e78c","centroidTarget","minx","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","posAttr","normalized","posArr","bufferOffset","stride","getters","tri3","tri6","ai","bi","ci","el","halfExtents","el2","abs","FLOAT32_EPSILON","$33d016ef2ae8a9ff$export$9e40712018083c80","$33d016ef2ae8a9ff$var$binsSort","candidate","$33d016ef2ae8a9ff$var$sahBins","fill","bounds","rightCacheBounds","leftCacheBounds","$33d016ef2ae8a9ff$var$leftBounds","nodeBoundingData","pos","getLongestEdgeIndex","AVERAGE","$33d016ef2ae8a9ff$var$getAverage","avg","rootSurfaceArea","computeSurfaceArea","bestCost","TRIANGLE_INTERSECT_COST","cStart","cEnd","axisLeft","binWidth","axisLength","axisRight","$33d016ef2ae8a9ff$var$BIN_COUNT","truncatedBins","bin","d","expandByTriangleBounds","splitCount","splice","center","leftCount","rightCount","leftBounds","rightBounds","leftProb","rightProb","cost","TRAVERSAL_COST","binIndex","relativeCenter","triCenter","lastBin","copyBounds","nextBin","unionBounds","binCount","$a9f34d1ac25848aa$export$40b9a5e446bf11e0","nodeIndex32","x","y","z","$a9f34d1ac25848aa$export$dcdc414399b99746","splitDimIdx","splitDist","dist","$a9f34d1ac25848aa$export$14b050a767b4a3a7","$a9f34d1ac25848aa$export$a8a7063dce01a911","aVal","bVal","d3","$a9f34d1ac25848aa$export$c989e53c4b24c2f5","startIndex","tCenter","tHalf","tMin","tMax","$a9f34d1ac25848aa$export$dbf4320364dc239e","d0","d1","d2","$096668f03fbb5645$export$6f473cc5f89b0a1c","$5f38cfeb5f7666c7$export$b29f828819edca8d","axisOffset","t0","tb","$b1583556301b54a3$export$7cee363d477551d0","t","$63b9f27945e6e48e$var$float32Array","$63b9f27945e6e48e$var$uint32Array","$63b9f27945e6e48e$var$uint16Array","$63b9f27945e6e48e$var$uint8Array","$63b9f27945e6e48e$export$1daf15cbaf649dad","$63b9f27945e6e48e$export$faac1b763a0eceb5","$8x2iv","Uint8Array","$63b9f27945e6e48e$var$_populateBuffer","stride4Offset","stride2Offset","IS_LEAF","nextUnusedPointer","$6363300ccf15b961$export$bc7cbaf27fbe938e","n16","$6363300ccf15b961$export$3231e969238304f3","n32","$6363300ccf15b961$export$d61684373eacdf61","$6363300ccf15b961$export$7a68bc00425859d","$6363300ccf15b961$export$4f44f52d9f75fa31","$6363300ccf15b961$export$b43717b3ca95505","$6363300ccf15b961$export$b5b7e27a1440579d","$f74d70f31e44d1f9$export$4ccecd8ac6ee0e58","$2OKGW","$8VYkb","$f56Km","matrix","isOrientedBox","Vector3","Matrix4","invMatrix","points","satAxes","satBounds","SeparatingAxisBounds","alignedSatBounds","copy","other","minVec","sb","pi","subVectors","setFromPoints","setFromPointsField","invert","aabbBounds","isSeparated","setFromBox","saTri","ExtendedTriangle","pointsArr","cachedSatBounds","cachedSatBounds2","cachedAxis","isExtendedTriangle","sa","triSatBounds","triSatAxes","sa1","sa2","crossVectors","clamp","distanceToPoint","distanceTo","distanceToBox","xyzFields","segments1","Line3","segments2","point1","point2","threshold","getCenter","threshold2","closestDistanceSq","p","distanceToSquared","sqrt","nextIndex","nextIndex2","p1","p2","line1","f1","f2","f3","line2","closestPointsSegmentToSegment","$20d478469c10be0c$export$f758e41ecdcd8e69","field","val","dot","boxMin","boxMax","$681270c6f2e9ebff$export$a37f7ec1c23dfacf","$681270c6f2e9ebff$var$isNearZero","Triangle","args","Sphere","plane","Plane","sphereIntersectTriangle","axis0","sab0","getNormal","axis1","sab1","axis2","sab2","axis3","sab3","setFromNormalAndCoplanarPoint","closestPointToSegment","edge","segment","distSq","nexti","saTri2","arr1","arr2","dir","dir1","dir2","tempDir","edge1","edge2","tempPoint","triIntersectPlane","targetEdge","startPointIntersection","delta","startIntersects","normal","doesIntersect","intersectLine","suppressLog","plane1","plane2","satBounds1","satAxes1","satBounds2","satAxes2","containsPoint","tmp","s1","e1","s2","e2","separated1","distanceToTriangle","cornerFields","lineTarget","otherVec","thisVec","f11","f12","f21","f22","$afac8e64b68760a8$export$b09f296caca7547a","$afac8e64b68760a8$export$eed3a6606b3adc41","$afac8e64b68760a8$export$479eef7c8f1b846c","v02","v0","v2","d0232","d3210","v32","d3232","d0210","denom","d1010","v10","paramResult","Vector2","temp1","temp2","at","closestPoint","closestPoint2","closestPointTemp","projectedPointTemp","planeTemp","lineTemp","radius","closestPoint1","closestPoint3","getPlane","dp","pp","projectPoint","$593bc8ef8d1a55fc$export$2622f4315304edad","$1l8b2","$593bc8ef8d1a55fc$var$ExtendedTrianglePoolBase","PrimitivePool","$0f9e1864656e7fae$export$bf300c504651112a","getNewPrimitive","_getNewPrimitive","_primitives","primitives","pop","primitive","$6075a1513b66f4c0$var$_box1","$6075a1513b66f4c0$var$_box2","$6075a1513b66f4c0$export$963c78622ed2c172","$xqrrD","$6075a1513b66f4c0$var$boxStack","$6075a1513b66f4c0$var$boxPool","BufferStack","setBuffer","$6075a1513b66f4c0$var$shapecastTraverse","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexByteOffset","float32Array","nodeIndex16","OFFSET","COUNT","BOUNDING_DATA_INDEX","score1","score2","box1","box2","c1StopTraversal","c2StopTraversal","LEFT_NODE","RIGHT_NODE","c1","c2","temp","c1Intersection","CONTAINED","getLeftOffset","getRightEndOffset","c2Intersection","clearBuffer","$064797f1cfb48450$export$7451c73ce907854f","stack","prevBuffer","$67f4708097c33efc$export$96ec44700e587d99","$67f4708097c33efc$var$temp","$67f4708097c33efc$var$temp1","minThresholdSq","maxThresholdSq","closestDistanceTriIndex","score","triIndex","closestDistance","clone","faceIndex","$01d4f4206273ed95$export$6f0a8fc5d2775a51","$01d4f4206273ed95$export$4331f2604b0bca4","$01d4f4206273ed95$export$be1391b7aa79c0f6","$7pS02","intersections","intersectTri","res","intersection","intersectsTriangleFunc","$5664c169f49816c4$export$1a557053019a130b","$5664c169f49816c4$var$_vA","$5664c169f49816c4$var$_vB","$5664c169f49816c4$var$_vC","$5664c169f49816c4$var$_uvA","$5664c169f49816c4$var$_uvB","$5664c169f49816c4$var$_uvC","$5664c169f49816c4$var$_normalA","$5664c169f49816c4$var$_normalB","$5664c169f49816c4$var$_normalC","$5664c169f49816c4$var$_intersectionPoint","triOffset","getX","uv","uv1","$5664c169f49816c4$var$checkBufferGeometryIntersection","fromBufferAttribute","intersect","BackSide","intersectTriangle","DoubleSide","origin","getInterpolation","direction","multiplyScalar","$a17a0e7ef0b826e6$export$32f7fa781964ae30","ta","tc","i0","getY","getZ","$7afeb992771d32d5$export$8eb1eda96b2e6d7a","indexArr","force","offsetLeft","offsetRight","forceChildren","includesLeft","includesRight","has","traverseLeft","traverseRight","leftChange","rightChange","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","$f6a695dbb681b4c5$export$630e89aab3ddc1d6","$d4vta","$f6a695dbb681b4c5$var$_raycast","intersectTris","leftIndex","intersectRay","rightIndex","$98440f459aa220f3$export$d5a069a08bb68982","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","ox","oy","oz","isNaN","$15dd3f9915d1b1ff$export$1fa457bc72ef1a2a","$15dd3f9915d1b1ff$var$_xyzFields","$15dd3f9915d1b1ff$var$_raycastFirst","intersectClosestTri","SPLIT_AXIS","xyzAxis","leftToRight","rayDir","c1Result","c2Result","$9acb57256233c065$export$b2f96b0abaf94e0a","$9acb57256233c065$var$boundingBox","$9acb57256233c065$var$triangle","$9acb57256233c065$var$triangle2","$9acb57256233c065$var$invertedMat","$9acb57256233c065$var$obb","$9acb57256233c065$var$obb2","$9acb57256233c065$var$_intersectsGeometry","cachedObb","computeBoundingBox","thisGeometry","thisIndex","thisPos","boundsTree","$9be714d2e19cc068$export$5912902c175a555e","$9be714d2e19cc068$var$tempMatrix","$9be714d2e19cc068$var$obb","$9be714d2e19cc068$var$obb2","$9be714d2e19cc068$var$temp1","$9be714d2e19cc068$var$temp2","$9be714d2e19cc068$var$temp3","$9be714d2e19cc068$var$temp4","otherPos","otherIndex","tempTarget2","tempTargetDest2","closestDistanceOtherTriIndex","otherOffset","otherCount","tempTargetDest1","sub","$c1c3e12524864241$export$7e7412b9f4f11a5c","$c1c3e12524864241$export$dddff414156655a1","$c1c3e12524864241$export$dae1f8efdced590b","vi","$d955d16ddee6d2e4$export$40f4af49b81ca898","$f2500bdd73784d92$export$1999205ebe856279","$f2500bdd73784d92$var$_raycast","intersectTris_indirect","$0b8fb114025d9d97$export$44e48d4cf2fe0609","$0b8fb114025d9d97$var$_xyzFields","$0b8fb114025d9d97$var$_raycastFirst","intersectClosestTri_indirect","$8774d8cede10b4d0$export$80dca0df80ee0084","$8774d8cede10b4d0$var$boundingBox","$8774d8cede10b4d0$var$triangle","$8774d8cede10b4d0$var$triangle2","$8774d8cede10b4d0$var$invertedMat","$8774d8cede10b4d0$var$obb","$8774d8cede10b4d0$var$obb2","$8774d8cede10b4d0$var$_intersectsGeometry","$c4f746093678aa23$export$334b669407b5ec06","$c4f746093678aa23$var$tempMatrix","$c4f746093678aa23$var$obb","$c4f746093678aa23$var$obb2","$c4f746093678aa23$var$temp1","$c4f746093678aa23$var$temp2","$c4f746093678aa23$var$temp3","$c4f746093678aa23$var$temp4","$9611e0cfae405faf$export$9c28fa8114adc339","$9611e0cfae405faf$export$fadff02e9aa23f60","$af02cf38ee8e10da$export$a2253c6980b92559","$af02cf38ee8e10da$var$_bufferStack1","$af02cf38ee8e10da$var$_bufferStack2","$af02cf38ee8e10da$var$_boxPool","$af02cf38ee8e10da$var$_leftBox1","$af02cf38ee8e10da$var$_rightBox1","$af02cf38ee8e10da$var$_leftBox2","$af02cf38ee8e10da$var$_rightBox2","$af02cf38ee8e10da$var$_active","otherRoots","invMat","il","localBox","$af02cf38ee8e10da$var$_traverse","node1Index32","node2Index32","matrix2to1","matrix1to2","intersectsRangesFunc","node1IndexByteOffset","node2IndexByteOffset","currBox","reversed","bufferStack1","bufferStack2","float32Array1","uint32Array1","uint16Array1","float32Array2","uint32Array2","uint16Array2","node1Index16","node2Index16","isLeaf1","isLeaf2","newBox","cl1","cr1","intersectCl1","intersectCr1","cl2","cr2","leftIntersects","rightIntersects","$9eacedee756f73b0$export$ddc917fcb8a0cb5e","$9eacedee756f73b0$export$9d0dec2f433c8a42","$9eacedee756f73b0$export$855d2b1d3a353384","$9eacedee756f73b0$export$3516980c1ea07296","$7V7xb","$2b74x","useGroups","applyWorldTransforms","generateMissingAttributes","overwriteIndex","_intermediateGeometry","Map","_geometryMergeSets","WeakMap","_mergeOrder","_dummyMesh","_getDummyMesh","dummyMaterial","MeshBasicMaterial","emptyGeometry","_getMeshes","meshes","$9eacedee756f73b0$var$flatTraverseMeshes","cb","object","traverseVisible","isMesh","mesh","_updateIntermediateGeometries","unusedMeshKeys","convertOptions","meshKey","delete","geom","isCompatible","BakedGeometry","updateFrom","setCommonAttributes","targetGeometry","skipAssigningAttributes","mergeGeometry","previousMergeInfo","forceUpdate","info","version","$9eacedee756f73b0$var$mergeGeometryList","geometries","attrs","deleteAttribute","mergeGeometries","g","includes","$9eacedee756f73b0$var$getMaterials","$5c43b36cecf64594$export$f06f69b3bf41d25c","$iYpwh","$5c43b36cecf64594$var$validateMergeability","isIndexed","attributesUsed","getAttribute","attributesCount","name","size","totalIndexCount","$5c43b36cecf64594$var$getTotalIndexCount","totalAttributeCount","$5c43b36cecf64594$var$getTotalAttributeCount","$5c43b36cecf64594$var$trimMismatchedAttributes","indexCount","attrCount","attr","primitiveCount","addGroup","forceUpdateIndex","targetOffset","indexOffset","targetIndex","setX","forceUpdateAttr","firstAttr","createAttributeClone","targetAttribute","skip","itemSize","setXYZW","copyAttributeContents","$dd01a0424002e6a9$export$16ecced3bb0ee496","$dd01a0424002e6a9$export$f129ac5b0a0bbb35","$dd01a0424002e6a9$export$87f0ba9cb6ea9964","io","setY","setZ","setW","getW","cons","BYTES_PER_ELEMENT","countOverride","attr1","attr2","sameCount","sameNormalized","sameType","sameItemSize","$662e72ceb18db3d0$export$e7c7cc0a9714fa82","$662e72ceb18db3d0$export$f5a01205d395aca","allMaterials","indexAttr","vertCount","totalCount","materialIndexAttribute","materialArray","endCount","mat","indexOf","computeVertexNormals","uv2","tangent","computeTangents","color","$1962183cefca0848$export$93d9a3230423d56b","$ddiur","$gz5pJ","hash","_diff","MeshDiff","validateAttributes","diff","convertToStaticGeometry","$99ead4f72dcbbc3d$export$507d8b359822d42d","$6ply6","$99ead4f72dcbbc3d$var$getGeometryHash","$99ead4f72dcbbc3d$var$getSkeletonHash","boneTexture","computeBoneTexture","dataHash","bufferToHash","image","matrixWorld","geometryHash","skeletonHash","equals","$4aa5cb15510fc60f$export$d10cf98ed3bc976d","uintArray","$c0f41d5980ac4a7a$export$8ed71501c410233d","$c0f41d5980ac4a7a$var$_positionVector","$c0f41d5980ac4a7a$var$_normalVector","$c0f41d5980ac4a7a$var$_tangentVector","$c0f41d5980ac4a7a$var$_tangentVector4","Vector4","$c0f41d5980ac4a7a$var$_morphVector","$c0f41d5980ac4a7a$var$_temp","$c0f41d5980ac4a7a$var$_skinIndex","$c0f41d5980ac4a7a$var$_skinWeight","$c0f41d5980ac4a7a$var$_matrix","$c0f41d5980ac4a7a$var$_boneMatrix","$c0f41d5980ac4a7a$var$boneNormalTransform","bones","boneInverses","skinIndex","skinWeight","elements","weight","getComponent","boneIndex","multiplyMatrices","$c0f41d5980ac4a7a$var$addScaledMatrix","scale","targetArray","matrixArray","multiply","bindMatrix","premultiply","bindMatrixInverse","transformDirection","$c0f41d5980ac4a7a$var$applyMorphTarget","morphData","morphInfluences","morphTargetsRelative","influence","morphAttribute","addScaledVector","includeNormal","includeTangent","targetAttributes","morphPosition","morphAttributes","morphNormal","morphTangent","morphTargetInfluences","normalMatrix","Matrix3","getNormalMatrix","applyBoneTransform","setXYZ","applyNormalMatrix","w","determinant","$c0f41d5980ac4a7a$var$invertGeometry","setComponent","$7rn9W","$b78om","$eL5d2","$fFvuX","$56ad0500f946240e$export$25a1e84cdffa9fe9","$8176db9d094041c0$export$ae4e12e8c7af5f08","$abe97ef051d4d2c5$export$3c2bc5470251fe4a","$b6831e42db74378f$export$5e276bbaa046dbad","$272edb95ce0a48ac$export$4dc20da53fccce35","$hN8zD","UIntVertexAttributeTexture","FloatVertexAttributeTexture","bvhBounds","DataTexture","bvhContents","_cachedIndexAttr","overrideItemSize","$272edb95ce0a48ac$var$bvhToTextures","boundsTexture","contentsTexture","boundsDimension","ceil","boundsArray","contentsDimension","contentsArray","boundsIndex","mergedLeafCount","width","height","format","RGBAFormat","type","FloatType","internalFormat","minFilter","NearestFilter","magFilter","generateMipmaps","RGIntegerFormat","UnsignedIntType","getIndexArray","getVertexCount","$272edb95ce0a48ac$var$dereferenceIndex","unpacked","i3","v3","$cf3da9d49bbdbfb4$export$de036370a093ef","$cf3da9d49bbdbfb4$export$5444fd0f1815741f","$cf3da9d49bbdbfb4$var$countToIntFormat","RedIntegerFormat","RGBAIntegerFormat","$cf3da9d49bbdbfb4$export$2ba8de89bc26b001","_forcedType","normalizeValue","targetBufferCons","originalItemSize","originalCount","originalBufferCons","targetType","finalStride","Int8Array","Int16Array","Int32Array","IntType","$cf3da9d49bbdbfb4$var$countToStringFormat","$cf3da9d49bbdbfb4$var$countToFormat","RedFormat","RGFormat","UnsignedByteType","ByteType","pow","ShortType","UnsignedShortType","dimension","dataArray","originalNormalized","ii","$f69686fae5159582$export$c4a81a0bfb84e9fe","$f69686fae5159582$export$ae96f3619813ce17","$9wqOU","$f69686fae5159582$var$MaterialFeatures","_features","isUsed","feature","setUsed","used","reset","wrapS","ClampToEdgeWrapping","wrapT","features","getTexture","def","textureLookUp","getTextureHash","getField","writeTextureMatrixToArray","textureKey","texture","matrixAutoUpdate","updateMatrix","floatArray","m","isFogVolumeMaterial","r","emissive","density","normalScale","clearcoatNormalScale","sheenColor","iridescenceThicknessRange","specularColor","isThinFilm","Number","attenuationColor","opacity","alphaTest","transmission","vertexColors","flatShading","transparent","$6eebe81d767f0e44$var$uuidSort","$6eebe81d767f0e44$export$62c3d260e4e2abca","colorSpace","$6eebe81d767f0e44$export$b22c535c66112848","filter","$6eebe81d767f0e44$export$560c941db545ef55","$6eebe81d767f0e44$var$reduceTexturesToUniqueSources","sourceSet","tex","$6eebe81d767f0e44$export$3ae1ccb94aa877f9","scene","$10bbc6f618708662$export$f47304f32d084e8b","$907d2c82b3e6ae31$export$4d6021b7971af115","$ed3261c1debf969a$export$c7fd8b12fd4f43be"],"version":3,"file":"aoRender.d33f21b3.js.map"}