{"mappings":"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","sources":["<anon>","node_modules/three/examples/jsm/controls/OrbitControls.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5b70\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5b70\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"5Rd1x\", function(module, exports) {\n\n$parcel$export(module.exports, \"OrbitControls\", () => $443c013b983d0324$export$8ff7788029dfdf52);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n// OrbitControls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\nconst $443c013b983d0324$var$_changeEvent = {\n    type: \"change\"\n};\nconst $443c013b983d0324$var$_startEvent = {\n    type: \"start\"\n};\nconst $443c013b983d0324$var$_endEvent = {\n    type: \"end\"\n};\nconst $443c013b983d0324$var$_ray = new (0, $ilwiq.Ray)();\nconst $443c013b983d0324$var$_plane = new (0, $ilwiq.Plane)();\nconst $443c013b983d0324$var$TILT_LIMIT = Math.cos(70 * (0, $ilwiq.MathUtils).DEG2RAD);\nclass $443c013b983d0324$export$8ff7788029dfdf52 extends (0, $ilwiq.EventDispatcher) {\n    constructor(object, domElement){\n        super();\n        this.object = object;\n        this.domElement = domElement;\n        this.domElement.style.touchAction = \"none\"; // disable touch scroll\n        // Set to false to disable this control\n        this.enabled = true;\n        // \"target\" sets the location of focus, where the object orbits around\n        this.target = new (0, $ilwiq.Vector3)();\n        // Sets the 3D cursor (similar to Blender), from which the maxTargetRadius takes effect\n        this.cursor = new (0, $ilwiq.Vector3)();\n        // How far you can dolly in and out ( PerspectiveCamera only )\n        this.minDistance = 0;\n        this.maxDistance = Infinity;\n        // How far you can zoom in and out ( OrthographicCamera only )\n        this.minZoom = 0;\n        this.maxZoom = Infinity;\n        // Limit camera target within a spherical area around the cursor\n        this.minTargetRadius = 0;\n        this.maxTargetRadius = Infinity;\n        // How far you can orbit vertically, upper and lower limits.\n        // Range is 0 to Math.PI radians.\n        this.minPolarAngle = 0; // radians\n        this.maxPolarAngle = Math.PI; // radians\n        // How far you can orbit horizontally, upper and lower limits.\n        // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n        this.minAzimuthAngle = -Infinity; // radians\n        this.maxAzimuthAngle = Infinity; // radians\n        // Set to true to enable damping (inertia)\n        // If damping is enabled, you must call controls.update() in your animation loop\n        this.enableDamping = false;\n        this.dampingFactor = 0.05;\n        // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n        // Set to false to disable zooming\n        this.enableZoom = true;\n        this.zoomSpeed = 1.0;\n        // Set to false to disable rotating\n        this.enableRotate = true;\n        this.rotateSpeed = 1.0;\n        // Set to false to disable panning\n        this.enablePan = true;\n        this.panSpeed = 1.0;\n        this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n        this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n        this.zoomToCursor = false;\n        // Set to true to automatically rotate around the target\n        // If auto-rotate is enabled, you must call controls.update() in your animation loop\n        this.autoRotate = false;\n        this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60\n        // The four arrow keys\n        this.keys = {\n            LEFT: \"ArrowLeft\",\n            UP: \"ArrowUp\",\n            RIGHT: \"ArrowRight\",\n            BOTTOM: \"ArrowDown\"\n        };\n        // Mouse buttons\n        this.mouseButtons = {\n            LEFT: (0, $ilwiq.MOUSE).ROTATE,\n            MIDDLE: (0, $ilwiq.MOUSE).DOLLY,\n            RIGHT: (0, $ilwiq.MOUSE).PAN\n        };\n        // Touch fingers\n        this.touches = {\n            ONE: (0, $ilwiq.TOUCH).ROTATE,\n            TWO: (0, $ilwiq.TOUCH).DOLLY_PAN\n        };\n        // for reset\n        this.target0 = this.target.clone();\n        this.position0 = this.object.position.clone();\n        this.zoom0 = this.object.zoom;\n        // the target DOM element for key events\n        this._domElementKeyEvents = null;\n        //\n        // public methods\n        //\n        this.getPolarAngle = function() {\n            return spherical.phi;\n        };\n        this.getAzimuthalAngle = function() {\n            return spherical.theta;\n        };\n        this.getDistance = function() {\n            return this.object.position.distanceTo(this.target);\n        };\n        this.listenToKeyEvents = function(domElement) {\n            domElement.addEventListener(\"keydown\", onKeyDown);\n            this._domElementKeyEvents = domElement;\n        };\n        this.stopListenToKeyEvents = function() {\n            this._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n            this._domElementKeyEvents = null;\n        };\n        this.saveState = function() {\n            scope.target0.copy(scope.target);\n            scope.position0.copy(scope.object.position);\n            scope.zoom0 = scope.object.zoom;\n        };\n        this.reset = function() {\n            scope.target.copy(scope.target0);\n            scope.object.position.copy(scope.position0);\n            scope.object.zoom = scope.zoom0;\n            scope.object.updateProjectionMatrix();\n            scope.dispatchEvent($443c013b983d0324$var$_changeEvent);\n            scope.update();\n            state = STATE.NONE;\n        };\n        // this method is exposed, but perhaps it would be better if we can make it private...\n        this.update = function() {\n            const offset = new (0, $ilwiq.Vector3)();\n            // so camera.up is the orbit axis\n            const quat = new (0, $ilwiq.Quaternion)().setFromUnitVectors(object.up, new (0, $ilwiq.Vector3)(0, 1, 0));\n            const quatInverse = quat.clone().invert();\n            const lastPosition = new (0, $ilwiq.Vector3)();\n            const lastQuaternion = new (0, $ilwiq.Quaternion)();\n            const lastTargetPosition = new (0, $ilwiq.Vector3)();\n            const twoPI = 2 * Math.PI;\n            return function update(deltaTime = null) {\n                const position = scope.object.position;\n                offset.copy(position).sub(scope.target);\n                // rotate offset to \"y-axis-is-up\" space\n                offset.applyQuaternion(quat);\n                // angle from z-axis around y-axis\n                spherical.setFromVector3(offset);\n                if (scope.autoRotate && state === STATE.NONE) rotateLeft(getAutoRotationAngle(deltaTime));\n                if (scope.enableDamping) {\n                    spherical.theta += sphericalDelta.theta * scope.dampingFactor;\n                    spherical.phi += sphericalDelta.phi * scope.dampingFactor;\n                } else {\n                    spherical.theta += sphericalDelta.theta;\n                    spherical.phi += sphericalDelta.phi;\n                }\n                // restrict theta to be between desired limits\n                let min = scope.minAzimuthAngle;\n                let max = scope.maxAzimuthAngle;\n                if (isFinite(min) && isFinite(max)) {\n                    if (min < -Math.PI) min += twoPI;\n                    else if (min > Math.PI) min -= twoPI;\n                    if (max < -Math.PI) max += twoPI;\n                    else if (max > Math.PI) max -= twoPI;\n                    if (min <= max) spherical.theta = Math.max(min, Math.min(max, spherical.theta));\n                    else spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);\n                }\n                // restrict phi to be between desired limits\n                spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\n                spherical.makeSafe();\n                // move target to panned location\n                if (scope.enableDamping === true) scope.target.addScaledVector(panOffset, scope.dampingFactor);\n                else scope.target.add(panOffset);\n                // Limit the target distance from the cursor to create a sphere around the center of interest\n                scope.target.sub(scope.cursor);\n                scope.target.clampLength(scope.minTargetRadius, scope.maxTargetRadius);\n                scope.target.add(scope.cursor);\n                let zoomChanged = false;\n                // adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera\n                // we adjust zoom later in these cases\n                if (scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera) spherical.radius = clampDistance(spherical.radius);\n                else {\n                    const prevRadius = spherical.radius;\n                    spherical.radius = clampDistance(spherical.radius * scale);\n                    zoomChanged = prevRadius != spherical.radius;\n                }\n                offset.setFromSpherical(spherical);\n                // rotate offset back to \"camera-up-vector-is-up\" space\n                offset.applyQuaternion(quatInverse);\n                position.copy(scope.target).add(offset);\n                scope.object.lookAt(scope.target);\n                if (scope.enableDamping === true) {\n                    sphericalDelta.theta *= 1 - scope.dampingFactor;\n                    sphericalDelta.phi *= 1 - scope.dampingFactor;\n                    panOffset.multiplyScalar(1 - scope.dampingFactor);\n                } else {\n                    sphericalDelta.set(0, 0, 0);\n                    panOffset.set(0, 0, 0);\n                }\n                // adjust camera position\n                if (scope.zoomToCursor && performCursorZoom) {\n                    let newRadius = null;\n                    if (scope.object.isPerspectiveCamera) {\n                        // move the camera down the pointer ray\n                        // this method avoids floating point error\n                        const prevRadius = offset.length();\n                        newRadius = clampDistance(prevRadius * scale);\n                        const radiusDelta = prevRadius - newRadius;\n                        scope.object.position.addScaledVector(dollyDirection, radiusDelta);\n                        scope.object.updateMatrixWorld();\n                        zoomChanged = !!radiusDelta;\n                    } else if (scope.object.isOrthographicCamera) {\n                        // adjust the ortho camera position based on zoom changes\n                        const mouseBefore = new (0, $ilwiq.Vector3)(mouse.x, mouse.y, 0);\n                        mouseBefore.unproject(scope.object);\n                        const prevZoom = scope.object.zoom;\n                        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));\n                        scope.object.updateProjectionMatrix();\n                        zoomChanged = prevZoom !== scope.object.zoom;\n                        const mouseAfter = new (0, $ilwiq.Vector3)(mouse.x, mouse.y, 0);\n                        mouseAfter.unproject(scope.object);\n                        scope.object.position.sub(mouseAfter).add(mouseBefore);\n                        scope.object.updateMatrixWorld();\n                        newRadius = offset.length();\n                    } else {\n                        console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.\");\n                        scope.zoomToCursor = false;\n                    }\n                    // handle the placement of the target\n                    if (newRadius !== null) {\n                        if (this.screenSpacePanning) // position the orbit target in front of the new camera position\n                        scope.target.set(0, 0, -1).transformDirection(scope.object.matrix).multiplyScalar(newRadius).add(scope.object.position);\n                        else {\n                            // get the ray and translation plane to compute target\n                            $443c013b983d0324$var$_ray.origin.copy(scope.object.position);\n                            $443c013b983d0324$var$_ray.direction.set(0, 0, -1).transformDirection(scope.object.matrix);\n                            // if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid\n                            // extremely large values\n                            if (Math.abs(scope.object.up.dot($443c013b983d0324$var$_ray.direction)) < $443c013b983d0324$var$TILT_LIMIT) object.lookAt(scope.target);\n                            else {\n                                $443c013b983d0324$var$_plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target);\n                                $443c013b983d0324$var$_ray.intersectPlane($443c013b983d0324$var$_plane, scope.target);\n                            }\n                        }\n                    }\n                } else if (scope.object.isOrthographicCamera) {\n                    const prevZoom = scope.object.zoom;\n                    scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));\n                    if (prevZoom !== scope.object.zoom) {\n                        scope.object.updateProjectionMatrix();\n                        zoomChanged = true;\n                    }\n                }\n                scale = 1;\n                performCursorZoom = false;\n                // update condition is:\n                // min(camera displacement, camera rotation in radians)^2 > EPS\n                // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n                if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS || lastTargetPosition.distanceToSquared(scope.target) > EPS) {\n                    scope.dispatchEvent($443c013b983d0324$var$_changeEvent);\n                    lastPosition.copy(scope.object.position);\n                    lastQuaternion.copy(scope.object.quaternion);\n                    lastTargetPosition.copy(scope.target);\n                    return true;\n                }\n                return false;\n            };\n        }();\n        this.dispose = function() {\n            scope.domElement.removeEventListener(\"contextmenu\", onContextMenu);\n            scope.domElement.removeEventListener(\"pointerdown\", onPointerDown);\n            scope.domElement.removeEventListener(\"pointercancel\", onPointerUp);\n            scope.domElement.removeEventListener(\"wheel\", onMouseWheel);\n            scope.domElement.removeEventListener(\"pointermove\", onPointerMove);\n            scope.domElement.removeEventListener(\"pointerup\", onPointerUp);\n            const document = scope.domElement.getRootNode(); // offscreen canvas compatibility\n            document.removeEventListener(\"keydown\", interceptControlDown, {\n                capture: true\n            });\n            if (scope._domElementKeyEvents !== null) {\n                scope._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n                scope._domElementKeyEvents = null;\n            }\n        //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n        };\n        //\n        // internals\n        //\n        const scope = this;\n        const STATE = {\n            NONE: -1,\n            ROTATE: 0,\n            DOLLY: 1,\n            PAN: 2,\n            TOUCH_ROTATE: 3,\n            TOUCH_PAN: 4,\n            TOUCH_DOLLY_PAN: 5,\n            TOUCH_DOLLY_ROTATE: 6\n        };\n        let state = STATE.NONE;\n        const EPS = 0.000001;\n        // current position in spherical coordinates\n        const spherical = new (0, $ilwiq.Spherical)();\n        const sphericalDelta = new (0, $ilwiq.Spherical)();\n        let scale = 1;\n        const panOffset = new (0, $ilwiq.Vector3)();\n        const rotateStart = new (0, $ilwiq.Vector2)();\n        const rotateEnd = new (0, $ilwiq.Vector2)();\n        const rotateDelta = new (0, $ilwiq.Vector2)();\n        const panStart = new (0, $ilwiq.Vector2)();\n        const panEnd = new (0, $ilwiq.Vector2)();\n        const panDelta = new (0, $ilwiq.Vector2)();\n        const dollyStart = new (0, $ilwiq.Vector2)();\n        const dollyEnd = new (0, $ilwiq.Vector2)();\n        const dollyDelta = new (0, $ilwiq.Vector2)();\n        const dollyDirection = new (0, $ilwiq.Vector3)();\n        const mouse = new (0, $ilwiq.Vector2)();\n        let performCursorZoom = false;\n        const pointers = [];\n        const pointerPositions = {};\n        let controlActive = false;\n        function getAutoRotationAngle(deltaTime) {\n            if (deltaTime !== null) return 2 * Math.PI / 60 * scope.autoRotateSpeed * deltaTime;\n            else return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n        }\n        function getZoomScale(delta) {\n            const normalizedDelta = Math.abs(delta * 0.01);\n            return Math.pow(0.95, scope.zoomSpeed * normalizedDelta);\n        }\n        function rotateLeft(angle) {\n            sphericalDelta.theta -= angle;\n        }\n        function rotateUp(angle) {\n            sphericalDelta.phi -= angle;\n        }\n        const panLeft = function() {\n            const v = new (0, $ilwiq.Vector3)();\n            return function panLeft(distance, objectMatrix) {\n                v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\n                v.multiplyScalar(-distance);\n                panOffset.add(v);\n            };\n        }();\n        const panUp = function() {\n            const v = new (0, $ilwiq.Vector3)();\n            return function panUp(distance, objectMatrix) {\n                if (scope.screenSpacePanning === true) v.setFromMatrixColumn(objectMatrix, 1);\n                else {\n                    v.setFromMatrixColumn(objectMatrix, 0);\n                    v.crossVectors(scope.object.up, v);\n                }\n                v.multiplyScalar(distance);\n                panOffset.add(v);\n            };\n        }();\n        // deltaX and deltaY are in pixels; right and down are positive\n        const pan = function() {\n            const offset = new (0, $ilwiq.Vector3)();\n            return function pan(deltaX, deltaY) {\n                const element = scope.domElement;\n                if (scope.object.isPerspectiveCamera) {\n                    // perspective\n                    const position = scope.object.position;\n                    offset.copy(position).sub(scope.target);\n                    let targetDistance = offset.length();\n                    // half of the fov is center to top of screen\n                    targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);\n                    // we use only clientHeight here so aspect ratio does not distort speed\n                    panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);\n                    panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);\n                } else if (scope.object.isOrthographicCamera) {\n                    // orthographic\n                    panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);\n                    panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);\n                } else {\n                    // camera neither orthographic nor perspective\n                    console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\");\n                    scope.enablePan = false;\n                }\n            };\n        }();\n        function dollyOut(dollyScale) {\n            if (scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera) scale /= dollyScale;\n            else {\n                console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n                scope.enableZoom = false;\n            }\n        }\n        function dollyIn(dollyScale) {\n            if (scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera) scale *= dollyScale;\n            else {\n                console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n                scope.enableZoom = false;\n            }\n        }\n        function updateZoomParameters(x, y) {\n            if (!scope.zoomToCursor) return;\n            performCursorZoom = true;\n            const rect = scope.domElement.getBoundingClientRect();\n            const dx = x - rect.left;\n            const dy = y - rect.top;\n            const w = rect.width;\n            const h = rect.height;\n            mouse.x = dx / w * 2 - 1;\n            mouse.y = -(dy / h) * 2 + 1;\n            dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize();\n        }\n        function clampDistance(dist) {\n            return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist));\n        }\n        //\n        // event callbacks - update the object state\n        //\n        function handleMouseDownRotate(event) {\n            rotateStart.set(event.clientX, event.clientY);\n        }\n        function handleMouseDownDolly(event) {\n            updateZoomParameters(event.clientX, event.clientX);\n            dollyStart.set(event.clientX, event.clientY);\n        }\n        function handleMouseDownPan(event) {\n            panStart.set(event.clientX, event.clientY);\n        }\n        function handleMouseMoveRotate(event) {\n            rotateEnd.set(event.clientX, event.clientY);\n            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n            const element = scope.domElement;\n            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n            rotateStart.copy(rotateEnd);\n            scope.update();\n        }\n        function handleMouseMoveDolly(event) {\n            dollyEnd.set(event.clientX, event.clientY);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n            if (dollyDelta.y > 0) dollyOut(getZoomScale(dollyDelta.y));\n            else if (dollyDelta.y < 0) dollyIn(getZoomScale(dollyDelta.y));\n            dollyStart.copy(dollyEnd);\n            scope.update();\n        }\n        function handleMouseMovePan(event) {\n            panEnd.set(event.clientX, event.clientY);\n            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n            pan(panDelta.x, panDelta.y);\n            panStart.copy(panEnd);\n            scope.update();\n        }\n        function handleMouseWheel(event) {\n            updateZoomParameters(event.clientX, event.clientY);\n            if (event.deltaY < 0) dollyIn(getZoomScale(event.deltaY));\n            else if (event.deltaY > 0) dollyOut(getZoomScale(event.deltaY));\n            scope.update();\n        }\n        function handleKeyDown(event) {\n            let needsUpdate = false;\n            switch(event.code){\n                case scope.keys.UP:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) rotateUp(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);\n                    else pan(0, scope.keyPanSpeed);\n                    needsUpdate = true;\n                    break;\n                case scope.keys.BOTTOM:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) rotateUp(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);\n                    else pan(0, -scope.keyPanSpeed);\n                    needsUpdate = true;\n                    break;\n                case scope.keys.LEFT:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) rotateLeft(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);\n                    else pan(scope.keyPanSpeed, 0);\n                    needsUpdate = true;\n                    break;\n                case scope.keys.RIGHT:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) rotateLeft(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);\n                    else pan(-scope.keyPanSpeed, 0);\n                    needsUpdate = true;\n                    break;\n            }\n            if (needsUpdate) {\n                // prevent the browser from scrolling on cursor keys\n                event.preventDefault();\n                scope.update();\n            }\n        }\n        function handleTouchStartRotate(event) {\n            if (pointers.length === 1) rotateStart.set(event.pageX, event.pageY);\n            else {\n                const position = getSecondPointerPosition(event);\n                const x = 0.5 * (event.pageX + position.x);\n                const y = 0.5 * (event.pageY + position.y);\n                rotateStart.set(x, y);\n            }\n        }\n        function handleTouchStartPan(event) {\n            if (pointers.length === 1) panStart.set(event.pageX, event.pageY);\n            else {\n                const position = getSecondPointerPosition(event);\n                const x = 0.5 * (event.pageX + position.x);\n                const y = 0.5 * (event.pageY + position.y);\n                panStart.set(x, y);\n            }\n        }\n        function handleTouchStartDolly(event) {\n            const position = getSecondPointerPosition(event);\n            const dx = event.pageX - position.x;\n            const dy = event.pageY - position.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            dollyStart.set(0, distance);\n        }\n        function handleTouchStartDollyPan(event) {\n            if (scope.enableZoom) handleTouchStartDolly(event);\n            if (scope.enablePan) handleTouchStartPan(event);\n        }\n        function handleTouchStartDollyRotate(event) {\n            if (scope.enableZoom) handleTouchStartDolly(event);\n            if (scope.enableRotate) handleTouchStartRotate(event);\n        }\n        function handleTouchMoveRotate(event) {\n            if (pointers.length == 1) rotateEnd.set(event.pageX, event.pageY);\n            else {\n                const position = getSecondPointerPosition(event);\n                const x = 0.5 * (event.pageX + position.x);\n                const y = 0.5 * (event.pageY + position.y);\n                rotateEnd.set(x, y);\n            }\n            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n            const element = scope.domElement;\n            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n            rotateStart.copy(rotateEnd);\n        }\n        function handleTouchMovePan(event) {\n            if (pointers.length === 1) panEnd.set(event.pageX, event.pageY);\n            else {\n                const position = getSecondPointerPosition(event);\n                const x = 0.5 * (event.pageX + position.x);\n                const y = 0.5 * (event.pageY + position.y);\n                panEnd.set(x, y);\n            }\n            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n            pan(panDelta.x, panDelta.y);\n            panStart.copy(panEnd);\n        }\n        function handleTouchMoveDolly(event) {\n            const position = getSecondPointerPosition(event);\n            const dx = event.pageX - position.x;\n            const dy = event.pageY - position.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            dollyEnd.set(0, distance);\n            dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n            dollyOut(dollyDelta.y);\n            dollyStart.copy(dollyEnd);\n            const centerX = (event.pageX + position.x) * 0.5;\n            const centerY = (event.pageY + position.y) * 0.5;\n            updateZoomParameters(centerX, centerY);\n        }\n        function handleTouchMoveDollyPan(event) {\n            if (scope.enableZoom) handleTouchMoveDolly(event);\n            if (scope.enablePan) handleTouchMovePan(event);\n        }\n        function handleTouchMoveDollyRotate(event) {\n            if (scope.enableZoom) handleTouchMoveDolly(event);\n            if (scope.enableRotate) handleTouchMoveRotate(event);\n        }\n        //\n        // event handlers - FSM: listen for events and reset state\n        //\n        function onPointerDown(event) {\n            if (scope.enabled === false) return;\n            if (pointers.length === 0) {\n                scope.domElement.setPointerCapture(event.pointerId);\n                scope.domElement.addEventListener(\"pointermove\", onPointerMove);\n                scope.domElement.addEventListener(\"pointerup\", onPointerUp);\n            }\n            //\n            if (isTrackingPointer(event)) return;\n            //\n            addPointer(event);\n            if (event.pointerType === \"touch\") onTouchStart(event);\n            else onMouseDown(event);\n        }\n        function onPointerMove(event) {\n            if (scope.enabled === false) return;\n            if (event.pointerType === \"touch\") onTouchMove(event);\n            else onMouseMove(event);\n        }\n        function onPointerUp(event) {\n            removePointer(event);\n            switch(pointers.length){\n                case 0:\n                    scope.domElement.releasePointerCapture(event.pointerId);\n                    scope.domElement.removeEventListener(\"pointermove\", onPointerMove);\n                    scope.domElement.removeEventListener(\"pointerup\", onPointerUp);\n                    scope.dispatchEvent($443c013b983d0324$var$_endEvent);\n                    state = STATE.NONE;\n                    break;\n                case 1:\n                    const pointerId = pointers[0];\n                    const position = pointerPositions[pointerId];\n                    // minimal placeholder event - allows state correction on pointer-up\n                    onTouchStart({\n                        pointerId: pointerId,\n                        pageX: position.x,\n                        pageY: position.y\n                    });\n                    break;\n            }\n        }\n        function onMouseDown(event) {\n            let mouseAction;\n            switch(event.button){\n                case 0:\n                    mouseAction = scope.mouseButtons.LEFT;\n                    break;\n                case 1:\n                    mouseAction = scope.mouseButtons.MIDDLE;\n                    break;\n                case 2:\n                    mouseAction = scope.mouseButtons.RIGHT;\n                    break;\n                default:\n                    mouseAction = -1;\n            }\n            switch(mouseAction){\n                case (0, $ilwiq.MOUSE).DOLLY:\n                    if (scope.enableZoom === false) return;\n                    handleMouseDownDolly(event);\n                    state = STATE.DOLLY;\n                    break;\n                case (0, $ilwiq.MOUSE).ROTATE:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) {\n                        if (scope.enablePan === false) return;\n                        handleMouseDownPan(event);\n                        state = STATE.PAN;\n                    } else {\n                        if (scope.enableRotate === false) return;\n                        handleMouseDownRotate(event);\n                        state = STATE.ROTATE;\n                    }\n                    break;\n                case (0, $ilwiq.MOUSE).PAN:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) {\n                        if (scope.enableRotate === false) return;\n                        handleMouseDownRotate(event);\n                        state = STATE.ROTATE;\n                    } else {\n                        if (scope.enablePan === false) return;\n                        handleMouseDownPan(event);\n                        state = STATE.PAN;\n                    }\n                    break;\n                default:\n                    state = STATE.NONE;\n            }\n            if (state !== STATE.NONE) scope.dispatchEvent($443c013b983d0324$var$_startEvent);\n        }\n        function onMouseMove(event) {\n            switch(state){\n                case STATE.ROTATE:\n                    if (scope.enableRotate === false) return;\n                    handleMouseMoveRotate(event);\n                    break;\n                case STATE.DOLLY:\n                    if (scope.enableZoom === false) return;\n                    handleMouseMoveDolly(event);\n                    break;\n                case STATE.PAN:\n                    if (scope.enablePan === false) return;\n                    handleMouseMovePan(event);\n                    break;\n            }\n        }\n        function onMouseWheel(event) {\n            if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE) return;\n            event.preventDefault();\n            scope.dispatchEvent($443c013b983d0324$var$_startEvent);\n            handleMouseWheel(customWheelEvent(event));\n            scope.dispatchEvent($443c013b983d0324$var$_endEvent);\n        }\n        function customWheelEvent(event) {\n            const mode = event.deltaMode;\n            // minimal wheel event altered to meet delta-zoom demand\n            const newEvent = {\n                clientX: event.clientX,\n                clientY: event.clientY,\n                deltaY: event.deltaY\n            };\n            switch(mode){\n                case 1:\n                    newEvent.deltaY *= 16;\n                    break;\n                case 2:\n                    newEvent.deltaY *= 100;\n                    break;\n            }\n            // detect if event was triggered by pinching\n            if (event.ctrlKey && !controlActive) newEvent.deltaY *= 10;\n            return newEvent;\n        }\n        function interceptControlDown(event) {\n            if (event.key === \"Control\") {\n                controlActive = true;\n                const document = scope.domElement.getRootNode(); // offscreen canvas compatibility\n                document.addEventListener(\"keyup\", interceptControlUp, {\n                    passive: true,\n                    capture: true\n                });\n            }\n        }\n        function interceptControlUp(event) {\n            if (event.key === \"Control\") {\n                controlActive = false;\n                const document = scope.domElement.getRootNode(); // offscreen canvas compatibility\n                document.removeEventListener(\"keyup\", interceptControlUp, {\n                    passive: true,\n                    capture: true\n                });\n            }\n        }\n        function onKeyDown(event) {\n            if (scope.enabled === false || scope.enablePan === false) return;\n            handleKeyDown(event);\n        }\n        function onTouchStart(event) {\n            trackPointer(event);\n            switch(pointers.length){\n                case 1:\n                    switch(scope.touches.ONE){\n                        case (0, $ilwiq.TOUCH).ROTATE:\n                            if (scope.enableRotate === false) return;\n                            handleTouchStartRotate(event);\n                            state = STATE.TOUCH_ROTATE;\n                            break;\n                        case (0, $ilwiq.TOUCH).PAN:\n                            if (scope.enablePan === false) return;\n                            handleTouchStartPan(event);\n                            state = STATE.TOUCH_PAN;\n                            break;\n                        default:\n                            state = STATE.NONE;\n                    }\n                    break;\n                case 2:\n                    switch(scope.touches.TWO){\n                        case (0, $ilwiq.TOUCH).DOLLY_PAN:\n                            if (scope.enableZoom === false && scope.enablePan === false) return;\n                            handleTouchStartDollyPan(event);\n                            state = STATE.TOUCH_DOLLY_PAN;\n                            break;\n                        case (0, $ilwiq.TOUCH).DOLLY_ROTATE:\n                            if (scope.enableZoom === false && scope.enableRotate === false) return;\n                            handleTouchStartDollyRotate(event);\n                            state = STATE.TOUCH_DOLLY_ROTATE;\n                            break;\n                        default:\n                            state = STATE.NONE;\n                    }\n                    break;\n                default:\n                    state = STATE.NONE;\n            }\n            if (state !== STATE.NONE) scope.dispatchEvent($443c013b983d0324$var$_startEvent);\n        }\n        function onTouchMove(event) {\n            trackPointer(event);\n            switch(state){\n                case STATE.TOUCH_ROTATE:\n                    if (scope.enableRotate === false) return;\n                    handleTouchMoveRotate(event);\n                    scope.update();\n                    break;\n                case STATE.TOUCH_PAN:\n                    if (scope.enablePan === false) return;\n                    handleTouchMovePan(event);\n                    scope.update();\n                    break;\n                case STATE.TOUCH_DOLLY_PAN:\n                    if (scope.enableZoom === false && scope.enablePan === false) return;\n                    handleTouchMoveDollyPan(event);\n                    scope.update();\n                    break;\n                case STATE.TOUCH_DOLLY_ROTATE:\n                    if (scope.enableZoom === false && scope.enableRotate === false) return;\n                    handleTouchMoveDollyRotate(event);\n                    scope.update();\n                    break;\n                default:\n                    state = STATE.NONE;\n            }\n        }\n        function onContextMenu(event) {\n            if (scope.enabled === false) return;\n            event.preventDefault();\n        }\n        function addPointer(event) {\n            pointers.push(event.pointerId);\n        }\n        function removePointer(event) {\n            delete pointerPositions[event.pointerId];\n            for(let i = 0; i < pointers.length; i++)if (pointers[i] == event.pointerId) {\n                pointers.splice(i, 1);\n                return;\n            }\n        }\n        function isTrackingPointer(event) {\n            for(let i = 0; i < pointers.length; i++){\n                if (pointers[i] == event.pointerId) return true;\n            }\n            return false;\n        }\n        function trackPointer(event) {\n            let position = pointerPositions[event.pointerId];\n            if (position === undefined) {\n                position = new (0, $ilwiq.Vector2)();\n                pointerPositions[event.pointerId] = position;\n            }\n            position.set(event.pageX, event.pageY);\n        }\n        function getSecondPointerPosition(event) {\n            const pointerId = event.pointerId === pointers[0] ? pointers[1] : pointers[0];\n            return pointerPositions[pointerId];\n        }\n        //\n        scope.domElement.addEventListener(\"contextmenu\", onContextMenu);\n        scope.domElement.addEventListener(\"pointerdown\", onPointerDown);\n        scope.domElement.addEventListener(\"pointercancel\", onPointerUp);\n        scope.domElement.addEventListener(\"wheel\", onMouseWheel, {\n            passive: false\n        });\n        const document = scope.domElement.getRootNode(); // offscreen canvas compatibility\n        document.addEventListener(\"keydown\", interceptControlDown, {\n            passive: true,\n            capture: true\n        });\n        // force an update at start\n        this.update();\n    }\n}\n\n});\n\n\n//# sourceMappingURL=aoRender.fc8349f1.js.map\n","import {\n\tEventDispatcher,\n\tMOUSE,\n\tQuaternion,\n\tSpherical,\n\tTOUCH,\n\tVector2,\n\tVector3,\n\tPlane,\n\tRay,\n\tMathUtils\n} from 'three';\n\n// OrbitControls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nconst _changeEvent = { type: 'change' };\nconst _startEvent = { type: 'start' };\nconst _endEvent = { type: 'end' };\nconst _ray = new Ray();\nconst _plane = new Plane();\nconst TILT_LIMIT = Math.cos( 70 * MathUtils.DEG2RAD );\n\nclass OrbitControls extends EventDispatcher {\n\n\tconstructor( object, domElement ) {\n\n\t\tsuper();\n\n\t\tthis.object = object;\n\t\tthis.domElement = domElement;\n\t\tthis.domElement.style.touchAction = 'none'; // disable touch scroll\n\n\t\t// Set to false to disable this control\n\t\tthis.enabled = true;\n\n\t\t// \"target\" sets the location of focus, where the object orbits around\n\t\tthis.target = new Vector3();\n\n\t\t// Sets the 3D cursor (similar to Blender), from which the maxTargetRadius takes effect\n\t\tthis.cursor = new Vector3();\n\n\t\t// How far you can dolly in and out ( PerspectiveCamera only )\n\t\tthis.minDistance = 0;\n\t\tthis.maxDistance = Infinity;\n\n\t\t// How far you can zoom in and out ( OrthographicCamera only )\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\n\t\t// Limit camera target within a spherical area around the cursor\n\t\tthis.minTargetRadius = 0;\n\t\tthis.maxTargetRadius = Infinity;\n\n\t\t// How far you can orbit vertically, upper and lower limits.\n\t\t// Range is 0 to Math.PI radians.\n\t\tthis.minPolarAngle = 0; // radians\n\t\tthis.maxPolarAngle = Math.PI; // radians\n\n\t\t// How far you can orbit horizontally, upper and lower limits.\n\t\t// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n\t\tthis.minAzimuthAngle = - Infinity; // radians\n\t\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t\t// Set to true to enable damping (inertia)\n\t\t// If damping is enabled, you must call controls.update() in your animation loop\n\t\tthis.enableDamping = false;\n\t\tthis.dampingFactor = 0.05;\n\n\t\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t\t// Set to false to disable zooming\n\t\tthis.enableZoom = true;\n\t\tthis.zoomSpeed = 1.0;\n\n\t\t// Set to false to disable rotating\n\t\tthis.enableRotate = true;\n\t\tthis.rotateSpeed = 1.0;\n\n\t\t// Set to false to disable panning\n\t\tthis.enablePan = true;\n\t\tthis.panSpeed = 1.0;\n\t\tthis.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n\t\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\t\tthis.zoomToCursor = false;\n\n\t\t// Set to true to automatically rotate around the target\n\t\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\t\tthis.autoRotate = false;\n\t\tthis.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60\n\n\t\t// The four arrow keys\n\t\tthis.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };\n\n\t\t// Mouse buttons\n\t\tthis.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };\n\n\t\t// Touch fingers\n\t\tthis.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };\n\n\t\t// for reset\n\t\tthis.target0 = this.target.clone();\n\t\tthis.position0 = this.object.position.clone();\n\t\tthis.zoom0 = this.object.zoom;\n\n\t\t// the target DOM element for key events\n\t\tthis._domElementKeyEvents = null;\n\n\t\t//\n\t\t// public methods\n\t\t//\n\n\t\tthis.getPolarAngle = function () {\n\n\t\t\treturn spherical.phi;\n\n\t\t};\n\n\t\tthis.getAzimuthalAngle = function () {\n\n\t\t\treturn spherical.theta;\n\n\t\t};\n\n\t\tthis.getDistance = function () {\n\n\t\t\treturn this.object.position.distanceTo( this.target );\n\n\t\t};\n\n\t\tthis.listenToKeyEvents = function ( domElement ) {\n\n\t\t\tdomElement.addEventListener( 'keydown', onKeyDown );\n\t\t\tthis._domElementKeyEvents = domElement;\n\n\t\t};\n\n\t\tthis.stopListenToKeyEvents = function () {\n\n\t\t\tthis._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );\n\t\t\tthis._domElementKeyEvents = null;\n\n\t\t};\n\n\t\tthis.saveState = function () {\n\n\t\t\tscope.target0.copy( scope.target );\n\t\t\tscope.position0.copy( scope.object.position );\n\t\t\tscope.zoom0 = scope.object.zoom;\n\n\t\t};\n\n\t\tthis.reset = function () {\n\n\t\t\tscope.target.copy( scope.target0 );\n\t\t\tscope.object.position.copy( scope.position0 );\n\t\t\tscope.object.zoom = scope.zoom0;\n\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tscope.dispatchEvent( _changeEvent );\n\n\t\t\tscope.update();\n\n\t\t\tstate = STATE.NONE;\n\n\t\t};\n\n\t\t// this method is exposed, but perhaps it would be better if we can make it private...\n\t\tthis.update = function () {\n\n\t\t\tconst offset = new Vector3();\n\n\t\t\t// so camera.up is the orbit axis\n\t\t\tconst quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );\n\t\t\tconst quatInverse = quat.clone().invert();\n\n\t\t\tconst lastPosition = new Vector3();\n\t\t\tconst lastQuaternion = new Quaternion();\n\t\t\tconst lastTargetPosition = new Vector3();\n\n\t\t\tconst twoPI = 2 * Math.PI;\n\n\t\t\treturn function update( deltaTime = null ) {\n\n\t\t\t\tconst position = scope.object.position;\n\n\t\t\t\toffset.copy( position ).sub( scope.target );\n\n\t\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\t\toffset.applyQuaternion( quat );\n\n\t\t\t\t// angle from z-axis around y-axis\n\t\t\t\tspherical.setFromVector3( offset );\n\n\t\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\n\n\t\t\t\t\trotateLeft( getAutoRotationAngle( deltaTime ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scope.enableDamping ) {\n\n\t\t\t\t\tspherical.theta += sphericalDelta.theta * scope.dampingFactor;\n\t\t\t\t\tspherical.phi += sphericalDelta.phi * scope.dampingFactor;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\t\t\tspherical.phi += sphericalDelta.phi;\n\n\t\t\t\t}\n\n\t\t\t\t// restrict theta to be between desired limits\n\n\t\t\t\tlet min = scope.minAzimuthAngle;\n\t\t\t\tlet max = scope.maxAzimuthAngle;\n\n\t\t\t\tif ( isFinite( min ) && isFinite( max ) ) {\n\n\t\t\t\t\tif ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;\n\n\t\t\t\t\tif ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;\n\n\t\t\t\t\tif ( min <= max ) {\n\n\t\t\t\t\t\tspherical.theta = Math.max( min, Math.min( max, spherical.theta ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tspherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?\n\t\t\t\t\t\t\tMath.max( min, spherical.theta ) :\n\t\t\t\t\t\t\tMath.min( max, spherical.theta );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// restrict phi to be between desired limits\n\t\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\n\n\t\t\t\tspherical.makeSafe();\n\n\n\t\t\t\t// move target to panned location\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tscope.target.addScaledVector( panOffset, scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tscope.target.add( panOffset );\n\n\t\t\t\t}\n\n\t\t\t\t// Limit the target distance from the cursor to create a sphere around the center of interest\n\t\t\t\tscope.target.sub( scope.cursor );\n\t\t\t\tscope.target.clampLength( scope.minTargetRadius, scope.maxTargetRadius );\n\t\t\t\tscope.target.add( scope.cursor );\n\n\t\t\t\tlet zoomChanged = false;\n\t\t\t\t// adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera\n\t\t\t\t// we adjust zoom later in these cases\n\t\t\t\tif ( scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera ) {\n\n\t\t\t\t\tspherical.radius = clampDistance( spherical.radius );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst prevRadius = spherical.radius;\n\t\t\t\t\tspherical.radius = clampDistance( spherical.radius * scale );\n\t\t\t\t\tzoomChanged = prevRadius != spherical.radius;\n\n\t\t\t\t}\n\n\t\t\t\toffset.setFromSpherical( spherical );\n\n\t\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\t\toffset.applyQuaternion( quatInverse );\n\n\t\t\t\tposition.copy( scope.target ).add( offset );\n\n\t\t\t\tscope.object.lookAt( scope.target );\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\n\t\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\n\n\t\t\t\t\tpanOffset.multiplyScalar( 1 - scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsphericalDelta.set( 0, 0, 0 );\n\n\t\t\t\t\tpanOffset.set( 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\t// adjust camera position\n\t\t\t\tif ( scope.zoomToCursor && performCursorZoom ) {\n\n\t\t\t\t\tlet newRadius = null;\n\t\t\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\t\t\t// move the camera down the pointer ray\n\t\t\t\t\t\t// this method avoids floating point error\n\t\t\t\t\t\tconst prevRadius = offset.length();\n\t\t\t\t\t\tnewRadius = clampDistance( prevRadius * scale );\n\n\t\t\t\t\t\tconst radiusDelta = prevRadius - newRadius;\n\t\t\t\t\t\tscope.object.position.addScaledVector( dollyDirection, radiusDelta );\n\t\t\t\t\t\tscope.object.updateMatrixWorld();\n\n\t\t\t\t\t\tzoomChanged = !! radiusDelta;\n\n\t\t\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\t\t\t// adjust the ortho camera position based on zoom changes\n\t\t\t\t\t\tconst mouseBefore = new Vector3( mouse.x, mouse.y, 0 );\n\t\t\t\t\t\tmouseBefore.unproject( scope.object );\n\n\t\t\t\t\t\tconst prevZoom = scope.object.zoom;\n\t\t\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );\n\t\t\t\t\t\tscope.object.updateProjectionMatrix();\n\n\t\t\t\t\t\tzoomChanged = prevZoom !== scope.object.zoom;\n\n\t\t\t\t\t\tconst mouseAfter = new Vector3( mouse.x, mouse.y, 0 );\n\t\t\t\t\t\tmouseAfter.unproject( scope.object );\n\n\t\t\t\t\t\tscope.object.position.sub( mouseAfter ).add( mouseBefore );\n\t\t\t\t\t\tscope.object.updateMatrixWorld();\n\n\t\t\t\t\t\tnewRadius = offset.length();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.' );\n\t\t\t\t\t\tscope.zoomToCursor = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// handle the placement of the target\n\t\t\t\t\tif ( newRadius !== null ) {\n\n\t\t\t\t\t\tif ( this.screenSpacePanning ) {\n\n\t\t\t\t\t\t\t// position the orbit target in front of the new camera position\n\t\t\t\t\t\t\tscope.target.set( 0, 0, - 1 )\n\t\t\t\t\t\t\t\t.transformDirection( scope.object.matrix )\n\t\t\t\t\t\t\t\t.multiplyScalar( newRadius )\n\t\t\t\t\t\t\t\t.add( scope.object.position );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// get the ray and translation plane to compute target\n\t\t\t\t\t\t\t_ray.origin.copy( scope.object.position );\n\t\t\t\t\t\t\t_ray.direction.set( 0, 0, - 1 ).transformDirection( scope.object.matrix );\n\n\t\t\t\t\t\t\t// if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid\n\t\t\t\t\t\t\t// extremely large values\n\t\t\t\t\t\t\tif ( Math.abs( scope.object.up.dot( _ray.direction ) ) < TILT_LIMIT ) {\n\n\t\t\t\t\t\t\t\tobject.lookAt( scope.target );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t_plane.setFromNormalAndCoplanarPoint( scope.object.up, scope.target );\n\t\t\t\t\t\t\t\t_ray.intersectPlane( _plane, scope.target );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\t\tconst prevZoom = scope.object.zoom;\n\t\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );\n\n\t\t\t\t\tif ( prevZoom !== scope.object.zoom ) {\n\n\t\t\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\t\t\tzoomChanged = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tscale = 1;\n\t\t\t\tperformCursorZoom = false;\n\n\t\t\t\t// update condition is:\n\t\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\t\tif ( zoomChanged ||\n\t\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\n\t\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ||\n\t\t\t\t\tlastTargetPosition.distanceToSquared( scope.target ) > EPS ) {\n\n\t\t\t\t\tscope.dispatchEvent( _changeEvent );\n\n\t\t\t\t\tlastPosition.copy( scope.object.position );\n\t\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\n\t\t\t\t\tlastTargetPosition.copy( scope.target );\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t}();\n\n\t\tthis.dispose = function () {\n\n\t\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu );\n\n\t\t\tscope.domElement.removeEventListener( 'pointerdown', onPointerDown );\n\t\t\tscope.domElement.removeEventListener( 'pointercancel', onPointerUp );\n\t\t\tscope.domElement.removeEventListener( 'wheel', onMouseWheel );\n\n\t\t\tscope.domElement.removeEventListener( 'pointermove', onPointerMove );\n\t\t\tscope.domElement.removeEventListener( 'pointerup', onPointerUp );\n\n\t\t\tconst document = scope.domElement.getRootNode(); // offscreen canvas compatibility\n\n\t\t\tdocument.removeEventListener( 'keydown', interceptControlDown, { capture: true } );\n\n\t\t\tif ( scope._domElementKeyEvents !== null ) {\n\n\t\t\t\tscope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );\n\t\t\t\tscope._domElementKeyEvents = null;\n\n\t\t\t}\n\n\t\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\n\t\t};\n\n\t\t//\n\t\t// internals\n\t\t//\n\n\t\tconst scope = this;\n\n\t\tconst STATE = {\n\t\t\tNONE: - 1,\n\t\t\tROTATE: 0,\n\t\t\tDOLLY: 1,\n\t\t\tPAN: 2,\n\t\t\tTOUCH_ROTATE: 3,\n\t\t\tTOUCH_PAN: 4,\n\t\t\tTOUCH_DOLLY_PAN: 5,\n\t\t\tTOUCH_DOLLY_ROTATE: 6\n\t\t};\n\n\t\tlet state = STATE.NONE;\n\n\t\tconst EPS = 0.000001;\n\n\t\t// current position in spherical coordinates\n\t\tconst spherical = new Spherical();\n\t\tconst sphericalDelta = new Spherical();\n\n\t\tlet scale = 1;\n\t\tconst panOffset = new Vector3();\n\n\t\tconst rotateStart = new Vector2();\n\t\tconst rotateEnd = new Vector2();\n\t\tconst rotateDelta = new Vector2();\n\n\t\tconst panStart = new Vector2();\n\t\tconst panEnd = new Vector2();\n\t\tconst panDelta = new Vector2();\n\n\t\tconst dollyStart = new Vector2();\n\t\tconst dollyEnd = new Vector2();\n\t\tconst dollyDelta = new Vector2();\n\n\t\tconst dollyDirection = new Vector3();\n\t\tconst mouse = new Vector2();\n\t\tlet performCursorZoom = false;\n\n\t\tconst pointers = [];\n\t\tconst pointerPositions = {};\n\n\t\tlet controlActive = false;\n\n\t\tfunction getAutoRotationAngle( deltaTime ) {\n\n\t\t\tif ( deltaTime !== null ) {\n\n\t\t\t\treturn ( 2 * Math.PI / 60 * scope.autoRotateSpeed ) * deltaTime;\n\n\t\t\t} else {\n\n\t\t\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getZoomScale( delta ) {\n\n\t\t\tconst normalizedDelta = Math.abs( delta * 0.01 );\n\t\t\treturn Math.pow( 0.95, scope.zoomSpeed * normalizedDelta );\n\n\t\t}\n\n\t\tfunction rotateLeft( angle ) {\n\n\t\t\tsphericalDelta.theta -= angle;\n\n\t\t}\n\n\t\tfunction rotateUp( angle ) {\n\n\t\t\tsphericalDelta.phi -= angle;\n\n\t\t}\n\n\t\tconst panLeft = function () {\n\n\t\t\tconst v = new Vector3();\n\n\t\t\treturn function panLeft( distance, objectMatrix ) {\n\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\n\t\t\t\tv.multiplyScalar( - distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\tconst panUp = function () {\n\n\t\t\tconst v = new Vector3();\n\n\t\t\treturn function panUp( distance, objectMatrix ) {\n\n\t\t\t\tif ( scope.screenSpacePanning === true ) {\n\n\t\t\t\t\tv.setFromMatrixColumn( objectMatrix, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 );\n\t\t\t\t\tv.crossVectors( scope.object.up, v );\n\n\t\t\t\t}\n\n\t\t\t\tv.multiplyScalar( distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\t// deltaX and deltaY are in pixels; right and down are positive\n\t\tconst pan = function () {\n\n\t\t\tconst offset = new Vector3();\n\n\t\t\treturn function pan( deltaX, deltaY ) {\n\n\t\t\t\tconst element = scope.domElement;\n\n\t\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\t\t// perspective\n\t\t\t\t\tconst position = scope.object.position;\n\t\t\t\t\toffset.copy( position ).sub( scope.target );\n\t\t\t\t\tlet targetDistance = offset.length();\n\n\t\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t\t\t// we use only clientHeight here so aspect ratio does not distort speed\n\t\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\n\t\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\t\t// orthographic\n\t\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\n\t\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\t\t\t\tscope.enablePan = false;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}();\n\n\t\tfunction dollyOut( dollyScale ) {\n\n\t\t\tif ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {\n\n\t\t\t\tscale /= dollyScale;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction dollyIn( dollyScale ) {\n\n\t\t\tif ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {\n\n\t\t\t\tscale *= dollyScale;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction updateZoomParameters( x, y ) {\n\n\t\t\tif ( ! scope.zoomToCursor ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tperformCursorZoom = true;\n\n\t\t\tconst rect = scope.domElement.getBoundingClientRect();\n\t\t\tconst dx = x - rect.left;\n\t\t\tconst dy = y - rect.top;\n\t\t\tconst w = rect.width;\n\t\t\tconst h = rect.height;\n\n\t\t\tmouse.x = ( dx / w ) * 2 - 1;\n\t\t\tmouse.y = - ( dy / h ) * 2 + 1;\n\n\t\t\tdollyDirection.set( mouse.x, mouse.y, 1 ).unproject( scope.object ).sub( scope.object.position ).normalize();\n\n\t\t}\n\n\t\tfunction clampDistance( dist ) {\n\n\t\t\treturn Math.max( scope.minDistance, Math.min( scope.maxDistance, dist ) );\n\n\t\t}\n\n\t\t//\n\t\t// event callbacks - update the object state\n\t\t//\n\n\t\tfunction handleMouseDownRotate( event ) {\n\n\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownDolly( event ) {\n\n\t\t\tupdateZoomParameters( event.clientX, event.clientX );\n\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownPan( event ) {\n\n\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseMoveRotate( event ) {\n\n\t\t\trotateEnd.set( event.clientX, event.clientY );\n\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\n\n\t\t\tconst element = scope.domElement;\n\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMoveDolly( event ) {\n\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale( dollyDelta.y ) );\n\n\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale( dollyDelta.y ) );\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMovePan( event ) {\n\n\t\t\tpanEnd.set( event.clientX, event.clientY );\n\n\t\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseWheel( event ) {\n\n\t\t\tupdateZoomParameters( event.clientX, event.clientY );\n\n\t\t\tif ( event.deltaY < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale( event.deltaY ) );\n\n\t\t\t} else if ( event.deltaY > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale( event.deltaY ) );\n\n\t\t\t}\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleKeyDown( event ) {\n\n\t\t\tlet needsUpdate = false;\n\n\t\t\tswitch ( event.code ) {\n\n\t\t\t\tcase scope.keys.UP:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\trotateUp( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpan( 0, scope.keyPanSpeed );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.BOTTOM:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\trotateUp( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpan( 0, - scope.keyPanSpeed );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.LEFT:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\trotateLeft( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpan( scope.keyPanSpeed, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.RIGHT:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\trotateLeft( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpan( - scope.keyPanSpeed, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( needsUpdate ) {\n\n\t\t\t\t// prevent the browser from scrolling on cursor keys\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\tscope.update();\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tfunction handleTouchStartRotate( event ) {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\trotateStart.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\trotateStart.set( x, y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartPan( event ) {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\tpanStart.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\tpanStart.set( x, y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartDolly( event ) {\n\n\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\tconst dx = event.pageX - position.x;\n\t\t\tconst dy = event.pageY - position.y;\n\n\t\t\tconst distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyStart.set( 0, distance );\n\n\t\t}\n\n\t\tfunction handleTouchStartDollyPan( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchStartDolly( event );\n\n\t\t\tif ( scope.enablePan ) handleTouchStartPan( event );\n\n\t\t}\n\n\t\tfunction handleTouchStartDollyRotate( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchStartDolly( event );\n\n\t\t\tif ( scope.enableRotate ) handleTouchStartRotate( event );\n\n\t\t}\n\n\t\tfunction handleTouchMoveRotate( event ) {\n\n\t\t\tif ( pointers.length == 1 ) {\n\n\t\t\t\trotateEnd.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\trotateEnd.set( x, y );\n\n\t\t\t}\n\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\n\n\t\t\tconst element = scope.domElement;\n\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMovePan( event ) {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\tpanEnd.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\tpanEnd.set( x, y );\n\n\t\t\t}\n\n\t\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDolly( event ) {\n\n\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\tconst dx = event.pageX - position.x;\n\t\t\tconst dy = event.pageY - position.y;\n\n\t\t\tconst distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyEnd.set( 0, distance );\n\n\t\t\tdollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );\n\n\t\t\tdollyOut( dollyDelta.y );\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tconst centerX = ( event.pageX + position.x ) * 0.5;\n\t\t\tconst centerY = ( event.pageY + position.y ) * 0.5;\n\n\t\t\tupdateZoomParameters( centerX, centerY );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDollyPan( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchMoveDolly( event );\n\n\t\t\tif ( scope.enablePan ) handleTouchMovePan( event );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDollyRotate( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchMoveDolly( event );\n\n\t\t\tif ( scope.enableRotate ) handleTouchMoveRotate( event );\n\n\t\t}\n\n\t\t//\n\t\t// event handlers - FSM: listen for events and reset state\n\t\t//\n\n\t\tfunction onPointerDown( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tif ( pointers.length === 0 ) {\n\n\t\t\t\tscope.domElement.setPointerCapture( event.pointerId );\n\n\t\t\t\tscope.domElement.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\tscope.domElement.addEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( isTrackingPointer( event ) ) return;\n\n\t\t\t//\n\n\t\t\taddPointer( event );\n\n\t\t\tif ( event.pointerType === 'touch' ) {\n\n\t\t\t\tonTouchStart( event );\n\n\t\t\t} else {\n\n\t\t\t\tonMouseDown( event );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onPointerMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tif ( event.pointerType === 'touch' ) {\n\n\t\t\t\tonTouchMove( event );\n\n\t\t\t} else {\n\n\t\t\t\tonMouseMove( event );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onPointerUp( event ) {\n\n\t\t\tremovePointer( event );\n\n\t\t\tswitch ( pointers.length ) {\n\n\t\t\t\tcase 0:\n\n\t\t\t\t\tscope.domElement.releasePointerCapture( event.pointerId );\n\n\t\t\t\t\tscope.domElement.removeEventListener( 'pointermove', onPointerMove );\n\t\t\t\t\tscope.domElement.removeEventListener( 'pointerup', onPointerUp );\n\n\t\t\t\t\tscope.dispatchEvent( _endEvent );\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\tconst pointerId = pointers[ 0 ];\n\t\t\t\t\tconst position = pointerPositions[ pointerId ];\n\n\t\t\t\t\t// minimal placeholder event - allows state correction on pointer-up\n\t\t\t\t\tonTouchStart( { pointerId: pointerId, pageX: position.x, pageY: position.y } );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseDown( event ) {\n\n\t\t\tlet mouseAction;\n\n\t\t\tswitch ( event.button ) {\n\n\t\t\t\tcase 0:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.LEFT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.MIDDLE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.RIGHT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tmouseAction = - 1;\n\n\t\t\t}\n\n\t\t\tswitch ( mouseAction ) {\n\n\t\t\t\tcase MOUSE.DOLLY:\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleMouseDownDolly( event );\n\n\t\t\t\t\tstate = STATE.DOLLY;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MOUSE.ROTATE:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MOUSE.PAN:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseMove( event ) {\n\n\t\t\tswitch ( state ) {\n\n\t\t\t\tcase STATE.ROTATE:\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleMouseMoveRotate( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.DOLLY:\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleMouseMoveDolly( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.PAN:\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleMouseMovePan( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseWheel( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\thandleMouseWheel( customWheelEvent( event ) );\n\n\t\t\tscope.dispatchEvent( _endEvent );\n\n\t\t}\n\n\t\tfunction customWheelEvent( event ) {\n\n\t\t\tconst mode = event.deltaMode;\n\n\t\t\t// minimal wheel event altered to meet delta-zoom demand\n\t\t\tconst newEvent = {\n\t\t\t\tclientX: event.clientX,\n\t\t\t\tclientY: event.clientY,\n\t\t\t\tdeltaY: event.deltaY,\n\t\t\t};\n\n\t\t\tswitch ( mode ) {\n\n\t\t\t\tcase 1: // LINE_MODE\n\t\t\t\t\tnewEvent.deltaY *= 16;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // PAGE_MODE\n\t\t\t\t\tnewEvent.deltaY *= 100;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// detect if event was triggered by pinching\n\t\t\tif ( event.ctrlKey && ! controlActive ) {\n\n\t\t\t\tnewEvent.deltaY *= 10;\n\n\t\t\t}\n\n\t\t\treturn newEvent;\n\n\t\t}\n\n\t\tfunction interceptControlDown( event ) {\n\n\t\t\tif ( event.key === 'Control' ) {\n\n\t\t\t\tcontrolActive = true;\n\n\n\t\t\t\tconst document = scope.domElement.getRootNode(); // offscreen canvas compatibility\n\n\t\t\t\tdocument.addEventListener( 'keyup', interceptControlUp, { passive: true, capture: true } );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction interceptControlUp( event ) {\n\n\t\t\tif ( event.key === 'Control' ) {\n\n\t\t\t\tcontrolActive = false;\n\n\n\t\t\t\tconst document = scope.domElement.getRootNode(); // offscreen canvas compatibility\n\n\t\t\t\tdocument.removeEventListener( 'keyup', interceptControlUp, { passive: true, capture: true } );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onKeyDown( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enablePan === false ) return;\n\n\t\t\thandleKeyDown( event );\n\n\t\t}\n\n\t\tfunction onTouchStart( event ) {\n\n\t\t\ttrackPointer( event );\n\n\t\t\tswitch ( pointers.length ) {\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\tswitch ( scope.touches.ONE ) {\n\n\t\t\t\t\t\tcase TOUCH.ROTATE:\n\n\t\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartRotate( event );\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TOUCH.PAN:\n\n\t\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartPan( event );\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\tswitch ( scope.touches.TWO ) {\n\n\t\t\t\t\t\tcase TOUCH.DOLLY_PAN:\n\n\t\t\t\t\t\t\tif ( scope.enableZoom === false && scope.enablePan === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartDollyPan( event );\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY_PAN;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TOUCH.DOLLY_ROTATE:\n\n\t\t\t\t\t\t\tif ( scope.enableZoom === false && scope.enableRotate === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartDollyRotate( event );\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY_ROTATE;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchMove( event ) {\n\n\t\t\ttrackPointer( event );\n\n\t\t\tswitch ( state ) {\n\n\t\t\t\tcase STATE.TOUCH_ROTATE:\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchMoveRotate( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_PAN:\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchMovePan( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_DOLLY_PAN:\n\n\t\t\t\t\tif ( scope.enableZoom === false && scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchMoveDollyPan( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_DOLLY_ROTATE:\n\n\t\t\t\t\tif ( scope.enableZoom === false && scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchMoveDollyRotate( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onContextMenu( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t}\n\n\t\tfunction addPointer( event ) {\n\n\t\t\tpointers.push( event.pointerId );\n\n\t\t}\n\n\t\tfunction removePointer( event ) {\n\n\t\t\tdelete pointerPositions[ event.pointerId ];\n\n\t\t\tfor ( let i = 0; i < pointers.length; i ++ ) {\n\n\t\t\t\tif ( pointers[ i ] == event.pointerId ) {\n\n\t\t\t\t\tpointers.splice( i, 1 );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isTrackingPointer( event ) {\n\n\t\t\tfor ( let i = 0; i < pointers.length; i ++ ) {\n\n\t\t\t\tif ( pointers[ i ] == event.pointerId ) return true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tfunction trackPointer( event ) {\n\n\t\t\tlet position = pointerPositions[ event.pointerId ];\n\n\t\t\tif ( position === undefined ) {\n\n\t\t\t\tposition = new Vector2();\n\t\t\t\tpointerPositions[ event.pointerId ] = position;\n\n\t\t\t}\n\n\t\t\tposition.set( event.pageX, event.pageY );\n\n\t\t}\n\n\t\tfunction getSecondPointerPosition( event ) {\n\n\t\t\tconst pointerId = ( event.pointerId === pointers[ 0 ] ) ? pointers[ 1 ] : pointers[ 0 ];\n\n\t\t\treturn pointerPositions[ pointerId ];\n\n\t\t}\n\n\t\t//\n\n\t\tscope.domElement.addEventListener( 'contextmenu', onContextMenu );\n\n\t\tscope.domElement.addEventListener( 'pointerdown', onPointerDown );\n\t\tscope.domElement.addEventListener( 'pointercancel', onPointerUp );\n\t\tscope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );\n\n\t\tconst document = scope.domElement.getRootNode(); // offscreen canvas compatibility\n\n\t\tdocument.addEventListener( 'keydown', interceptControlDown, { passive: true, capture: true } );\n\n\t\t// force an update at start\n\n\t\tthis.update();\n\n\t}\n\n}\n\nexport { OrbitControls };\n"],"names":["$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","Object","defineProperty","get","$443c013b983d0324$export$8ff7788029dfdf52","set","s","enumerable","configurable","$ilwiq","$443c013b983d0324$var$_changeEvent","type","$443c013b983d0324$var$_startEvent","$443c013b983d0324$var$_endEvent","$443c013b983d0324$var$_ray","Ray","$443c013b983d0324$var$_plane","Plane","$443c013b983d0324$var$TILT_LIMIT","Math","cos","MathUtils","DEG2RAD","EventDispatcher","constructor","object","domElement","style","touchAction","enabled","target","Vector3","cursor","minDistance","maxDistance","Infinity","minZoom","maxZoom","minTargetRadius","maxTargetRadius","minPolarAngle","maxPolarAngle","PI","minAzimuthAngle","maxAzimuthAngle","enableDamping","dampingFactor","enableZoom","zoomSpeed","enableRotate","rotateSpeed","enablePan","panSpeed","screenSpacePanning","keyPanSpeed","zoomToCursor","autoRotate","autoRotateSpeed","keys","LEFT","UP","RIGHT","BOTTOM","mouseButtons","MOUSE","ROTATE","MIDDLE","DOLLY","PAN","touches","ONE","TOUCH","TWO","DOLLY_PAN","target0","clone","position0","position","zoom0","zoom","_domElementKeyEvents","getPolarAngle","spherical","phi","getAzimuthalAngle","theta","getDistance","distanceTo","listenToKeyEvents","addEventListener","onKeyDown","stopListenToKeyEvents","removeEventListener","saveState","scope","copy","reset","updateProjectionMatrix","dispatchEvent","update","state","STATE","NONE","offset","quat","Quaternion","setFromUnitVectors","up","quatInverse","invert","lastPosition","lastQuaternion","lastTargetPosition","twoPI","deltaTime","sub","applyQuaternion","setFromVector3","rotateLeft","sphericalDelta","min","max","isFinite","makeSafe","addScaledVector","panOffset","add","clampLength","zoomChanged","performCursorZoom","isOrthographicCamera","radius","clampDistance","prevRadius","scale","setFromSpherical","lookAt","multiplyScalar","newRadius","isPerspectiveCamera","length","radiusDelta","dollyDirection","updateMatrixWorld","mouseBefore","mouse","x","y","unproject","prevZoom","mouseAfter","console","warn","transformDirection","matrix","origin","direction","abs","dot","setFromNormalAndCoplanarPoint","intersectPlane","distanceToSquared","EPS","quaternion","dispose","onContextMenu","onPointerDown","onPointerUp","onMouseWheel","onPointerMove","document","getRootNode","interceptControlDown","capture","TOUCH_ROTATE","TOUCH_PAN","TOUCH_DOLLY_PAN","TOUCH_DOLLY_ROTATE","Spherical","rotateStart","Vector2","rotateEnd","rotateDelta","panStart","panEnd","panDelta","dollyStart","dollyEnd","dollyDelta","pointers","pointerPositions","controlActive","getZoomScale","delta","pow","angle","rotateUp","panLeft","v","distance","objectMatrix","setFromMatrixColumn","panUp","crossVectors","pan","deltaX","deltaY","element","targetDistance","tan","fov","clientHeight","right","left","clientWidth","top","bottom","dollyOut","dollyScale","dollyIn","updateZoomParameters","rect","getBoundingClientRect","dx","dy","w","width","h","height","normalize","dist","handleMouseDownRotate","event","clientX","clientY","handleMouseDownPan","handleTouchStartRotate","pageX","pageY","getSecondPointerPosition","handleTouchStartPan","handleTouchStartDolly","sqrt","handleTouchMoveRotate","subVectors","handleTouchMovePan","handleTouchMoveDolly","setPointerCapture","pointerId","isTrackingPointer","i","push","pointerType","onTouchStart","onMouseDown","mouseAction","button","ctrlKey","metaKey","shiftKey","onTouchMove","trackPointer","onMouseMove","handleMouseMoveRotate","removePointer","splice","releasePointerCapture","preventDefault","customWheelEvent","mode","deltaMode","newEvent","key","interceptControlUp","passive","handleKeyDown","needsUpdate","DOLLY_ROTATE","undefined"],"version":3,"file":"aoRender.fc8349f1.js.map"}