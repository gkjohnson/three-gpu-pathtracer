{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,A,C,E,E,Q,A,E,Q,S,C,C,C,E,E,E,O,C,4B,I,G,E,E,O,C,kB,I,G,E,E,O,C,gB,I,G,E,E,O,C,sB,I,G,I,E,E,SCaA,SAAS,EAA2B,CAAQ,CAAE,CAAU,CAAE,EAAa,CAAA,CAAI,EAE1E,GAAK,CAAE,GAAc,CAAE,EAAW,OAAO,CAExC,MAAM,AAAI,MAAO,iEAIlB,GAAK,CAAE,EAAS,YAAY,CAAE,aAAgB,CAAE,EAAS,YAAY,CAAE,WAAc,CAAE,EAAS,YAAY,CAAE,MAE7G,MAAM,AAAI,MAAO,oFAIlB,SAAS,EAAmB,CAAS,EAEpC,GAAK,EAAU,UAAU,EAAI,EAAU,4BAA4B,CAAG,CAErE,IAAM,EAAW,IAAI,aAAc,EAAU,KAAK,CAAG,EAAU,QAAQ,EAEvE,IAAM,IAAI,EAAI,EAAG,EAAI,EAAG,EAAI,EAAU,KAAK,CAAE,IAE5C,CAAQ,CAAE,IAAM,CAAG,EAAU,IAAI,CAAE,GACnC,CAAQ,CAAE,IAAM,CAAG,EAAU,IAAI,CAAE,GAE9B,EAAU,QAAQ,CAAG,GAEzB,CAAA,CAAQ,CAAE,IAAM,CAAG,EAAU,IAAI,CAAE,EAFpC,EAQD,OAAO,CAER,QAEA,AAAK,EAAU,KAAK,YAAY,aAExB,EAAU,KAAK,CAIhB,IAAI,aAAc,EAAU,KAAK,CAEzC,CAIA,IAAM,EAAY,EAAS,KAAK,CAAG,EAAS,YAAY,GAAK,EAIvD,EAAW,EAAW,gBAAgB,CAE3C,EAAmB,EAAU,UAAU,CAAC,QAAQ,EAChD,EAAmB,EAAU,UAAU,CAAC,MAAM,EAC9C,EAAmB,EAAU,UAAU,CAAC,EAAE,GAO3C,GAAK,EAEJ,IAAM,IAAI,EAAI,EAAG,EAAI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","sources":["<anon>","node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5b70\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5b70\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"7ePFa\", function(module, exports) {\n\n$parcel$export(module.exports, \"computeMikkTSpaceTangents\", () => $5451ea62abbe5f68$export$676e3e70c930f774);\n$parcel$export(module.exports, \"mergeGeometries\", () => $5451ea62abbe5f68$export$f06f69b3bf41d25c);\n$parcel$export(module.exports, \"mergeVertices\", () => $5451ea62abbe5f68$export$e36bb98c4c944f9);\n$parcel$export(module.exports, \"toTrianglesDrawMode\", () => $5451ea62abbe5f68$export$5492ca6e5c0c7aa0);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nfunction $5451ea62abbe5f68$export$676e3e70c930f774(geometry, MikkTSpace, negateSign = true) {\n    if (!MikkTSpace || !MikkTSpace.isReady) throw new Error(\"BufferGeometryUtils: Initialized MikkTSpace library required.\");\n    if (!geometry.hasAttribute(\"position\") || !geometry.hasAttribute(\"normal\") || !geometry.hasAttribute(\"uv\")) throw new Error('BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.');\n    function getAttributeArray(attribute) {\n        if (attribute.normalized || attribute.isInterleavedBufferAttribute) {\n            const dstArray = new Float32Array(attribute.count * attribute.itemSize);\n            for(let i = 0, j = 0; i < attribute.count; i++){\n                dstArray[j++] = attribute.getX(i);\n                dstArray[j++] = attribute.getY(i);\n                if (attribute.itemSize > 2) dstArray[j++] = attribute.getZ(i);\n            }\n            return dstArray;\n        }\n        if (attribute.array instanceof Float32Array) return attribute.array;\n        return new Float32Array(attribute.array);\n    }\n    // MikkTSpace algorithm requires non-indexed input.\n    const _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n    // Compute vertex tangents.\n    const tangents = MikkTSpace.generateTangents(getAttributeArray(_geometry.attributes.position), getAttributeArray(_geometry.attributes.normal), getAttributeArray(_geometry.attributes.uv));\n    // Texture coordinate convention of glTF differs from the apparent\n    // default of the MikkTSpace library; .w component must be flipped.\n    if (negateSign) for(let i = 3; i < tangents.length; i += 4)tangents[i] *= -1;\n    //\n    _geometry.setAttribute(\"tangent\", new (0, $ilwiq.BufferAttribute)(tangents, 4));\n    if (geometry !== _geometry) geometry.copy(_geometry);\n    return geometry;\n}\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */ function $5451ea62abbe5f68$export$f06f69b3bf41d25c(geometries, useGroups = false) {\n    const isIndexed = geometries[0].index !== null;\n    const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n    const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n    const attributes = {};\n    const morphAttributes = {};\n    const morphTargetsRelative = geometries[0].morphTargetsRelative;\n    const mergedGeometry = new (0, $ilwiq.BufferGeometry)();\n    let offset = 0;\n    for(let i = 0; i < geometries.length; ++i){\n        const geometry = geometries[i];\n        let attributesCount = 0;\n        // ensure that all geometries are indexed, or none\n        if (isIndexed !== (geometry.index !== null)) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\");\n            return null;\n        }\n        // gather attributes, exit early if they're different\n        for(const name in geometry.attributes){\n            if (!attributesUsed.has(name)) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n                return null;\n            }\n            if (attributes[name] === undefined) attributes[name] = [];\n            attributes[name].push(geometry.attributes[name]);\n            attributesCount++;\n        }\n        // ensure geometries have the same number of attributes\n        if (attributesCount !== attributesUsed.size) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\");\n            return null;\n        }\n        // gather morph attributes, exit early if they're different\n        if (morphTargetsRelative !== geometry.morphTargetsRelative) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\");\n            return null;\n        }\n        for(const name in geometry.morphAttributes){\n            if (!morphAttributesUsed.has(name)) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\");\n                return null;\n            }\n            if (morphAttributes[name] === undefined) morphAttributes[name] = [];\n            morphAttributes[name].push(geometry.morphAttributes[name]);\n        }\n        if (useGroups) {\n            let count;\n            if (isIndexed) count = geometry.index.count;\n            else if (geometry.attributes.position !== undefined) count = geometry.attributes.position.count;\n            else {\n                console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\");\n                return null;\n            }\n            mergedGeometry.addGroup(offset, count, i);\n            offset += count;\n        }\n    }\n    // merge indices\n    if (isIndexed) {\n        let indexOffset = 0;\n        const mergedIndex = [];\n        for(let i = 0; i < geometries.length; ++i){\n            const index = geometries[i].index;\n            for(let j = 0; j < index.count; ++j)mergedIndex.push(index.getX(j) + indexOffset);\n            indexOffset += geometries[i].attributes.position.count;\n        }\n        mergedGeometry.setIndex(mergedIndex);\n    }\n    // merge attributes\n    for(const name in attributes){\n        const mergedAttribute = $5451ea62abbe5f68$export$9f98db6234c4bd78(attributes[name]);\n        if (!mergedAttribute) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the \" + name + \" attribute.\");\n            return null;\n        }\n        mergedGeometry.setAttribute(name, mergedAttribute);\n    }\n    // merge morph attributes\n    for(const name in morphAttributes){\n        const numMorphTargets = morphAttributes[name][0].length;\n        if (numMorphTargets === 0) break;\n        mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n        mergedGeometry.morphAttributes[name] = [];\n        for(let i = 0; i < numMorphTargets; ++i){\n            const morphAttributesToMerge = [];\n            for(let j = 0; j < morphAttributes[name].length; ++j)morphAttributesToMerge.push(morphAttributes[name][j][i]);\n            const mergedMorphAttribute = $5451ea62abbe5f68$export$9f98db6234c4bd78(morphAttributesToMerge);\n            if (!mergedMorphAttribute) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the \" + name + \" morphAttribute.\");\n                return null;\n            }\n            mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n        }\n    }\n    return mergedGeometry;\n}\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */ function $5451ea62abbe5f68$export$9f98db6234c4bd78(attributes) {\n    let TypedArray;\n    let itemSize;\n    let normalized;\n    let gpuType = -1;\n    let arrayLength = 0;\n    for(let i = 0; i < attributes.length; ++i){\n        const attribute = attributes[i];\n        if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n        if (TypedArray !== attribute.array.constructor) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\");\n            return null;\n        }\n        if (itemSize === undefined) itemSize = attribute.itemSize;\n        if (itemSize !== attribute.itemSize) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\");\n            return null;\n        }\n        if (normalized === undefined) normalized = attribute.normalized;\n        if (normalized !== attribute.normalized) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\");\n            return null;\n        }\n        if (gpuType === -1) gpuType = attribute.gpuType;\n        if (gpuType !== attribute.gpuType) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.\");\n            return null;\n        }\n        arrayLength += attribute.count * itemSize;\n    }\n    const array = new TypedArray(arrayLength);\n    const result = new (0, $ilwiq.BufferAttribute)(array, itemSize, normalized);\n    let offset = 0;\n    for(let i = 0; i < attributes.length; ++i){\n        const attribute = attributes[i];\n        if (attribute.isInterleavedBufferAttribute) {\n            const tupleOffset = offset / itemSize;\n            for(let j = 0, l = attribute.count; j < l; j++)for(let c = 0; c < itemSize; c++){\n                const value = attribute.getComponent(j, c);\n                result.setComponent(j + tupleOffset, c, value);\n            }\n        } else array.set(attribute.array, offset);\n        offset += attribute.count * itemSize;\n    }\n    if (gpuType !== undefined) result.gpuType = gpuType;\n    return result;\n}\nfunction $5451ea62abbe5f68$export$4848639a9adff548(attribute) {\n    if (attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute) return $5451ea62abbe5f68$export$4b7aa2f2134b7e19(attribute);\n    if (attribute.isInstancedBufferAttribute) return new (0, $ilwiq.InstancedBufferAttribute)().copy(attribute);\n    return new (0, $ilwiq.BufferAttribute)().copy(attribute);\n}\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */ function $5451ea62abbe5f68$export$308f9509e428a845(attributes) {\n    // Interleaves the provided attributes into an InterleavedBuffer and returns\n    // a set of InterleavedBufferAttributes for each attribute\n    let TypedArray;\n    let arrayLength = 0;\n    let stride = 0;\n    // calculate the length and type of the interleavedBuffer\n    for(let i = 0, l = attributes.length; i < l; ++i){\n        const attribute = attributes[i];\n        if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n        if (TypedArray !== attribute.array.constructor) {\n            console.error(\"AttributeBuffers of different types cannot be interleaved\");\n            return null;\n        }\n        arrayLength += attribute.array.length;\n        stride += attribute.itemSize;\n    }\n    // Create the set of buffer attributes\n    const interleavedBuffer = new (0, $ilwiq.InterleavedBuffer)(new TypedArray(arrayLength), stride);\n    let offset = 0;\n    const res = [];\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\",\n        \"getW\"\n    ];\n    const setters = [\n        \"setX\",\n        \"setY\",\n        \"setZ\",\n        \"setW\"\n    ];\n    for(let j = 0, l = attributes.length; j < l; j++){\n        const attribute = attributes[j];\n        const itemSize = attribute.itemSize;\n        const count = attribute.count;\n        const iba = new (0, $ilwiq.InterleavedBufferAttribute)(interleavedBuffer, itemSize, offset, attribute.normalized);\n        res.push(iba);\n        offset += itemSize;\n        // Move the data for each attribute into the new interleavedBuffer\n        // at the appropriate offset\n        for(let c = 0; c < count; c++)for(let k = 0; k < itemSize; k++)iba[setters[k]](c, attribute[getters[k]](c));\n    }\n    return res;\n}\nfunction $5451ea62abbe5f68$export$4b7aa2f2134b7e19(attribute) {\n    const cons = attribute.data.array.constructor;\n    const count = attribute.count;\n    const itemSize = attribute.itemSize;\n    const normalized = attribute.normalized;\n    const array = new cons(count * itemSize);\n    let newAttribute;\n    if (attribute.isInstancedInterleavedBufferAttribute) newAttribute = new (0, $ilwiq.InstancedBufferAttribute)(array, itemSize, normalized, attribute.meshPerAttribute);\n    else newAttribute = new (0, $ilwiq.BufferAttribute)(array, itemSize, normalized);\n    for(let i = 0; i < count; i++){\n        newAttribute.setX(i, attribute.getX(i));\n        if (itemSize >= 2) newAttribute.setY(i, attribute.getY(i));\n        if (itemSize >= 3) newAttribute.setZ(i, attribute.getZ(i));\n        if (itemSize >= 4) newAttribute.setW(i, attribute.getW(i));\n    }\n    return newAttribute;\n}\nfunction $5451ea62abbe5f68$export$e7413b17bfaaa80b(geometry) {\n    const attributes = geometry.attributes;\n    const morphTargets = geometry.morphTargets;\n    const attrMap = new Map();\n    for(const key in attributes){\n        const attr = attributes[key];\n        if (attr.isInterleavedBufferAttribute) {\n            if (!attrMap.has(attr)) attrMap.set(attr, $5451ea62abbe5f68$export$4b7aa2f2134b7e19(attr));\n            attributes[key] = attrMap.get(attr);\n        }\n    }\n    for(const key in morphTargets){\n        const attr = morphTargets[key];\n        if (attr.isInterleavedBufferAttribute) {\n            if (!attrMap.has(attr)) attrMap.set(attr, $5451ea62abbe5f68$export$4b7aa2f2134b7e19(attr));\n            morphTargets[key] = attrMap.get(attr);\n        }\n    }\n}\n/**\n * @param {BufferGeometry} geometry\n * @return {number}\n */ function $5451ea62abbe5f68$export$35bee7999e19754d(geometry) {\n    // Return the estimated memory used by this geometry in bytes\n    // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n    // for InterleavedBufferAttributes.\n    let mem = 0;\n    for(const name in geometry.attributes){\n        const attr = geometry.getAttribute(name);\n        mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n    }\n    const indices = geometry.getIndex();\n    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n    return mem;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */ function $5451ea62abbe5f68$export$e36bb98c4c944f9(geometry, tolerance = 1e-4) {\n    tolerance = Math.max(tolerance, Number.EPSILON);\n    // Generate an index buffer if the geometry doesn't have one, or optimize it\n    // if it's already available.\n    const hashToIndex = {};\n    const indices = geometry.getIndex();\n    const positions = geometry.getAttribute(\"position\");\n    const vertexCount = indices ? indices.count : positions.count;\n    // next value for triangle indices\n    let nextIndex = 0;\n    // attributes and new attribute arrays\n    const attributeNames = Object.keys(geometry.attributes);\n    const tmpAttributes = {};\n    const tmpMorphAttributes = {};\n    const newIndices = [];\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\",\n        \"getW\"\n    ];\n    const setters = [\n        \"setX\",\n        \"setY\",\n        \"setZ\",\n        \"setW\"\n    ];\n    // Initialize the arrays, allocating space conservatively. Extra\n    // space will be trimmed in the last step.\n    for(let i = 0, l = attributeNames.length; i < l; i++){\n        const name = attributeNames[i];\n        const attr = geometry.attributes[name];\n        tmpAttributes[name] = new (0, $ilwiq.BufferAttribute)(new attr.array.constructor(attr.count * attr.itemSize), attr.itemSize, attr.normalized);\n        const morphAttr = geometry.morphAttributes[name];\n        if (morphAttr) tmpMorphAttributes[name] = new (0, $ilwiq.BufferAttribute)(new morphAttr.array.constructor(morphAttr.count * morphAttr.itemSize), morphAttr.itemSize, morphAttr.normalized);\n    }\n    // convert the error tolerance to an amount of decimal places to truncate to\n    const halfTolerance = tolerance * 0.5;\n    const exponent = Math.log10(1 / tolerance);\n    const hashMultiplier = Math.pow(10, exponent);\n    const hashAdditive = halfTolerance * hashMultiplier;\n    for(let i = 0; i < vertexCount; i++){\n        const index = indices ? indices.getX(i) : i;\n        // Generate a hash for the vertex attributes at the current index 'i'\n        let hash = \"\";\n        for(let j = 0, l = attributeNames.length; j < l; j++){\n            const name = attributeNames[j];\n            const attribute = geometry.getAttribute(name);\n            const itemSize = attribute.itemSize;\n            for(let k = 0; k < itemSize; k++)// double tilde truncates the decimal value\n            hash += `${~~(attribute[getters[k]](index) * hashMultiplier + hashAdditive)},`;\n        }\n        // Add another reference to the vertex if it's already\n        // used by another index\n        if (hash in hashToIndex) newIndices.push(hashToIndex[hash]);\n        else {\n            // copy data to the new index in the temporary attributes\n            for(let j = 0, l = attributeNames.length; j < l; j++){\n                const name = attributeNames[j];\n                const attribute = geometry.getAttribute(name);\n                const morphAttr = geometry.morphAttributes[name];\n                const itemSize = attribute.itemSize;\n                const newarray = tmpAttributes[name];\n                const newMorphArrays = tmpMorphAttributes[name];\n                for(let k = 0; k < itemSize; k++){\n                    const getterFunc = getters[k];\n                    const setterFunc = setters[k];\n                    newarray[setterFunc](nextIndex, attribute[getterFunc](index));\n                    if (morphAttr) for(let m = 0, ml = morphAttr.length; m < ml; m++)newMorphArrays[m][setterFunc](nextIndex, morphAttr[m][getterFunc](index));\n                }\n            }\n            hashToIndex[hash] = nextIndex;\n            newIndices.push(nextIndex);\n            nextIndex++;\n        }\n    }\n    // generate result BufferGeometry\n    const result = geometry.clone();\n    for(const name in geometry.attributes){\n        const tmpAttribute = tmpAttributes[name];\n        result.setAttribute(name, new (0, $ilwiq.BufferAttribute)(tmpAttribute.array.slice(0, nextIndex * tmpAttribute.itemSize), tmpAttribute.itemSize, tmpAttribute.normalized));\n        if (!(name in tmpMorphAttributes)) continue;\n        for(let j = 0; j < tmpMorphAttributes[name].length; j++){\n            const tmpMorphAttribute = tmpMorphAttributes[name][j];\n            result.morphAttributes[name][j] = new (0, $ilwiq.BufferAttribute)(tmpMorphAttribute.array.slice(0, nextIndex * tmpMorphAttribute.itemSize), tmpMorphAttribute.itemSize, tmpMorphAttribute.normalized);\n        }\n    }\n    // indices\n    result.setIndex(newIndices);\n    return result;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */ function $5451ea62abbe5f68$export$5492ca6e5c0c7aa0(geometry, drawMode) {\n    if (drawMode === (0, $ilwiq.TrianglesDrawMode)) {\n        console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n        return geometry;\n    }\n    if (drawMode === (0, $ilwiq.TriangleFanDrawMode) || drawMode === (0, $ilwiq.TriangleStripDrawMode)) {\n        let index = geometry.getIndex();\n        // generate index if not present\n        if (index === null) {\n            const indices = [];\n            const position = geometry.getAttribute(\"position\");\n            if (position !== undefined) {\n                for(let i = 0; i < position.count; i++)indices.push(i);\n                geometry.setIndex(indices);\n                index = geometry.getIndex();\n            } else {\n                console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\");\n                return geometry;\n            }\n        }\n        //\n        const numberOfTriangles = index.count - 2;\n        const newIndices = [];\n        if (drawMode === (0, $ilwiq.TriangleFanDrawMode)) // gl.TRIANGLE_FAN\n        for(let i = 1; i <= numberOfTriangles; i++){\n            newIndices.push(index.getX(0));\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n        }\n        else {\n            // gl.TRIANGLE_STRIP\n            for(let i = 0; i < numberOfTriangles; i++)if (i % 2 === 0) {\n                newIndices.push(index.getX(i));\n                newIndices.push(index.getX(i + 1));\n                newIndices.push(index.getX(i + 2));\n            } else {\n                newIndices.push(index.getX(i + 2));\n                newIndices.push(index.getX(i + 1));\n                newIndices.push(index.getX(i));\n            }\n        }\n        if (newIndices.length / 3 !== numberOfTriangles) console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n        // build final geometry\n        const newGeometry = geometry.clone();\n        newGeometry.setIndex(newIndices);\n        newGeometry.clearGroups();\n        return newGeometry;\n    } else {\n        console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n        return geometry;\n    }\n}\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */ function $5451ea62abbe5f68$export$29e54e2e4ab904e7(object) {\n    const _vA = new (0, $ilwiq.Vector3)();\n    const _vB = new (0, $ilwiq.Vector3)();\n    const _vC = new (0, $ilwiq.Vector3)();\n    const _tempA = new (0, $ilwiq.Vector3)();\n    const _tempB = new (0, $ilwiq.Vector3)();\n    const _tempC = new (0, $ilwiq.Vector3)();\n    const _morphA = new (0, $ilwiq.Vector3)();\n    const _morphB = new (0, $ilwiq.Vector3)();\n    const _morphC = new (0, $ilwiq.Vector3)();\n    function _calculateMorphedAttributeData(object, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {\n        _vA.fromBufferAttribute(attribute, a);\n        _vB.fromBufferAttribute(attribute, b);\n        _vC.fromBufferAttribute(attribute, c);\n        const morphInfluences = object.morphTargetInfluences;\n        if (morphAttribute && morphInfluences) {\n            _morphA.set(0, 0, 0);\n            _morphB.set(0, 0, 0);\n            _morphC.set(0, 0, 0);\n            for(let i = 0, il = morphAttribute.length; i < il; i++){\n                const influence = morphInfluences[i];\n                const morph = morphAttribute[i];\n                if (influence === 0) continue;\n                _tempA.fromBufferAttribute(morph, a);\n                _tempB.fromBufferAttribute(morph, b);\n                _tempC.fromBufferAttribute(morph, c);\n                if (morphTargetsRelative) {\n                    _morphA.addScaledVector(_tempA, influence);\n                    _morphB.addScaledVector(_tempB, influence);\n                    _morphC.addScaledVector(_tempC, influence);\n                } else {\n                    _morphA.addScaledVector(_tempA.sub(_vA), influence);\n                    _morphB.addScaledVector(_tempB.sub(_vB), influence);\n                    _morphC.addScaledVector(_tempC.sub(_vC), influence);\n                }\n            }\n            _vA.add(_morphA);\n            _vB.add(_morphB);\n            _vC.add(_morphC);\n        }\n        if (object.isSkinnedMesh) {\n            object.applyBoneTransform(a, _vA);\n            object.applyBoneTransform(b, _vB);\n            object.applyBoneTransform(c, _vC);\n        }\n        modifiedAttributeArray[a * 3 + 0] = _vA.x;\n        modifiedAttributeArray[a * 3 + 1] = _vA.y;\n        modifiedAttributeArray[a * 3 + 2] = _vA.z;\n        modifiedAttributeArray[b * 3 + 0] = _vB.x;\n        modifiedAttributeArray[b * 3 + 1] = _vB.y;\n        modifiedAttributeArray[b * 3 + 2] = _vB.z;\n        modifiedAttributeArray[c * 3 + 0] = _vC.x;\n        modifiedAttributeArray[c * 3 + 1] = _vC.y;\n        modifiedAttributeArray[c * 3 + 2] = _vC.z;\n    }\n    const geometry = object.geometry;\n    const material = object.material;\n    let a, b, c;\n    const index = geometry.index;\n    const positionAttribute = geometry.attributes.position;\n    const morphPosition = geometry.morphAttributes.position;\n    const morphTargetsRelative = geometry.morphTargetsRelative;\n    const normalAttribute = geometry.attributes.normal;\n    const morphNormal = geometry.morphAttributes.position;\n    const groups = geometry.groups;\n    const drawRange = geometry.drawRange;\n    let i, j, il, jl;\n    let group;\n    let start, end;\n    const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n    const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n    if (index !== null) {\n        // indexed buffer geometry\n        if (Array.isArray(material)) for(i = 0, il = groups.length; i < il; i++){\n            group = groups[i];\n            start = Math.max(group.start, drawRange.start);\n            end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n            for(j = start, jl = end; j < jl; j += 3){\n                a = index.getX(j);\n                b = index.getX(j + 1);\n                c = index.getX(j + 2);\n                _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n        }\n        else {\n            start = Math.max(0, drawRange.start);\n            end = Math.min(index.count, drawRange.start + drawRange.count);\n            for(i = start, il = end; i < il; i += 3){\n                a = index.getX(i);\n                b = index.getX(i + 1);\n                c = index.getX(i + 2);\n                _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n        }\n    } else {\n        // non-indexed buffer geometry\n        if (Array.isArray(material)) for(i = 0, il = groups.length; i < il; i++){\n            group = groups[i];\n            start = Math.max(group.start, drawRange.start);\n            end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n            for(j = start, jl = end; j < jl; j += 3){\n                a = j;\n                b = j + 1;\n                c = j + 2;\n                _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n        }\n        else {\n            start = Math.max(0, drawRange.start);\n            end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n            for(i = start, il = end; i < il; i += 3){\n                a = i;\n                b = i + 1;\n                c = i + 2;\n                _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n        }\n    }\n    const morphedPositionAttribute = new (0, $ilwiq.Float32BufferAttribute)(modifiedPosition, 3);\n    const morphedNormalAttribute = new (0, $ilwiq.Float32BufferAttribute)(modifiedNormal, 3);\n    return {\n        positionAttribute: positionAttribute,\n        normalAttribute: normalAttribute,\n        morphedPositionAttribute: morphedPositionAttribute,\n        morphedNormalAttribute: morphedNormalAttribute\n    };\n}\nfunction $5451ea62abbe5f68$export$8babbf41197098b1(geometry) {\n    if (geometry.groups.length === 0) {\n        console.warn(\"THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.\");\n        return geometry;\n    }\n    let groups = geometry.groups;\n    // sort groups by material index\n    groups = groups.sort((a, b)=>{\n        if (a.materialIndex !== b.materialIndex) return a.materialIndex - b.materialIndex;\n        return a.start - b.start;\n    });\n    // create index for non-indexed geometries\n    if (geometry.getIndex() === null) {\n        const positionAttribute = geometry.getAttribute(\"position\");\n        const indices = [];\n        for(let i = 0; i < positionAttribute.count; i += 3)indices.push(i, i + 1, i + 2);\n        geometry.setIndex(indices);\n    }\n    // sort index\n    const index = geometry.getIndex();\n    const newIndices = [];\n    for(let i = 0; i < groups.length; i++){\n        const group = groups[i];\n        const groupStart = group.start;\n        const groupLength = groupStart + group.count;\n        for(let j = groupStart; j < groupLength; j++)newIndices.push(index.getX(j));\n    }\n    geometry.dispose(); // Required to force buffer recreation\n    geometry.setIndex(newIndices);\n    // update groups indices\n    let start = 0;\n    for(let i = 0; i < groups.length; i++){\n        const group = groups[i];\n        group.start = start;\n        start += group.count;\n    }\n    // merge groups\n    let currentGroup = groups[0];\n    geometry.groups = [\n        currentGroup\n    ];\n    for(let i = 1; i < groups.length; i++){\n        const group = groups[i];\n        if (currentGroup.materialIndex === group.materialIndex) currentGroup.count += group.count;\n        else {\n            currentGroup = group;\n            geometry.groups.push(currentGroup);\n        }\n    }\n    return geometry;\n}\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry\n * @param {number} [creaseAngle]\n * @return {BufferGeometry}\n */ function $5451ea62abbe5f68$export$b525764477fc001f(geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n    const creaseDot = Math.cos(creaseAngle);\n    const hashMultiplier = (1 + 1e-10) * 1e2;\n    // reusable vectors\n    const verts = [\n        new (0, $ilwiq.Vector3)(),\n        new (0, $ilwiq.Vector3)(),\n        new (0, $ilwiq.Vector3)()\n    ];\n    const tempVec1 = new (0, $ilwiq.Vector3)();\n    const tempVec2 = new (0, $ilwiq.Vector3)();\n    const tempNorm = new (0, $ilwiq.Vector3)();\n    const tempNorm2 = new (0, $ilwiq.Vector3)();\n    // hashes a vector\n    function hashVertex(v) {\n        const x = ~~(v.x * hashMultiplier);\n        const y = ~~(v.y * hashMultiplier);\n        const z = ~~(v.z * hashMultiplier);\n        return `${x},${y},${z}`;\n    }\n    // BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n    // and returns the original geometry\n    const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n    const posAttr = resultGeometry.attributes.position;\n    const vertexMap = {};\n    // find all the normals shared by commonly located vertices\n    for(let i = 0, l = posAttr.count / 3; i < l; i++){\n        const i3 = 3 * i;\n        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n        tempVec1.subVectors(c, b);\n        tempVec2.subVectors(a, b);\n        // add the normal to the map for all vertices\n        const normal = new (0, $ilwiq.Vector3)().crossVectors(tempVec1, tempVec2).normalize();\n        for(let n = 0; n < 3; n++){\n            const vert = verts[n];\n            const hash = hashVertex(vert);\n            if (!(hash in vertexMap)) vertexMap[hash] = [];\n            vertexMap[hash].push(normal);\n        }\n    }\n    // average normals from all vertices that share a common location if they are within the\n    // provided crease threshold\n    const normalArray = new Float32Array(posAttr.count * 3);\n    const normAttr = new (0, $ilwiq.BufferAttribute)(normalArray, 3, false);\n    for(let i = 0, l = posAttr.count / 3; i < l; i++){\n        // get the face normal for this vertex\n        const i3 = 3 * i;\n        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n        tempVec1.subVectors(c, b);\n        tempVec2.subVectors(a, b);\n        tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n        // average all normals that meet the threshold and set the normal value\n        for(let n = 0; n < 3; n++){\n            const vert = verts[n];\n            const hash = hashVertex(vert);\n            const otherNormals = vertexMap[hash];\n            tempNorm2.set(0, 0, 0);\n            for(let k = 0, lk = otherNormals.length; k < lk; k++){\n                const otherNorm = otherNormals[k];\n                if (tempNorm.dot(otherNorm) > creaseDot) tempNorm2.add(otherNorm);\n            }\n            tempNorm2.normalize();\n            normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n        }\n    }\n    resultGeometry.setAttribute(\"normal\", normAttr);\n    return resultGeometry;\n}\n\n});\n\n\n//# sourceMappingURL=aoRender.5fc59dbe.js.map\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet gpuType = - 1;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\n\t\tif ( gpuType !== attribute.gpuType ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.count * itemSize;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tconst result = new BufferAttribute( array, itemSize, normalized );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst tupleOffset = offset / itemSize;\n\t\t\tfor ( let j = 0, l = attribute.count; j < l; j ++ ) {\n\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\t\tconst value = attribute.getComponent( j, c );\n\t\t\t\t\tresult.setComponent( j + tupleOffset, c, value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tarray.set( attribute.array, offset );\n\n\t\t}\n\n\t\toffset += attribute.count * itemSize;\n\n\t}\n\n\tif ( gpuType !== undefined ) {\n\n\t\tresult.gpuType = gpuType;\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new BufferAttribute(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\ttmpMorphAttributes[ name ] = new BufferAttribute(\n\t\t\t\tnew morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize ),\n\t\t\t\tmorphAttr.itemSize,\n\t\t\t\tmorphAttr.normalized\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst halfTolerance = tolerance * 0.5;\n\tconst exponent = Math.log10( 1 / tolerance );\n\tconst hashMultiplier = Math.pow( 10, exponent );\n\tconst hashAdditive = halfTolerance * hashMultiplier;\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * hashMultiplier + hashAdditive ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewarray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new BufferAttribute(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new BufferAttribute(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry\n * @param {number} [creaseAngle]\n * @return {BufferGeometry}\n */\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vectors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\t// BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n\t// and returns the original geometry\n\tconst resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$5451ea62abbe5f68$export$676e3e70c930f774","$5451ea62abbe5f68$export$f06f69b3bf41d25c","$5451ea62abbe5f68$export$e36bb98c4c944f9","$5451ea62abbe5f68$export$5492ca6e5c0c7aa0","$ilwiq","geometry","MikkTSpace","negateSign","isReady","hasAttribute","getAttributeArray","attribute","normalized","isInterleavedBufferAttribute","dstArray","Float32Array","count","itemSize","i","j","getX","getY","getZ","array","_geometry","index","toNonIndexed","tangents","generateTangents","attributes","position","normal","uv","length","setAttribute","BufferAttribute","copy","geometries","useGroups","isIndexed","attributesUsed","Set","keys","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","BufferGeometry","offset","attributesCount","console","error","name","has","undefined","push","size","addGroup","indexOffset","mergedIndex","setIndex","mergedAttribute","$5451ea62abbe5f68$export$9f98db6234c4bd78","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","gpuType","arrayLength","constructor","result","tupleOffset","l","c","value","getComponent","setComponent","tolerance","Math","max","Number","EPSILON","hashToIndex","indices","getIndex","positions","getAttribute","vertexCount","nextIndex","attributeNames","tmpAttributes","tmpMorphAttributes","newIndices","getters","setters","attr","morphAttr","halfTolerance","hashMultiplier","pow","log10","hashAdditive","hash","k","newarray","newMorphArrays","getterFunc","setterFunc","m","ml","clone","tmpAttribute","slice","tmpMorphAttribute","drawMode","TrianglesDrawMode","warn","TriangleFanDrawMode","TriangleStripDrawMode","numberOfTriangles","newGeometry","clearGroups"],"version":3,"file":"aoRender.5fc59dbe.js.map"}