import{B as H,al as D,ak as I,aj as O,K as F}from"./MaterialBase-byhyp4gt.js";function N(t,a,n=!0){if(!a||!a.isReady)throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!t.hasAttribute("position")||!t.hasAttribute("normal")||!t.hasAttribute("uv"))throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function f(e){if(e.normalized||e.isInterleavedBufferAttribute){const c=new Float32Array(e.count*e.itemSize);for(let s=0,l=0;s<e.count;s++)c[l++]=e.getX(s),c[l++]=e.getY(s),e.itemSize>2&&(c[l++]=e.getZ(s));return c}return e.array instanceof Float32Array?e.array:new Float32Array(e.array)}const i=t.index?t.toNonIndexed():t,h=a.generateTangents(f(i.attributes.position),f(i.attributes.normal),f(i.attributes.uv));if(n)for(let e=3;e<h.length;e+=4)h[e]*=-1;return i.setAttribute("tangent",new H(h,4)),t!==i&&t.copy(i),t}function Y(t,a=!1){const n=t[0].index!==null,f=new Set(Object.keys(t[0].attributes)),i=new Set(Object.keys(t[0].morphAttributes)),h={},e={},c=t[0].morphTargetsRelative,s=new F;let l=0;for(let r=0;r<t.length;++r){const u=t[r];let d=0;if(n!==(u.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+r+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const o in u.attributes){if(!f.has(o))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+r+'. All geometries must have compatible attributes; make sure "'+o+'" attribute exists among all geometries, or in none of them.'),null;h[o]===void 0&&(h[o]=[]),h[o].push(u.attributes[o]),d++}if(d!==f.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+r+". Make sure all geometries have the same number of attributes."),null;if(c!==u.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+r+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const o in u.morphAttributes){if(!i.has(o))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+r+".  .morphAttributes must be consistent throughout all geometries."),null;e[o]===void 0&&(e[o]=[]),e[o].push(u.morphAttributes[o])}if(a){let o;if(n)o=u.index.count;else if(u.attributes.position!==void 0)o=u.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+r+". The geometry must have either an index or a position attribute"),null;s.addGroup(l,o,r),l+=o}}if(n){let r=0;const u=[];for(let d=0;d<t.length;++d){const o=t[d].index;for(let p=0;p<o.count;++p)u.push(o.getX(p)+r);r+=t[d].attributes.position.count}s.setIndex(u)}for(const r in h){const u=v(h[r]);if(!u)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+r+" attribute."),null;s.setAttribute(r,u)}for(const r in e){const u=e[r][0].length;if(u===0)break;s.morphAttributes=s.morphAttributes||{},s.morphAttributes[r]=[];for(let d=0;d<u;++d){const o=[];for(let T=0;T<e[r].length;++T)o.push(e[r][T][d]);const p=v(o);if(!p)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+r+" morphAttribute."),null;s.morphAttributes[r].push(p)}}return s}function v(t){let a,n,f,i=-1,h=0;for(let l=0;l<t.length;++l){const r=t[l];if(a===void 0&&(a=r.array.constructor),a!==r.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(n===void 0&&(n=r.itemSize),n!==r.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(f===void 0&&(f=r.normalized),f!==r.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(i===-1&&(i=r.gpuType),i!==r.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;h+=r.count*n}const e=new a(h),c=new H(e,n,f);let s=0;for(let l=0;l<t.length;++l){const r=t[l];if(r.isInterleavedBufferAttribute){const u=s/n;for(let d=0,o=r.count;d<o;d++)for(let p=0;p<n;p++){const T=r.getComponent(d,p);c.setComponent(d+u,p,T)}}else e.set(r.array,s);s+=r.count*n}return i!==void 0&&(c.gpuType=i),c}function Z(t,a=1e-4){a=Math.max(a,Number.EPSILON);const n={},f=t.getIndex(),i=t.getAttribute("position"),h=f?f.count:i.count;let e=0;const c=Object.keys(t.attributes),s={},l={},r=[],u=["getX","getY","getZ","getW"],d=["setX","setY","setZ","setW"];for(let b=0,y=c.length;b<y;b++){const g=c[b],m=t.attributes[g];s[g]=new m.constructor(new m.array.constructor(m.count*m.itemSize),m.itemSize,m.normalized);const E=t.morphAttributes[g];E&&(l[g]||(l[g]=[]),E.forEach((A,w)=>{const x=new A.array.constructor(A.count*A.itemSize);l[g][w]=new A.constructor(x,A.itemSize,A.normalized)}))}const o=a*.5,p=Math.log10(1/a),T=Math.pow(10,p),M=o*T;for(let b=0;b<h;b++){const y=f?f.getX(b):b;let g="";for(let m=0,E=c.length;m<E;m++){const A=c[m],w=t.getAttribute(A),x=w.itemSize;for(let G=0;G<x;G++)g+=`${~~(w[u[G]](y)*T+M)},`}if(g in n)r.push(n[g]);else{for(let m=0,E=c.length;m<E;m++){const A=c[m],w=t.getAttribute(A),x=t.morphAttributes[A],G=w.itemSize,X=s[A],j=l[A];for(let B=0;B<G;B++){const S=u[B],R=d[B];if(X[R](e,w[S](y)),x)for(let U=0,k=x.length;U<k;U++)j[U][R](e,x[U][S](y))}}n[g]=e,r.push(e),e++}}const z=t.clone();for(const b in t.attributes){const y=s[b];if(z.setAttribute(b,new y.constructor(y.array.slice(0,e*y.itemSize),y.itemSize,y.normalized)),b in l)for(let g=0;g<l[b].length;g++){const m=l[b][g];z.morphAttributes[b][g]=new m.constructor(m.array.slice(0,e*m.itemSize),m.itemSize,m.normalized)}}return z.setIndex(r),z}function q(t,a){if(a===D)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),t;if(a===I||a===O){let n=t.getIndex();if(n===null){const e=[],c=t.getAttribute("position");if(c!==void 0){for(let s=0;s<c.count;s++)e.push(s);t.setIndex(e),n=t.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),t}const f=n.count-2,i=[];if(a===I)for(let e=1;e<=f;e++)i.push(n.getX(0)),i.push(n.getX(e)),i.push(n.getX(e+1));else for(let e=0;e<f;e++)e%2===0?(i.push(n.getX(e)),i.push(n.getX(e+1)),i.push(n.getX(e+2))):(i.push(n.getX(e+2)),i.push(n.getX(e+1)),i.push(n.getX(e)));i.length/3!==f&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const h=t.clone();return h.setIndex(i),h.clearGroups(),h}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",a),t}export{Z as a,N as c,Y as m,q as t};
