{"mappings":"IgBkHI,EAAY,EAAK,EACjB,EAAY,EAAU,EAAa,EAAmB,EACtD,EAAU,EAAO,EACjB,EACA,E,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,a,I,G,I,E,E,Qf1GJ,OAAM,UAAmB,EAAA,iBAAgB,CAExC,YAAa,CAAO,CAAG,CAEtB,KAAK,CAAE,GAEP,IAAI,CAAC,IAAI,CAAG,EAAA,aAAY,AAEzB,CAIA,MAAO,CAAM,CAAG,KAgVX,EAAM,EACN,EA/UJ,IAMC,EAAa,SAAW,CAAe,CAAE,CAAG,EAE3C,OAAS,GAER,KARgB,EAQM,MAAM,AAAI,MAAO,iCAAqC,CAAA,GAAO,EAAA,EACnF,MARiB,EAQM,MAAM,AAAI,MAAO,kCAAsC,CAAA,GAAO,EAAA,EACrF,MARkB,EAQM,MAAM,AAAI,MAAO,sCAA0C,CAAA,GAAO,EAAA,EAC1F,SACwB,MAAM,AAAI,MAAO,mCAAuC,CAAA,GAAO,EAAA,EAExF,CAED,EAiBA,EAAQ,SAAW,CAAM,CAAE,CAAS,CAAE,CAAO,EAI5C,EAAY,AAAE,GAAY,KAC1B,IAAI,EAAI,EAAO,GAAG,CACjB,EAAI,GAAK,EAAM,EAAG,EAAI,GACtB,EAAQ,OAAO,YAAY,CAAC,KAAK,CAAE,KAAM,IAAI,YAAa,EAAO,QAAQ,CAAE,EAAG,EAL7D,OAOlB,KAAU,EAAM,CAAA,EAAI,EAAM,OAAO,CAXxB,KAW0B,GAAmB,EAAM,GAAiB,EAAI,EAAO,UAAU,EAEjG,GAAK,EAAO,GAAO,EAAM,MAAM,CAC/B,GAViB,IAWjB,GAAS,OAAO,YAAY,CAAC,KAAK,CAAE,KAAM,IAAI,YAAa,EAAO,QAAQ,CAAE,EAAG,EAX9D,cAelB,AAAK,GAAM,IAQL,CAAA,IAAU,GAAU,CAAA,EAAO,GAAG,EAAI,EAAM,EAAI,CAAA,EAC1C,EAAI,EAAM,KAAK,CAAE,EAAG,GAM7B,EAkQK,EAAY,IAAI,WAAY,EAClC,CAAA,EAAU,GAAG,CAAG,EAChB,IAAM,EAAmB,AAjQN,SAAW,CAAM,MA+B9B,EAAM,EA3BV,IACC,EAAW,oCACX,EAAc,uCACd,EAAY,uBACZ,EAAgB,oCAGhB,EAAS,CAER,MAAO,EAEP,OAAQ,GAER,SAAU,GAEV,YAAa,OAEb,OAAQ,GAER,MAAO,EAEP,SAAU,EAEV,MAAO,EAAG,OAAQ,CAEnB,EAqBD,KAjBK,CAAA,EAAO,GAAG,EAAI,EAAO,UAAU,AAAV,GAAkB,CAAA,EAAO,EAAO,EAAA,GAEzD,EAvGgB,EAuGa,mBAKrB,CAAA,EAAQ,EAAK,KAAK,CApCJ,YAoCM,GAE5B,EA5GkB,EA4Ga,qBAIhC,EAAO,KAAK,EAvFY,EAwFxB,EAAO,WAAW,CAAG,CAAK,CAAE,EAAG,CAC/B,EAAO,MAAM,EAAI,EAAO,KAKlB,CAAA,IADL,CAAA,EAAO,EAAO,EAAd,GAFc,CAMd,GAFA,EAAO,MAAM,EAAI,EAAO,KAEnB,MAAQ,EAAK,MAAM,CAAE,GAAM,CAE/B,EAAO,QAAQ,EAAI,EAAO,KAC1B,QAED,CA6BA,GA3BK,CAAA,EAAQ,EAAK,KAAK,CAAE,EAAA,GAExB,CAAA,EAAO,KAAK,CAAG,WAAY,CAAK,CAAE,EAAG,CAAA,EAIjC,CAAA,EAAQ,EAAK,KAAK,CAAE,EAAA,GAExB,CAAA,EAAO,QAAQ,CAAG,WAAY,CAAK,CAAE,EAAG,CAAA,EAIpC,CAAA,EAAQ,EAAK,KAAK,CAAE,EAAA,IAExB,EAAO,KAAK,EArHK,EAsHjB,EAAO,MAAM,CAAG,CAAK,CAAE,EAAG,EAItB,CAAA,EAAQ,EAAK,KAAK,CAAE,EAAA,IAExB,EAAO,KAAK,EA3HS,EA4HrB,EAAO,MAAM,CAAG,SAAU,CAAK,CAAE,EAAG,CAAE,IACtC,EAAO,KAAK,CAAG,SAAU,CAAK,CAAE,EAAG,CAAE,KAI/B,AAlIW,EAkIX,EAAO,KAAK,EAA4B,AAjIzB,EAiIyB,EAAO,KAAK,CAA6B,KAEzF,CAcA,OAlJmB,EAsIV,EAAO,KAAK,EAEpB,EAlKkB,EAkKa,4BAvIT,EA2Id,EAAO,KAAK,EAEpB,EAxKkB,EAwKa,gCAIzB,CAER,EAqJyC,GAEpC,EAAI,EAAiB,KAAK,CAC/B,EAAI,EAAiB,MAAM,CAC3B,EAAkB,AAvJI,SAAW,CAAM,CAAE,CAAC,CAAE,CAAC,EAI5C,GAEK,AAJkB,EAID,GAAS,AAJR,EAIyB,OAE3C,IAAM,CAAM,CAAE,EAAG,EAAQ,IAAM,CAAM,CAAE,EAAG,EAAQ,AAAc,IAAd,CAAM,CAAE,EAAG,CAIjE,OAAO,IAAI,WAAY,GAVD,IAcK,CAAA,CAAM,CAAE,EAAG,EAAI,EAAM,CAAM,CAAE,EAAE,AAAF,GAExD,EAlMkB,EAkMa,wBAIhC,IAAM,EAAY,IAAI,WAAY,EAAI,EAAI,EAEnC,CAAA,EAAU,MAAM,EAEtB,EAzMkB,EAyMa,mCAIhC,IAAI,EAAS,EAAG,EAAM,EAEhB,EAAU,EA9BO,EA+BjB,EAAY,IAAI,WAAY,GAC5B,EAAkB,IAAI,WAAY,GACpC,EAAgB,EAGpB,KAAU,EAAgB,GAAS,EAAM,EAAO,UAAU,EAAK,CAEzD,EAAM,EAAI,EAAO,UAAU,EAE/B,EA5Ne,GAgOhB,CAAS,CAAE,EAAG,CAAG,CAAM,CAAE,IAAQ,CACjC,CAAS,CAAE,EAAG,CAAG,CAAM,CAAE,IAAQ,CACjC,CAAS,CAAE,EAAG,CAAG,CAAM,CAAE,IAAQ,CACjC,CAAS,CAAE,EAAG,CAAG,CAAM,CAAE,IAAQ,CAE5B,CAAA,GAAO,CAAS,CAAE,EAAG,EAAQ,GAAK,CAAS,CAAE,EAAG,EAAU,AAAA,CAAA,CAAW,CAAE,EAAG,EAAI,EAAM,CAAS,CAAE,EAAE,AAAF,GAjD9E,CAiDuF,GAE5G,EArOiB,EAqOc,4BAMhC,IAAI,EAAM,EAAG,EAEb,KAAU,EAAM,GAAe,EAAM,EAAO,UAAU,EAAK,CAG1D,IAAM,EAAe,AADrB,CAAA,EAAQ,CAAM,CAAE,IAAQ,AAAR,EACa,IAS7B,GARK,GAAe,CAAA,GAAS,GAA7B,EAEO,CAAA,IAAM,GAAa,EAAM,EAAQ,CAAA,GAEvC,EArPgB,EAqPe,qBAI3B,EAAe,CAGnB,IAAM,EAAY,CAAM,CAAE,IAAQ,CAClC,IAAM,IAAI,EAAI,EAAG,EAAI,EAAO,IAE3B,CAAe,CAAE,IAAQ,CAAG,CAK9B,MAGC,EAAgB,GAAG,CAAE,EAAO,QAAQ,CAAE,EAAK,EAAM,GAAS,GAC1D,GAAO,EAAO,GAAO,CAIvB,CAMA,IAAM,IAAI,EAAI,EAAG,EAhGK,EAgGE,IAAO,CAE9B,IAAI,EAAM,CACV,CAAA,CAAS,CAAE,EAAQ,CAAG,CAAe,CAAE,EAAI,EAAK,CAChD,GApGqB,EAqGrB,CAAS,CAAE,EAAS,EAAG,CAAG,CAAe,CAAE,EAAI,EAAK,CACpD,GAtGqB,EAuGrB,CAAS,CAAE,EAAS,EAAG,CAAG,CAAe,CAAE,EAAI,EAAK,CACpD,GAxGqB,EAyGrB,CAAS,CAAE,EAAS,EAAG,CAAG,CAAe,CAAE,EAAI,EAAK,CACpD,GAAU,CAEX,CAEA,GAED,CAEA,OAAO,CAER,EAiCuC,EAAU,QAAQ,CAAE,EAAU,GAAG,EAAI,EAAG,GAMhF,OAAS,IAAI,CAAC,IAAI,EAEjB,KAAK,EAAL,SAAA,CAGC,IAAM,EAAa,IAAI,aAAc,AAAc,EADnD,CAAA,EAAc,EAAgB,MAAM,CAAG,CAAA,GAGvC,IAAM,IAAI,EAAI,EAAG,EAAI,EAAa,KAEjC,AA9CwB,SAAW,CAAW,CAAE,CAAY,CAAE,CAAS,CAAE,CAAU,EAGrF,IAAM,EAAQ,KAAK,GAAG,CAAE,EAAK,AADnB,CAAW,CAAE,EAAe,EAAG,CACR,KAAU,GAE3C,CAAA,CAAS,CAAE,EAAa,EAAG,CAAG,CAAW,CAAE,EAAe,EAAG,CAAG,EAChE,CAAS,CAAE,EAAa,EAAG,CAAG,CAAW,CAAE,EAAe,EAAG,CAAG,EAChE,CAAS,CAAE,EAAa,EAAG,CAAG,CAAW,CAAE,EAAe,EAAG,CAAG,EAChE,CAAS,CAAE,EAAa,EAAG,CAAG,CAE/B,EAoCuB,EAAiB,AAAI,EAAJ,EAAO,EAAY,AAAI,EAAJ,GAIzD,EAAO,EACP,EAAO,EAAA,SAAQ,CACf,KAED,MAAK,EAAL,aAAA,CAGC,IAAM,EAAY,IAAI,YAAa,AAAc,EADjD,CAAA,EAAc,EAAgB,MAAM,CAAG,CAAA,GAGvC,IAAM,IAAI,EAAI,EAAG,EAAI,EAAa,KAEjC,AAjDuB,SAAW,CAAW,CAAE,CAAY,CAAE,CAAS,CAAE,CAAU,EAGpF,IAAM,EAAQ,KAAK,GAAG,CAAE,EAAK,AADnB,CAAW,CAAE,EAAe,EAAG,CACR,KAAU,GAG3C,CAAA,CAAS,CAAE,EAAa,EAAG,CAAG,AAAA,CAAA,EAAA,EAAA,SAAQ,AAAR,EAAU,WAAW,CAAE,KAAK,GAAG,CAAE,CAAW,CAAE,EAAe,EAAG,CAAG,EAAO,QACxG,CAAS,CAAE,EAAa,EAAG,CAAG,AAAA,CAAA,EAAA,EAAA,SAAQ,AAAR,EAAU,WAAW,CAAE,KAAK,GAAG,CAAE,CAAW,CAAE,EAAe,EAAG,CAAG,EAAO,QACxG,CAAS,CAAE,EAAa,EAAG,CAAG,AAAA,CAAA,EAAA,EAAA,SAAQ,AAAR,EAAU,WAAW,CAAE,KAAK,GAAG,CAAE,CAAW,CAAE,EAAe,EAAG,CAAG,EAAO,QACxG,CAAS,CAAE,EAAa,EAAG,CAAG,AAAA,CAAA,EAAA,EAAA,SAAQ,AAAR,EAAU,WAAW,CAAE,EAEtD,EAsCsB,EAAiB,AAAI,EAAJ,EAAO,EAAW,AAAI,EAAJ,GAIvD,EAAO,EACP,EAAO,EAAA,aAAY,CACnB,KAED,SAEC,MAAM,AAAI,MAAO,uCAAyC,IAAI,CAAC,IAAI,CAGrE,CAEA,MAAO,CACN,MAAO,EAAG,OAAQ,EAClB,KAAM,EACN,OAAQ,EAAiB,MAAM,CAC/B,MAAO,EAAiB,KAAK,CAC7B,SAAU,EAAiB,QAAQ,CACnC,KAAM,CACP,CAED,CAEA,YAAa,CAAK,CAAG,CAGpB,OADA,IAAI,CAAC,IAAI,CAAG,EACL,IAAI,AAEZ,CAEA,KAAM,CAAG,CAAE,CAAM,CAAE,CAAU,CAAE,CAAO,CAAG,CAuBxC,OAAO,KAAK,CAAC,KAAM,EArBnB,SAAyB,CAAO,CAAE,CAAO,EAExC,OAAS,EAAQ,IAAI,EAEpB,KAAK,EAAL,SAAA,CACA,KAAK,EAAL,aAAA,CAEC,EAAQ,UAAU,CAAG,EAAA,oBAAmB,CACxC,EAAQ,SAAS,CAAG,EAAA,YAAW,CAC/B,EAAQ,SAAS,CAAG,EAAA,YAAW,CAC/B,EAAQ,eAAe,CAAG,CAAA,EAC1B,EAAQ,KAAK,CAAG,CAAA,CAIlB,CAEK,GAAS,EAAQ,EAAS,EAEhC,EAEwC,EAAY,EAErD,CAED,C,G,E,Q,S,C,C,C,E,E,E,O,C,U,I,GC/bA,IAAI,EAAQ,WAEX,IAAI,EAAO,EAEP,EAAY,SAAS,aAAa,CAAE,OAWxC,SAAS,EAAU,CAAK,EAGvB,OADA,EAAU,WAAW,CAAE,EAAM,GAAG,EACzB,CAER,CAEA,SAAS,EAAW,CAAE,EAErB,IAAM,IAAI,EAAI,EAAG,EAAI,EAAU,QAAQ,CAAC,MAAM,CAAE,IAE/C,EAAU,QAAQ,CAAE,EAAG,CAAC,KAAK,CAAC,OAAO,CAAG,IAAM,EAAK,QAAU,OAI9D,EAAO,CAER,CA3BA,EAAU,KAAK,CAAC,OAAO,CAAG,uEAC1B,EAAU,gBAAgB,CAAE,QAAS,SAAW,CAAK,EAEpD,EAAM,cAAc,GACpB,EAAW,EAAG,EAAO,EAAU,QAAQ,CAAC,MAAM,CAE/C,EAAG,CAAA,GAyBH,IAAI,EAAc,AAAA,CAAA,aAAe,IAAA,EAAO,GAAG,GAAI,EAAW,EAAW,EAAS,EAE1E,EAAW,EAAU,IAAI,EAAM,KAAK,CAAE,MAAO,OAAQ,SACrD,EAAU,EAAU,IAAI,EAAM,KAAK,CAAE,KAAM,OAAQ,SAEvD,GAAK,KAAK,WAAW,EAAI,KAAK,WAAW,CAAC,MAAM,CAE/C,IAAI,EAAW,EAAU,IAAI,EAAM,KAAK,CAAE,KAAM,OAAQ,SAMzD,OAFA,EAAW,GAEJ,CAEN,SAAU,GAEV,IAAK,EAEL,SAAU,EACV,UAAW,EAEX,MAAO,WAEN,EAAc,AAAA,CAAA,aAAe,IAAA,EAAO,GAAG,EAExC,EAEA,IAAK,WAEJ,IAEA,IAAI,EAAO,AAAE,CAAA,aAAe,IAAA,EAAO,GAAG,GAItC,GAFA,EAAQ,MAAM,CAAE,EAAO,EAAW,KAE7B,GAAQ,EAAW,MAEvB,EAAS,MAAM,CAAI,AAAS,IAAT,EAAoB,CAAA,EAAO,CAAA,EAAY,KAE1D,EAAW,EACX,EAAS,EAEJ,GAAW,CAEf,IAAI,EAAS,YAAY,MAAM,CAC/B,EAAS,MAAM,CAAE,EAAO,cAAc,CAAG,QAAS,EAAO,eAAe,CAAG,QAE5E,CAID,OAAO,CAER,EAEA,OAAQ,WAEP,EAAY,IAAI,CAAC,GAAG,EAErB,EAIA,WAAY,EACZ,QAAS,CAEV,CAED,CAEA,CAAA,EAAM,KAAK,CAAG,SAAW,CAAI,CAAE,CAAE,CAAE,CAAE,EAEpC,IAAI,EAAM,IAAU,EAAM,EAAG,EAAQ,KAAK,KAAK,CAC3C,EAAK,EAAO,OAAO,gBAAgB,EAAI,GAEvC,EAAQ,GAAK,EAAI,EAAS,GAAK,EAClC,EAAS,EAAI,EAAI,EAAS,EAAI,EAC9B,EAAU,EAAI,EAAI,EAAU,GAAK,EACjC,EAAc,GAAK,EAAI,EAAe,GAAK,EAExC,EAAS,SAAS,aAAa,CAAE,SACrC,CAAA,EAAO,KAAK,CAAG,EACf,EAAO,MAAM,CAAG,EAChB,EAAO,KAAK,CAAC,OAAO,CAAG,yBAEvB,IAAI,EAAU,EAAO,UAAU,CAAE,MAejC,OAdA,EAAQ,IAAI,CAAG,QAAY,EAAI,EAAO,gCACtC,EAAQ,YAAY,CAAG,MAEvB,EAAQ,SAAS,CAAG,EACpB,EAAQ,QAAQ,CAAE,EAAG,EAAG,EAAO,GAE/B,EAAQ,SAAS,CAAG,EACpB,EAAQ,QAAQ,CAAE,EAAM,EAAQ,GAChC,EAAQ,QAAQ,CAAE,EAAS,EAAS,EAAa,GAEjD,EAAQ,SAAS,CAAG,EACpB,EAAQ,WAAW,CAAG,GACtB,EAAQ,QAAQ,CAAE,EAAS,EAAS,EAAa,GAE1C,CAEN,IAAK,EAEL,OAAQ,SAAW,CAAK,CAAE,CAAQ,EAEjC,EAAM,KAAK,GAAG,CAAE,EAAK,GACrB,EAAM,KAAK,GAAG,CAAE,EAAK,GAErB,EAAQ,SAAS,CAAG,EACpB,EAAQ,WAAW,CAAG,EACtB,EAAQ,QAAQ,CAAE,EAAG,EAAG,EAAO,GAC/B,EAAQ,SAAS,CAAG,EACpB,EAAQ,QAAQ,CAAE,EAAO,GAAU,IAAM,EAAO,KAAO,EAAO,GAAQ,IAAM,EAAO,GAAQ,IAAK,EAAQ,GAExG,EAAQ,SAAS,CAAE,EAAQ,EAAU,EAAI,EAAS,EAAc,EAAI,EAAc,EAAS,EAAS,EAAc,EAAI,GAEtH,EAAQ,QAAQ,CAAE,EAAU,EAAc,EAAI,EAAS,EAAI,GAE3D,EAAQ,SAAS,CAAG,EACpB,EAAQ,WAAW,CAAG,GACtB,EAAQ,QAAQ,CAAE,EAAU,EAAc,EAAI,EAAS,EAAI,EAAS,AAAA,CAAA,EAAM,EAAQ,CAAA,EAAe,GAElG,CAED,CAED,EAEA,IAAA,EAAe,C,G,E,Q,S,C,C,C,E,E,E,O,C,6B,I,G,I,E,E,SCpKR,SAAS,EAA4B,CAAG,EAE9C,IAAM,EAAO,IAAI,WAAY,EAAM,EAAM,GAEzC,IAAM,IAAI,EAAI,EAAG,EAAI,EAAK,IAEzB,IAAM,IAAI,EAAI,EAAG,EAAI,EAAK,IAAO,CAOhC,IAAI,EAAI,KAAK,GAAG,CAAE,KAAK,GAAG,CAAE,EAAM,KAAK,IAAI,CAAE,AAF/B,CAAA,EAAQ,CAAA,AAHR,EAAM,CAAA,EAAM,CAAA,EAGI,EAAA,CAAE,GAEsB,EAAI,AAD5C,CAAA,EAAQ,CAAA,AAHR,EAAM,CAAA,EAAM,CAAA,EAGI,EAAA,CAAE,GACmC,GAAK,GAAO,GAG/E,EAAI,KAAK,GAAG,CADZ,EADI,GAAK,EACD,IACS,GAEjB,IAAM,EAAI,EAAI,EAAM,CACpB,CAAA,CAAI,CAAE,AAAI,EAAJ,EAAQ,EAAG,CAAG,IACpB,CAAI,CAAE,AAAI,EAAJ,EAAQ,EAAG,CAAG,IACpB,CAAI,CAAE,AAAI,EAAJ,EAAQ,EAAG,CAAG,IACpB,CAAI,CAAE,AAAI,EAAJ,EAAQ,EAAG,CAAG,AAAI,IAAJ,CAErB,CAID,IAAM,EAAM,IAAI,EAAA,WAAA,CAAmB,EAAM,EAAK,GAQ9C,OAPA,EAAI,MAAM,CAAG,EAAb,UAAA,CACA,EAAI,IAAI,CAAG,EAAX,gBAAA,CACA,EAAI,SAAS,CAAG,EAAhB,YAAA,CACA,EAAI,SAAS,CAAG,EAAhB,YAAA,CACA,EAAI,KAAK,CAAG,EAAZ,cAAA,CACA,EAAI,KAAK,CAAG,EAAZ,cAAA,CACA,EAAI,WAAW,CAAG,CAAA,EACX,CAER,C,G,E,Q,S,C,C,C,E,E,E,O,C,oB,I,GCxCO,SAAS,IAEf,IAAI,EAAQ,EACR,EAAc,KAAK,GAAG,CAAE,EAAI,OAAO,gBAAgB,CAAE,IAWzD,OARoB,OAAO,UAAU,CAAG,OAAO,WAAW,CACvC,MAElB,EAAQ,EACR,EAAc,GAAM,OAAO,gBAAgB,EAIrC,CAAE,MAAA,EAAO,YAAA,CAAY,CAE7B,C,G,E,Q,S,C,C,C,MChBI,E,E,E,O,C,gB,I,EAuEG,OAAM,EAEZ,aAAc,CAtET,IAOL,AADA,CAAA,EAAgB,SAAS,aAAa,CAAE,QAAxC,EACc,WAAW,CAAY,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwDtC,CAAC,CACD,SAAS,IAAI,CAAC,WAAW,CAAE,IAU1B,IAAM,EAAY,SAAS,aAAa,CAAE,OAC1C,EAAU,SAAS,CAAC,GAAG,CAAE,oBAEzB,IAAM,EAAe,SAAS,aAAa,CAAE,OAC7C,EAAa,SAAS,CAAC,GAAG,CAAE,cAC5B,EAAU,WAAW,CAAE,GAEvB,IAAM,EAAY,SAAS,aAAa,CAAE,OAC1C,EAAU,SAAS,CAAC,GAAG,CAAE,WACzB,EAAU,WAAW,CAAE,GAEvB,IAAM,EAAY,SAAS,aAAa,CAAE,OAC1C,EAAU,SAAS,CAAC,GAAG,CAAE,WACzB,EAAU,WAAW,CAAE,GAEvB,IAAM,EAAc,SAAS,aAAa,CAAE,OAC5C,EAAY,SAAS,CAAC,GAAG,CAAE,OAC3B,EAAU,WAAW,CAAE,GAEvB,IAAM,EAAgB,SAAS,aAAa,CAAE,OAC9C,EAAc,SAAS,CAAC,GAAG,CAAE,eAC7B,EAAU,WAAW,CAAE,GAEvB,IAAI,CAAC,YAAY,CAAG,EACpB,IAAI,CAAC,UAAU,CAAG,EAClB,IAAI,CAAC,WAAW,CAAG,EACnB,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,UAAU,CAAG,EAElB,IAAI,CAAC,aAAa,CAAE,EAErB,CAEA,OAAQ,CAAS,CAAG,CAEnB,EAAU,WAAW,CAAE,IAAI,CAAC,UAAU,EACtC,EAAU,WAAW,CAAE,IAAI,CAAC,YAAY,CAEzC,CAEA,cAAe,CAAI,CAAG,CAErB,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,CAAG,CAAC,EAAG,AAAO,IAAP,EAAY,CAAC,CAAC,CAE3C,AAAS,IAAT,EAEJ,IAAI,CAAC,WAAW,CAAC,SAAS,CAAG,aAI7B,IAAI,CAAC,WAAW,CAAC,SAAS,CAAG,CAAC,EAAK,AAAA,CAAA,AAAO,IAAP,CAAO,EAAM,OAAO,CAAE,GAAK,CAAC,CAAC,CAI5D,GAAQ,EAEZ,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,MAAM,CAAE,WAIlC,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,GAAG,CAAE,UAIjC,CAEA,WAAY,CAAK,CAAE,EAAY,CAAA,CAAK,CAAG,CAEjC,EAEJ,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAG,sBAI1B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAG,CAAC,EAAG,KAAK,KAAK,CAAE,GAAS,QAAQ,CAAC,AAI9D,CAEA,WAAY,CAAO,CAAG,CAErB,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAG,CAE3B,CAEA,eAAgB,CAAW,CAAG,CAE7B,IAAI,CAAC,YAAY,CAAC,SAAS,CAAG,CAE/B,CAED,C,G,E,Q,S,C,C,C,E,E,E,O,C,wB,I,G,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,SCnKA,IAAM,EAAuB,AAAqB,aAArB,OAAO,UAA4B,UAAU,mBAAmB,CAAG,CAChG,OAAM,UAA+B,EAAA,UAAS,CAE7C,aAAc,CAQb,GALA,KAAK,CADU,IAAI,OAAnB,EAAA,WAGA,IAAI,CAAC,IAAI,CAAG,wBACZ,IAAI,CAAC,cAAc,CAAG,KAAK,GAAG,CAAE,EAAsB,GAEjD,CAAE,AAAA,CAAA,EAAA,EAAA,4BAA2B,AAA3B,IAEN,MAAM,AAAI,MAAO,iEAInB,CAEA,QAAS,CAAM,CAAE,CAAQ,CAAE,EAAU,CAAC,CAAC,CAAG,CAEzC,OAAO,IAAI,QAAS,CAAE,EAAS,KAQ9B,GANO,EAAS,KAAK,EAAM,EAAQ,QAAQ,EAE1C,AAAA,CAAA,EAAA,EAAA,WAAU,AAAV,EAAa,EAAU,GAKvB,EAAS,YAAY,CAAE,YAAa,4BAA4B,EAChE,EAAS,KAAK,EAAI,EAAS,KAAK,CAAC,4BAA4B,CAG7D,MAAM,AAAI,MAAO,mGAIlB,CAAA,EAAO,OAAO,CAAG,AAAA,IAEhB,EAAQ,AAAI,MAAO,CAAC,uBAAuB,EAAG,EAAE,OAAO,CAAE,CAAC,EAE3D,EAEA,EAAO,SAAS,CAAG,AAAA,IAElB,GAAM,CAAA,KAAE,CAAI,CAAE,CAAG,EAEjB,GAAK,EAAK,KAAK,CAEd,EAAQ,AAAI,MAAO,EAAK,KAAK,GAC7B,EAAO,SAAS,CAAG,UAEb,GAAK,EAAK,UAAU,CAAG,CAE7B,GAAM,CAAA,WAAE,CAAU,CAAA,SAAE,CAAQ,CAAE,CAAG,EAC3B,EAAM,AAAA,CAAA,EAAA,EAAA,OAAM,AAAN,EAAQ,WAAW,CAAE,EAAY,EAAU,CAAE,SAAU,CAAA,CAAM,GACnE,EAAgB,CACrB,eAAgB,CAAA,EAChB,GAAG,CAAO,AACX,EAKA,GADA,EAAS,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAG,EAChC,EAAW,KAAK,EAEpB,GAAK,EAAS,KAAK,CAElB,EAAS,KAAK,CAAC,KAAK,CAAG,EAAW,KAAK,KAEjC,CAEN,IAAM,EAAW,IAAI,EAAA,eAAc,CAAG,EAAW,KAAK,CAAE,EAAG,CAAA,GAC3D,EAAS,QAAQ,CAAE,EAEpB,EAII,EAAc,cAAc,EAEhC,CAAA,EAAS,WAAW,CAAG,EAAI,cAAc,CAAE,IAAI,EAAA,IAAG,CAFnD,EAMK,EAAQ,UAAU,EAEtB,EAAQ,UAAU,CAAE,EAAK,QAAQ,EAIlC,EAAS,GACT,EAAO,SAAS,CAAG,IAEpB,MAAY,EAAQ,UAAU,EAE7B,EAAQ,UAAU,CAAE,EAAK,QAAQ,CAInC,EAEA,IAAM,EAAQ,EAAS,KAAK,CAAG,EAAS,KAAK,CAAC,KAAK,CAAG,KAChD,EAAW,EAAS,UAAU,CAAC,QAAQ,CAAC,KAAK,CACnD,EAAO,WAAW,CAAE,CAEnB,UAAW,YACX,eAAgB,IAAI,CAAC,cAAc,CACnC,MAAO,AAAA,CAAA,EAAA,EAAA,mBAAkB,AAAlB,EAAqB,EAAO,mBACnC,SAAU,AAAA,CAAA,EAAA,EAAA,mBAAkB,AAAlB,EAAqB,EAAU,mBACzC,QAAS,CACR,GAAG,CAAO,CACV,WAAY,KACZ,yBAA0B,CAAA,CAAS,EAAQ,UAAU,CACrD,OAAQ,IAAM,EAAS,MAAM,CAAE,AAChC,CAED,EAED,EAED,CAED,CAEO,MAAM,EAEZ,aAAc,CAEb,GAAK,AAAA,CAAA,EAAA,EAAA,4BAA2B,AAA3B,IAEJ,OAAO,IAAI,CAEL,EAEN,QAAQ,IAAI,CAAE,mHAEd,IAAM,EAAS,IAAI,EAAA,qBAAoB,CAEvC,OADA,EAAO,cAAc,CAAG,EACjB,CAER,CAED,CAED,C,G,E,Q,S,C,C,C,E,E,E,O,C,a,I,ECzJO,OAAM,EAEZ,YAAa,CAAM,CAAG,CAErB,IAAI,CAAC,IAAI,CAAG,aACZ,IAAI,CAAC,OAAO,CAAG,CAAA,EACf,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,MAAM,CAAC,OAAO,CAAG,AAAA,IAErB,GAAK,EAAE,OAAO,CAEb,MAAM,AAAI,MAAO,CAAC,EAAG,IAAI,CAAC,IAAI,CAAE,0CAA0C,EAAG,EAAE,OAAO,CAAE,CAAC,CAAC,CAI1F,OAAM,AAAI,MAAO,CAAC,EAAG,IAAI,CAAC,IAAI,CAAE,8BAA8B,CAAC,CAIjE,CAED,CAEA,SAAU,CAAC,CAEX,SAAU,GAAG,CAAI,CAAG,CAEnB,GAAK,IAAI,CAAC,OAAO,CAEhB,MAAM,AAAI,MAAO,+CAIlB,GAAK,AAAgB,OAAhB,IAAI,CAAC,MAAM,CAEf,MAAM,AAAI,MAAO,mDAIlB,CAAA,IAAI,CAAC,OAAO,CAAG,CAAA,EAEf,IAAM,EAAU,IAAI,CAAC,OAAO,CAAE,IAAI,CAAC,MAAM,IAAK,GAO9C,OANA,EAAQ,OAAO,CAAE,KAEhB,IAAI,CAAC,OAAO,CAAG,CAAA,CAEhB,GAEO,CAER,CAEA,SAAU,CAET,IAAI,CAAC,MAAM,CAAC,SAAS,GACrB,IAAI,CAAC,MAAM,CAAG,IAEf,CAED,C,G,E,Q,S,C,C,C,E,E,E,O,C,wB,I,G,I,E,E,S,E,E,S,E,E,QCvDO,OAAM,UAA8B,EAAA,UAAS,CAEnD,aAAc,CAGb,KAAK,CADU,IAAI,OAAnB,EAAA,WAEA,IAAI,CAAC,IAAI,CAAG,uBAEb,CAEA,QAAS,CAAM,CAAE,CAAQ,CAAE,EAAU,CAAC,CAAC,CAAG,CAEzC,OAAO,IAAI,QAAS,CAAE,EAAS,KAE9B,GACC,EAAS,YAAY,CAAE,YAAa,4BAA4B,EAChE,EAAS,KAAK,EAAI,EAAS,KAAK,CAAC,4BAA4B,CAG7D,MAAM,AAAI,MAAO,mGAIlB,CAAA,EAAO,OAAO,CAAG,AAAA,IAEhB,EAAQ,AAAI,MAAO,CAAC,uBAAuB,EAAG,EAAE,OAAO,CAAE,CAAC,EAE3D,EAEA,EAAO,SAAS,CAAG,AAAA,IAElB,GAAM,CAAA,KAAE,CAAI,CAAE,CAAG,EAEjB,GAAK,EAAK,KAAK,CAEd,EAAQ,AAAI,MAAO,EAAK,KAAK,GAC7B,EAAO,SAAS,CAAG,UAEb,GAAK,EAAK,UAAU,CAAG,CAE7B,GAAM,CAAA,WAAE,CAAU,CAAA,SAAE,CAAQ,CAAE,CAAG,EAC3B,EAAM,AAAA,CAAA,EAAA,EAAA,OAAM,AAAN,EAAQ,WAAW,CAAE,EAAY,EAAU,CAAE,SAAU,CAAA,CAAM,GACnE,EAAgB,OAAO,MAAM,CAAE,CAEpC,eAAgB,CAAA,CAEjB,EAAG,GAKH,GADA,EAAS,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAG,EAChC,EAAW,KAAK,EAEpB,GAAK,EAAS,KAAK,CAElB,EAAS,KAAK,CAAC,KAAK,CAAG,EAAW,KAAK,KAEjC,CAEN,IAAM,EAAW,IAAI,EAAA,eAAc,CAAG,EAAW,KAAK,CAAE,EAAG,CAAA,GAC3D,EAAS,QAAQ,CAAE,EAEpB,EAII,EAAc,cAAc,EAEhC,CAAA,EAAS,WAAW,CAAG,EAAI,cAAc,CAAE,IAAI,EAAA,IAAG,CAFnD,EAMK,EAAQ,UAAU,EAEtB,EAAQ,UAAU,CAAE,EAAK,QAAQ,EAIlC,EAAS,GACT,EAAO,SAAS,CAAG,IAEpB,MAAY,EAAQ,UAAU,EAE7B,EAAQ,UAAU,CAAE,EAAK,QAAQ,CAInC,EAEA,IAAM,EAAQ,EAAS,KAAK,CAAG,EAAS,KAAK,CAAC,KAAK,CAAG,KAChD,EAAW,EAAS,UAAU,CAAC,QAAQ,CAAC,KAAK,CAC7C,EAAe,CAAE,EAAU,CAC5B,GAEJ,EAAa,IAAI,CAAE,GAIpB,EAAO,WAAW,CAAE,CAEnB,MAAA,EACA,SAAA,EACA,QAAS,CACR,GAAG,CAAO,CACV,WAAY,KACZ,yBAA0B,CAAA,CAAS,EAAQ,UAAU,CACrD,OAAQ,IAAM,EAAS,MAAM,CAAE,AAChC,CAED,EAAG,EAAa,GAAG,CAAE,AAAA,GAAO,EAAI,MAAM,EAAG,MAAM,CAAE,AAAA,GAAO,AAA6B,aAA7B,OAAO,mBAAuC,CAAI,CAAA,aAAa,iBAAA,GAExH,EAED,CAED,C,G,E,Q,S,C,C,C,E,I,E,E,SCtHA,IAAI,EAAA,IAAA,IAA0B,qCAA9B,YAAA,GAAA,CACA,CAAA,EAAA,OAAA,CAAiB,EAAU,EAAI,QAAQ,GAAI,EAAI,MAAM,CAAE,CAAA,E,G,E,Q,S,C,C,C,ECAvD,EAAA,OAAA,CAAiB,SAAU,CAAS,CAAE,CAAM,CAAE,CAAK,EACjD,GAAI,IAAW,KAAK,QAAQ,CAAC,MAAM,CAGjC,OAAO,EAGP,IAAI,EAAS,EAAQ,UAAY,KAAK,SAAS,CAAC,GAAa,IAAM,iBAAmB,KAAK,SAAS,CAAC,GAAa,KAClH,OAAO,IAAI,eAAe,CAAC,IAAI,KAAK,CAAC,EAAO,CAAE,CAC5C,KAAM,wBACR,GAEJ,C,G,E,Q,S,C,C,C,E,I,E,E,SCbA,IAAI,EAAA,IAAA,IAA0B,qCAA9B,YAAA,GAAA,CACA,CAAA,EAAA,OAAA,CAAiB,EAAU,EAAI,QAAQ,GAAI,EAAI,MAAM,CAAE,CAAA,E,G,E,Q,S,C,C,C,E,E,E,O,C,e,I,G,I,E,E,QCAhD,OAAM,UAAqB,EAAA,cAAa,CAE9C,IAAI,YAAa,CAAC,CAAG,CAEpB,KAAK,CAAC,YAAc,CAAA,EACpB,IAAI,CAAC,aAAa,CAAE,CAEnB,KAAM,eAEP,EAED,CAEA,YAAa,CAAM,CAAG,CAIrB,IAAM,IAAM,KAFZ,KAAK,CAAE,GAEY,IAAI,CAAC,QAAQ,CAE/B,OAAO,cAAc,CAAE,IAAI,CAAE,EAAK,CAEjC,MAEC,OAAO,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,KAAK,AAElC,EAEA,IAAK,CAAC,EAEL,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,KAAK,CAAG,CAE9B,CAED,EAIF,CAGA,UAAW,CAAI,CAAE,CAAiB,CAAG,CAEpC,GAAK,MAAA,EAEJ,CAAA,GAAK,KAAQ,IAAI,CAAC,OAAO,CAIxB,OAFA,OAAO,IAAI,CAAC,OAAO,CAAE,EAAM,CAC3B,IAAI,CAAC,WAAW,CAAG,CAAA,EACZ,CAAA,CAER,MAIA,GAAK,IAAI,CAAC,OAAO,CAAE,EAAM,GAAK,EAI7B,OAFA,IAAI,CAAC,OAAO,CAAE,EAAM,CAAG,EACvB,IAAI,CAAC,WAAW,CAAG,CAAA,EACZ,CAAA,EAMT,MAAO,CAAA,CAER,CAED,C,G,E,Q,S,C,C,C,E,E,E,O,C,iB,I,GCtEO,IAAM,EAA2B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgFzC,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,iB,I,GChFM,IAAM,EAA2B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmHzC,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,gB,I,GCnHM,IAAM,EAA0B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqGxC,CAAC,A,G,I,E,E,S,E,E,S,E,E,S,E,E,S,G,E,S,E,SGhGD,OAAM,UAAkB,EAAA,iBAAgB,CAEvC,YAAa,CAAO,CAAG,CAEtB,KAAK,CAAE,EAER,CAEA,MAAO,CAAM,CAAG,CA2Zf,GAAK,EAAO,MAAM,CAAG,GAAK,MAAM,AAAI,MAAO,uDAE3C,IAAI,EAAS,EAEP,EAAU,IAAI,WAAY,GAC/B,EAAS,CACR,UAAW,CAAO,CAAE,IAAW,CAC/B,cAAe,CAAO,CAAE,IAAW,CACnC,WAAY,CAAO,CAAE,IAAW,CAChC,eAAgB,CAAO,CAAE,IAAW,CAAG,CAAO,CAAE,IAAW,EAAI,EAC/D,gBAAiB,CAAO,CAAE,IAAW,CAAG,CAAO,CAAE,IAAW,EAAI,EAChE,cAAe,CAAO,CAAE,IAAW,CACnC,OAAQ,CACP,CAAO,CAAE,IAAW,CAAG,CAAO,CAAE,IAAW,EAAI,EAC/C,CAAO,CAAE,IAAW,CAAG,CAAO,CAAE,IAAW,EAAI,EAC/C,CACD,MAAO,CAAO,CAAE,IAAW,CAAG,CAAO,CAAE,IAAW,EAAI,EACtD,OAAQ,CAAO,CAAE,IAAW,CAAG,CAAO,CAAE,IAAW,EAAI,EACvD,WAAY,CAAO,CAAE,IAAW,CAChC,MAAO,CAAO,CAAE,IAAW,AAC5B,EAMD,IAFA,AA/aA,SAAyB,CAAM,EAE9B,OAAS,EAAO,UAAU,EAIzB,KAmYkB,EAlYlB,KAqYsB,EApYrB,GAAK,EAAO,eAAe,CAAG,KAAO,AAAyB,KAAzB,EAAO,aAAa,EAAW,AAAyB,IAAzB,EAAO,aAAa,CAEvF,MAAM,AAAI,MAAO,iEAIlB,KAID,MAwXc,EAvXd,KAwXe,EAvXf,KAyXkB,GAxXlB,KAyXmB,GAxXlB,GAAK,EAAO,aAAa,CAExB,MAAM,AAAI,MAAO,kEAIlB,KAID,MAwWuB,EAvWtB,MAAM,AAAI,MAAO,4BAIlB,SACC,MAAM,AAAI,MAAO,iCAAmC,EAAO,UAAU,CAEvE,CAIA,GAAK,EAAO,KAAK,EAAI,GAAK,EAAO,MAAM,EAAI,EAE1C,MAAM,AAAI,MAAO,wCAMlB,GAAK,AAAsB,IAAtB,EAAO,UAAU,EAAU,AAAsB,KAAtB,EAAO,UAAU,EAChD,AAAsB,KAAtB,EAAO,UAAU,EAAW,AAAsB,KAAtB,EAAO,UAAU,CAE7C,MAAM,AAAI,MAAO,uCAAyC,EAAO,UAAU,CAI7E,EAoXgB,GAEX,EAAO,SAAS,CAAG,EAAS,EAAO,MAAM,CAE7C,MAAM,AAAI,MAAO,6BAMlB,GAAU,EAAO,SAAS,CAI1B,IAAI,EAAU,CAAA,EACb,EAAU,CAAA,EACV,EAAW,CAAA,EAEZ,OAAS,EAAO,UAAU,EAEzB,KAvDuB,EAwDtB,EAAU,CAAA,EACV,EAAU,CAAA,EACV,KAED,MA/DmB,EAgElB,EAAU,CAAA,EACV,KAED,MA/DmB,GAgElB,EAAU,CAAA,EACV,KAED,MAtEe,EAuEd,KAED,MArEoB,GAsEnB,EAAU,CAAA,EACV,EAAW,CAAA,EACX,KAED,MA7EgB,EA8Ef,EAAW,CAAA,CAGb,CAIA,IAAM,EAAY,IAAI,WAAY,EAAO,KAAK,CAAG,EAAO,MAAM,CAAG,GAC3D,EAAS,AAlaf,SAAmB,CAAO,CAAE,CAAO,CAAE,CAAM,CAAE,CAAM,CAAE,CAAI,MAEpD,EACH,EAED,IAAM,EAAa,EAAO,UAAU,EAAI,EAClC,EAAc,EAAO,KAAK,CAAG,EAAO,MAAM,CAAG,EAYlD,GARK,GAEJ,CAAA,EAAW,EAAK,QAAQ,CAAE,EAAQ,GAAU,EAAO,eAAe,CAAK,CAAA,EAAO,aAAa,EAAI,CAAA,EAFhG,EAQK,EAAU,KAIX,EAAG,EAAO,EAFb,EAAa,IAAI,WAAY,GAG9B,IAAI,EAAQ,EACN,EAAS,IAAI,WAAY,GAE/B,KAAQ,EAAQ,GAOf,GAJA,EAAQ,AAAE,CAAA,AAAI,IADd,CAAA,EAAI,CAAI,CAAE,IAAW,AAAX,CACI,EAAS,EAIlB,AAAI,IAAJ,EAAW,CAIf,IAAM,EAAI,EAAG,EAAI,EAAY,EAAG,EAE/B,CAAM,CAAE,EAAG,CAAG,CAAI,CAAE,IAAW,CAMhC,IAAM,EAAI,EAAG,EAAI,EAAO,EAAG,EAE1B,EAAW,GAAG,CAAE,EAAQ,EAAQ,EAAI,GAIrC,GAAS,EAAa,CAEvB,KAAO,CAMN,IAFA,GAAS,EAEH,EAAI,EAAG,EAAI,EAAO,EAAG,EAE1B,CAAU,CAAE,EAAQ,EAAG,CAAG,CAAI,CAAE,IAAW,CAI5C,GAAS,CAEV,CAID,MAIA,EAAa,EAAK,QAAQ,CACxB,EAAQ,GAAY,EAAU,EAAO,KAAK,CAAG,EAAO,MAAM,CAAG,GAK/D,MAAO,CACP,WAAY,EACZ,SAAU,CACV,CAEF,EA4UyB,EAAS,EAAS,EAAQ,EAAQ,GAG3D,OAFA,AAnMA,SAAqB,CAAI,CAAE,CAAK,CAAE,CAAM,CAAE,CAAK,CAAE,CAAO,EAEvD,IAAI,EACH,EACA,EACA,EACA,EACA,EAED,OAAW,AAAA,CAAA,AAwGO,GAxGP,EAAO,KAAK,AAAG,GAyGP,GAvGlB,QACA,KAyGe,EAxGd,EAAU,EACV,EAAS,EACT,EAAQ,EACR,EAAU,EACV,EAAS,EACT,EAAQ,EACR,KAED,MA8Fe,EA7Fd,EAAU,EACV,EAAS,EACT,EAAQ,EACR,EAAU,EAAS,EACnB,EAAS,GACT,EAAQ,GACR,KAED,MAwFe,EAvFd,EAAU,EAAQ,EAClB,EAAS,GACT,EAAQ,GACR,EAAU,EACV,EAAS,EACT,EAAQ,EACR,KAED,MA6Ee,EA5Ed,EAAU,EAAQ,EAClB,EAAS,GACT,EAAQ,GACR,EAAU,EAAS,EACnB,EAAS,GACT,EAAQ,EAGV,CAEA,GAAK,EAEJ,OAAS,EAAO,UAAU,EAEzB,KAAK,GACJ,AApGJ,SAAmC,CAAS,CAAE,CAAO,CAAE,CAAM,CAAE,CAAK,CAAE,CAAO,CAAE,CAAM,CAAE,CAAK,CAAE,CAAK,EAElG,IAAI,EAAO,EAAI,EAAG,EAAG,EACf,EAAQ,EAAO,KAAK,CAE1B,IAAM,EAAI,EAAS,IAAM,EAAO,GAAK,EAEpC,IAAM,EAAI,EAAS,IAAM,EAAO,GAAK,EAAQ,IAE5C,EAAQ,CAAK,CAAE,EAAG,CAClB,CAAS,CAAI,AAAA,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,EACzC,CAAS,CAAI,AAAA,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,EACzC,CAAS,CAAI,AAAA,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,EACzC,CAAS,CAAI,AAAA,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,GAQ5C,EA+E8B,EAAM,EAAS,EAAQ,EAAO,EAAS,EAAQ,EAAO,GAChF,KAED,MAAK,IACJ,AAjFJ,SAAoC,CAAS,CAAE,CAAO,CAAE,CAAM,CAAE,CAAK,CAAE,CAAO,CAAE,CAAM,CAAE,CAAK,CAAE,CAAK,EAEnG,IAAI,EAAI,EAAG,EAAG,EACR,EAAQ,EAAO,KAAK,CAE1B,IAAM,EAAI,EAAS,IAAM,EAAO,GAAK,EAEpC,IAAM,EAAI,EAAS,IAAM,EAAO,GAAK,EAAQ,GAAK,EAEjD,CAAS,CAAE,AAAE,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,CAAK,CAAE,EAAI,EAAG,CACvD,CAAS,CAAE,AAAE,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,CAAK,CAAE,EAAI,EAAG,CACvD,CAAS,CAAE,AAAE,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,CAAK,CAAE,EAAI,EAAG,CACvD,CAAS,CAAE,AAAE,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,CAAK,CAAE,EAAI,EAAG,AAQ1D,EA6D+B,EAAM,EAAS,EAAQ,EAAO,EAAS,EAAQ,EAAO,GACjF,KAED,SACC,MAAM,AAAI,MAAO,yCAGnB,MAIA,OAAS,EAAO,UAAU,EAEzB,KAAK,GACJ,AAjNJ,SAA+B,CAAS,CAAE,CAAO,CAAE,CAAM,CAAE,CAAK,CAAE,CAAO,CAAE,CAAM,CAAE,CAAK,CAAE,CAAK,CAAE,CAAQ,EAGxG,IAAI,EAAO,EAAI,EAAG,EAAG,EACf,EAAQ,EAAO,KAAK,CAE1B,IAAM,EAAI,EAAS,IAAM,EAAO,GAAK,EAEpC,IAAM,EAAI,EAAS,IAAM,EAAO,GAAK,EAAQ,IAE5C,EAAQ,CAAK,CAAE,EAAG,CAClB,CAAS,CAAI,AAAA,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,IACzC,CAAS,CAAE,AAAE,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,AAV1B,CAUkC,CAAI,AAAQ,EAAR,EAAc,EAAG,CACtE,CAAS,CAAE,AAAE,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,AAX1B,CAWkC,CAAI,AAAQ,EAAR,EAAc,EAAG,CACtE,CAAS,CAAE,AAAE,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,AAZ1B,CAYkC,CAAI,AAAQ,EAAR,EAAc,EAAG,AAQzE,EA2L0B,EAAM,EAAS,EAAQ,EAAO,EAAS,EAAQ,EAAO,EAAO,GACnF,KAED,MAAK,IACJ,AA7LJ,SAAgC,CAAS,CAAE,CAAO,CAAE,CAAM,CAAE,CAAK,CAAE,CAAO,CAAE,CAAM,CAAE,CAAK,CAAE,CAAK,EAE/F,IAAI,EAAO,EAAI,EAAG,EAAG,EACf,EAAQ,EAAO,KAAK,CAE1B,IAAM,EAAI,EAAS,IAAM,EAAO,GAAK,EAEpC,IAAM,EAAI,EAAS,IAAM,EAAO,GAAK,EAAQ,GAAK,EAEjD,EAAQ,CAAK,CAAE,EAAI,EAAG,CAAK,CAAA,CAAK,CAAE,EAAI,EAAG,EAAI,CAAA,EAC7C,CAAS,CAAE,AAAE,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,AAAE,CAAA,AAAQ,MAAR,CAAQ,GAAY,EAC/D,CAAS,CAAE,AAAE,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,AAAE,CAAA,AAAQ,IAAR,CAAQ,GAAY,EAC/D,CAAS,CAAE,AAAE,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,AAAE,CAAA,AAAQ,GAAR,CAAQ,GAAY,EAC/D,CAAS,CAAE,AAAE,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAK,AAAQ,MAAR,EAAmB,EAAI,GAQrE,EAwK2B,EAAM,EAAS,EAAQ,EAAO,EAAS,EAAQ,EAAO,GAC7E,KAED,MAAK,IACJ,AA1KJ,SAAgC,CAAS,CAAE,CAAO,CAAE,CAAM,CAAE,CAAK,CAAE,CAAO,CAAE,CAAM,CAAE,CAAK,CAAE,CAAK,EAE/F,IAAI,EAAI,EAAG,EAAG,EACR,EAAQ,EAAO,KAAK,CAE1B,IAAM,EAAI,EAAS,IAAM,EAAO,GAAK,EAEpC,IAAM,EAAI,EAAS,IAAM,EAAO,GAAK,EAAQ,GAAK,EAEjD,CAAS,CAAI,AAAA,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,IACzC,CAAS,CAAE,AAAE,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,CAAK,CAAE,EAAI,EAAG,CACvD,CAAS,CAAE,AAAE,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,CAAK,CAAE,EAAI,EAAG,CACvD,CAAS,CAAE,AAAE,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,CAAK,CAAE,EAAI,EAAG,AAQ1D,EAsJ2B,EAAM,EAAS,EAAQ,EAAO,EAAS,EAAQ,EAAO,GAC7E,KAED,MAAK,IACJ,AAxJJ,SAAgC,CAAS,CAAE,CAAO,CAAE,CAAM,CAAE,CAAK,CAAE,CAAO,CAAE,CAAM,CAAE,CAAK,CAAE,CAAK,EAE/F,IAAI,EAAI,EAAG,EAAG,EACR,EAAQ,EAAO,KAAK,CAE1B,IAAM,EAAI,EAAS,IAAM,EAAO,GAAK,EAEpC,IAAM,EAAI,EAAS,IAAM,EAAO,GAAK,EAAQ,GAAK,EAEjD,CAAS,CAAE,AAAE,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,CAAK,CAAE,EAAI,EAAG,CACvD,CAAS,CAAE,AAAE,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,CAAK,CAAE,EAAI,EAAG,CACvD,CAAS,CAAE,AAAE,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,CAAK,CAAE,EAAI,EAAG,CACvD,CAAS,CAAE,AAAE,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAI,EAAG,CAAG,CAAK,CAAE,EAAI,EAAG,AAQ1D,EAoI2B,EAAM,EAAS,EAAQ,EAAO,EAAS,EAAQ,EAAO,GAC7E,KAED,SACC,MAAM,AAAI,MAAO,yCAGnB,CASF,EA8FY,EAAW,EAAO,KAAK,CAAE,EAAO,MAAM,CAAE,EAAO,UAAU,CAAE,EAAO,QAAQ,EAE/E,CAEN,KAAM,EACN,MAAO,EAAO,KAAK,CACnB,OAAQ,EAAO,MAAM,CACrB,MAAO,CAAA,EACP,gBAAiB,CAAA,EACjB,UAAW,EAAA,wBAAuB,AAEnC,CAED,CAED,CDxdA,MAAM,UAAsB,EAAA,MAAK,CAEhC,KAAM,CAAG,CAAE,CAAM,CAAE,CAAU,CAAE,CAAO,CAAG,CAExC,IAAM,EAAQ,IAAI,CAEZ,EAAO,AAAiB,KAAjB,EAAQ,IAAI,CAAY,AAAA,CAAA,EAAA,EAAA,WAAU,AAAV,EAAY,cAAc,CAAE,GAAQ,EAAM,IAAI,CAE7E,EAAS,IAAI,EAAA,UAAS,CAAG,EAAM,OAAO,EAC5C,EAAO,OAAO,CAAE,EAAM,IAAI,EAC1B,EAAO,gBAAgB,CAAE,EAAM,aAAa,EAC5C,EAAO,kBAAkB,CAAE,EAAM,eAAe,EAChD,EAAO,IAAI,CAAE,EAAK,SAAW,CAAI,EAEhC,GAAI,CAEH,EAAQ,EAAM,KAAK,CAAE,EAAM,GAE5B,CAAE,MAAQ,EAAI,CAER,EAEJ,EAAS,GAIT,QAAQ,KAAK,CAAE,GAIhB,EAAM,OAAO,CAAC,SAAS,CAAE,EAE1B,CAED,EAAG,EAAY,EAEhB,CAEA,MAAO,CAAI,CAAE,CAAI,CAAG,KAgGE,EAgpHA,EAvoHI,EAcE,MAgvHvB,EAr2HJ,SAAS,EAAsB,CAAG,CAAE,CAAI,EAIvC,IAAM,EAAQ,EAAE,CACV,EAAa,EAAI,UAAU,CAEjC,IAAM,IAAI,EAAI,EAAG,EAAI,EAAW,MAAM,CAAE,EAAI,EAAG,IAAO,CAErD,IAAM,EAAQ,CAAU,CAAE,EAAG,AAExB,CAAA,EAAM,QAAQ,GAAK,GAEvB,EAAM,IAAI,CAAE,EAId,CAEA,OAAO,CAER,CAmBA,SAAS,EAAa,CAAI,EAEzB,GAAK,AAAgB,IAAhB,EAAK,MAAM,CAAS,MAAO,EAAE,CAElC,IAAM,EAAQ,EAAK,IAAI,GAAG,KAAK,CAAE,OAC3B,EAAQ,AAAI,MAAO,EAAM,MAAM,EAErC,IAAM,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,EAAI,EAAG,IAEzC,CAAK,CAAE,EAAG,CAAG,WAAY,CAAK,CAAE,EAAG,EAIpC,OAAO,CAER,CAEA,SAAS,EAAW,CAAI,EAEvB,GAAK,AAAgB,IAAhB,EAAK,MAAM,CAAS,MAAO,EAAE,CAElC,IAAM,EAAQ,EAAK,IAAI,GAAG,KAAK,CAAE,OAC3B,EAAQ,AAAI,MAAO,EAAM,MAAM,EAErC,IAAM,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,EAAI,EAAG,IAEzC,CAAK,CAAE,EAAG,CAAG,SAAU,CAAK,CAAE,EAAG,EAIlC,OAAO,CAER,CAEA,SAAS,EAAS,CAAI,EAErB,OAAO,EAAK,SAAS,CAAE,EAExB,CAQA,SAAS,EAAS,CAAM,EAEvB,OAAO,AAAiC,IAAjC,OAAO,IAAI,CAAE,GAAS,MAAM,AAEpC,CAmCA,SAAS,EAAc,CAAG,CAAE,CAAW,CAAE,CAAQ,CAAE,CAAM,EAExD,IAAM,EAAU,EAAsB,EAAK,EAAa,CAAE,EAAG,CAE7D,GAAK,AAAY,KAAA,IAAZ,EAAwB,CAE5B,IAAM,EAAW,EAAsB,EAAS,GAEhD,IAAM,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAE,IAErC,EAAQ,CAAQ,CAAE,EAAG,CAIvB,CAED,CAEA,SAAS,EAAc,CAAI,CAAE,CAAO,EAEnC,IAAM,IAAM,KAAQ,EAGnB,AADe,CAAI,CAAE,EAAM,CACpB,KAAK,CAAG,EAAS,CAAI,CAAE,EAAM,CAItC,CAIA,SAAS,EAAU,CAAI,CAAE,CAAO,SAEX,KAAA,IAAf,EAAK,KAAK,EAEf,CAAA,EAAK,KAAK,CAAG,EAAS,EAAtB,EAFuC,EAAK,KAAK,AAMlD,CAiJA,SAAS,EAAgB,CAAI,EAE5B,IAAM,EAAS,EAAE,CAEX,EAAW,EAAK,QAAQ,CACxB,EAAW,EAAK,QAAQ,CACxB,EAAU,EAAK,OAAO,CAE5B,IAAM,IAAM,KAAU,EAErB,GAAK,EAAS,cAAc,CAAE,GAAW,CAExC,IAAM,EAAU,CAAQ,CAAE,EAAQ,CAC5B,EAAU,CAAQ,CAAE,EAAQ,OAAO,CAAE,CAErC,EAAU,EAAQ,MAAM,CAAC,KAAK,CAC9B,EAAW,EAAQ,MAAM,CAAC,MAAM,EAOtC,AAiIH,SAA+B,CAAS,CAAE,CAAM,EAE/C,IAAM,EAAY,EAAU,SAAS,CAC/B,EAAO,EAAU,IAAI,CAErB,EAAQ,EAAE,CACV,EAAe,EAAE,CACjB,EAAiB,EAAE,CACnB,EAAY,EAAE,CAEpB,IAAM,IAAI,EAAI,EAAG,EAAI,EAAU,MAAM,CAAE,EAAI,EAAG,IAAO,CAEpD,IAAM,EAAW,CAAS,CAAE,EAAG,CAEzB,EAAO,EAAS,IAAI,CACpB,EAAQ,EAAS,KAAK,CAE5B,EAAO,SAAS,CAAE,GAAQ,SAAS,GACnC,EAAO,SAAS,CAAE,EAAU,EAAY,GAExC,EAAM,IAAI,CAAE,GACZ,EAAa,IAAI,CAAE,EAAS,CAAC,CAAE,EAAS,CAAC,CAAE,EAAS,CAAC,EACrD,EAAe,IAAI,CAAE,EAAW,CAAC,CAAE,EAAW,CAAC,CAAE,EAAW,CAAC,CAAE,EAAW,CAAC,EAC3E,EAAU,IAAI,CAAE,EAAM,CAAC,CAAE,EAAM,CAAC,CAAE,EAAM,CAAC,CAE1C,CAEK,EAAa,MAAM,CAAG,GAAI,EAAO,IAAI,CAAE,IAAI,EAAA,mBAAkB,CAAG,EAAO,YAAa,EAAO,IAC3F,EAAe,MAAM,CAAG,GAAI,EAAO,IAAI,CAAE,IAAI,EAAA,uBAAsB,CAAG,EAAO,cAAe,EAAO,IACnG,EAAU,MAAM,CAAG,GAAI,EAAO,IAAI,CAAE,IAAI,EAAA,mBAAkB,CAAG,EAAO,SAAU,EAAO,GAI3F,EApKqB,AAkBrB,SAAgC,CAAO,CAAE,CAAW,CAAE,CAAY,MAQ7D,EAAM,EACN,EAAG,EAAI,EAAG,EAPd,IAAM,EAAO,GAAQ,KAAK,CAAE,EAAQ,EAAE,CAAE,CAClC,EAAW,EAAS,EAAK,EAAE,EAE3B,EAAY,EAAK,UAAU,CAAE,EAAQ,GAAG,CAAE,CAC1C,EAAgB,EAAK,MAAM,CAAC,KAAK,GAAG,SAAS,GAK7C,EAAO,CAAC,EAKd,OAAS,GAER,IAAK,SAEJ,IAAM,EAAI,EAAG,EAAK,EAAY,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAOnD,GALA,EAAO,EAAY,KAAK,CAAE,EAAG,CAC7B,EAAS,EAAI,EAAa,MAAM,CAEV,KAAA,IAAjB,CAAI,CAAE,EAAM,EAAiB,CAAA,CAAI,CAAE,EAAM,CAAG,CAAC,CAAA,EAE7C,AAAwB,CAAA,IAAxB,EAAQ,WAAW,CAAY,CAEnC,IAAM,EAAQ,EAAa,KAAK,CAAE,EAAQ,CACpC,EAAQ,EAAQ,OAAO,CAAE,EAAG,CAAG,EAAI,EAAQ,OAAO,CAAE,EAAG,AAE7D,CAAA,CAAI,CAAE,EAAM,CAAE,EAAO,CAAG,CAEzB,MAEC,IAAM,EAAI,EAAG,EAAK,EAAa,MAAM,CAAE,EAAI,EAAI,IAE9C,CAAI,CAAE,EAAM,CAAE,EAAG,CAAG,EAAa,KAAK,CAAE,EAAS,EAAG,CAQvD,KAED,KAAK,YAIL,IAAK,SAIL,IAAK,QAPJ,QAAQ,IAAI,CAAE,0EAA2E,EAW3F,CAEA,IAAM,EAAY,AAWnB,SAA+B,CAAI,CAAE,CAAa,EAEjD,IAAM,EAAY,EAAE,CAIpB,IAAM,IAAM,KAAQ,EAEnB,EAAU,IAAI,CAAE,CAAE,KAAM,WAAY,GAAQ,MAAO,CAAI,CAAE,EAAM,AAAC,GAMjE,EAAU,IAAI,CAcd,SAAoB,CAAC,CAAE,CAAC,EAEvB,OAAO,EAAE,IAAI,CAAG,EAAE,IAAI,AAEvB,GAdA,IAAM,IAAI,EAAI,EAAG,EAAI,GAAI,KAExB,AAuDF,SAAiC,CAAS,CAAE,CAAQ,CAAE,CAAY,MAE7D,EAGA,EAAG,EADP,IAAI,EAAQ,CAAA,EAKZ,IAAM,EAAI,EAAG,EAAI,EAAU,MAAM,CAAE,EAAI,EAAG,IAIpC,AAA+B,KAAA,IAA/B,AAFL,CAAA,EAAW,CAAS,CAAE,EAAG,AAAH,EAER,KAAK,CAAE,EAAU,CAE9B,EAAS,KAAK,CAAE,EAAU,CAAG,KAI7B,EAAQ,CAAA,EAMV,GAAK,AAAU,CAAA,IAAV,EAIJ,IAAM,EAAI,EAAG,EAAI,EAAU,MAAM,CAAE,EAAI,EAAG,IAIzC,AAFA,CAAA,EAAW,CAAS,CAAE,EAAG,AAAH,EAEb,KAAK,CAAE,EAAU,CAAG,OAQ9B,AAMF,SAAiC,CAAS,CAAE,CAAQ,EAEnD,IAAI,EAAM,EAEV,IAAM,IAAI,EAAI,EAAG,EAAI,EAAU,MAAM,CAAE,EAAI,EAAG,IAAO,CAEpD,IAAM,EAAW,CAAS,CAAE,EAAG,CAE/B,GAAK,AAA+B,OAA/B,EAAS,KAAK,CAAE,EAAU,CAAY,CAK1C,GAHA,EAAO,AAyBV,SAAkB,CAAS,CAAE,CAAC,CAAE,CAAQ,EAEvC,KAAQ,GAAK,GAAI,CAEhB,IAAM,EAAW,CAAS,CAAE,EAAG,CAE/B,GAAK,AAA+B,OAA/B,EAAS,KAAK,CAAE,EAAU,CAAY,OAAO,CAElD,CAAA,GAED,CAEA,OAAO,IAER,EAvCmB,EAAW,EAAG,GAC9B,EAAO,AAwCV,SAAkB,CAAS,CAAE,CAAC,CAAE,CAAQ,EAEvC,KAAQ,EAAI,EAAU,MAAM,EAAG,CAE9B,IAAM,EAAW,CAAS,CAAE,EAAG,CAE/B,GAAK,AAA+B,OAA/B,EAAS,KAAK,CAAE,EAAU,CAAY,OAAO,CAElD,CAAA,GAED,CAEA,OAAO,IAER,EAtDmB,EAAW,EAAG,GAEzB,AAAS,OAAT,EAAgB,CAEpB,EAAS,KAAK,CAAE,EAAU,CAAG,EAAK,KAAK,CAAE,EAAU,CACnD,QAED,CAEA,GAAK,AAAS,OAAT,EAAgB,CAEpB,EAAS,KAAK,CAAE,EAAU,CAAG,EAAK,KAAK,CAAE,EAAU,CACnD,QAED,EAEA,AAwCH,SAAsB,CAAG,CAAE,CAAI,CAAE,CAAI,CAAE,CAAQ,EAE9C,GAAO,EAAK,IAAI,CAAG,EAAK,IAAI,EAAO,EAAI,CAEtC,EAAI,KAAK,CAAE,EAAU,CAAG,EAAK,KAAK,CAAE,EAAU,CAC9C,MAED,CAEA,EAAI,KAAK,CAAE,EAAU,CAAO,AAAA,CAAA,EAAI,IAAI,CAAG,EAAK,IAAI,AAAJ,EAAW,CAAA,EAAK,KAAK,CAAE,EAAU,CAAG,EAAK,KAAK,CAAE,EAAU,AAAV,EAAiB,CAAA,EAAK,IAAI,CAAG,EAAK,IAAI,AAAJ,EAAW,EAAK,KAAK,CAAE,EAAU,AAEhK,EAnDgB,EAAU,EAAM,EAAM,EAEpC,CAED,CAED,EAvC0B,EAAW,EAIrC,EApG0B,EAAW,EAAG,EAAc,QAAQ,CAAE,EAAG,EAIlE,OAAO,CAUR,EA7CyC,EAAM,GAO9C,MALkB,CACjB,KAAM,EAAS,IAAI,CACnB,UAAW,CACZ,CAID,EAzF4C,EAHrB,CAAO,CAAE,EAAS,CACjB,CAAO,CAAE,EAAU,EAIP,EAElC,CAID,OAAO,CAER,CAEA,SAAS,EAAc,CAAE,EAExB,OAAO,EAAU,GAAQ,UAAU,CAAE,EAAI,CAAE,EAE5C,CA+GA,IAAM,EAAW,IAAI,EAAA,OAAM,CACrB,EAAQ,IAAI,EAAA,OAAM,CAClB,EAAa,IAAI,EAAA,UAAS,CAmMhC,SAAS,EAAoB,CAAI,EAEhC,IAAM,EAAS,EAAE,CAEX,EAAO,EAAK,IAAI,CAChB,EAAW,EAAO,GAAG,CAAG,EAAK,KAAK,EAAM,GACxC,EAAa,EAAK,UAAU,CAElC,IAAM,IAAI,EAAI,EAAG,EAAK,EAAW,MAAM,CAAE,EAAI,EAAI,IAAO,CAEvD,IAAM,EAAkB,EAAc,CAAU,CAAE,EAAG,EAErD,IAAM,IAAI,EAAI,EAAG,EAAK,EAAgB,MAAM,CAAE,EAAI,EAAI,IAErD,EAAO,IAAI,CAAE,CAAe,CAAE,EAAG,CAInC,CAEA,OAAO,IAAI,EAAA,aAAY,CAAG,EAAM,EAAU,EAE3C,CAiJA,SAAS,EAAiB,CAAI,EAE7B,IAAM,EAAQ,CACb,GAAI,EAAK,EAAE,AACZ,EAEM,EAAW,GAAQ,UAAU,CAAE,EAAM,EAAE,CAAE,CAa/C,OAXmB,KAAA,IAAd,EAAK,IAAI,GAEb,EAAM,IAAI,CAAG,AAaf,SAAoB,CAAI,MA8BnB,EAAG,EAAG,EA1BV,IAAM,EAAQ,CACb,OAAQ,EAAE,CACV,QAAS,CACR,MAAO,EAAE,CACT,OANiB,CAOlB,EACA,QAAS,CACR,MAAO,EAAE,CACT,OAViB,CAWlB,CACD,EAEM,EAAU,EAAK,OAAO,CACtB,EAAgB,EAAK,aAAa,CAElC,EAAS,EAAc,MAAM,CAC7B,EAAI,EAAc,CAAC,CACnB,EAAc,EAAc,MAAM,CAAC,KAAK,CAAC,MAAM,CAC/C,EAAe,EAAc,MAAM,CAAC,MAAM,CAAC,MAAM,CAEjD,EAAc,EAAK,OAAO,CAAE,EAAK,MAAM,CAAC,MAAM,CAAC,KAAK,CAAE,CACtD,EAAgB,EAAK,OAAO,CAAE,EAAK,MAAM,CAAC,MAAM,CAAC,eAAe,CAAE,CAElE,EAAU,CAAO,CAAE,EAAc,MAAM,CAAC,MAAM,CAAC,EAAE,CAAE,CAAC,KAAK,CAC3D,EAAS,EAMb,IAAM,EAAI,EAAG,EAAI,EAAO,MAAM,CAAE,EAAI,EAAG,IAAO,CAE7C,IAAM,EAAa,CAAM,CAAE,EAAG,CACxB,EAAiB,EAAE,CAEzB,IAAM,EAAI,EAAG,EAAI,EAAY,IAAO,CAEnC,IAAM,EAAY,CAAC,CAAE,EAAS,EAAa,CAErC,EAAa,CAAO,CADT,CAAC,CAAE,EAAS,EAAc,CACL,CAEtC,EAAe,IAAI,CAAE,CAAE,MAAO,EAAW,OAAQ,CAAW,GAE5D,GAAU,CAEX,CAUA,IALA,EAAe,IAAI,CAAE,GAKf,EAAI,EAAG,EAzDK,EAyDW,IAAO,CAEnC,IAAM,EAAI,CAAc,CAAE,EAAG,AAExB,AAAM,MAAA,IAAN,GAEJ,EAAM,OAAO,CAAC,KAAK,CAAC,IAAI,CAAE,EAAE,KAAK,EACjC,EAAM,OAAO,CAAC,KAAK,CAAC,IAAI,CAAE,EAAE,MAAM,IAIlC,EAAM,OAAO,CAAC,KAAK,CAAC,IAAI,CAAE,GAC1B,EAAM,OAAO,CAAC,KAAK,CAAC,IAAI,CAAE,GAI5B,CAED,CAgBA,IAAM,AAZD,EAAK,eAAe,CAExB,EAAM,UAAU,CAAG,GAAI,CAAA,EAAA,EAAA,OAAM,AAAN,IAAU,SAAS,CAAE,EAAK,eAAe,EAAG,SAAS,GAI5E,EAAM,UAAU,CAAG,GAAI,CAAA,EAAA,EAAA,OAAM,AAAN,IAAU,QAAQ,GAMpC,EAAI,EAAG,EAAI,EAAY,KAAK,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAExD,IAAM,EAAO,EAAY,KAAK,CAAE,EAAG,CAC7B,EAAc,GAAI,CAAA,EAAA,EAAA,OAAM,AAAN,IAAU,SAAS,CAAE,EAAc,KAAK,CAAE,EAAI,EAAc,MAAM,EAAG,SAAS,GAEtG,EAAM,MAAM,CAAC,IAAI,CAAE,CAAE,KAAM,EAAM,YAAa,CAAY,EAE3D,CAEA,OAAO,EAIP,SAAS,EAAY,CAAC,CAAE,CAAC,EAExB,OAAO,EAAE,MAAM,CAAG,EAAE,MAAM,AAE3B,CAED,EA7H0B,EAAK,IAAI,EAIjC,EAAS,OAAO,CAAC,WAAW,CAAG,EAAM,IAAI,CAAC,OAAO,CACjD,EAAS,OAAO,CAAC,WAAW,CAAG,EAAM,IAAI,CAAC,OAAO,EAI3C,CAER,CAsIA,SAAS,EAAY,CAAI,SAExB,AAAK,AAAe,KAAA,IAAf,EAAK,KAAK,CAAwB,EAAK,KAAK,CAE1C,EAAK,SAAS,AAEtB,CAEA,SAAS,EAAU,CAAE,EAEpB,IAAM,EAAO,GAAQ,MAAM,CAAE,EAAI,QAEjC,AAAK,AAAS,KAAA,IAAT,EAEG,EAAU,EAAM,IAIxB,QAAQ,IAAI,CAAE,oDAAsD,GAE7D,KAER,CA6MA,SAAS,EAAsB,CAAG,EAEjC,IAAM,EAAO,CAAC,EAEd,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAEnB,OAAS,EAAM,QAAQ,EAEtB,IAAK,QACJ,CAAI,CAAE,EAAM,QAAQ,CAAE,CAAG,EAAa,EAAM,WAAW,EACvD,KAED,KAAK,QACJ,CAAI,CAAE,EAAM,QAAQ,CAAE,CAAG,WAAY,EAAM,WAAW,EACtD,KAED,KAAK,UACJ,CAAI,CAAE,EAAM,QAAQ,CAAE,CAAG,CAAE,GAAI,EAAM,YAAY,CAAE,WAAa,MAAO,EAA6B,EAAQ,CAG9G,CAED,CAEA,OAAO,CAER,CAEA,SAAS,EAA6B,CAAG,EAExC,IAAM,EAAO,CACZ,UAAW,CAAC,CACb,EAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,AAET,CAAA,IAAnB,EAAM,QAAQ,EAIb,UAFG,EAAM,QAAQ,EAGrB,AAWJ,SAA2C,CAAG,CAAE,CAAI,EAEnD,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,AAET,CAAA,IAAnB,EAAM,QAAQ,EAIb,cAFG,EAAM,QAAQ,EAGrB,AASJ,SAAoD,CAAG,CAAE,CAAI,EAE5D,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAEnB,OAAS,EAAM,QAAQ,EAEtB,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACJ,EAAK,SAAS,CAAE,EAAM,QAAQ,CAAE,CAAG,WAAY,EAAM,WAAW,EAChE,KAED,KAAK,QACL,IAAK,QAIC,AAAoC,SAApC,EAAM,WAAW,CAAC,WAAW,GAEjC,EAAK,SAAS,CAAE,EAAM,QAAQ,CAAE,CAAG,EAExB,AAAoC,UAApC,EAAM,WAAW,CAAC,WAAW,GAExC,EAAK,SAAS,CAAE,EAAM,QAAQ,CAAE,CAAG,EAInC,EAAK,SAAS,CAAE,EAAM,QAAQ,CAAE,CAAG,SAAU,EAAM,WAAW,EAI/D,KAED,KAAK,OACJ,CAAI,CAAE,EAAM,QAAQ,CAAE,CAAG,EAA+B,EAG1D,CAED,CAED,EAvD+C,EAAO,EAKrD,CAED,EA7BsC,EAAO,EAK5C,CAEA,OAAO,CAER,CAsEA,SAAS,EAAkB,CAAG,EAE7B,IAAM,EAAO,CAAC,EAEd,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,AAET,CAAA,IAAnB,EAAM,QAAQ,EAIb,cAFG,EAAM,QAAQ,EAGrB,CAAA,EAAK,SAAS,CAAG,AAWrB,SAAoC,CAAG,EAEtC,IAAM,EAAO,CAAC,EAEd,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAEnB,OAAS,EAAM,QAAQ,EAEtB,IAAK,eACJ,CAAI,CAAE,EAAM,QAAQ,CAAE,CAAG,SAAU,EAAM,WAAW,EACpD,KAED,KAAK,OACJ,CAAI,CAAE,EAAM,QAAQ,CAAE,CAAG,EAA+B,EAG1D,CAED,CAEA,OAAO,CAER,EArCgD,EAA5C,CAKH,CAEA,OAAO,CAER,CA8BA,SAAS,EAA+B,CAAG,EAE1C,IAAM,EAAO,CAAC,EAEd,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,AAET,CAAA,IAAnB,EAAM,QAAQ,EAIb,YAFG,EAAM,QAAQ,EAGrB,CAAA,CAAI,CAAE,EAAM,QAAQ,CAAE,CAAG,CAAE,GAAI,EAAM,YAAY,CAAE,WAAa,SAAU,EAAM,YAAY,CAAE,YAAc,MAAO,EAA6B,EAAQ,CAAA,CAK3J,CAEA,OAAO,CAER,CAEA,SAAS,EAAa,CAAI,EAEzB,OAAO,CAER,CA0DA,SAAS,EAAe,CAAI,MAxDR,MA6Df,EAHJ,IAAM,GA1Da,EA0DO,EAAK,GAAG,CAxD3B,EAAU,GAAQ,OAAO,CAAE,EAAI,CAAE,IAyDlC,EAAY,EAAO,OAAO,CAAC,SAAS,CAI1C,OAAS,EAAU,IAAI,EAEtB,IAAK,QACL,IAAK,QACJ,EAAW,IAAI,EAAA,iBAAgB,CAC/B,KAED,KAAK,UACJ,EAAW,IAAI,EAAA,mBAAkB,CACjC,KAED,SACC,EAAW,IAAI,EAAA,iBAAgB,AAGjC,CAIA,SAAS,EAAY,CAAa,CAAE,EAAa,IAAI,EAEpD,IAAM,EAAU,EAAO,OAAO,CAAC,QAAQ,CAAE,EAAc,EAAE,CAAE,CACvD,EAAQ,KAkBZ,GAdK,AAAY,KAAA,IAAZ,EAGJ,EAAQ,EAAU,AADF,EAAO,OAAO,CAAC,QAAQ,CAAE,EAAQ,MAAM,CAAE,CAC/B,SAAS,GAInC,QAAQ,IAAI,CAAE,+EACd,EAAQ,EAAU,EAAc,EAAE,GAM9B,AAAU,OAAV,EA+CJ,OAFA,QAAQ,IAAI,CAAE,wDAA0D,EAAc,EAAE,EAEjF,IA/Cc,MArEG,MAEtB,EAEA,EAmEF,IAAM,EA9DF,QAJM,AADI,CAJU,EAuES,GAnEb,KAAK,CAAI,AAAA,CAAA,EAAM,WAAW,CAAE,KAAQ,IAAM,CAAA,EAAM,GAChD,WAAW,GAKtB,EAIA,GA2DT,GAAK,AAAW,KAAA,IAAX,EAmCJ,OAFA,QAAQ,IAAI,CAAE,wDAAyD,GAEhE,IAnCoB,EAE3B,IAAM,EAAU,EAAO,IAAI,CAAE,GAEvB,EAAQ,EAAc,KAAK,CAEjC,GAAK,AAAU,KAAA,IAAV,GAAuB,AAAoB,KAAA,IAApB,EAAM,SAAS,EAAkB,AAA+B,CAAA,IAA/B,EAAS,EAAM,SAAS,EAAe,CAEnG,IAAM,EAAY,EAAM,SAAS,AAEjC,CAAA,EAAQ,KAAK,CAAG,EAAU,KAAK,CAAG,EAAA,cAAa,CAAI,EAAA,mBAAkB,CACrE,EAAQ,KAAK,CAAG,EAAU,KAAK,CAAG,EAAA,cAAa,CAAI,EAAA,mBAAkB,CAErE,EAAQ,MAAM,CAAC,GAAG,CAAE,EAAU,OAAO,EAAI,EAAG,EAAU,OAAO,EAAI,GACjE,EAAQ,MAAM,CAAC,GAAG,CAAE,EAAU,OAAO,EAAI,EAAG,EAAU,OAAO,EAAI,EAElE,MAEC,EAAQ,KAAK,CAAG,EAAA,cAAa,CAC7B,EAAQ,KAAK,CAAG,EAAA,cAAa,CAU9B,OANoB,OAAf,GAEJ,CAAA,EAAQ,UAAU,CAAG,CAFtB,EAMO,CAER,CAQD,CAQD,CA1EA,EAAS,IAAI,CAAG,EAAK,IAAI,EAAI,GA4E7B,IAAM,EAAa,EAAU,UAAU,CAEvC,IAAM,IAAM,KAAO,EAAa,CAE/B,IAAM,EAAY,CAAU,CAAE,EAAK,CAEnC,OAAS,GAER,IAAK,UACC,EAAU,KAAK,EAAG,EAAS,KAAK,CAAC,SAAS,CAAE,EAAU,KAAK,EAC3D,EAAU,OAAO,EAAG,CAAA,EAAS,GAAG,CAAG,EAAY,EAAU,OAAO,CAAE,EAAA,cAAa,CAApF,EACA,KACD,KAAK,WACC,EAAU,KAAK,EAAI,EAAS,QAAQ,EAAG,EAAS,QAAQ,CAAC,SAAS,CAAE,EAAU,KAAK,EACnF,EAAU,OAAO,EAAG,CAAA,EAAS,WAAW,CAAG,EAAY,EAAU,OAAO,CAAA,EAC7E,KACD,KAAK,OACC,EAAU,OAAO,EAAG,CAAA,EAAS,SAAS,CAAG,EAAY,EAAU,OAAO,CAAA,EAC3E,KACD,KAAK,UACC,EAAU,OAAO,EAAG,CAAA,EAAS,QAAQ,CAAG,EAAY,EAAU,OAAO,CAAE,EAAA,cAAa,CAAzF,EACA,KACD,KAAK,YACC,EAAU,KAAK,EAAI,EAAS,SAAS,EAAG,CAAA,EAAS,SAAS,CAAG,EAAU,KAAK,AAAL,EAC5E,KACD,KAAK,WACC,EAAU,KAAK,EAAI,EAAS,QAAQ,EAAG,EAAS,QAAQ,CAAC,SAAS,CAAE,EAAU,KAAK,EACnF,EAAU,OAAO,EAAG,CAAA,EAAS,WAAW,CAAG,EAAY,EAAU,OAAO,CAAE,EAAA,cAAa,CAA5F,CAGF,CAED,CAEA,EAAS,KAAK,CAAC,mBAAmB,GAC7B,EAAS,QAAQ,EAAG,EAAS,QAAQ,CAAC,mBAAmB,GACzD,EAAS,QAAQ,EAAG,EAAS,QAAQ,CAAC,mBAAmB,GAI9D,IAAI,EAAc,EAAY,WAAe,CACzC,EAAe,EAAY,YAAgB,CAwB/C,GApBsB,KAAA,IAAjB,GAA8B,GAElC,CAAA,EAAe,CACd,MAAO,CACR,CAAA,EAMoB,KAAA,IAAhB,GAA6B,GAEjC,CAAA,EAAc,CACb,OAAQ,QACR,KAAM,CACL,MAAO,CAAE,EAAG,EAAG,EAAG,EAAG,AACtB,CAAE,CAAA,EAIC,GAAe,GAInB,GAAK,EAAY,IAAI,CAAC,OAAO,CAI5B,EAAS,WAAW,CAAG,CAAA,MAEjB,CAEN,IAAM,EAAQ,EAAY,IAAI,CAAC,KAAK,CAEpC,OAAS,EAAY,MAAM,EAE1B,IAAK,QACJ,EAAS,OAAO,CAAG,CAAK,CAAE,EAAG,CAAG,EAAa,KAAK,CAClD,KACD,KAAK,WACJ,EAAS,OAAO,CAAG,EAAM,CAAK,CAAE,EAAG,CAAG,EAAa,KAAK,CACxD,KACD,KAAK,SACJ,EAAS,OAAO,CAAG,EAAM,CAAK,CAAE,EAAG,CAAG,EAAa,KAAK,CACxD,KACD,KAAK,UACJ,EAAS,OAAO,CAAG,CAAK,CAAE,EAAG,CAAG,EAAa,KAAK,CAClD,KACD,SACC,QAAQ,IAAI,CAAE,oEAAqE,EAAY,MAAM,CAEvG,CAEK,EAAS,OAAO,CAAG,GAAI,CAAA,EAAS,WAAW,CAAG,CAAA,CAAnD,CAED,EAOD,GAAK,AAAoB,KAAA,IAApB,EAAU,KAAK,EAAkB,AAA8B,KAAA,IAA9B,EAAU,KAAK,CAAC,SAAS,CAAiB,CAE/E,IAAM,EAAa,EAAU,KAAK,CAAC,SAAS,CAE5C,IAAM,IAAM,KAAK,EAAa,CAE7B,IAAM,EAAI,CAAU,CAAE,EAAG,CAEzB,OAAS,GAER,IAAK,eACJ,EAAS,IAAI,CAAK,AAAM,IAAN,EAAU,EAAA,UAAS,CAAI,EAAA,SAAQ,CACjD,KAED,KAAK,OACJ,EAAS,SAAS,CAAG,EAAY,EAAE,OAAO,EAC1C,EAAS,WAAW,CAAG,IAAI,EAAA,OAAM,CAAG,EAAG,EAGzC,CAED,CAED,CAEA,OAAO,CAER,CA6GA,SAAS,EAAa,CAAI,EAEzB,IAAI,EAEJ,OAAS,EAAK,MAAM,CAAC,SAAS,EAE7B,IAAK,cACJ,EAAS,IAAI,EAAA,iBAAgB,CAC5B,EAAK,MAAM,CAAC,UAAU,CAAC,IAAI,CAC3B,EAAK,MAAM,CAAC,UAAU,CAAC,YAAY,CACnC,EAAK,MAAM,CAAC,UAAU,CAAC,KAAK,CAC5B,EAAK,MAAM,CAAC,UAAU,CAAC,IAAI,EAE5B,KAED,KAAK,eACJ,IAAI,EAAO,EAAK,MAAM,CAAC,UAAU,CAAC,IAAI,CAClC,EAAO,EAAK,MAAM,CAAC,UAAU,CAAC,IAAI,CAChC,EAAc,EAAK,MAAM,CAAC,UAAU,CAAC,YAAY,CAEvD,EAAO,AAAW,KAAA,IAAX,EAA2B,EAAO,EAAgB,EACzD,EAAO,AAAW,KAAA,IAAX,EAA2B,EAAO,EAAgB,EAEzD,GAAQ,GACR,GAAQ,GAER,EAAS,IAAI,EAAA,kBAAiB,CAC7B,CAAE,EAAM,EAAM,EAAM,CAAE,EACtB,EAAK,MAAM,CAAC,UAAU,CAAC,KAAK,CAC5B,EAAK,MAAM,CAAC,UAAU,CAAC,IAAI,EAE5B,KAED,SACC,EAAS,IAAI,EAAA,iBAAgB,AAG/B,CAIA,OAFA,EAAO,IAAI,CAAG,EAAK,IAAI,EAAI,GAEpB,CAER,CA0GA,SAAS,EAAY,CAAI,EAExB,IAAI,EAEJ,OAAS,EAAK,SAAS,EAEtB,IAAK,cACJ,EAAQ,IAAI,EAAA,gBAAe,CAC3B,KAED,KAAK,QACJ,EAAQ,IAAI,EAAA,UAAS,CACrB,KAED,KAAK,OACJ,EAAQ,IAAI,EAAA,SAAQ,CACpB,KAED,KAAK,UACJ,EAAQ,IAAI,EAAA,YAAW,AAGzB,CAKA,OAHK,EAAK,UAAU,CAAC,KAAK,EAAG,EAAM,KAAK,CAAC,IAAI,CAAE,EAAK,UAAU,CAAC,KAAK,EAC/D,EAAK,UAAU,CAAC,QAAQ,EAAG,CAAA,EAAM,QAAQ,CAAG,EAAK,UAAU,CAAC,QAAQ,AAAR,EAE1D,CAER,CA2EA,SAAS,EAAa,CAAG,EAExB,IAAM,EAAO,CACZ,MAAO,EAAE,CACT,OAAQ,CACT,EAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,IAAO,CAElD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAEnB,OAAS,EAAM,QAAQ,EAEtB,IAAK,cACJ,EAAK,KAAK,CAAG,EAAa,EAAM,WAAW,EAC3C,KAED,KAAK,aACJ,EAAK,KAAK,CAAG,AA5gEjB,SAAuB,CAAI,EAE1B,GAAK,AAAgB,IAAhB,EAAK,MAAM,CAAS,MAAO,EAAE,CAElC,IAAM,EAAQ,EAAK,IAAI,GAAG,KAAK,CAAE,OAC3B,EAAQ,AAAI,MAAO,EAAM,MAAM,EAErC,IAAM,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,EAAI,EAAG,IAEzC,CAAK,CAAE,EAAG,CAAG,CAAK,CAAE,EAAG,CAIxB,OAAO,CAER,EA6/D+B,EAAM,WAAW,EAC5C,KAED,KAAK,mBACJ,IAAM,EAAW,EAAsB,EAAO,WAAY,CAAE,EAAG,AAE7C,MAAA,IAAb,GAEJ,CAAA,EAAK,MAAM,CAAG,SAAU,EAAS,YAAY,CAAE,UAFhD,CAQF,CAED,CAEA,OAAO,CAER,CA4GA,SAAS,EAAe,CAAI,EAE3B,IAAM,EAAQ,CAAC,EAET,EAAU,EAAK,OAAO,CACtB,EAAW,EAAK,QAAQ,CACxB,EAAa,EAAK,UAAU,CAElC,GAAK,AAAsB,IAAtB,EAAW,MAAM,CAAS,MAAO,CAAC,EAKvC,IAAM,EAAoB,AAvD3B,SAA0B,CAAU,EAEnC,IAAM,EAAQ,CAAC,EAEf,IAAM,IAAI,EAAI,EAAG,EAAI,EAAW,MAAM,CAAE,IAAO,CAE9C,IAAM,EAAY,CAAU,CAAE,EAAG,AAEA,MAAA,IAA5B,CAAK,CAAE,EAAU,IAAI,CAAE,EAAiB,CAAA,CAAK,CAAE,EAAU,IAAI,CAAE,CAAG,EAAE,AAAF,EAEvE,CAAK,CAAE,EAAU,IAAI,CAAE,CAAC,IAAI,CAAE,EAE/B,CAEA,OAAO,CAER,EAuC4C,GAE3C,IAAM,IAAM,KAAQ,EAAoB,CAEvC,IAAM,EAAgB,CAAiB,CAAE,EAAM,EAI/C,AA7CF,SAA6B,CAAU,EAEtC,IAAI,EAAQ,EAEZ,IAAM,IAAI,EAAI,EAAG,EAAI,EAAW,MAAM,CAAE,EAAI,EAAG,IAIrB,CAAA,IAApB,AAFa,CAAU,CAAE,EAAG,CAElB,KAAK,EAEnB,IAMG,EAAQ,GAAK,EAAQ,EAAW,MAAM,EAE1C,CAAA,EAAW,WAAW,CAAG,CAAA,CAF1B,CAMD,EAuBsB,GAIpB,CAAK,CAAE,EAAM,CAAG,AAQlB,SAA4B,CAAU,CAAE,CAAO,CAAE,CAAQ,EAExD,IAAM,EAAQ,CAAC,EAET,EAAW,CAAE,MAAO,EAAE,CAAE,OAAQ,CAAE,EAClC,EAAS,CAAE,MAAO,EAAE,CAAE,OAAQ,CAAE,EAChC,EAAK,CAAE,MAAO,EAAE,CAAE,OAAQ,CAAE,EAC5B,EAAM,CAAE,MAAO,EAAE,CAAE,OAAQ,CAAE,EAC7B,EAAQ,CAAE,MAAO,EAAE,CAAE,OAAQ,CAAE,EAE/B,EAAY,CAAE,MAAO,EAAE,CAAE,OAAQ,CAAE,EACnC,EAAa,CAAE,MAAO,EAAE,CAAE,OAAQ,CAAE,EAEpC,EAAW,IAAI,EAAA,cAAa,CAE5B,EAAe,EAAE,CAEnB,EAAQ,EAEZ,IAAM,IAAI,EAAI,EAAG,EAAI,EAAW,MAAM,CAAE,IAAO,CAE9C,IAAM,EAAY,CAAU,CAAE,EAAG,CAC3B,EAAS,EAAU,MAAM,CAI3B,EAAQ,EAEZ,OAAS,EAAU,IAAI,EAEtB,IAAK,QACL,IAAK,aACJ,EAAQ,AAAkB,EAAlB,EAAU,KAAK,CACvB,KAED,KAAK,YACJ,EAAQ,AAAkB,EAAlB,EAAU,KAAK,CACvB,KAED,KAAK,WAEJ,IAAM,IAAI,EAAI,EAAG,EAAI,EAAU,KAAK,CAAE,IAAO,CAE5C,IAAM,EAAK,EAAU,MAAM,CAAE,EAAG,CAEhC,OAAS,GAER,KAAK,EACJ,GAAS,EACT,KAED,MAAK,EACJ,GAAS,EACT,KAED,SACC,GAAW,AAAA,CAAA,EAAK,CAAA,EAAM,CAGxB,CAED,CAEA,KAED,SACC,QAAQ,IAAI,CAAE,8CAA+C,EAAU,IAAI,CAE7E,CAeA,IAAM,IAAM,KAbZ,EAAS,QAAQ,CAAE,EAAO,EAAO,GACjC,GAAS,EAIJ,EAAU,QAAQ,EAEtB,EAAa,IAAI,CAAE,EAAU,QAAQ,EAMlB,EAAS,CAE5B,IAAM,EAAQ,CAAM,CAAE,EAAM,CAE5B,OAAS,GAER,IAAK,SACJ,IAAM,IAAM,KAAO,EAAW,CAE7B,IAAM,EAAK,CAAQ,CAAE,EAAK,CAE1B,OAAS,GAER,IAAK,WACJ,IAAM,EAAa,EAAS,KAAK,CAAC,MAAM,CAaxC,GAZA,EAAmB,EAAW,CAAO,CAAE,EAAI,CAAE,EAAM,MAAM,CAAE,EAAS,KAAK,EACzE,EAAS,MAAM,CAAG,CAAO,CAAE,EAAI,CAAC,MAAM,CAEjC,EAAQ,WAAW,EAAI,EAAQ,WAAW,GAE9C,EAAmB,EAAW,EAAQ,WAAW,CAAE,EAAM,MAAM,CAAE,EAAU,KAAK,EAChF,EAAmB,EAAW,EAAQ,WAAW,CAAE,EAAM,MAAM,CAAE,EAAW,KAAK,GAM7E,AAAoB,CAAA,IAApB,EAAU,KAAK,EAAc,AAA2B,CAAA,IAA3B,EAAW,WAAW,CAAY,CAEnE,IAAM,EAAU,AAAA,CAAA,EAAS,KAAK,CAAC,MAAM,CAAG,CAAA,EAAe,EAAS,MAAM,CAEtE,IAAM,IAAI,EAAI,EAAG,EAAI,EAAO,IAI3B,EAAG,KAAK,CAAC,IAAI,CAAE,EAAG,EAIpB,CAEA,KAED,KAAK,SACJ,EAAmB,EAAW,CAAO,CAAE,EAAI,CAAE,EAAM,MAAM,CAAE,EAAO,KAAK,EACvE,EAAO,MAAM,CAAG,CAAO,CAAE,EAAI,CAAC,MAAM,CACpC,KAED,KAAK,QACJ,EAAmB,EAAW,CAAO,CAAE,EAAI,CAAE,EAAM,MAAM,CAAE,EAAM,KAAK,EACtE,EAAM,MAAM,CAAG,CAAO,CAAE,EAAI,CAAC,MAAM,CACnC,KAED,KAAK,WACJ,EAAmB,EAAW,CAAO,CAAE,EAAI,CAAE,EAAM,MAAM,CAAE,EAAG,KAAK,EACnE,EAAG,MAAM,CAAG,CAAO,CAAE,EAAI,CAAC,MAAM,CAChC,KAED,KAAK,YACJ,EAAmB,EAAW,CAAO,CAAE,EAAI,CAAE,EAAM,MAAM,CAAE,EAAI,KAAK,EACpE,EAAG,MAAM,CAAG,CAAO,CAAE,EAAI,CAAC,MAAM,CAChC,KAED,SACC,QAAQ,IAAI,CAAE,4EAA6E,EAE7F,CAED,CAEA,KAED,KAAK,SACJ,EAAmB,EAAW,CAAO,CAAE,EAAM,EAAE,CAAE,CAAE,EAAM,MAAM,CAAE,EAAO,KAAK,EAC7E,EAAO,MAAM,CAAG,CAAO,CAAE,EAAM,EAAE,CAAE,CAAC,MAAM,CAC1C,KAED,KAAK,QACJ,EAAmB,EAAW,CAAO,CAAE,EAAM,EAAE,CAAE,CAAE,EAAM,MAAM,CAAE,EAAM,KAAK,CAAE,CAAA,GAC9E,EAAM,MAAM,CAAG,CAAO,CAAE,EAAM,EAAE,CAAE,CAAC,MAAM,CACzC,KAED,KAAK,WACJ,EAAmB,EAAW,CAAO,CAAE,EAAM,EAAE,CAAE,CAAE,EAAM,MAAM,CAAE,EAAG,KAAK,EACzE,EAAG,MAAM,CAAG,CAAO,CAAE,EAAM,EAAE,CAAE,CAAC,MAAM,CACtC,KAED,KAAK,YACJ,EAAmB,EAAW,CAAO,CAAE,EAAM,EAAE,CAAE,CAAE,EAAM,MAAM,CAAE,EAAI,KAAK,EAC1E,EAAI,MAAM,CAAG,CAAO,CAAE,EAAM,EAAE,CAAE,CAAC,MAAM,AAGzC,CAED,CAED,CAiBA,OAbK,EAAS,KAAK,CAAC,MAAM,CAAG,GAAI,EAAS,YAAY,CAAE,WAAY,IAAI,EAAA,sBAAqB,CAAG,EAAS,KAAK,CAAE,EAAS,MAAM,GAC1H,EAAO,KAAK,CAAC,MAAM,CAAG,GAAI,EAAS,YAAY,CAAE,SAAU,IAAI,EAAA,sBAAqB,CAAG,EAAO,KAAK,CAAE,EAAO,MAAM,GAClH,EAAM,KAAK,CAAC,MAAM,CAAG,GAAI,EAAS,YAAY,CAAE,QAAS,IAAI,EAAA,sBAAqB,CAAG,EAAM,KAAK,CAAE,EAAM,MAAM,GAC9G,EAAG,KAAK,CAAC,MAAM,CAAG,GAAI,EAAS,YAAY,CAAE,KAAM,IAAI,EAAA,sBAAqB,CAAG,EAAG,KAAK,CAAE,EAAG,MAAM,GAClG,EAAI,KAAK,CAAC,MAAM,CAAG,GAAI,EAAS,YAAY,CAAE,MAAO,IAAI,EAAA,sBAAqB,CAAG,EAAI,KAAK,CAAE,EAAI,MAAM,GAEtG,EAAU,KAAK,CAAC,MAAM,CAAG,GAAI,EAAS,YAAY,CAAE,YAAa,IAAI,EAAA,sBAAqB,CAAG,EAAU,KAAK,CAAE,EAAU,MAAM,GAC9H,EAAW,KAAK,CAAC,MAAM,CAAG,GAAI,EAAS,YAAY,CAAE,aAAc,IAAI,EAAA,sBAAqB,CAAG,EAAW,KAAK,CAAE,EAAW,MAAM,GAEvI,EAAM,IAAI,CAAG,EACb,EAAM,IAAI,CAAG,CAAU,CAAE,EAAG,CAAC,IAAI,CACjC,EAAM,YAAY,CAAG,EAEd,CAER,EA9MqC,EAAe,EAAS,EAE5D,CAEA,OAAO,CAER,CA0MA,SAAS,EAAmB,CAAS,CAAE,CAAM,CAAE,CAAM,CAAE,CAAK,CAAE,EAAU,CAAA,CAAK,EAE5E,IAAM,EAAU,EAAU,CAAC,CACrB,EAAS,EAAU,MAAM,CACzB,EAAS,EAAU,MAAM,CAE/B,SAAS,EAAY,CAAC,EAErB,IAAI,EAAQ,CAAO,CAAE,EAAI,EAAQ,CAAG,EAC9B,EAAS,EAAQ,EAEvB,KAAQ,EAAQ,EAAQ,IAEvB,EAAM,IAAI,CAAE,CAAW,CAAE,EAAO,EAIjC,GAAK,EAAU,CAGd,IAAM,EAAa,EAAM,MAAM,CAAG,EAAe,EACjD,GAAU,MAAM,CACf,CAAK,CAAE,EAAa,EAAG,CACvB,CAAK,CAAE,EAAa,EAAG,CACvB,CAAK,CAAE,EAAa,EAAG,EACtB,mBAAmB,GAErB,CAAK,CAAE,EAAa,EAAG,CAAG,GAAU,CAAC,CACrC,CAAK,CAAE,EAAa,EAAG,CAAG,GAAU,CAAC,CACrC,CAAK,CAAE,EAAa,EAAG,CAAG,GAAU,CAAC,AAEtC,CAED,CAEA,IAAM,EAAc,EAAO,KAAK,CAC1B,EAAe,EAAO,MAAM,CAElC,GAAK,AAAqB,KAAA,IAArB,EAAU,MAAM,CAAiB,CAErC,IAAI,EAAQ,EAEZ,IAAM,IAAI,EAAI,EAAG,EAAI,EAAO,MAAM,CAAE,EAAI,EAAG,IAAO,CAEjD,IAAM,EAAQ,CAAM,CAAE,EAAG,CAEzB,GAAK,AAAU,IAAV,EAAc,CAElB,IAAM,EAAI,EAAQ,AAAS,EAAT,EACZ,EAAI,EAAQ,AAAS,EAAT,EACZ,EAAI,EAAQ,AAAS,EAAT,EACZ,EAAI,EAAQ,AAAS,EAAT,EAElB,EAAY,GAAK,EAAY,GAAK,EAAY,GAC9C,EAAY,GAAK,EAAY,GAAK,EAAY,EAE/C,MAAO,GAAK,AAAU,IAAV,EAAc,CAEzB,IAAM,EAAI,EAAQ,AAAS,EAAT,EACZ,EAAI,EAAQ,AAAS,EAAT,EACZ,EAAI,EAAQ,AAAS,EAAT,EAElB,EAAY,GAAK,EAAY,GAAK,EAAY,EAE/C,MAAO,GAAK,EAAQ,EAEnB,IAAM,IAAI,EAAI,EAAG,EAAO,EAAQ,EAAK,GAAK,EAAI,IAAO,CAEpD,IAAM,EAAI,EAAQ,AAAS,EAAT,EACZ,EAAI,EAAQ,EAAS,EACrB,EAAI,EAAQ,EAAW,CAAA,EAAI,CAAA,EAEjC,EAAY,GAAK,EAAY,GAAK,EAAY,EAE/C,CAID,GAAS,EAAS,CAEnB,CAED,MAEC,IAAM,IAAI,EAAI,EAAG,EAAI,EAAQ,MAAM,CAAE,EAAI,EAAG,GAAK,EAEhD,EAAY,EAMf,CAEA,SAAS,EAAa,CAAE,EAEvB,OAAO,EAAU,GAAQ,UAAU,CAAE,EAAI,CAAE,EAE5C,CAgCA,SAAS,EAAsB,CAAI,SAElC,AAAK,AAAe,KAAA,IAAf,EAAK,KAAK,CAAwB,EAAK,KAAK,CAE1C,CAER,CAsLA,SAAS,EAA0B,CAAG,EAErC,IAAM,EAAO,CACZ,KAAM,EAAI,QAAQ,AACnB,EAEM,EAAQ,EAAa,EAAI,WAAW,EAE1C,OAAS,EAAK,IAAI,EAEjB,IAAK,SACJ,EAAK,GAAG,CAAG,IAAI,EAAA,OAAM,CACrB,EAAK,GAAG,CAAC,SAAS,CAAE,GAAQ,SAAS,GACrC,KAED,KAAK,YACJ,EAAK,GAAG,CAAG,IAAI,EAAA,OAAM,CACrB,EAAK,GAAG,CAAC,SAAS,CAAE,GACpB,KAED,KAAK,SACJ,EAAK,GAAG,CAAG,IAAI,EAAA,OAAM,CACrB,EAAK,GAAG,CAAC,SAAS,CAAE,GACpB,EAAK,KAAK,CAAG,AAAA,CAAA,EAAA,EAAA,SAAQ,AAAR,EAAU,QAAQ,CAAE,CAAK,CAAE,EAAG,CAG7C,CAEA,OAAO,CAER,CAqIA,SAAS,EAAsB,CAAI,SAElC,AAAK,AAAe,KAAA,IAAf,EAAK,KAAK,CAAwB,EAAK,KAAK,CAE1C,CAER,CAuQA,IAAM,EAAS,IAAI,EAAA,OAAM,CACnB,EAAS,IAAI,EAAA,OAAM,CAEzB,SAAS,EAAW,CAAG,EAEtB,IAAM,EAAO,CACZ,KAAM,EAAI,YAAY,CAAE,SAAY,GACpC,KAAM,EAAI,YAAY,CAAE,QACxB,GAAI,EAAI,YAAY,CAAE,MACtB,IAAK,EAAI,YAAY,CAAE,OACvB,OAAQ,IAAI,EAAA,OAAM,CAClB,MAAO,EAAE,CACT,gBAAiB,EAAE,CACnB,oBAAqB,EAAE,CACvB,eAAgB,EAAE,CAClB,mBAAoB,EAAE,CACtB,cAAe,EAAE,CACjB,WAAY,CAAC,CACd,EAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,IAAO,KAM9C,EAJJ,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAInB,OAAS,EAAM,QAAQ,EAEtB,IAAK,OACJ,EAAK,KAAK,CAAC,IAAI,CAAE,EAAM,YAAY,CAAE,OACrC,EAAW,GACX,KAED,KAAK,kBACJ,EAAK,eAAe,CAAC,IAAI,CAAE,EAAS,EAAM,YAAY,CAAE,SACxD,KAED,KAAK,sBACJ,EAAK,mBAAmB,CAAC,IAAI,CAAE,EAAmB,IAClD,KAED,KAAK,iBACJ,EAAK,cAAc,CAAC,IAAI,CAAE,EAAS,EAAM,YAAY,CAAE,SACvD,KAED,KAAK,oBACJ,EAAK,kBAAkB,CAAC,IAAI,CAAE,EAAmB,IACjD,KAED,KAAK,gBACJ,EAAK,aAAa,CAAC,IAAI,CAAE,EAAS,EAAM,YAAY,CAAE,SACtD,KAED,KAAK,SACJ,EAAQ,EAAa,EAAM,WAAW,EACtC,EAAK,MAAM,CAAC,QAAQ,CAAE,EAAO,SAAS,CAAE,GAAQ,SAAS,IACzD,EAAK,UAAU,CAAE,EAAM,YAAY,CAAE,OAAS,CAAG,EAAM,QAAQ,CAC/D,KAED,KAAK,YACJ,EAAQ,EAAa,EAAM,WAAW,EACtC,EAAO,SAAS,CAAE,GAClB,EAAK,MAAM,CAAC,QAAQ,CAAE,EAAO,eAAe,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,GAC1E,EAAK,UAAU,CAAE,EAAM,YAAY,CAAE,OAAS,CAAG,EAAM,QAAQ,CAC/D,KAED,KAAK,SACJ,EAAQ,EAAa,EAAM,WAAW,EACtC,IAAM,EAAQ,AAAA,CAAA,EAAA,EAAA,SAAQ,AAAR,EAAU,QAAQ,CAAE,CAAK,CAAE,EAAG,EAC5C,EAAK,MAAM,CAAC,QAAQ,CAAE,EAAO,gBAAgB,CAAE,EAAO,SAAS,CAAE,GAAS,IAC1E,EAAK,UAAU,CAAE,EAAM,YAAY,CAAE,OAAS,CAAG,EAAM,QAAQ,CAC/D,KAED,KAAK,QACJ,EAAQ,EAAa,EAAM,WAAW,EACtC,EAAK,MAAM,CAAC,KAAK,CAAE,EAAO,SAAS,CAAE,IACrC,EAAK,UAAU,CAAE,EAAM,YAAY,CAAE,OAAS,CAAG,EAAM,QAAQ,CAC/D,KAED,KAAK,QACJ,KAED,SACC,QAAQ,GAAG,CAAE,EAEf,CAED,CAYA,OAVK,EAAS,EAAK,EAAE,EAEpB,QAAQ,IAAI,CAAE,yGAA0G,EAAK,EAAE,EAI/H,GAAQ,KAAK,CAAE,EAAK,EAAE,CAAE,CAAG,EAIrB,CAER,CAEA,SAAS,EAAmB,CAAG,EAE9B,IAAM,EAAO,CACZ,GAAI,EAAS,EAAI,YAAY,CAAE,QAC/B,UAAW,CAAC,EACZ,UAAW,EAAE,AACd,EAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,IAAO,CAElD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,OAAS,EAAM,QAAQ,EAEtB,IAAK,gBACJ,IAAM,EAAY,EAAM,oBAAoB,CAAE,qBAE9C,IAAM,IAAI,EAAI,EAAG,EAAI,EAAU,MAAM,CAAE,IAAO,CAE7C,IAAM,EAAW,CAAS,CAAE,EAAG,CACzB,EAAS,EAAS,YAAY,CAAE,UAChC,EAAS,EAAS,YAAY,CAAE,SAEtC,CAAA,EAAK,SAAS,CAAE,EAAQ,CAAG,EAAS,EAErC,CAEA,KAED,KAAK,WACJ,EAAK,SAAS,CAAC,IAAI,CAAE,EAAS,EAAM,WAAW,EAMjD,CAED,CAEA,OAAO,CAER,CAwGA,SAAS,EAAoB,CAAI,CAAE,CAAM,CAAE,CAAQ,EAIlD,EAAK,QAAQ,CAAE,SAAW,CAAM,EAE/B,GAAK,AAAkB,CAAA,IAAlB,EAAO,MAAM,CAAY,CAE7B,IAAI,EAIJ,IAAM,IAAI,EAAI,EAAG,EAAI,EAAO,MAAM,CAAE,IAAO,CAE1C,IAAM,EAAQ,CAAM,CAAE,EAAG,CAEzB,GAAK,EAAM,IAAI,GAAK,EAAO,IAAI,CAAG,CAEjC,EAAc,EAAM,WAAW,CAC/B,KAED,CAED,CAEqB,KAAA,IAAhB,GAQJ,CAAA,EAAc,IAAI,EAAA,OAAM,AAAxB,EAID,EAAS,IAAI,CAAE,CAAE,KAAM,EAAQ,YAAa,EAAa,UAAW,CAAA,CAAM,EAE3E,CAED,EAED,CAEA,SAAS,EAAW,CAAI,MA4GnB,EA1GJ,IAAM,EAAU,EAAE,CAEZ,EAAS,EAAK,MAAM,CACpB,EAAQ,EAAK,KAAK,CAClB,EAAO,EAAK,IAAI,CAChB,EAAkB,EAAK,eAAe,CACtC,EAAsB,EAAK,mBAAmB,CAC9C,EAAiB,EAAK,cAAc,CACpC,EAAqB,EAAK,kBAAkB,CAC5C,EAAgB,EAAK,aAAa,CAIxC,IAAM,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,EAAI,EAAG,IAEzC,EAAQ,IAAI,CAAE,EAAS,CAAK,CAAE,EAAG,GAMlC,IAAM,IAAI,EAAI,EAAG,EAAI,EAAgB,MAAM,CAAE,EAAI,EAAG,IAAO,CAE1D,IAAM,EAAiB,AA5nDzB,SAAoB,CAAE,EAErB,IAAM,EAAO,GAAQ,OAAO,CAAE,EAAI,QAElC,AAAK,AAAS,KAAA,IAAT,EAEG,EAAU,EAAM,IAIxB,QAAQ,IAAI,CAAE,qDAAuD,GAE9D,KAER,EA8mDoC,CAAe,CAAE,EAAG,CAE9B,QAAnB,GAEJ,EAAQ,IAAI,CAAE,EAAe,KAAK,GAIpC,CAIA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAoB,MAAM,CAAE,EAAI,EAAG,IAAO,KAzgFxC,EA2gFtB,IAAM,EAAW,CAAmB,CAAE,EAAG,CACnC,GA5gFgB,EA4gFY,EAAS,EAAE,CA1gFvC,EAAU,GAAQ,WAAW,CAAE,EAAI,CAAE,IA4gFrC,EAAa,EADA,EAAa,EAAW,EAAE,EACA,EAAS,SAAS,EAKzD,EAAW,AAlMnB,SAAwB,CAAS,CAAE,CAAM,MAKpC,EAAG,EAAG,EAHV,IAAM,EAAW,EAAE,CACb,EAAiB,EAAE,CAOzB,IAAM,EAAI,EAAG,EAAI,EAAU,MAAM,CAAE,IAAO,CAEzC,IAAM,EAAW,CAAS,CAAE,EAAG,CAI/B,GAAK,EAAS,GAGb,EADO,EAAS,GACU,EAAQ,QAE5B,GA8bD,AAA+B,KAAA,IAA/B,GAAQ,YAAY,CA9bE,EA8bI,CA9bS,CAKxC,IAAM,EAAW,AADG,GAAQ,YAAY,CAAE,EAAU,CACvB,QAAQ,CAErC,IAAM,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAE,IAAO,CAE5C,IAAM,EAAQ,CAAQ,CAAE,EAAG,AAEP,CAAA,UAAf,EAAM,IAAI,EAGd,EADa,EAAS,EAAM,EAAE,EACJ,EAAQ,EAIpC,CAED,MAEC,QAAQ,KAAK,CAAE,qEAAsE,EAIvF,CAIA,IAAM,EAAI,EAAG,EAAI,EAAO,MAAM,CAAE,IAE/B,IAAM,EAAI,EAAG,EAAI,EAAS,MAAM,CAAE,IAIjC,GAAK,AAFL,CAAA,EAAO,CAAQ,CAAE,EAAG,AAAH,EAEP,IAAI,CAAC,IAAI,GAAK,CAAM,CAAE,EAAG,CAAC,IAAI,CAAG,CAE1C,CAAc,CAAE,EAAG,CAAG,EACtB,EAAK,SAAS,CAAG,CAAA,EACjB,KAED,CAQF,IAAM,EAAI,EAAG,EAAI,EAAS,MAAM,CAAE,IAIT,CAAA,IAAnB,AAFL,CAAA,EAAO,CAAQ,CAAE,EAAG,AAAH,EAEP,SAAS,GAElB,EAAe,IAAI,CAAE,GACrB,EAAK,SAAS,CAAG,CAAA,GAQnB,IAAM,EAAQ,EAAE,CACV,EAAe,EAAE,CAEvB,IAAM,EAAI,EAAG,EAAI,EAAe,MAAM,CAAE,IAEvC,EAAO,CAAc,CAAE,EAAG,CAE1B,EAAM,IAAI,CAAE,EAAK,IAAI,EACrB,EAAa,IAAI,CAAE,EAAK,WAAW,EAIpC,OAAO,IAAI,EAAA,QAAO,CAAG,EAAO,EAE7B,EA2FoB,EAAS,SAAS,CACrB,EAAW,IAAI,CAAC,MAAM,EAIrC,IAAM,IAAI,EAAI,EAAG,EAAK,EAAW,MAAM,CAAE,EAAI,EAAI,IAAO,CAEvD,IAAM,EAAS,CAAU,CAAE,EAAG,AAEzB,CAAA,EAAO,aAAa,GAExB,EAAO,IAAI,CAAE,EAAU,EAAW,IAAI,CAAC,UAAU,EACjD,EAAO,oBAAoB,IAI5B,EAAQ,IAAI,CAAE,EAEf,CAED,CAIA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAe,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAgB,AAliDxB,SAAmB,CAAE,EAEpB,IAAM,EAAO,GAAQ,MAAM,CAAE,EAAI,QAEjC,AAAK,AAAS,KAAA,IAAT,EAEG,EAAU,EAAM,IAIxB,QAAQ,IAAI,CAAE,oDAAsD,GAE7D,KAER,EAohDkC,CAAc,CAAE,EAAG,CAE5B,QAAlB,GAEJ,EAAQ,IAAI,CAAE,EAAc,KAAK,GAInC,CAIA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAmB,MAAM,CAAE,EAAI,EAAG,IAAO,CAE7D,IAAM,EAAW,CAAkB,CAAE,EAAG,CAMlC,EAAa,EADA,EAAa,EAAS,EAAE,EACE,EAAS,SAAS,EAE/D,IAAM,IAAI,EAAI,EAAG,EAAK,EAAW,MAAM,CAAE,EAAI,EAAI,IAEhD,EAAQ,IAAI,CAAE,CAAU,CAAE,EAAG,CAI/B,CAIA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAc,MAAM,CAAE,EAAI,EAAG,IAEjD,EAAQ,IAAI,CAAE,EAAS,CAAa,CAAE,EAAG,EAAG,KAAK,IAMlD,GAAK,AAAiB,IAAjB,EAAM,MAAM,EAAU,AAAmB,IAAnB,EAAQ,MAAM,CAExC,EAAS,CAAO,CAAE,EAAG,KAEf,CAEN,EAAS,AAAW,UAAX,EAAuB,IAAI,EAAA,IAAG,CAAM,IAAI,EAAA,KAAI,CAErD,IAAM,IAAI,EAAI,EAAG,EAAI,EAAQ,MAAM,CAAE,IAEpC,EAAO,GAAG,CAAE,CAAO,CAAE,EAAG,CAI1B,CAMA,OAJA,EAAO,IAAI,CAAG,AAAW,UAAX,EAAuB,EAAK,GAAG,CAAG,EAAK,IAAI,CACzD,EAAO,MAAM,CAAC,IAAI,CAAE,GACpB,EAAO,MAAM,CAAC,SAAS,CAAE,EAAO,QAAQ,CAAE,EAAO,UAAU,CAAE,EAAO,KAAK,EAElE,CAER,CAEA,IAAM,EAAmB,IAAI,EAAA,iBAAgB,CAAG,CAC/C,KAAM,AAAA,EAAA,MAAK,CAAE,qBAAqB,CAClC,MAAO,QACR,GA2BA,SAAS,EAAc,CAAU,CAAE,CAAiB,EAEnD,IAAM,EAAU,EAAE,CAElB,IAAM,IAAM,KAAQ,EAAa,KA4D5B,EA1DJ,IAAM,EAAW,CAAU,CAAE,EAAM,CAE7B,EAAY,AAjCpB,SAAiC,CAAI,CAAE,CAAiB,EAEvD,IAAM,EAAY,EAAE,CAEpB,IAAM,IAAI,EAAI,EAAG,EAAI,EAAK,MAAM,CAAE,EAAI,EAAG,IAAO,CAE/C,IAAM,EAAK,CAAiB,CAAE,CAAI,CAAE,EAAG,CAAE,AAEpC,AAAO,MAAA,IAAP,GAEJ,QAAQ,IAAI,CAAE,gFAAiF,CAAI,CAAE,EAAG,EACxG,EAAU,IAAI,CAAE,IAIhB,EAAU,IAAI,CAn5DT,EAAU,GAAQ,SAAS,CAm5DH,EAn5DS,CAAE,GAu5D1C,CAEA,OAAO,CAER,EAU4C,EAAS,YAAY,CAAE,GAoBjE,GAhB0B,IAArB,EAAU,MAAM,GAEf,AAAS,UAAT,GAAoB,AAAS,eAAT,EAExB,EAAU,IAAI,CAAE,IAAI,EAAA,iBAAgB,EAIpC,EAAU,IAAI,CAAE,IAAI,EAAA,iBAAgB,GAQjC,AAAS,UAAT,GAAoB,AAAS,eAAT,EAExB,IAAM,IAAI,EAAI,EAAG,EAAI,EAAU,MAAM,CAAE,EAAI,EAAG,IAAO,CAEpD,IAAM,EAAW,CAAS,CAAE,EAAG,CAE/B,GAAK,AAAiC,CAAA,IAAjC,EAAS,mBAAmB,EAAa,AAAmC,CAAA,IAAnC,EAAS,qBAAqB,CAAY,CAEvF,IAAM,EAAe,IAAI,EAAA,iBAAgB,CAIzC,EAAa,KAAK,CAAC,IAAI,CAAE,EAAS,KAAK,EACvC,EAAa,OAAO,CAAG,EAAS,OAAO,CACvC,EAAa,WAAW,CAAG,EAAS,WAAW,CAI/C,CAAS,CAAE,EAAG,CAAG,CAElB,CAED,CAMD,IAAM,EAAa,AAAuC,KAAA,IAAvC,EAAS,IAAI,CAAC,UAAU,CAAC,SAAS,CAI/C,EAAa,AAAqB,IAArB,EAAU,MAAM,CAAW,CAAS,CAAE,EAAG,CAAG,EAM/D,OAAS,GAER,IAAK,QACJ,EAAS,IAAI,EAAA,YAAW,CAAG,EAAS,IAAI,CAAE,GAC1C,KAED,KAAK,aACJ,EAAS,IAAI,EAAA,IAAG,CAAG,EAAS,IAAI,CAAE,GAClC,KAED,KAAK,YACL,IAAK,WAGH,EAFI,EAEK,IAAI,EAAA,WAAU,CAAG,EAAS,IAAI,CAAE,GAIhC,IAAI,EAAA,IAAG,CAAG,EAAS,IAAI,CAAE,EAMrC,CAEA,EAAQ,IAAI,CAAE,EAEf,CAEA,OAAO,CAER,CAEA,SAAS,EAAS,CAAE,EAEnB,OAAO,AAAwB,KAAA,IAAxB,GAAQ,KAAK,CAAE,EAAI,AAE3B,CAEA,SAAS,EAAS,CAAE,EAEnB,OAAO,EAAU,GAAQ,KAAK,CAAE,EAAI,CAAE,EAEvC,CAyBA,SAAS,EAAkB,CAAI,EAE9B,IAAM,EAAQ,IAAI,EAAA,KAAI,AACtB,CAAA,EAAM,IAAI,CAAG,EAAK,IAAI,CAEtB,IAAM,EAAW,EAAK,QAAQ,CAE9B,IAAM,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAE,IAAO,CAE5C,IAAM,EAAQ,CAAQ,CAAE,EAAG,CAE3B,EAAM,GAAG,CAAE,EAAS,EAAM,EAAE,EAE7B,CAEA,OAAO,CAER,CAQA,SAAS,EAAgB,CAAE,EAE1B,OAAO,EAAU,GAAQ,YAAY,CAAE,EAAI,CAAE,EAE9C,CAgFA,GAAK,AAAgB,IAAhB,EAAK,MAAM,CAEf,MAAO,CAAE,MAAO,IAAI,EAAA,KAAI,AAAI,EAI7B,IAAM,EAAM,IAAI,YAAY,eAAe,CAAE,EAAM,mBAE7C,GAAU,EAAsB,EAAK,UAAW,CAAE,EAAG,CAErD,GAAc,EAAI,oBAAoB,CAAE,cAAe,CAAE,EAAG,CAClE,GAAK,AAAgB,KAAA,IAAhB,GAA4B,CAIhC,IAAM,EAAe,EAAsB,GAAa,MAAO,CAAE,EAAG,CAepE,OAFA,QAAQ,KAAK,CAAE,uDAVV,EAEQ,EAAa,WAAW,CAIxB,AAlDd,SAA4B,CAAW,EAEtC,IAAI,EAAS,GACP,EAAQ,CAAE,EAAa,CAE7B,KAAQ,EAAM,MAAM,EAAG,CAEtB,IAAM,EAAO,EAAM,KAAK,EAEnB,CAAA,EAAK,QAAQ,GAAK,KAAK,SAAS,CAEpC,GAAU,EAAK,WAAW,EAI1B,GAAU,KACV,EAAM,IAAI,CAAC,KAAK,CAAE,EAAO,EAAK,UAAU,EAI1C,CAEA,OAAO,EAAO,IAAI,EAEnB,EA0BiC,KAMzB,IAER,CAKA,QAAQ,KAAK,CAAE,oCADC,GAAQ,YAAY,CAAE,YAGtC,IAAM,IAnwHe,EAmwHK,EAAsB,GAAS,QAAS,CAAE,EAAG,CAjwH/D,CACN,KAQD,AAAK,AAAU,KAAA,KAFS,EAND,EAAsB,EAAK,OAAQ,CAAE,EAAG,GAQ/B,AAAgC,CAAA,IAAhC,EAAI,YAAY,CAAE,SAE1C,WAAY,EAAI,YAAY,CAAE,UAI9B,EAbP,OAqBM,AAAQ,KAAA,KAFW,EAnBC,EAAsB,EAAK,UAAW,CAAE,EAAG,EAqB3C,EAAI,WAAW,CAAG,MApB7C,GA+vHK,GAAgB,IAAI,EAAA,aAAY,CAAG,IAAI,CAAC,OAAO,EACrD,GAAc,OAAO,CAAE,IAAI,CAAC,YAAY,EAAI,GAAO,cAAc,CAAE,IAAI,CAAC,WAAW,EAI9E,GAGJ,AADA,CAAA,EAAY,IAAI,EAAW,IAAI,CAAC,OAAO,CAAA,EAC7B,OAAO,CAAE,IAAI,CAAC,YAAY,EAAI,GAMzC,IAAM,GAAY,IAAI,EAAA,KAAI,CACpB,GAAa,EAAE,CACjB,GAAa,CAAC,EACd,GAAQ,EAIN,GAAU,CACf,WAAY,CAAC,EACb,MAAO,CAAC,EACR,YAAa,CAAC,EACd,OAAQ,CAAC,EACT,QAAS,CAAC,EACV,UAAW,CAAC,EACZ,QAAS,CAAC,EACV,OAAQ,CAAC,EACT,WAAY,CAAC,EACb,MAAO,CAAC,EACR,aAAc,CAAC,EACf,iBAAkB,CAAC,EACnB,cAAe,CAAC,EAChB,iBAAkB,CAAC,CACpB,EAEA,EAAc,GAAS,qBAAsB,YAhuH7C,SAAS,EAAgB,CAAG,EAE3B,IAAM,EAAO,CACZ,QAAS,CAAC,EACV,SAAU,CAAC,EACX,SAAU,CAAC,CACZ,EAEI,EAAc,CAAA,EAElB,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,KAMrD,EAJJ,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAInB,OAAS,EAAM,QAAQ,EAEtB,IAAK,SACJ,EAAK,EAAM,YAAY,CAAE,MACzB,EAAK,OAAO,CAAE,EAAI,CAAG,EAAa,GAClC,KAED,KAAK,UACJ,EAAK,EAAM,YAAY,CAAE,MACzB,EAAK,QAAQ,CAAE,EAAI,CAAG,AA+B1B,SAAgC,CAAG,EAElC,IAAM,EAAO,CACZ,OAAQ,CAAC,CACV,EAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,EAIb,UAFG,EAAM,QAAQ,EAGrB,IAAM,EAAK,EAAS,EAAM,YAAY,CAAE,WAClC,EAAW,EAAM,YAAY,CAAE,WACrC,CAAA,EAAK,MAAM,CAAE,EAAU,CAAG,EAK7B,CAEA,OAAO,CAER,EAzDiD,GAC7C,KAED,KAAK,UACJ,EAAK,EAAM,YAAY,CAAE,UACzB,EAAK,QAAQ,CAAE,EAAI,CAAG,AAsD1B,SAAgC,CAAG,EAElC,IAAM,EAAO,CAAC,EAMV,EAAQ,AAJG,EAAI,YAAY,CAAE,UAId,KAAK,CAAE,KAEpB,EAAK,EAAM,KAAK,GAClB,EAAM,EAAM,KAAK,GAIf,EAAgB,AAAuB,KAAvB,EAAI,OAAO,CAAE,KAC7B,EAAiB,AAAuB,KAAvB,EAAI,OAAO,CAAE,KAEpC,GAAK,EAKJ,EAAM,AADN,CAAA,EAAQ,EAAI,KAAK,CAAE,IAAnB,EACY,KAAK,GACjB,EAAK,MAAM,CAAG,EAAM,KAAK,QAEnB,GAAK,EAAc,CAIzB,IAAM,EAAU,EAAI,KAAK,CAAE,KAC3B,EAAM,EAAQ,KAAK,GAEnB,IAAM,IAAI,EAAI,EAAG,EAAI,EAAQ,MAAM,CAAE,IAEpC,CAAO,CAAE,EAAG,CAAG,SAAU,CAAO,CAAE,EAAG,CAAC,OAAO,CAAE,KAAM,IAItD,CAAA,EAAK,OAAO,CAAG,CAEhB,CAUA,OARA,EAAK,EAAE,CAAG,EACV,EAAK,GAAG,CAAG,EAEX,EAAK,WAAW,CAAG,EACnB,EAAK,YAAY,CAAG,EAEpB,EAAK,OAAO,CAAG,EAAS,EAAI,YAAY,CAAE,WAEnC,CAER,EA3GiD,GAC7C,KAED,KAAK,YAEJ,EAAgB,GAChB,EAAc,CAAA,EACd,KAED,SACC,QAAQ,GAAG,CAAE,EAEf,CAED,CAEqB,CAAA,IAAhB,GAIJ,CAAA,GAAQ,UAAU,CAAE,EAAI,YAAY,CAAE,OAAU,AAAA,CAAA,EAAA,EAAA,SAAQ,AAAR,EAAU,YAAY,GAAI,CAAG,CAA7E,CAIF,GAyqHA,EAAc,GAAS,0BAA2B,iBAxxGlD,SAA6B,CAAG,EAE/B,IAAM,EAAO,CACZ,KAAM,EAAI,YAAY,CAAE,OAAU,UAClC,MAAO,WAAY,EAAI,YAAY,CAAE,UAAa,GAClD,IAAK,WAAY,EAAI,YAAY,CAAE,QAAW,GAC9C,WAAY,EAAE,AACf,EAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,AAET,CAAA,IAAnB,EAAM,QAAQ,EAIb,uBAFG,EAAM,QAAQ,EAGrB,EAAK,UAAU,CAAC,IAAI,CAAE,EAAS,EAAM,YAAY,CAAE,QAKtD,CAEA,GAAQ,KAAK,CAAE,EAAI,YAAY,CAAE,MAAQ,CAAG,CAE7C,GA8vGA,EAAc,GAAS,sBAAuB,aA5tG9C,SAA0B,CAAG,EAE5B,IAAM,EAAO,CAAC,EAEd,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAEnB,OAAS,EAAM,QAAQ,EAEtB,IAAK,OAEJ,EAAK,EAAE,CAAG,EAAS,EAAM,YAAY,CAAE,WACvC,EAAK,IAAI,CAAG,AAgBhB,SAAoB,CAAG,EAEtB,IAAM,EAAO,CACZ,QAAS,CAAC,CACX,EAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAEnB,OAAS,EAAM,QAAQ,EAEtB,IAAK,oBACJ,EAAK,eAAe,CAAG,EAAa,EAAM,WAAW,EACrD,KAED,KAAK,SACJ,IAAM,EAAK,EAAM,YAAY,CAAE,KAC/B,CAAA,EAAK,OAAO,CAAE,EAAI,CAAG,EAAa,GAClC,KAED,KAAK,SACJ,EAAK,MAAM,CAAG,AAelB,SAAsB,CAAG,EAExB,IAAM,EAAO,CACZ,OAAQ,CAAC,CACV,EAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,EAIb,UAFG,EAAM,QAAQ,EAGrB,IAAM,EAAW,EAAM,YAAY,CAAE,YAC/B,EAAK,EAAS,EAAM,YAAY,CAAE,UACxC,CAAA,EAAK,MAAM,CAAE,EAAU,CAAG,EAK7B,CAEA,OAAO,CAER,EAzC+B,GAC3B,KAED,KAAK,iBACJ,EAAK,aAAa,CAAG,AAuCzB,SAA6B,CAAG,EAE/B,IAAM,EAAO,CACZ,OAAQ,CAAC,CACV,EAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAEnB,OAAS,EAAM,QAAQ,EAEtB,IAAK,QACJ,IAAM,EAAW,EAAM,YAAY,CAAE,YAC/B,EAAK,EAAS,EAAM,YAAY,CAAE,WAClC,EAAS,SAAU,EAAM,YAAY,CAAE,UAC7C,CAAA,EAAK,MAAM,CAAE,EAAU,CAAG,CAAE,GAAI,EAAI,OAAQ,CAAO,EACnD,KAED,KAAK,SACJ,EAAK,MAAM,CAAG,EAAW,EAAM,WAAW,EAC1C,KAED,KAAK,IACJ,EAAK,CAAC,CAAG,EAAW,EAAM,WAAW,CAGvC,CAED,CAEA,OAAO,CAER,EA1E6C,EAG3C,CAED,CAEA,OAAO,CAER,EArD2B,GACvB,KAED,KAAK,QACJ,EAAK,EAAE,CAAG,EAAS,EAAM,YAAY,CAAE,WACvC,QAAQ,IAAI,CAAE,iEAGhB,CAED,CAEA,GAAQ,WAAW,CAAE,EAAI,YAAY,CAAE,MAAQ,CAAG,CAEnD,GAgsGA,EAAc,GAAS,iBAAkB,QAr8FzC,SAAqB,CAAG,EAEvB,IAAM,EAAO,CACZ,UAAW,EAAsB,EAAK,YAAa,CAAE,EAAG,CAAC,WAAW,AACrE,CAEA,CAAA,GAAQ,MAAM,CAAE,EAAI,YAAY,CAAE,MAAQ,CAAG,CAE9C,GA87FA,EAAc,GAAS,kBAAmB,SAl6F1C,SAAsB,CAAG,EAExB,IAAM,EAAO,CAAC,EAEd,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,AAET,CAAA,IAAnB,EAAM,QAAQ,EAIb,mBAFG,EAAM,QAAQ,EAGrB,CAAA,EAAK,OAAO,CAAG,AAWnB,SAAmC,CAAG,EAErC,IAAM,EAAO,CACZ,SAAU,CAAC,EACX,SAAU,CAAC,CACZ,EAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAEnB,OAAS,EAAM,QAAQ,EAEtB,IAAK,WACJ,AAmBJ,CAAA,SAA8B,CAAG,CAAE,CAAI,EAEtC,IAAM,EAAM,EAAI,YAAY,CAAE,OAE9B,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAEnB,OAAS,EAAM,QAAQ,EAEtB,IAAK,UACJ,EAAK,QAAQ,CAAE,EAAK,CAAG,AAa3B,SAA6B,CAAG,EAE/B,IAAM,EAAO,CAAC,EAEd,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,AAET,CAAA,IAAnB,EAAM,QAAQ,EAIb,cAFG,EAAM,QAAQ,EAGrB,CAAA,EAAK,SAAS,CAAG,EAAM,WAAW,AAAX,CAK1B,CAEA,OAAO,CAER,EAnC+C,GAC3C,KAED,KAAK,YACJ,EAAK,QAAQ,CAAE,EAAK,CAAG,AAiC3B,SAA6B,CAAG,EAE/B,IAAM,EAAO,CAAC,EAEd,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,AAET,CAAA,IAAnB,EAAM,QAAQ,EAIb,WAFG,EAAM,QAAQ,EAGrB,CAAA,EAAK,MAAM,CAAG,EAAM,WAAW,AAAX,CAKvB,CAEA,OAAO,CAER,EAvD+C,EAG7C,CAED,CAED,CAAA,EA3CyB,EAAO,GAC5B,KAED,KAAK,YACJ,EAAK,SAAS,CAAG,AAyFrB,SAA+B,CAAG,EAEjC,IAAM,EAAO,CAAC,EAEd,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAEnB,OAAS,EAAM,QAAQ,EAEtB,IAAK,WACL,IAAK,UACL,IAAK,QACL,IAAK,QACJ,EAAK,IAAI,CAAG,EAAM,QAAQ,CAC1B,EAAK,UAAU,CAAG,AAetB,SAAgC,CAAG,EAElC,IAAM,EAAO,CAAC,EAEd,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAEnB,OAAS,EAAM,QAAQ,EAEtB,IAAK,WACL,IAAK,UACL,IAAK,WACL,IAAK,OACL,IAAK,UACL,IAAK,YACL,IAAK,eACJ,CAAI,CAAE,EAAM,QAAQ,CAAE,CAAG,EAAsB,GAC/C,KACD,KAAK,cACJ,CAAI,CAAE,EAAM,QAAQ,CAAE,CAAG,CACxB,OAAQ,EAAM,YAAY,CAAE,UAAa,EAAM,YAAY,CAAE,UAAa,QAC1E,KAAM,EAAsB,EAC7B,CAGF,CAED,CAEA,OAAO,CAER,EAjD6C,GACzC,KAED,KAAK,QACJ,EAAK,KAAK,CAAG,EAAkB,EAGjC,CAED,CAEA,OAAO,CAER,EAvH2C,GACvC,KAED,KAAK,QACJ,EAAK,KAAK,CAAG,EAAkB,EAGjC,CAED,CAEA,OAAO,CAER,EA5C6C,EAAzC,CAKH,CAEA,GAAQ,OAAO,CAAE,EAAI,YAAY,CAAE,MAAQ,CAAG,CAE/C,GA64FA,EAAc,GAAS,oBAAqB,WAlgF5C,SAAwB,CAAG,EAE1B,IAAM,EAAO,CACZ,KAAM,EAAI,YAAY,CAAE,OACzB,EAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,AAET,CAAA,IAAnB,EAAM,QAAQ,EAIb,oBAFG,EAAM,QAAQ,EAGrB,CAAA,EAAK,GAAG,CAAG,EAAS,EAAM,YAAY,CAAE,OAAxC,CAKH,CAEA,GAAQ,SAAS,CAAE,EAAI,YAAY,CAAE,MAAQ,CAAG,CAEjD,GA2+EA,EAAc,GAAS,kBAAmB,SA/tE1C,SAAsB,CAAG,EAExB,IAAM,EAAO,CACZ,KAAM,EAAI,YAAY,CAAE,OACzB,EAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,AAET,CAAA,IAAnB,EAAM,QAAQ,EAIb,WAFG,EAAM,QAAQ,EAGrB,CAAA,EAAK,MAAM,CAAG,AAWlB,SAA4B,CAAG,EAE9B,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,IAAO,CAElD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAEM,qBAFG,EAAM,QAAQ,CAGrB,OAAO,AAUX,SAA+B,CAAG,EAEjC,IAAM,EAAO,CAAC,EAEd,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,IAAO,CAElD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,OAAS,EAAM,QAAQ,EAEtB,IAAK,cACL,IAAK,eAEJ,EAAK,SAAS,CAAG,EAAM,QAAQ,CAC/B,EAAK,UAAU,CAAG,AAYtB,SAAgC,CAAG,EAElC,IAAM,EAAO,CAAC,EAEd,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,IAAO,CAElD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,OAAS,EAAM,QAAQ,EAEtB,IAAK,OACL,IAAK,OACL,IAAK,OACL,IAAK,OACL,IAAK,QACL,IAAK,OACL,IAAK,eACJ,CAAI,CAAE,EAAM,QAAQ,CAAE,CAAG,WAAY,EAAM,WAAW,CAGxD,CAED,CAEA,OAAO,CAER,EAtC6C,EAI3C,CAED,CAEA,OAAO,CAER,EAlCiC,EAIhC,CAEA,MAAO,CAAC,CAET,EA5BqC,EAAjC,CAKH,CAEA,GAAQ,OAAO,CAAE,EAAI,YAAY,CAAE,MAAQ,CAAG,CAE/C,GAwsEA,EAAc,GAAS,iBAAkB,QA9jEzC,SAAqB,CAAG,EAEvB,IAAI,EAAO,CAAC,EAEZ,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,AAET,CAAA,IAAnB,EAAM,QAAQ,EAIb,qBAFG,EAAM,QAAQ,EAGrB,CAAA,EAAO,AAWX,SAA8B,CAAG,EAEhC,IAAM,EAAO,CAAC,EAEd,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAEnB,OAAS,EAAM,QAAQ,EAEtB,IAAK,cACL,IAAK,QACL,IAAK,OACL,IAAK,UAEJ,EAAK,SAAS,CAAG,EAAM,QAAQ,CAC/B,EAAK,UAAU,CAAG,AAUtB,SAA+B,CAAG,EAEjC,IAAM,EAAO,CAAC,EAEd,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAEnB,OAAS,EAAM,QAAQ,EAEtB,IAAK,QACJ,IAAM,EAAQ,EAAa,EAAM,WAAW,CAC5C,CAAA,EAAK,KAAK,CAAG,GAAI,CAAA,EAAA,EAAA,KAAI,AAAJ,IAAQ,SAAS,CAAE,GAAQ,mBAAmB,GAC/D,KAED,KAAK,gBACJ,EAAK,YAAY,CAAG,WAAY,EAAM,WAAW,EACjD,KAED,KAAK,wBACJ,IAAM,EAAI,WAAY,EAAM,WAAW,CACvC,CAAA,EAAK,QAAQ,CAAG,EAAI,KAAK,IAAI,CAAE,EAAI,GAAM,CAG3C,CAED,CAEA,OAAO,CAER,EA1C4C,EAE1C,CAED,CAEA,OAAO,CAER,EArCgC,EAA5B,CAKH,CAEA,GAAQ,MAAM,CAAE,EAAI,YAAY,CAAE,MAAQ,CAAG,CAE9C,GAyiEA,EAAc,GAAS,qBAAsB,WAx7D7C,SAAwB,CAAG,EAE1B,IAAM,EAAO,CACZ,KAAM,EAAI,YAAY,CAAE,QACxB,QAAS,CAAC,EACV,SAAU,CAAC,EACX,WAAY,EAAE,AACf,EAEM,EAAO,EAAsB,EAAK,OAAQ,CAAE,EAAG,CAGrD,GAAK,AAAS,KAAA,IAAT,GAEL,IAAM,IAAI,EAAI,EAAG,EAAI,EAAK,UAAU,CAAC,MAAM,CAAE,IAAO,CAEnD,IAAM,EAAQ,EAAK,UAAU,CAAE,EAAG,CAElC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAAS,SAE5B,IAAM,EAAK,EAAM,YAAY,CAAE,MAE/B,OAAS,EAAM,QAAQ,EAEtB,IAAK,SACJ,EAAK,OAAO,CAAE,EAAI,CAAG,EAAa,GAClC,KAED,KAAK,WAEJ,EAAK,QAAQ,CAAG,AAmEpB,SAAgC,CAAG,EAElC,IAAM,EAAO,CAAC,EAEd,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,IAAO,CAElD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,AAET,CAAA,IAAnB,EAAM,QAAQ,EAEnB,CAAA,CAAI,CAAE,EAAM,YAAY,CAAE,YAAc,CAAG,EAAS,EAAM,YAAY,CAAE,UAAxE,CAED,CAEA,OAAO,CAER,EAnF2C,GACvC,KAED,KAAK,WACJ,QAAQ,IAAI,CAAE,oDAAqD,EAAM,QAAQ,EACjF,KAED,KAAK,QACL,IAAK,aACL,IAAK,WACL,IAAK,YACJ,EAAK,UAAU,CAAC,IAAI,CAAE,AA0E1B,SAAiC,CAAG,EAEnC,IAAM,EAAY,CACjB,KAAM,EAAI,QAAQ,CAClB,SAAU,EAAI,YAAY,CAAE,YAC5B,MAAO,SAAU,EAAI,YAAY,CAAE,UACnC,OAAQ,CAAC,EACT,OAAQ,EACR,MAAO,CAAA,CACR,EAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAEzD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAEnB,OAAS,EAAM,QAAQ,EAEtB,IAAK,QACJ,IAAM,EAAK,EAAS,EAAM,YAAY,CAAE,WAClC,EAAW,EAAM,YAAY,CAAE,YAC/B,EAAS,SAAU,EAAM,YAAY,CAAE,WACvC,EAAM,SAAU,EAAM,YAAY,CAAE,QACpC,EAAc,EAAM,EAAI,EAAW,EAAM,CAC/C,CAAA,EAAU,MAAM,CAAE,EAAW,CAAG,CAAE,GAAI,EAAI,OAAQ,CAAO,EACzD,EAAU,MAAM,CAAG,KAAK,GAAG,CAAE,EAAU,MAAM,CAAE,EAAS,GACtC,aAAb,GAA0B,CAAA,EAAU,KAAK,CAAG,CAAA,CAAjD,EACA,KAED,KAAK,SACJ,EAAU,MAAM,CAAG,EAAW,EAAM,WAAW,EAC/C,KAED,KAAK,IACJ,EAAU,CAAC,CAAG,EAAW,EAAM,WAAW,CAG5C,CAED,CAEA,OAAO,CAER,EAtHkD,IAC9C,KAED,SACC,QAAQ,GAAG,CAAE,EAEf,CAED,CAEA,GAAQ,UAAU,CAAE,EAAI,YAAY,CAAE,MAAQ,CAAG,EAElD,GAo4DA,EAAc,GAAS,gBAAiB,OAAQ,GAChD,EAAc,GAAS,wBAAyB,eA1NhD,SAA2B,CAAG,EAE7B,IAAM,EAAO,CACZ,KAAM,EAAI,YAAY,CAAE,QACxB,SAAU,EAAE,AACb,GAEA,AAzlBD,SAAuB,CAAG,EAEzB,IAAM,EAAW,EAAI,oBAAoB,CAAE,QAI3C,IAAM,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAE,IAAO,CAE5C,IAAM,EAAU,CAAQ,CAAE,EAAG,AAES,EAAA,IAAjC,EAAQ,YAAY,CAAE,OAE1B,EAAQ,YAAY,CAAE,KAhiGjB,iBAAqB,KAoiG5B,CAED,EAukBe,GAEd,IAAM,EAAW,EAAsB,EAAK,QAE5C,IAAM,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAE,IAErC,EAAK,QAAQ,CAAC,IAAI,CAAE,EAAW,CAAQ,CAAE,EAAG,EAI7C,CAAA,GAAQ,YAAY,CAAE,EAAI,YAAY,CAAE,MAAQ,CAAG,CAEpD,GAwMA,EAAc,GAAS,4BAA6B,mBAj6CpD,SAA+B,CAAG,EAEjC,IAAM,EAAO,CACZ,KAAM,EAAI,YAAY,CAAE,SAAY,GACpC,OAAQ,CAAC,EACT,MAAO,EAAE,AACV,EAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,IAAO,CAElD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,AAET,CAAA,IAAnB,EAAM,QAAQ,EAIb,qBAFG,EAAM,QAAQ,EAGrB,AAyBJ,SAAyC,CAAG,CAAE,CAAI,EAEjD,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,IAAO,CAElD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAEnB,OAAS,EAAM,QAAQ,EAEtB,IAAK,QACJ,EAAK,MAAM,CAAE,EAAM,YAAY,CAAE,OAAS,CAAG,AAajD,SAA+B,CAAG,EAEjC,IAAI,EAEJ,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,IAAO,CAElD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAEnB,OAAS,EAAM,QAAQ,EAEtB,IAAK,YACL,IAAK,WACJ,EAAO,AAWX,SAAwC,CAAG,EAE1C,IAAM,EAAO,CACZ,IAAK,EAAI,YAAY,CAAE,OACvB,KAAM,EAAI,YAAY,CAAE,SAAY,GACpC,KAAM,IAAI,EAAA,OAAM,CAChB,OAAQ,CACP,IAAK,EACL,IAAK,CACN,EACA,KAAM,EAAI,QAAQ,CAClB,OAAQ,CAAA,EACR,aAAc,EACd,eAAgB,CACjB,EAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,IAAO,CAElD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAEnB,OAAS,EAAM,QAAQ,EAEtB,IAAK,OACJ,IAAM,EAAQ,EAAa,EAAM,WAAW,EAC5C,EAAK,IAAI,CAAC,SAAS,CAAE,GACrB,KACD,KAAK,SACJ,IAAM,EAAM,EAAM,oBAAoB,CAAE,MAAO,CAAE,EAAG,CAC9C,EAAM,EAAM,oBAAoB,CAAE,MAAO,CAAE,EAAG,AAEpD,CAAA,EAAK,MAAM,CAAC,GAAG,CAAG,WAAY,EAAI,WAAW,EAC7C,EAAK,MAAM,CAAC,GAAG,CAAG,WAAY,EAAI,WAAW,CAG/C,CAED,CAcA,OAVK,EAAK,MAAM,CAAC,GAAG,EAAI,EAAK,MAAM,CAAC,GAAG,EAEtC,CAAA,EAAK,MAAM,CAAG,CAAA,CAFf,EAQA,EAAK,cAAc,CAAK,AAAA,CAAA,EAAK,MAAM,CAAC,GAAG,CAAG,EAAK,MAAM,CAAC,GAAE,AAAF,EAAQ,EAEvD,CAER,EAjE0C,EAGxC,CAED,CAEA,OAAO,CAER,EApCuE,GACnE,KAED,KAAK,OACJ,EAAK,KAAK,CAAC,IAAI,CAAE,AA0FrB,SAAS,EAAqB,CAAG,EAEhC,IAAM,EAAO,CACZ,IAAK,EAAI,YAAY,CAAE,OACvB,KAAM,EAAI,YAAY,CAAE,SAAY,GACpC,YAAa,EAAE,CACf,WAAY,EAAE,AACf,EAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,IAAO,CAElD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAEnB,OAAS,EAAM,QAAQ,EAEtB,IAAK,kBACJ,EAAK,WAAW,CAAC,IAAI,CAAE,AAiB3B,SAAoC,CAAG,EAEtC,IAAM,EAAO,CACZ,MAAO,EAAI,YAAY,CAAE,SAAU,KAAK,CAAE,KAAM,GAAG,GACnD,WAAY,EAAE,CACd,MAAO,EAAE,AACV,EAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,IAAO,CAElD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAEnB,OAAS,EAAM,QAAQ,EAEtB,IAAK,OACJ,EAAK,KAAK,CAAC,IAAI,CAAE,EAAqB,IACtC,KAED,KAAK,SACL,IAAK,YACL,IAAK,SACJ,EAAK,UAAU,CAAC,IAAI,CAAE,EAA0B,GAGlD,CAED,CAEA,OAAO,CAER,EAjDsD,IAClD,KAED,KAAK,SACL,IAAK,YACL,IAAK,SACJ,EAAK,UAAU,CAAC,IAAI,CAAE,EAA0B,GAGlD,CAED,CAEA,OAAO,CAER,EA3H0C,GAGxC,CAED,CAED,EA/CoC,EAAO,EAK1C,CAEA,GAAQ,gBAAgB,CAAE,EAAI,YAAY,CAAE,MAAQ,CAAG,CAExD,GAw4CA,EAAc,GAAS,yBAA0B,gBAxqCjD,SAA4B,CAAG,EAE9B,IAAM,EAAO,CACZ,KAAM,EAAI,YAAY,CAAE,SAAY,GACpC,YAAa,CAAC,CACf,EAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,IAAO,CAElD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,AAET,CAAA,IAAnB,EAAM,QAAQ,EAIb,eAFG,EAAM,QAAQ,GAGrB,EAAK,WAAW,CAAE,EAAM,YAAY,CAAE,QAAU,CAAG,CAAC,EACpD,AAWJ,SAAgC,CAAG,CAAE,CAAI,EAExC,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,IAAO,CAElD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,AAET,CAAA,IAAnB,EAAM,QAAQ,EAIb,qBAFG,EAAM,QAAQ,EAGrB,AASJ,SAAsC,CAAG,CAAE,CAAI,EAE9C,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,IAAO,CAElD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAEnB,OAAS,EAAM,QAAQ,EAEtB,IAAK,UACJ,EAAK,OAAO,CAAG,EAAa,EAAM,WAAW,EAC7C,KAED,KAAK,OACJ,EAAK,IAAI,CAAG,EAAa,EAAM,WAAW,CAAE,CAAE,EAAG,AAGnD,CAED,CAED,EA/BiC,EAAO,EAKvC,CAED,EA7B2B,EAAO,EAAK,WAAW,CAAE,EAAM,YAAY,CAAE,QAAU,EAKjF,CAEA,GAAQ,aAAa,CAAE,EAAI,YAAY,CAAE,MAAQ,CAAG,CAErD,GA+oCA,EAAc,GAAS,QAAS,4BA/lChC,SAA+B,CAAG,EAEjC,IAAM,EAAO,CACZ,cAAe,EAAE,AAClB,EAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,IAAO,CAElD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,AAET,CAAA,IAAnB,EAAM,QAAQ,EAIb,oBAFG,EAAM,QAAQ,EAGrB,EAAK,aAAa,CAAC,IAAI,CAAE,AAW7B,SAAuC,CAAG,EAEzC,IAAM,EAAO,CACZ,OAAQ,EAAI,YAAY,CAAE,UAAW,KAAK,CAAE,KAAM,GAAG,EACtD,EAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,IAAO,CAElD,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,EAIb,SAFG,EAAM,QAAQ,EAGrB,IAAM,EAAQ,EAAM,oBAAoB,CAAE,QAAS,CAAE,EAAG,AACxD,CAAA,EAAK,IAAI,CAAG,EAAM,WAAW,CAC7B,IAAM,EAAgB,EAAK,IAAI,CAAC,KAAK,CAAE,SAAU,GAAG,GAAG,KAAK,CAAE,OAAQ,CAAE,EAAG,AAC3E,CAAA,EAAK,UAAU,CAAG,EAAc,SAAS,CAAE,EAAG,EAAc,MAAM,CAAG,GAKxE,CAEA,OAAO,CAER,EAtC2D,GAK1D,CAEA,GAAQ,gBAAgB,CAAE,EAAS,EAAI,YAAY,CAAE,QAAW,CAAG,CAEpE,GAykCA,EAAc,GAAQ,UAAU,CAAE,GAClC,EAAc,GAAQ,KAAK,CAAE,GAC7B,EAAc,GAAQ,WAAW,CAAE,GACnC,EAAc,GAAQ,MAAM,CAAE,GAC9B,EAAc,GAAQ,OAAO,CAAE,GAC/B,EAAc,GAAQ,SAAS,CAAE,GACjC,EAAc,GAAQ,OAAO,CAAE,GAC/B,EAAc,GAAQ,MAAM,CAAE,GAC9B,EAAc,GAAQ,UAAU,CAAE,GAClC,EAAc,GAAQ,YAAY,CAAE,GAEpC,AA7KA,WAEC,IAAM,EAAQ,GAAQ,KAAK,CAE3B,GAAK,AAAqB,CAAA,IAArB,EAAS,GAEb,CAAA,GAAK,AAAkC,CAAA,IAAlC,EAAS,GAAQ,UAAU,EAAe,CAI9C,IAAM,EAAS,EAAE,CAEjB,IAAM,IAAM,KAAM,GAAQ,UAAU,CAAG,CAEtC,IAAM,EAAkB,EAAc,GAEtC,IAAM,IAAI,EAAI,EAAG,EAAI,EAAgB,MAAM,CAAE,EAAI,EAAG,IAEnD,EAAO,IAAI,CAAE,CAAe,CAAE,EAAG,CAInC,CAEA,GAAW,IAAI,CAAE,IAAI,EAAA,aAAY,CAAG,UAAW,GAAK,GAErD,CAAA,MAIA,IAAM,IAAM,KAAM,EAEjB,GAAW,IAAI,CA7mGV,EAAU,GAAQ,KAAK,CA6mGO,EA7mGD,CAAE,GAmnGvC,IAwIA,AAxiCA,WAEC,IAAM,EAAoB,OAAO,IAAI,CAAE,GAAQ,gBAAgB,CAAE,CAAE,EAAG,CAChE,EAAoB,OAAO,IAAI,CAAE,GAAQ,gBAAgB,CAAE,CAAE,EAAG,CAChE,EAAgB,OAAO,IAAI,CAAE,GAAQ,YAAY,CAAE,CAAE,EAAG,CAE9D,GAAK,AAAsB,KAAA,IAAtB,GAAmC,AAAsB,KAAA,IAAtB,EAAkC,OAE1E,IAAM,EA3WC,EAAU,GAAQ,gBAAgB,CA2WG,EA3WG,CAAE,GA4W3C,EAbC,EAAU,GAAQ,gBAAgB,CAaG,EAbG,CAAE,GAc3C,EAAc,EAAgB,GAE9B,EAAgB,EAAgB,aAAa,CAC7C,EAAW,CAAC,EAElB,IAAM,IAAI,EAAI,EAAG,EAAI,EAAc,MAAM,CAAE,EAAI,EAAG,IAAO,CAExD,IAAM,EAAO,CAAa,CAAE,EAAG,CAIzB,EAAgB,GAAQ,aAAa,CAAE,SAAW,EAAK,MAAM,CAAG,MAEtE,GAAK,EAAgB,CAIpB,IAAM,EAAsB,EAAc,aAAa,CAIvD,AAMF,CAAA,SAAkB,CAAU,CAAE,CAAa,EAE1C,IAAM,EAAoB,EAAc,YAAY,CAAE,QAChD,EAAQ,EAAgB,MAAM,CAAE,EAAY,CAElD,EAAY,QAAQ,CAAE,SAAW,CAAM,EAEjC,EAAO,IAAI,GAAK,GAEpB,CAAA,CAAQ,CAAE,EAAY,CAAG,CACxB,OAAQ,EACR,WAAY,AAgIjB,SAA6B,CAAI,EAEhC,IAAM,EAAa,EAAE,CAEf,EAAM,GAAQ,aAAa,CAAE,QAAU,EAAK,EAAE,CAAG,MAEvD,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,UAAU,CAAC,MAAM,CAAE,IAAO,KAM9C,EAAO,EAJX,IAAM,EAAQ,EAAI,UAAU,CAAE,EAAG,CAEjC,GAAK,AAAmB,IAAnB,EAAM,QAAQ,CAInB,OAAS,EAAM,QAAQ,EAEtB,IAAK,SACJ,EAAQ,EAAa,EAAM,WAAW,EACtC,IAAM,EAAS,GAAI,CAAA,EAAA,EAAA,OAAM,AAAN,IAAU,SAAS,CAAE,GAAQ,SAAS,GACzD,EAAW,IAAI,CAAE,CAChB,IAAK,EAAM,YAAY,CAAE,OACzB,KAAM,EAAM,QAAQ,CACpB,IAAK,CACN,GACA,KAED,KAAK,YACL,IAAK,QACJ,EAAQ,EAAa,EAAM,WAAW,EACtC,EAAS,GAAI,CAAA,EAAA,EAAA,OAAM,AAAN,IAAU,SAAS,CAAE,GAClC,EAAW,IAAI,CAAE,CAChB,IAAK,EAAM,YAAY,CAAE,OACzB,KAAM,EAAM,QAAQ,CACpB,IAAK,CACN,GACA,KAED,KAAK,SACJ,EAAQ,EAAa,EAAM,WAAW,EACtC,EAAS,GAAI,CAAA,EAAA,EAAA,OAAM,AAAN,IAAU,SAAS,CAAE,GAClC,IAAM,EAAQ,AAAA,CAAA,EAAA,EAAA,SAAQ,AAAR,EAAU,QAAQ,CAAE,CAAK,CAAE,EAAG,EAC5C,EAAW,IAAI,CAAE,CAChB,IAAK,EAAM,YAAY,CAAE,OACzB,KAAM,EAAM,QAAQ,CACpB,IAAK,EACL,MAAO,CACR,EAGF,CAED,CAEA,OAAO,CAER,EAvLqC,GAChC,MAAO,EACP,SAAU,EAAM,YAAY,AAC7B,CAAA,CAIF,EAED,CAAA,EA1BW,EAAK,UAAU,CAAE,EAE3B,CAED,CAwBA,IAAM,EAAK,IAAI,EAAA,OAAM,CAErB,GAAa,CAEZ,OAAQ,GAAmB,EAAgB,MAAM,CAEjD,cAAe,SAAW,CAAU,EAEnC,IAAM,EAAY,CAAQ,CAAE,EAAY,CAExC,GAAK,EAEJ,OAAO,EAAU,QAAQ,CAIzB,QAAQ,IAAI,CAAE,8BAAgC,EAAa,kBAI7D,EAEA,cAAe,SAAW,CAAU,CAAE,CAAK,EAE1C,IAAM,EAAY,CAAQ,CAAE,EAAY,CAExC,GAAK,EAAY,CAEhB,IAAM,EAAQ,EAAU,KAAK,CAE7B,GAAK,EAAQ,EAAM,MAAM,CAAC,GAAG,EAAI,EAAQ,EAAM,MAAM,CAAC,GAAG,CAExD,QAAQ,IAAI,CAAE,8BAAgC,EAAa,UAAY,EAAQ,4BAA8B,EAAM,MAAM,CAAC,GAAG,CAAG,UAAY,EAAM,MAAM,CAAC,GAAG,CAAG,WAEzJ,GAAK,EAAM,MAAM,CAEvB,QAAQ,IAAI,CAAE,8BAAgC,EAAa,mBAErD,CAEN,IAAM,EAAS,EAAU,MAAM,CACzB,EAAO,EAAM,IAAI,CACjB,EAAa,EAAU,UAAU,CAEvC,EAAO,QAAQ,GAIf,IAAM,IAAI,EAAI,EAAG,EAAI,EAAW,MAAM,CAAE,IAAO,CAE9C,IAAM,EAAY,CAAU,CAAE,EAAG,CAIjC,GAAK,EAAU,GAAG,EAAI,AAAwC,KAAxC,EAAU,GAAG,CAAC,OAAO,CAAE,GAE5C,OAAS,EAAM,IAAI,EAElB,IAAK,WACJ,EAAO,QAAQ,CAAE,EAAG,gBAAgB,CAAE,EAAM,AAAA,CAAA,EAAA,EAAA,SAAQ,AAAR,EAAU,QAAQ,CAAE,KAChE,KAED,KAAK,YACJ,EAAO,QAAQ,CAAE,EAAG,eAAe,CAAE,EAAK,CAAC,CAAG,EAAO,EAAK,CAAC,CAAG,EAAO,EAAK,CAAC,CAAG,IAC9E,KAED,SACC,QAAQ,IAAI,CAAE,4CAA8C,EAAM,IAAI,CAGxE,MAIA,OAAS,EAAU,IAAI,EAEtB,IAAK,SACJ,EAAO,QAAQ,CAAE,EAAU,GAAG,EAC9B,KAED,KAAK,YACJ,EAAO,QAAQ,CAAE,EAAG,eAAe,CAAE,EAAU,GAAG,CAAC,CAAC,CAAE,EAAU,GAAG,CAAC,CAAC,CAAE,EAAU,GAAG,CAAC,CAAC,GACtF,KAED,KAAK,QACJ,EAAO,KAAK,CAAE,EAAU,GAAG,EAC3B,KAED,KAAK,SACJ,EAAO,QAAQ,CAAE,EAAG,gBAAgB,CAAE,EAAU,GAAG,CAAE,EAAU,KAAK,EAGtE,CAIF,CAEA,EAAO,MAAM,CAAC,IAAI,CAAE,GACpB,EAAO,MAAM,CAAC,SAAS,CAAE,EAAO,QAAQ,CAAE,EAAO,UAAU,CAAE,EAAO,KAAK,EAEzE,CAAQ,CAAE,EAAY,CAAC,QAAQ,CAAG,CAEnC,CAED,MAEC,QAAQ,GAAG,CAAE,wBAA0B,EAAa,mBAItD,CAED,CAED,IA43BA,IAAM,IAvLe,EAuLK,EAAsB,GAAS,QAAS,CAAE,EAAG,CApL/D,EAAgB,EAAS,AADf,EAAsB,EAAK,wBAAyB,CAAE,EAAG,CACjC,YAAY,CAAE,UAgMxD,OAXA,GAAM,UAAU,CAAG,GAEG,SAAjB,GAAM,MAAM,GAEhB,QAAQ,IAAI,CAAE,4LACd,GAAM,QAAQ,CAAC,GAAG,CAAE,CAAE,KAAK,EAAE,CAAG,EAAG,EAAG,IAIvC,GAAM,KAAK,CAAC,cAAc,CAAE,GAAM,IAAI,EAE/B,CACN,IAAI,YAAa,CAGhB,OADA,QAAQ,IAAI,CAAE,4EACP,EAER,EACA,WAAY,GACZ,QAAS,GACT,MAAO,EACR,CAED,CAED,C,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,SDj/HA,MAAM,EAAU,CACf,kBAAmB,iHACnB,gBAAiB,+GACjB,SAAY,qHACZ,gBAAiB,+GACjB,eAAgB,8FAChB,iBAAkB,gGAClB,oBAAqB,gGACrB,YAAe,6FACf,gBAAiB,+FACjB,eAAgB,2FAChB,iBAAkB,6FAClB,SAAY,0FAEZ,gBAAiB,oGACjB,iBAAkB,6FAClB,kBAAmB,8FAEnB,qBAAsB,iGACtB,qBAAsB,iGACtB,4BAA6B,wGAC7B,wBAAyB,oGACzB,aAAc,yFACd,sBAAuB,kGACvB,yBAA0B,qGAC1B,uBAAwB,mGACxB,mBAAoB,+FACpB,uBAAwB,mGACxB,uBAAwB,mGACxB,eAAgB,2FAChB,wBAAyB,oGACzB,qBAAsB,iGACtB,gBAAiB,4FACjB,UAAa,wFACb,sBAAuB,kGACvB,4BAA6B,wGAC7B,wBAAyB,mGAE1B,EAEM,EAAS,OAAO,UAAU,EAAI,CAAC,EAE/B,EAAS,CAEd,2BAA4B,CAAA,EAC5B,gBAAiB,CAAA,EACjB,YAAa,EAAI,OAAO,gBAAgB,CACxC,MAAO,EAEP,MAAO,GAEP,OAAQ,CAAO,CAAE,wBAAyB,CAE1C,YAAa,UACb,eAAgB,UAEhB,qBAAsB,EACtB,oBAAqB,EAErB,iBAAkB,cAElB,eAAgB,WAChB,cAAe,UACf,iBAAkB,UAClB,eAAgB,EAChB,sBAAuB,CAAA,EACvB,yBAA0B,CAAA,EAE1B,OAAQ,CAAA,EACR,QAAS,EACT,mBAAoB,GACpB,MAAO,CAAA,EAEP,WAAY,UACZ,aAAc,EACd,eAAgB,GAChB,eAAgB,GAEhB,GAAG,AAAA,CAAA,EAAA,EAAA,iBAAgB,AAAhB,GAAmB,AAEvB,EAsHA,SAAS,IAER,EAAW,0BAA0B,CAAG,EAAO,0BAA0B,CACzE,EAAW,OAAO,CAAG,EAAO,OAAO,CACnC,EAAW,kBAAkB,CAAG,EAAO,kBAAkB,CACzD,EAAW,WAAW,CAAG,EAAO,WAAW,CAE3C,EAAW,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAE,EAAO,UAAU,EAChD,EAAW,QAAQ,CAAC,SAAS,CAAG,EAAO,cAAc,CACrD,EAAW,QAAQ,CAAC,SAAS,CAAG,EAAO,cAAc,CACrD,EAAW,QAAQ,CAAC,OAAO,CAAG,EAAO,YAAY,CAEjD,EAAM,oBAAoB,CAAG,EAAO,oBAAoB,CACxD,EAAM,mBAAmB,CAAC,CAAC,CAAG,EAAO,mBAAmB,CACxD,EAAM,oBAAoB,CAAG,EAAO,cAAc,CAE7C,AAA0B,aAA1B,EAAO,cAAc,EAEzB,EAAY,QAAQ,CAAC,GAAG,CAAE,EAAO,aAAa,EAC9C,EAAY,WAAW,CAAC,GAAG,CAAE,EAAO,gBAAgB,EACpD,EAAY,MAAM,GAElB,EAAM,UAAU,CAAG,EACnB,EAAM,mBAAmB,CAAG,EAC5B,EAAM,mBAAmB,CAAC,CAAC,CAAG,IAI9B,EAAM,UAAU,CAAG,EAAM,WAAW,CACpC,EAAM,mBAAmB,CAAG,EAAO,oBAAoB,CACvD,EAAM,kBAAkB,CAAC,CAAC,CAAG,EAAO,mBAAmB,EAInD,EAAO,qBAAqB,GAEhC,EAAM,UAAU,CAAG,KACnB,EAAS,aAAa,CAAE,IAIzB,EAAW,eAAe,GAC1B,EAAW,iBAAiB,EAE7B,CAEA,SAAS,IAER,IAAI,EAAY,GAChB,GAAK,OAAO,QAAQ,CAAC,IAAI,CAAG,CAE3B,IAAM,EAAY,UAAW,OAAO,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAE,IACxD,KAAa,GAEjB,CAAA,EAAY,CAFb,CAMD,CAES,KAAa,GAErB,CAAA,EAAY,OAAO,IAAI,CAAE,EAAQ,CAAE,EAAG,AAAH,EAIpC,EAAO,KAAK,CAAG,EACf,GAED,CAEA,SAAS,IAER,IAAM,EAAI,OAAO,UAAU,CACrB,EAAI,OAAO,WAAW,CACtB,EAAM,OAAO,gBAAgB,CAEnC,EAAS,OAAO,CAAE,EAAG,GACrB,EAAS,aAAa,CAAE,GAExB,IAAM,EAAS,EAAI,CACnB,CAAA,EAAkB,MAAM,CAAG,EAC3B,EAAkB,sBAAsB,GAExC,IAAM,EAAc,AAlMF,EAkMe,CACjC,CAAA,EAAY,GAAG,CAAG,EAAc,EAChC,EAAY,MAAM,CAAG,CAAA,CAAA,EAAc,CAAnC,EACA,EAAY,sBAAsB,GAElC,EAAW,YAAY,EAExB,CA0EA,SAAS,IAER,GAAI,CAAA,EAAA,EAAA,UAAS,AAAT,IACF,IAAI,CAAE,EAAO,MAAM,CAAE,AAAA,IAEhB,EAAM,WAAW,EAErB,EAAM,WAAW,CAAC,OAAO,GAI1B,EAAQ,OAAO,CAAG,EAAA,gCAA+B,CACjD,EAAM,WAAW,CAAG,EACpB,EAAW,iBAAiB,GAC5B,GAED,EAEF,CAEA,SAAS,EAAwB,CAAgB,EAG3C,IAEJ,EAAkB,QAAQ,CAAC,IAAI,CAAE,EAAa,QAAQ,EACtD,EAAY,QAAQ,CAAC,IAAI,CAAE,EAAa,QAAQ,GAOhD,EAFI,AAAqB,gBAArB,EAEW,EAIA,EAIhB,EAAS,MAAM,CAAG,EAClB,EAAS,MAAM,GAEf,EAAW,SAAS,CAAE,EAEvB,CA2DA,eAAe,IAET,IAEJ,SAAS,IAAI,CAAC,SAAS,CAAC,MAAM,CAAE,gBAChC,EAAI,OAAO,GACX,EAAM,MAIP,IAAM,EAAY,CAAM,CAAE,EAAO,KAAK,CAAE,AAExC,CAAA,EAAS,UAAU,CAAC,KAAK,CAAC,UAAU,CAAG,SACvC,EAAO,aAAa,CAAE,GAEjB,IAEJ,EAAM,QAAQ,CAAE,AAAA,IAEf,GAAK,EAAE,QAAQ,CAAG,CAEjB,IAAM,EAAW,EAAE,QAAQ,CAC3B,IAAM,IAAM,KAAO,EAEb,CAAQ,CAAE,EAAK,EAAI,CAAQ,CAAE,EAAK,CAAC,SAAS,EAEhD,CAAQ,CAAE,EAAK,CAAC,OAAO,EAM1B,CAED,GAEA,EAAM,MAAM,CAAE,GACd,EAAQ,MAIT,GAAI,CAEH,EAAQ,MAAM,EAAW,EAAU,GAAG,CAAE,AAAA,IAEvC,EAAO,aAAa,CAAE,GAAM,EAE7B,EAED,CAAE,MAAQ,EAAM,CAEf,EAAO,UAAU,CAAE,wBAA0B,EAAI,OAAO,EACxD,EAAO,aAAa,CAAE,EAEvB,CAIK,EAAU,cAAc,EAE5B,EAAM,QAAQ,CAAE,AAAA,IAEV,EAAE,QAAQ,GAEd,EAAE,QAAQ,CAAC,WAAW,CAAG,KACzB,EAAE,QAAQ,CAAC,iBAAiB,CAAG,EAIjC,GAII,EAAU,qBAAqB,EAEnC,AApIF,SAAuC,CAAK,CAAE,CAAG,EAEhD,EAAM,QAAQ,CAAE,AAAA,IAEf,GAAK,EAAE,QAAQ,CAAG,CAEjB,IAAM,EAAW,EAAE,QAAQ,CAC3B,GAAK,EAAS,OAAO,CAAG,KAAQ,EAAS,OAAO,CAAG,GAAM,CAExD,IAAM,EAAc,IAAI,EAAA,oBAAmB,CAC3C,IAAM,IAAM,KAAO,EAElB,GAAK,KAAO,EAAW,CAEtB,GAAK,AAAoB,OAApB,CAAQ,CAAE,EAAK,CAEnB,QAII,CAAA,CAAQ,CAAE,EAAK,CAAC,SAAS,CAE7B,CAAW,CAAE,EAAK,CAAG,CAAQ,CAAE,EAAK,CAEzB,CAAQ,CAAE,EAAK,CAAC,IAAI,EAAI,CAAQ,CAAE,EAAK,CAAC,WAAW,GAAK,CAAW,CAAE,EAAK,CAAC,WAAW,CAEjG,CAAW,CAAE,EAAK,CAAC,IAAI,CAAE,CAAQ,CAAE,EAAK,EAEE,UAA7B,OAAO,CAAQ,CAAE,EAAK,EAEnC,CAAA,CAAW,CAAE,EAAK,CAAG,CAAQ,CAAE,EAAK,AAAL,CAIjC,CAID,EAAY,OAAO,CAAG,EACtB,EAAY,YAAY,CAAG,EAC3B,EAAY,GAAG,CAAG,EAElB,IAAM,EAAM,CAAC,EACb,EAAY,KAAK,CAAC,MAAM,CAAE,GAC1B,EAAI,CAAC,CAAG,KAAK,GAAG,CAAE,EAAI,CAAC,CAAE,KACzB,EAAY,KAAK,CAAC,MAAM,CAAE,EAAI,CAAC,CAAE,EAAI,CAAC,CAAE,EAAI,CAAC,EAE7C,EAAE,QAAQ,CAAG,CAEd,CAED,CAED,EAED,EA6EgC,EAAO,EAAU,GAAG,EAAI,KAIvD,EAAM,QAAQ,CAAE,AAAA,IAEV,EAAE,QAAQ,EAGd,CAAA,EAAE,QAAQ,CAAC,SAAS,CAAG,CAAvB,CAIF,GAEK,EAAU,WAAW,EAEzB,EAAU,WAAW,CAAE,GAKnB,EAAU,QAAQ,EAEtB,EAAM,QAAQ,CAAC,GAAG,IAAK,EAAU,QAAQ,EAK1C,IAAM,EAAM,IAAI,EAAA,IAAG,CACnB,EAAI,aAAa,CAAE,GACnB,EAAM,QAAQ,CACZ,eAAe,CAAE,EAAI,GAAG,CAAE,KAC1B,eAAe,CAAE,EAAI,GAAG,CAAE,KAE5B,IAAM,EAAS,IAAI,EAAA,MAAK,CACxB,EAAI,iBAAiB,CAAE,GAEvB,EAAM,KAAK,CAAC,SAAS,CAAE,EAAI,EAAO,MAAM,EACxC,EAAM,QAAQ,CAAC,cAAc,CAAE,EAAI,EAAO,MAAM,EAChD,EAAI,aAAa,CAAE,GACnB,EAAW,QAAQ,CAAC,CAAC,CAAG,EAAI,GAAG,CAAC,CAAC,CAEjC,EAAM,GAAG,CAAE,GAEX,MAAM,EAAW,aAAa,CAAE,EAAO,EAAc,CAEpD,WAAY,AAAA,GAAK,EAAO,aAAa,CAAE,GAAM,GAAM,EAEpD,GAEA,EAAO,aAAa,CAAE,GACtB,EAAO,UAAU,CAAE,EAAU,MAAM,EAAI,IACvC,EAAO,OAAO,CAAG,EAAU,OAAO,EAAI,EACtC,EAAO,UAAU,CAAG,EAAU,UAAU,EAAI,UAC5C,EAAO,cAAc,CAAG,EAAU,cAAc,EAAI,GACpD,EAAO,cAAc,CAAG,EAAU,cAAc,EAAI,GACpD,EAAO,aAAa,CAAG,EAAU,WAAW,EAAI,UAChD,EAAO,gBAAgB,CAAG,EAAU,WAAW,EAAI,UAEnD,AAxTD,WAEM,GAEJ,EAAI,OAAO,GAMZ,AAFA,CAAA,EAAM,IAAI,EAAA,GAAE,AAAZ,EAEI,GAAG,CAAE,EAAQ,QAAS,OAAO,IAAI,CAAE,GAAS,IAAI,IAAK,QAAQ,CAAE,AAAA,IAElE,OAAO,QAAQ,CAAC,IAAI,CAAG,CAExB,GAEA,IAAM,EAAoB,EAAI,SAAS,CAAE,eACzC,EAAkB,GAAG,CAAE,EAAQ,UAC/B,EAAkB,GAAG,CAAE,EAAQ,SAC/B,EAAkB,GAAG,CAAE,EAAQ,8BAA+B,QAAQ,CAAE,GACxE,EAAkB,GAAG,CAAE,EAAQ,mBAAoB,QAAQ,CAAE,AAAA,IAE5D,EAAS,WAAW,CAAG,EAAI,EAAA,qBAAoB,CAAI,EAAA,aAAY,AAEhE,GACA,EAAkB,GAAG,CAAE,EAAQ,UAAW,EAAG,GAAI,GAAI,QAAQ,CAAE,GAC/D,EAAkB,GAAG,CAAE,EAAQ,qBAAsB,EAAG,GAAI,QAAQ,CAAE,GACtE,EAAkB,GAAG,CAAE,EAAQ,cAAe,GAAK,EAAK,KAAO,QAAQ,CAAE,KAExE,GAED,GACA,EAAkB,GAAG,CAAE,EAAQ,QAAS,EAAG,GAAI,GAAI,QAAQ,CAAE,AAAA,IAE5D,EAAW,KAAK,CAAC,GAAG,CAAE,EAAG,EAE1B,GACA,EAAkB,GAAG,CAAE,EAAQ,mBAAoB,CAAE,cAAe,eAAgB,EAAG,QAAQ,CAAE,AAAA,IAEhG,EAAwB,EAEzB,GACA,EAAkB,IAAI,GAEtB,IAAM,EAAoB,EAAI,SAAS,CAAE,eACzC,EAAkB,GAAG,CAAE,EAAQ,SAAU,GAAU,IAAI,CAAE,OAAQ,QAAQ,CAAE,GAC3E,EAAkB,GAAG,CAAE,EAAQ,uBAAwB,EAAK,IAAO,QAAQ,CAAE,GAAiB,IAAI,CAAE,aACpG,EAAkB,GAAG,CAAE,EAAQ,sBAAuB,EAAG,EAAI,KAAK,EAAE,EAAG,QAAQ,CAAE,GACjF,EAAkB,IAAI,GAEtB,IAAM,EAAmB,EAAI,SAAS,CAAE,cACxC,EAAiB,GAAG,CAAE,EAAQ,iBAAkB,CAAE,cAAe,WAAY,EAAG,QAAQ,CAAE,GAC1F,EAAiB,QAAQ,CAAE,EAAQ,iBAAkB,QAAQ,CAAE,GAC/D,EAAiB,QAAQ,CAAE,EAAQ,oBAAqB,QAAQ,CAAE,GAClE,EAAiB,GAAG,CAAE,EAAQ,iBAAkB,EAAG,GAAI,QAAQ,CAAE,GACjE,EAAiB,GAAG,CAAE,EAAQ,wBAAyB,EAAG,GAAI,QAAQ,CAAE,GACxE,EAAiB,GAAG,CAAE,EAAQ,4BAA6B,QAAQ,CAAE,AAAA,IAE/D,EAAI,SAAS,IAAI,CAAC,SAAS,CAAC,GAAG,CAAE,gBACjC,SAAS,IAAI,CAAC,SAAS,CAAC,MAAM,CAAE,eAEtC,GAEA,IAAM,EAAc,EAAI,SAAS,CAAE,SACnC,EAAY,QAAQ,CAAE,EAAQ,cAAe,QAAQ,CAAE,GACvD,EAAY,GAAG,CAAE,EAAQ,iBAAkB,EAAG,GAAI,QAAQ,CAAE,GAC5D,EAAY,GAAG,CAAE,EAAQ,iBAAkB,EAAG,GAAI,QAAQ,CAAE,GAC5D,EAAY,GAAG,CAAE,EAAQ,eAAgB,EAAG,GAAI,QAAQ,CAAE,GAC1D,EAAY,KAAK,EAElB,IAmPC,IAEA,EAAS,UAAU,CAAC,KAAK,CAAC,UAAU,CAAG,UAClC,EAAO,wBAAwB,EAEnC,SAAS,IAAI,CAAC,SAAS,CAAC,GAAG,CAAE,eAI/B,CAEA,eAAe,EAAW,CAAG,CAAE,CAAU,EAGxC,IAAM,EAAU,IAAI,EAAA,cAAa,CACjC,GAAK,QAAQ,IAAI,CAAE,GAAQ,CAE1B,IAAM,EAAW,IAAI,QAAS,AAAA,GAAW,EAAQ,MAAM,CAAG,GACpD,EAAM,MAAM,IAAI,EAAe,GAAU,SAAS,CAAE,EAAK,AAAA,IAEtC,IAAnB,EAAS,KAAK,EAAU,EAAS,KAAK,EAAI,EAAS,MAAM,EAE7D,EAAY,EAAS,MAAM,CAAG,EAAS,KAAK,CAI9C,GAsBA,OArBA,MAAM,EAEN,EAAI,KAAK,CAAC,KAAK,CAAC,SAAS,CAAE,GAC3B,EAAI,KAAK,CAAC,QAAQ,CAAE,AAAA,IAEnB,GAAM,CAAA,SAAE,CAAQ,CAAE,CAAG,EAChB,GAAY,EAAS,mBAAmB,EAE5C,CAAA,EAAE,QAAQ,CAAG,IAAI,EAAA,oBAAmB,CAAG,CAEtC,MAAO,EAAS,KAAK,CACrB,UAAW,EAAS,SAAS,EAAI,EACjC,UAAW,EAAS,SAAS,EAAI,EACjC,IAAK,EAAS,GAAG,EAAI,IAEtB,EAAA,CAIF,GAEO,EAAI,KAAK,AAEjB,CAAO,GAAK,eAAe,IAAI,CAAE,GAAQ,CAExC,IAAM,EAAW,IAAI,QAAS,AAAA,GAAW,EAAQ,MAAM,CAAG,GACpD,EAAO,MAAM,GAAI,CAAA,EAAA,EAAA,UAAS,AAAT,EAAY,GAAU,iBAAiB,CAAE,EAAA,cAAa,EAAI,SAAS,CAAE,EAAK,AAAA,IAExE,IAAnB,EAAS,KAAK,EAAU,EAAS,KAAK,EAAI,EAAS,MAAM,EAE7D,EAAY,EAAS,MAAM,CAAG,EAAS,KAAK,CAI9C,GAGA,OAFA,MAAM,EAEC,EAAK,KAAK,AAElB,CAAO,GAAK,QAAQ,IAAI,CAAE,GAAQ,CAEjC,EAAQ,UAAU,CAAG,CAAE,EAAK,EAAQ,KAEnC,EAAY,EAAS,EAEtB,EAEA,IAAM,EAAW,IAAI,QAAS,AAAA,GAAW,EAAQ,MAAM,CAAG,GACpD,EAAc,IAAI,EAAA,WAAU,CAAG,EACrC,OAAM,EAAY,gBAAgB,CAAE,8FACpC,IAAM,EAAS,MAAM,EACnB,mBAAmB,CAAE,0FACrB,SAAS,CAAE,EACb,OAAM,EAEN,IAAM,EAAQ,AAAA,CAAA,EAAA,EAAA,UAAS,AAAT,EAAW,WAAW,CAAE,GACtC,EAAM,QAAQ,CAAC,GAAG,CAAE,KAAK,EAAE,CAAE,EAAG,GAEhC,IAAM,EAAW,EAAE,CAuBnB,OAtBA,EAAM,QAAQ,CAAE,AAAA,IAEV,EAAE,cAAc,EAEpB,EAAS,IAAI,CAAE,GAIX,EAAE,MAAM,EAEZ,CAAA,EAAE,QAAQ,CAAC,SAAS,EAAI,GAFzB,CAMD,GAEA,EAAS,OAAO,CAAE,AAAA,IAEjB,EAAE,MAAM,CAAC,MAAM,CAAE,EAElB,GAEO,CAER,CAED,EAlnBA,AAEA,iBAGC,AADA,CAAA,EAAS,IAAI,EAAA,aAAY,AAAzB,EACO,MAAM,CAAE,SAAS,IAAI,EAI5B,AADA,CAAA,EAAW,IAAI,EAAA,aAAY,CAAG,CAAE,UAAW,CAAA,CAAK,EAAA,EACvC,WAAW,CAAG,EAAA,qBAAoB,CAC3C,SAAS,IAAI,CAAC,WAAW,CAAE,EAAS,UAAU,EAI9C,AADA,CAAA,EAAa,IAAI,EAAA,eAAc,CAAG,EAAlC,EACW,YAAY,CAAE,IAAI,EAAA,qBAAoB,EACjD,EAAW,uBAAuB,CAAG,CAAA,EACrC,EAAW,KAAK,CAAC,GAAG,CAAE,EAAO,KAAK,CAAE,EAAO,KAAK,EAChD,EAAW,0BAA0B,CAAG,EAAO,0BAA0B,CACzE,EAAW,mBAAmB,CAAG,GAGjC,IAAM,EAAS,OAAO,UAAU,CAAG,OAAO,WAAW,CAErD,AADA,CAAA,EAAoB,IAAI,EAAA,iBAAgB,CAAG,GAAI,EAAQ,KAAO,IAA9D,EACkB,QAAQ,CAAC,GAAG,CAAE,GAAK,IAAM,GAE3C,IAAM,EAAc,AA3BF,EA2Be,EAEjC,AADA,CAAA,EAAc,IAAI,EAAA,kBAAiB,CAAG,GAAkB,EAAgB,EAAc,EAAG,CAAA,CAAA,EAAc,CAAA,EAAK,EAAG,IAA/G,EACY,QAAQ,CAAC,GAAG,CAAE,GAAK,IAAM,GAIrC,AADA,CAAA,EAAc,IAAI,EAAA,uBAAsB,AAAxC,EACY,QAAQ,CAAC,GAAG,CAAE,EAAO,aAAa,EAC9C,EAAY,WAAW,CAAC,GAAG,CAAE,EAAO,gBAAgB,EACpD,EAAY,MAAM,GAIlB,AADA,CAAA,EAAW,IAAI,EAAA,aAAY,CAAG,EAAmB,EAAS,UAAU,CAAA,EAC3D,gBAAgB,CAAE,SAAU,KAEpC,EAAW,YAAY,EAExB,GAIA,AADA,CAAA,EAAQ,IAAI,EAAA,KAAI,AAAhB,EACM,UAAU,CAAG,EAEnB,IAAM,EAAW,AAAA,CAAA,EAAA,EAAA,0BAAyB,AAAzB,EAA4B,MAY7C,AAXA,CAAA,EAAa,IAAI,EAAA,IAAG,CACnB,IAAI,EAAA,aAAY,CAChB,IAAI,EAAA,oBAAmB,CAAG,CACzB,IAAK,EACL,YAAa,CAAA,EACb,MAAO,QACP,UAAW,GACX,UAAW,EACX,KAAM,EAAA,UAAS,AAChB,GAAA,EAEU,KAAK,CAAC,SAAS,CAAE,GAC5B,EAAW,QAAQ,CAAC,CAAC,CAAG,CAAE,KAAK,EAAE,CAAG,EACpC,EAAM,GAAG,CAAE,GAEX,EAAQ,IAAI,EAAA,OAAI,CAChB,SAAS,IAAI,CAAC,WAAW,CAAE,EAAM,GAAG,EAEpC,EAAwB,EAAO,gBAAgB,EAC/C,IACA,IACA,IAEA,AAOD,SAAS,IAER,sBAAuB,GAEvB,EAAM,MAAM,GAEL,IAMF,EAAO,MAAM,CAEZ,CAAA,CAAE,EAAO,KAAK,EAAI,EAAW,OAAO,CAAG,CAAA,GAE3C,EAAW,YAAY,GAMxB,EAAS,MAAM,CAAE,EAAO,GAIzB,EAAO,UAAU,CAAE,EAAW,OAAO,CAAE,EAAW,WAAW,EAE9D,IAjCC,OAAO,gBAAgB,CAAE,SAAU,GACnC,OAAO,gBAAgB,CAAE,aAAc,EAExC","sources":["<anon>","node_modules/three/examples/jsm/loaders/RGBELoader.js","node_modules/three/examples/jsm/libs/stats.module.js","example/utils/generateRadialFloorTexture.js","example/utils/getScaledSettings.js","example/utils/LoaderElement.js","node_modules/three-mesh-bvh/src/workers/ParallelMeshBVHWorker.js","node_modules/three-mesh-bvh/src/workers/utils/WorkerBase.js","node_modules/three-mesh-bvh/src/workers/GenerateMeshBVHWorker.js","node_modules/@parcel/runtime-js/lib/runtime-1c6990855bd7ff8d.js","node_modules/@parcel/runtime-js/lib/helpers/get-worker-url.js","node_modules/@parcel/runtime-js/lib/runtime-c3f6ca7a2f7d9043.js","src/materials/MaterialBase.js","src/shader/common/math_functions.glsl.js","src/shader/common/util_functions.glsl.js","src/shader/bsdf/ggx_functions.glsl.js","example/index.js","node_modules/three/examples/jsm/loaders/ColladaLoader.js","node_modules/three/examples/jsm/loaders/TGALoader.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5b70\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5b70\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"891vQ\", function(module, exports) {\n\n$parcel$export(module.exports, \"RGBELoader\", () => $5ee05658f4b0e3bf$export$d076a711b55c758a);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\nclass $5ee05658f4b0e3bf$export$d076a711b55c758a extends (0, $ilwiq.DataTextureLoader) {\n    constructor(manager){\n        super(manager);\n        this.type = (0, $ilwiq.HalfFloatType);\n    }\n    // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n    parse(buffer) {\n        const /* default error routine.  change this to change error handling */ rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {\n            switch(rgbe_error_code){\n                case rgbe_read_error:\n                    throw new Error(\"THREE.RGBELoader: Read Error: \" + (msg || \"\"));\n                case rgbe_write_error:\n                    throw new Error(\"THREE.RGBELoader: Write Error: \" + (msg || \"\"));\n                case rgbe_format_error:\n                    throw new Error(\"THREE.RGBELoader: Bad File Format: \" + (msg || \"\"));\n                default:\n                case rgbe_memory_error:\n                    throw new Error(\"THREE.RGBELoader: Memory Error: \" + (msg || \"\"));\n            }\n        }, /* offsets to red, green, and blue components in a data (float) pixel */ //RGBE_DATA_RED = 0,\n        //RGBE_DATA_GREEN = 1,\n        //RGBE_DATA_BLUE = 2,\n        /* number of floats per pixel, use 4 since stored in rgba image format */ //RGBE_DATA_SIZE = 4,\n        /* flags indicating which fields in an rgbe_header_info are valid */ RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = \"\\n\", fgets = function(buffer, lineLimit, consume) {\n            const chunkSize = 128;\n            lineLimit = !lineLimit ? 1024 : lineLimit;\n            let p = buffer.pos, i = -1, len = 0, s = \"\", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n            while(0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength){\n                s += chunk;\n                len += chunk.length;\n                p += chunkSize;\n                chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n            }\n            if (-1 < i) {\n                /*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/ if (false !== consume) buffer.pos += len + i + 1;\n                return s + chunk.slice(0, i);\n            }\n            return false;\n        }, /* minimal header reading.  modify if you want to parse more information */ RGBE_ReadHeader = function(buffer) {\n            // regexes to parse header info fields\n            const magic_token_re = /^#\\?(\\S+)/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, // RGBE format header struct\n            header = {\n                valid: 0,\n                /* indicate which fields are valid */ string: \"\",\n                /* the actual header string */ comments: \"\",\n                /* comments found in header */ programtype: \"RGBE\",\n                /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */ format: \"\",\n                /* RGBE format, default 32-bit_rle_rgbe */ gamma: 1.0,\n                /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */ exposure: 1.0,\n                /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */ width: 0,\n                height: 0 /* image dimensions, width/height */ \n            };\n            let line, match;\n            if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) rgbe_error(rgbe_read_error, \"no header found\");\n            /* if you want to require the magic token then uncomment the next line */ if (!(match = line.match(magic_token_re))) rgbe_error(rgbe_format_error, \"bad initial token\");\n            header.valid |= RGBE_VALID_PROGRAMTYPE;\n            header.programtype = match[1];\n            header.string += line + \"\\n\";\n            while(true){\n                line = fgets(buffer);\n                if (false === line) break;\n                header.string += line + \"\\n\";\n                if (\"#\" === line.charAt(0)) {\n                    header.comments += line + \"\\n\";\n                    continue; // comment line\n                }\n                if (match = line.match(gamma_re)) header.gamma = parseFloat(match[1]);\n                if (match = line.match(exposure_re)) header.exposure = parseFloat(match[1]);\n                if (match = line.match(format_re)) {\n                    header.valid |= RGBE_VALID_FORMAT;\n                    header.format = match[1]; //'32-bit_rle_rgbe';\n                }\n                if (match = line.match(dimensions_re)) {\n                    header.valid |= RGBE_VALID_DIMENSIONS;\n                    header.height = parseInt(match[1], 10);\n                    header.width = parseInt(match[2], 10);\n                }\n                if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n            }\n            if (!(header.valid & RGBE_VALID_FORMAT)) rgbe_error(rgbe_format_error, \"missing format specifier\");\n            if (!(header.valid & RGBE_VALID_DIMENSIONS)) rgbe_error(rgbe_format_error, \"missing image size specifier\");\n            return header;\n        }, RGBE_ReadPixels_RLE = function(buffer, w, h) {\n            const scanline_width = w;\n            if (scanline_width < 8 || scanline_width > 0x7fff || // this file is not run length encoded\n            2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) // return the flat buffer\n            return new Uint8Array(buffer);\n            if (scanline_width !== (buffer[2] << 8 | buffer[3])) rgbe_error(rgbe_format_error, \"wrong scanline width\");\n            const data_rgba = new Uint8Array(4 * w * h);\n            if (!data_rgba.length) rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n            let offset = 0, pos = 0;\n            const ptr_end = 4 * scanline_width;\n            const rgbeStart = new Uint8Array(4);\n            const scanline_buffer = new Uint8Array(ptr_end);\n            let num_scanlines = h;\n            // read in each successive scanline\n            while(num_scanlines > 0 && pos < buffer.byteLength){\n                if (pos + 4 > buffer.byteLength) rgbe_error(rgbe_read_error);\n                rgbeStart[0] = buffer[pos++];\n                rgbeStart[1] = buffer[pos++];\n                rgbeStart[2] = buffer[pos++];\n                rgbeStart[3] = buffer[pos++];\n                if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n                // read each of the four channels for the scanline into the buffer\n                // first red, then green, then blue, then exponent\n                let ptr = 0, count;\n                while(ptr < ptr_end && pos < buffer.byteLength){\n                    count = buffer[pos++];\n                    const isEncodedRun = count > 128;\n                    if (isEncodedRun) count -= 128;\n                    if (0 === count || ptr + count > ptr_end) rgbe_error(rgbe_format_error, \"bad scanline data\");\n                    if (isEncodedRun) {\n                        // a (encoded) run of the same value\n                        const byteValue = buffer[pos++];\n                        for(let i = 0; i < count; i++)scanline_buffer[ptr++] = byteValue;\n                    //ptr += count;\n                    } else {\n                        // a literal-run\n                        scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n                        ptr += count;\n                        pos += count;\n                    }\n                }\n                // now convert data from buffer into rgba\n                // first red, then green, then blue, then exponent (alpha)\n                const l = scanline_width; //scanline_buffer.byteLength;\n                for(let i = 0; i < l; i++){\n                    let off = 0;\n                    data_rgba[offset] = scanline_buffer[i + off];\n                    off += scanline_width; //1;\n                    data_rgba[offset + 1] = scanline_buffer[i + off];\n                    off += scanline_width; //1;\n                    data_rgba[offset + 2] = scanline_buffer[i + off];\n                    off += scanline_width; //1;\n                    data_rgba[offset + 3] = scanline_buffer[i + off];\n                    offset += 4;\n                }\n                num_scanlines--;\n            }\n            return data_rgba;\n        };\n        const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2.0, e - 128.0) / 255.0;\n            destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n            destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n            destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n            destArray[destOffset + 3] = 1;\n        };\n        const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2.0, e - 128.0) / 255.0;\n            // clamping to 65504, the maximum representable value in float16\n            destArray[destOffset + 0] = (0, $ilwiq.DataUtils).toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n            destArray[destOffset + 1] = (0, $ilwiq.DataUtils).toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n            destArray[destOffset + 2] = (0, $ilwiq.DataUtils).toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n            destArray[destOffset + 3] = (0, $ilwiq.DataUtils).toHalfFloat(1);\n        };\n        const byteArray = new Uint8Array(buffer);\n        byteArray.pos = 0;\n        const rgbe_header_info = RGBE_ReadHeader(byteArray);\n        const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n        let data, type;\n        let numElements;\n        switch(this.type){\n            case 0, $ilwiq.FloatType:\n                numElements = image_rgba_data.length / 4;\n                const floatArray = new Float32Array(numElements * 4);\n                for(let j = 0; j < numElements; j++)RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\n                data = floatArray;\n                type = (0, $ilwiq.FloatType);\n                break;\n            case 0, $ilwiq.HalfFloatType:\n                numElements = image_rgba_data.length / 4;\n                const halfArray = new Uint16Array(numElements * 4);\n                for(let j = 0; j < numElements; j++)RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);\n                data = halfArray;\n                type = (0, $ilwiq.HalfFloatType);\n                break;\n            default:\n                throw new Error(\"THREE.RGBELoader: Unsupported type: \" + this.type);\n        }\n        return {\n            width: w,\n            height: h,\n            data: data,\n            header: rgbe_header_info.string,\n            gamma: rgbe_header_info.gamma,\n            exposure: rgbe_header_info.exposure,\n            type: type\n        };\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            switch(texture.type){\n                case 0, $ilwiq.FloatType:\n                case 0, $ilwiq.HalfFloatType:\n                    texture.colorSpace = (0, $ilwiq.LinearSRGBColorSpace);\n                    texture.minFilter = (0, $ilwiq.LinearFilter);\n                    texture.magFilter = (0, $ilwiq.LinearFilter);\n                    texture.generateMipmaps = false;\n                    texture.flipY = true;\n                    break;\n            }\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n}\n\n});\n\nparcelRegister(\"7MGRS\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $5aae44c9b1864d53$export$2e2bcd8739ae039);\nvar $5aae44c9b1864d53$var$Stats = function() {\n    var mode = 0;\n    var container = document.createElement(\"div\");\n    container.style.cssText = \"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";\n    container.addEventListener(\"click\", function(event) {\n        event.preventDefault();\n        showPanel(++mode % container.children.length);\n    }, false);\n    //\n    function addPanel(panel) {\n        container.appendChild(panel.dom);\n        return panel;\n    }\n    function showPanel(id) {\n        for(var i = 0; i < container.children.length; i++)container.children[i].style.display = i === id ? \"block\" : \"none\";\n        mode = id;\n    }\n    //\n    var beginTime = (performance || Date).now(), prevTime = beginTime, frames = 0;\n    var fpsPanel = addPanel(new $5aae44c9b1864d53$var$Stats.Panel(\"FPS\", \"#0ff\", \"#002\"));\n    var msPanel = addPanel(new $5aae44c9b1864d53$var$Stats.Panel(\"MS\", \"#0f0\", \"#020\"));\n    if (self.performance && self.performance.memory) var memPanel = addPanel(new $5aae44c9b1864d53$var$Stats.Panel(\"MB\", \"#f08\", \"#201\"));\n    showPanel(0);\n    return {\n        REVISION: 16,\n        dom: container,\n        addPanel: addPanel,\n        showPanel: showPanel,\n        begin: function() {\n            beginTime = (performance || Date).now();\n        },\n        end: function() {\n            frames++;\n            var time = (performance || Date).now();\n            msPanel.update(time - beginTime, 200);\n            if (time >= prevTime + 1000) {\n                fpsPanel.update(frames * 1000 / (time - prevTime), 100);\n                prevTime = time;\n                frames = 0;\n                if (memPanel) {\n                    var memory = performance.memory;\n                    memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);\n                }\n            }\n            return time;\n        },\n        update: function() {\n            beginTime = this.end();\n        },\n        // Backwards Compatibility\n        domElement: container,\n        setMode: showPanel\n    };\n};\n$5aae44c9b1864d53$var$Stats.Panel = function(name, fg, bg) {\n    var min = Infinity, max = 0, round = Math.round;\n    var PR = round(window.devicePixelRatio || 1);\n    var WIDTH = 80 * PR, HEIGHT = 48 * PR, TEXT_X = 3 * PR, TEXT_Y = 2 * PR, GRAPH_X = 3 * PR, GRAPH_Y = 15 * PR, GRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;\n    var canvas = document.createElement(\"canvas\");\n    canvas.width = WIDTH;\n    canvas.height = HEIGHT;\n    canvas.style.cssText = \"width:80px;height:48px\";\n    var context = canvas.getContext(\"2d\");\n    context.font = \"bold \" + 9 * PR + \"px Helvetica,Arial,sans-serif\";\n    context.textBaseline = \"top\";\n    context.fillStyle = bg;\n    context.fillRect(0, 0, WIDTH, HEIGHT);\n    context.fillStyle = fg;\n    context.fillText(name, TEXT_X, TEXT_Y);\n    context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);\n    context.fillStyle = bg;\n    context.globalAlpha = 0.9;\n    context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);\n    return {\n        dom: canvas,\n        update: function(value, maxValue) {\n            min = Math.min(min, value);\n            max = Math.max(max, value);\n            context.fillStyle = bg;\n            context.globalAlpha = 1;\n            context.fillRect(0, 0, WIDTH, GRAPH_Y);\n            context.fillStyle = fg;\n            context.fillText(round(value) + \" \" + name + \" (\" + round(min) + \"-\" + round(max) + \")\", TEXT_X, TEXT_Y);\n            context.drawImage(canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT);\n            context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT);\n            context.fillStyle = bg;\n            context.globalAlpha = 0.9;\n            context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round((1 - value / maxValue) * GRAPH_HEIGHT));\n        }\n    };\n};\nvar $5aae44c9b1864d53$export$2e2bcd8739ae039 = $5aae44c9b1864d53$var$Stats;\n\n});\n\nparcelRegister(\"1EdOY\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateRadialFloorTexture\", () => $13343f7d1c4dd8ec$export$92750171fb06fc99);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nfunction $13343f7d1c4dd8ec$export$92750171fb06fc99(dim) {\n    const data = new Uint8Array(dim * dim * 4);\n    for(let x = 0; x < dim; x++)for(let y = 0; y < dim; y++){\n        const xNorm = x / (dim - 1);\n        const yNorm = y / (dim - 1);\n        const xCent = 2.0 * (xNorm - 0.5);\n        const yCent = 2.0 * (yNorm - 0.5);\n        let a = Math.max(Math.min(1.0 - Math.sqrt(xCent ** 2 + yCent ** 2), 1.0), 0.0);\n        a = a ** 2;\n        a = a * 1.5;\n        a = Math.min(a, 1.0);\n        const i = y * dim + x;\n        data[i * 4 + 0] = 255;\n        data[i * 4 + 1] = 255;\n        data[i * 4 + 2] = 255;\n        data[i * 4 + 3] = a * 255;\n    }\n    const tex = new $ilwiq.DataTexture(data, dim, dim);\n    tex.format = $ilwiq.RGBAFormat;\n    tex.type = $ilwiq.UnsignedByteType;\n    tex.minFilter = $ilwiq.LinearFilter;\n    tex.magFilter = $ilwiq.LinearFilter;\n    tex.wrapS = $ilwiq.RepeatWrapping;\n    tex.wrapT = $ilwiq.RepeatWrapping;\n    tex.needsUpdate = true;\n    return tex;\n}\n\n});\n\nparcelRegister(\"cE5k3\", function(module, exports) {\n\n$parcel$export(module.exports, \"getScaledSettings\", () => $934d596524c3e5a8$export$5bc756cb1c628b75);\nfunction $934d596524c3e5a8$export$5bc756cb1c628b75() {\n    let tiles = 3;\n    let renderScale = Math.max(1 / window.devicePixelRatio, 0.5);\n    // adjust performance parameters for mobile\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    if (aspectRatio < 0.65) {\n        tiles = 4;\n        renderScale = 0.5 / window.devicePixelRatio;\n    }\n    return {\n        tiles: tiles,\n        renderScale: renderScale\n    };\n}\n\n});\n\nparcelRegister(\"e2Pv4\", function(module, exports) {\n\n$parcel$export(module.exports, \"LoaderElement\", () => $a399336cf50451da$export$c2252eb3bc5ad0b7);\nlet $a399336cf50451da$var$_styleElement;\nfunction $a399336cf50451da$var$initializeStyles() {\n    if ($a399336cf50451da$var$_styleElement) return;\n    $a399336cf50451da$var$_styleElement = document.createElement(\"style\");\n    $a399336cf50451da$var$_styleElement.textContent = /* css */ `\n\n\t\t.loader-container, .description {\n\t\t\tposition: absolute;\n\t\t\twidth: 100%;\n\t\t\tfont-family: 'Courier New', Courier, monospace;\n\t\t\tcolor: white;\n\t\t\tfont-weight: light;\n\t\t\talign-items: flex-start;\n\t\t\tfont-size: 14px;\n\t\t\tpointer-events: none;\n\t\t\tuser-select: none;\n\t\t}\n\n\t\t.loader-container {\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: column;\n\t\t\tbottom: 0;\n\t\t}\n\n\t\t.description {\n\t\t\ttop: 0;\n\t\t\twidth: 100%;\n\t\t\ttext-align: center;\n\t\t\tpadding: 5px 0;\n\t\t}\n\n\t\t.loader-container .bar {\n\t\t\theight: 2px;\n\t\t\tbackground: white;\n\t\t\twidth: 100%;\n\t\t}\n\n\t\t.loader-container .credits,\n\t\t.loader-container .samples,\n\t\t.loader-container .percentage {\n\t\t\tpadding: 5px;\n\t\t\tmargin: 0 0 1px 1px;\n\t\t\tbackground: rgba( 0, 0, 0, 0.2 );\n\t\t\tborder-radius: 2px;\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t.loader-container:not(.loading) .bar,\n\t\t.loader-container:not(.loading) .percentage,\n\t\t.loader-container.loading .credits,\n\t\t.loader-container.loading .samples,\n\t\t.loader-container .credits:empty {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t.loader-container .credits a,\n\t\t.loader-container .credits,\n\t\t.loader-container .samples {\n\t\t\tcolor: rgba( 255, 255, 255, 0.75 );\n\t\t}\n\t`;\n    document.head.appendChild($a399336cf50451da$var$_styleElement);\n}\nclass $a399336cf50451da$export$c2252eb3bc5ad0b7 {\n    constructor(){\n        $a399336cf50451da$var$initializeStyles();\n        const container = document.createElement(\"div\");\n        container.classList.add(\"loader-container\");\n        const percentageEl = document.createElement(\"div\");\n        percentageEl.classList.add(\"percentage\");\n        container.appendChild(percentageEl);\n        const samplesEl = document.createElement(\"div\");\n        samplesEl.classList.add(\"samples\");\n        container.appendChild(samplesEl);\n        const creditsEl = document.createElement(\"div\");\n        creditsEl.classList.add(\"credits\");\n        container.appendChild(creditsEl);\n        const loaderBarEl = document.createElement(\"div\");\n        loaderBarEl.classList.add(\"bar\");\n        container.appendChild(loaderBarEl);\n        const descriptionEl = document.createElement(\"div\");\n        descriptionEl.classList.add(\"description\");\n        container.appendChild(descriptionEl);\n        this._description = descriptionEl;\n        this._loaderBar = loaderBarEl;\n        this._percentage = percentageEl;\n        this._credits = creditsEl;\n        this._samples = samplesEl;\n        this._container = container;\n        this.setPercentage(0);\n    }\n    attach(container) {\n        container.appendChild(this._container);\n        container.appendChild(this._description);\n    }\n    setPercentage(perc) {\n        this._loaderBar.style.width = `${perc * 100}%`;\n        if (perc === 0) this._percentage.innerText = \"Loading...\";\n        else this._percentage.innerText = `${(perc * 100).toFixed(0)}%`;\n        if (perc >= 1) this._container.classList.remove(\"loading\");\n        else this._container.classList.add(\"loading\");\n    }\n    setSamples(count, compiling = false) {\n        if (compiling) this._samples.innerText = \"compiling shader...\";\n        else this._samples.innerText = `${Math.floor(count)} samples`;\n    }\n    setCredits(credits) {\n        this._credits.innerHTML = credits;\n    }\n    setDescription(description) {\n        this._description.innerHTML = description;\n    }\n}\n\n});\n\nparcelRegister(\"kqOCM\", function(module, exports) {\n\n$parcel$export(module.exports, \"ParallelMeshBVHWorker\", () => $edfd8156d2dff8d2$export$1369cce09af89668);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $6KVZ3 = parcelRequire(\"6KVZ3\");\n\nvar $3ePKg = parcelRequire(\"3ePKg\");\n\nvar $cSOJe = parcelRequire(\"cSOJe\");\n\nvar $a8VBx = parcelRequire(\"a8VBx\");\n\nvar $5Gkg5 = parcelRequire(\"5Gkg5\");\nconst $edfd8156d2dff8d2$var$DEFAULT_WORKER_COUNT = typeof navigator !== \"undefined\" ? navigator.hardwareConcurrency : 4;\n\nclass $edfd8156d2dff8d2$var$_ParallelMeshBVHWorker extends (0, $3ePKg.WorkerBase) {\n    constructor(){\n        const worker = new Worker((parcelRequire(\"2tQrc\")));\n        super(worker);\n        this.name = \"ParallelMeshBVHWorker\";\n        this.maxWorkerCount = Math.max($edfd8156d2dff8d2$var$DEFAULT_WORKER_COUNT, 4);\n        if (!(0, $cSOJe.isSharedArrayBufferSupported)()) throw new Error(\"ParallelMeshBVHWorker: Shared Array Buffers are not supported.\");\n    }\n    runTask(worker, geometry, options = {}) {\n        return new Promise((resolve, reject)=>{\n            if (!geometry.index && !options.indirect) (0, $5Gkg5.ensureIndex)(geometry, options);\n            if (geometry.getAttribute(\"position\").isInterleavedBufferAttribute || geometry.index && geometry.index.isInterleavedBufferAttribute) throw new Error(\"ParallelMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.\");\n            worker.onerror = (e)=>{\n                reject(new Error(`ParallelMeshBVHWorker: ${e.message}`));\n            };\n            worker.onmessage = (e)=>{\n                const { data: data } = e;\n                if (data.error) {\n                    reject(new Error(data.error));\n                    worker.onmessage = null;\n                } else if (data.serialized) {\n                    const { serialized: serialized, position: position } = data;\n                    const bvh = (0, $6KVZ3.MeshBVH).deserialize(serialized, geometry, {\n                        setIndex: false\n                    });\n                    const boundsOptions = {\n                        setBoundingBox: true,\n                        ...options\n                    };\n                    // we need to replace the arrays because they're neutered entirely by the\n                    // webworker transfer.\n                    geometry.attributes.position.array = position;\n                    if (serialized.index) {\n                        if (geometry.index) geometry.index.array = serialized.index;\n                        else {\n                            const newIndex = new (0, $ilwiq.BufferAttribute)(serialized.index, 1, false);\n                            geometry.setIndex(newIndex);\n                        }\n                    }\n                    if (boundsOptions.setBoundingBox) geometry.boundingBox = bvh.getBoundingBox(new (0, $ilwiq.Box3)());\n                    if (options.onProgress) options.onProgress(data.progress);\n                    resolve(bvh);\n                    worker.onmessage = null;\n                } else if (options.onProgress) options.onProgress(data.progress);\n            };\n            const index = geometry.index ? geometry.index.array : null;\n            const position = geometry.attributes.position.array;\n            worker.postMessage({\n                operation: \"BUILD_BVH\",\n                maxWorkerCount: this.maxWorkerCount,\n                index: (0, $cSOJe.convertToBufferType)(index, SharedArrayBuffer),\n                position: (0, $cSOJe.convertToBufferType)(position, SharedArrayBuffer),\n                options: {\n                    ...options,\n                    onProgress: null,\n                    includedProgressCallback: Boolean(options.onProgress),\n                    groups: [\n                        ...geometry.groups\n                    ]\n                }\n            });\n        });\n    }\n}\nclass $edfd8156d2dff8d2$export$1369cce09af89668 {\n    constructor(){\n        if ((0, $cSOJe.isSharedArrayBufferSupported)()) return new $edfd8156d2dff8d2$var$_ParallelMeshBVHWorker();\n        else {\n            console.warn(\"ParallelMeshBVHWorker: SharedArrayBuffers not supported. Falling back to single-threaded GenerateMeshBVHWorker.\");\n            const object = new (0, $a8VBx.GenerateMeshBVHWorker)();\n            object.maxWorkerCount = $edfd8156d2dff8d2$var$DEFAULT_WORKER_COUNT;\n            return object;\n        }\n    }\n}\n\n});\nparcelRegister(\"3ePKg\", function(module, exports) {\n\n$parcel$export(module.exports, \"WorkerBase\", () => $25bad171b6c71f9d$export$8dbf7c43841b75b7);\nclass $25bad171b6c71f9d$export$8dbf7c43841b75b7 {\n    constructor(worker){\n        this.name = \"WorkerBase\";\n        this.running = false;\n        this.worker = worker;\n        this.worker.onerror = (e)=>{\n            if (e.message) throw new Error(`${this.name}: Could not create Web Worker with error \"${e.message}\"`);\n            else throw new Error(`${this.name}: Could not create Web Worker.`);\n        };\n    }\n    runTask() {}\n    generate(...args) {\n        if (this.running) throw new Error(\"GenerateMeshBVHWorker: Already running job.\");\n        if (this.worker === null) throw new Error(\"GenerateMeshBVHWorker: Worker has been disposed.\");\n        this.running = true;\n        const promise = this.runTask(this.worker, ...args);\n        promise.finally(()=>{\n            this.running = false;\n        });\n        return promise;\n    }\n    dispose() {\n        this.worker.terminate();\n        this.worker = null;\n    }\n}\n\n});\n\nparcelRegister(\"a8VBx\", function(module, exports) {\n\n$parcel$export(module.exports, \"GenerateMeshBVHWorker\", () => $762755cd5891d020$export$426cc6213ad628cf);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $6KVZ3 = parcelRequire(\"6KVZ3\");\n\nvar $3ePKg = parcelRequire(\"3ePKg\");\n\nclass $762755cd5891d020$export$426cc6213ad628cf extends (0, $3ePKg.WorkerBase) {\n    constructor(){\n        const worker = new Worker((parcelRequire(\"jVRlM\")));\n        super(worker);\n        this.name = \"GenerateMeshBVHWorker\";\n    }\n    runTask(worker, geometry, options = {}) {\n        return new Promise((resolve, reject)=>{\n            if (geometry.getAttribute(\"position\").isInterleavedBufferAttribute || geometry.index && geometry.index.isInterleavedBufferAttribute) throw new Error(\"GenerateMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.\");\n            worker.onerror = (e)=>{\n                reject(new Error(`GenerateMeshBVHWorker: ${e.message}`));\n            };\n            worker.onmessage = (e)=>{\n                const { data: data } = e;\n                if (data.error) {\n                    reject(new Error(data.error));\n                    worker.onmessage = null;\n                } else if (data.serialized) {\n                    const { serialized: serialized, position: position } = data;\n                    const bvh = (0, $6KVZ3.MeshBVH).deserialize(serialized, geometry, {\n                        setIndex: false\n                    });\n                    const boundsOptions = Object.assign({\n                        setBoundingBox: true\n                    }, options);\n                    // we need to replace the arrays because they're neutered entirely by the\n                    // webworker transfer.\n                    geometry.attributes.position.array = position;\n                    if (serialized.index) {\n                        if (geometry.index) geometry.index.array = serialized.index;\n                        else {\n                            const newIndex = new (0, $ilwiq.BufferAttribute)(serialized.index, 1, false);\n                            geometry.setIndex(newIndex);\n                        }\n                    }\n                    if (boundsOptions.setBoundingBox) geometry.boundingBox = bvh.getBoundingBox(new (0, $ilwiq.Box3)());\n                    if (options.onProgress) options.onProgress(data.progress);\n                    resolve(bvh);\n                    worker.onmessage = null;\n                } else if (options.onProgress) options.onProgress(data.progress);\n            };\n            const index = geometry.index ? geometry.index.array : null;\n            const position = geometry.attributes.position.array;\n            const transferable = [\n                position\n            ];\n            if (index) transferable.push(index);\n            worker.postMessage({\n                index: index,\n                position: position,\n                options: {\n                    ...options,\n                    onProgress: null,\n                    includedProgressCallback: Boolean(options.onProgress),\n                    groups: [\n                        ...geometry.groups\n                    ]\n                }\n            }, transferable.map((arr)=>arr.buffer).filter((v)=>typeof SharedArrayBuffer === \"undefined\" || !(v instanceof SharedArrayBuffer)));\n        });\n    }\n}\n\n});\nparcelRegister(\"jVRlM\", function(module, exports) {\n\nvar $7ryUf = parcelRequire(\"7ryUf\");\nlet $e82cb97686acadc5$var$url = new URL(\"generateMeshBVH.worker.373f3c58.js\", import.meta.url);\nmodule.exports = $7ryUf($e82cb97686acadc5$var$url.toString(), $e82cb97686acadc5$var$url.origin, true);\n\n});\nparcelRegister(\"7ryUf\", function(module, exports) {\n\"use strict\";\nmodule.exports = function(workerUrl, origin, isESM) {\n    if (origin === self.location.origin) // If the worker bundle's url is on the same origin as the document,\n    // use the worker bundle's own url.\n    return workerUrl;\n    else {\n        // Otherwise, create a blob URL which loads the worker bundle with `importScripts`.\n        var source = isESM ? \"import \" + JSON.stringify(workerUrl) + \";\" : \"importScripts(\" + JSON.stringify(workerUrl) + \");\";\n        return URL.createObjectURL(new Blob([\n            source\n        ], {\n            type: \"application/javascript\"\n        }));\n    }\n};\n\n});\n\n\n\nparcelRegister(\"2tQrc\", function(module, exports) {\n\nvar $7ryUf = parcelRequire(\"7ryUf\");\nlet $1ce6f7437f671131$var$url = new URL(\"parallelMeshBVH.worker.22cf4bb0.js\", import.meta.url);\nmodule.exports = $7ryUf($1ce6f7437f671131$var$url.toString(), $1ce6f7437f671131$var$url.origin, true);\n\n});\n\n\nparcelRegister(\"9fZ6X\", function(module, exports) {\n\n$parcel$export(module.exports, \"MaterialBase\", () => $6bd4eb2914ee2835$export$f1ac3a587b6cbb5d);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $6bd4eb2914ee2835$export$f1ac3a587b6cbb5d extends (0, $ilwiq.ShaderMaterial) {\n    set needsUpdate(v) {\n        super.needsUpdate = true;\n        this.dispatchEvent({\n            type: \"recompilation\"\n        });\n    }\n    constructor(shader){\n        super(shader);\n        for(const key in this.uniforms)Object.defineProperty(this, key, {\n            get () {\n                return this.uniforms[key].value;\n            },\n            set (v) {\n                this.uniforms[key].value = v;\n            }\n        });\n    }\n    // sets the given named define value and sets \"needsUpdate\" to true if it's different\n    setDefine(name, value) {\n        if (value === undefined || value === null) {\n            if (name in this.defines) {\n                delete this.defines[name];\n                this.needsUpdate = true;\n                return true;\n            }\n        } else if (this.defines[name] !== value) {\n            this.defines[name] = value;\n            this.needsUpdate = true;\n            return true;\n        }\n        return false;\n    }\n}\n\n});\n\nparcelRegister(\"fYvb1\", function(module, exports) {\n\n$parcel$export(module.exports, \"math_functions\", () => $ba14a4aaa0cde19b$export$98323a006d35be35);\nconst $ba14a4aaa0cde19b$export$98323a006d35be35 = /* glsl */ `\n\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\n\t// For more information see: https://github.com/gkjohnson/three-gpu-pathtracer/pull/171#issuecomment-1152275248\n\tfloat acosApprox( float x ) {\n\n\t\tx = clamp( x, -1.0, 1.0 );\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\n\n\t}\n\n\t// An acos with input values bound to the range [-1, 1].\n\tfloat acosSafe( float x ) {\n\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\n\n\t}\n\n\tfloat saturateCos( float val ) {\n\n\t\treturn clamp( val, 0.001, 1.0 );\n\n\t}\n\n\tfloat square( float t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 square( vec2 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec3 square( vec3 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec4 square( vec4 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 rotateVector( vec2 v, float t ) {\n\n\t\tfloat ac = cos( t );\n\t\tfloat as = sin( t );\n\t\treturn vec2(\n\t\t\tv.x * ac - v.y * as,\n\t\t\tv.x * as + v.y * ac\n\t\t);\n\n\t}\n\n\t// forms a basis with the normal vector as Z\n\tmat3 getBasisFromNormal( vec3 normal ) {\n\n\t\tvec3 other;\n\t\tif ( abs( normal.x ) > 0.5 ) {\n\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\n\n\t\t} else {\n\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\n\n\t\t}\n\n\t\tvec3 ortho = normalize( cross( normal, other ) );\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\n\t\treturn mat3( ortho2, ortho, normal );\n\n\t}\n\n`;\n\n});\n\nparcelRegister(\"dUUQZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"util_functions\", () => $a21c9b4177584031$export$fe1d788deccfbee3);\nconst $a21c9b4177584031$export$fe1d788deccfbee3 = /* glsl */ `\n\n\t// TODO: possibly this should be renamed something related to material or path tracing logic\n\n\t#ifndef RAY_OFFSET\n\t#define RAY_OFFSET 1e-4\n\t#endif\n\n\t// adjust the hit point by the surface normal by a factor of some offset and the\n\t// maximum component-wise value of the current point to accommodate floating point\n\t// error as values increase.\n\tvec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {\n\n\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\tvec3 absPoint = abs( point );\n\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\treturn point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;\n\n\t}\n\n\t// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\n\tvec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {\n\n\t\tvec3 ot = - log( attColor ) / attDist;\n\t\treturn exp( - ot * dist );\n\n\t}\n\n\tvec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {\n\n\t\t// get the half vector - assuming if the light incident vector is on the other side\n\t\t// of the that it's transmissive.\n\t\tvec3 h;\n\t\tif ( wi.z > 0.0 ) {\n\n\t\t\th = normalize( wi + wo );\n\n\t\t} else {\n\n\t\t\t// Scale by the ior ratio to retrieve the appropriate half vector\n\t\t\t// From Section 2.2 on computing the transmission half vector:\n\t\t\t// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\n\t\t\th = normalize( wi + wo * eta );\n\n\t\t}\n\n\t\th *= sign( h.z );\n\t\treturn h;\n\n\t}\n\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\n\n\t\treturn normalize( a + b );\n\n\t}\n\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\n\t// we find a ray like that we ignore it to avoid artifacts.\n\t// This function returns if the direction is on the same side of both planes.\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\n\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\n\n\t}\n\n\t// ray sampling x and z are swapped to align with expected background view\n\tvec2 equirectDirectionToUv( vec3 direction ) {\n\n\t\t// from Spherical.setFromCartesianCoords\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\n\t\tuv /= vec2( 2.0 * PI, PI );\n\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\n\t\tuv.x += 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\t\treturn uv;\n\n\t}\n\n\tvec3 equirectUvToDirection( vec2 uv ) {\n\n\t\t// undo above adjustments\n\t\tuv.x -= 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\n\t\t// from Vector3.setFromSphericalCoords\n\t\tfloat theta = uv.x * 2.0 * PI;\n\t\tfloat phi = uv.y * PI;\n\n\t\tfloat sinPhi = sin( phi );\n\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\n\n\t}\n\n\t// power heuristic for multiple importance sampling\n\tfloat misHeuristic( float a, float b ) {\n\n\t\tfloat aa = a * a;\n\t\tfloat bb = b * b;\n\t\treturn aa / ( aa + bb );\n\n\t}\n\n\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\n\t// erichlof/THREE.js-PathTracing-Renderer/\n\tfloat tentFilter( float x ) {\n\n\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\n\n\t}\n`;\n\n});\n\nparcelRegister(\"8keuf\", function(module, exports) {\n\n$parcel$export(module.exports, \"ggx_functions\", () => $60fb6dc3c6495c33$export$4c711108e2e8ef5e);\nconst $60fb6dc3c6495c33$export$4c711108e2e8ef5e = /* glsl */ `\n\n\t// The GGX functions provide sampling and distribution information for normals as output so\n\t// in order to get probability of scatter direction the half vector must be computed and provided.\n\t// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\t// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n\t// [2] http://jcgt.org/published/0007/04/01/\n\t// [4] http://jcgt.org/published/0003/02/03/\n\n\t// trowbridge-reitz === GGX === GTR\n\n\tvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\n\n\t\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t\t// function below, as well\n\n\t\t// Implementation from reference [1]\n\t\t// stretch view\n\t\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\n\n\t\t// orthonormal basis\n\t\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\n\t\tvec3 T2 = cross( T1, V );\n\n\t\t// sample point with polar coordinates (r, phi)\n\t\tfloat a = 1.0 / ( 1.0 + V.z );\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\n\t\tfloat P1 = r * cos( phi );\n\t\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\n\n\t\t// compute normal\n\t\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\n\n\t\t// unstretch\n\t\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\n\n\t\treturn N;\n\n\t}\n\n\t// Below are PDF and related functions for use in a Monte Carlo path tracer\n\t// as specified in Appendix B of the following paper\n\t// See equation (34) from reference [0]\n\tfloat ggxLamda( float theta, float roughness ) {\n\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = tanTheta * tanTheta;\n\t\tfloat alpha2 = roughness * roughness;\n\n\t\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\n\t\treturn numerator / 2.0;\n\n\t}\n\n\t// See equation (34) from reference [0]\n\tfloat ggxShadowMaskG1( float theta, float roughness ) {\n\n\t\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n\t}\n\n\t// See equation (125) from reference [4]\n\tfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat scatterTheta = acos( wo.z );\n\t\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n\t}\n\n\t// See equation (33) from reference [0]\n\tfloat ggxDistribution( vec3 halfVector, float roughness ) {\n\n\t\tfloat a2 = roughness * roughness;\n\t\ta2 = max( EPSILON, a2 );\n\t\tfloat cosTheta = halfVector.z;\n\t\tfloat cosTheta4 = pow( cosTheta, 4.0 );\n\n\t\tif ( cosTheta == 0.0 ) return 0.0;\n\n\t\tfloat theta = acosSafe( halfVector.z );\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = pow( tanTheta, 2.0 );\n\n\t\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\n\t\treturn ( a2 / denom );\n\n\t}\n\n\t// See equation (3) from reference [2]\n\tfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat D = ggxDistribution( halfVector, roughness );\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\t\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\n\n\t}\n\n`;\n\n});\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $kp7Te = parcelRequire(\"kp7Te\");\n\nvar $891vQ = parcelRequire(\"891vQ\");\n\nvar $7lx9d = parcelRequire(\"7lx9d\");\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $dc743e2081fd10a7$export$f133a99b4c3153a extends (0, $ilwiq.DataTextureLoader) {\n    constructor(manager){\n        super(manager);\n    }\n    parse(buffer) {\n        // reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n        function tgaCheckHeader(header) {\n            switch(header.image_type){\n                // check indexed type\n                case TGA_TYPE_INDEXED:\n                case TGA_TYPE_RLE_INDEXED:\n                    if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) throw new Error(\"THREE.TGALoader: Invalid type colormap data for indexed type.\");\n                    break;\n                // check colormap type\n                case TGA_TYPE_RGB:\n                case TGA_TYPE_GREY:\n                case TGA_TYPE_RLE_RGB:\n                case TGA_TYPE_RLE_GREY:\n                    if (header.colormap_type) throw new Error(\"THREE.TGALoader: Invalid type colormap data for colormap type.\");\n                    break;\n                // What the need of a file without data ?\n                case TGA_TYPE_NO_DATA:\n                    throw new Error(\"THREE.TGALoader: No data.\");\n                // Invalid type ?\n                default:\n                    throw new Error(\"THREE.TGALoader: Invalid type \" + header.image_type);\n            }\n            // check image width and height\n            if (header.width <= 0 || header.height <= 0) throw new Error(\"THREE.TGALoader: Invalid image size.\");\n            // check image pixel size\n            if (header.pixel_size !== 8 && header.pixel_size !== 16 && header.pixel_size !== 24 && header.pixel_size !== 32) throw new Error(\"THREE.TGALoader: Invalid pixel size \" + header.pixel_size);\n        }\n        // parse tga image buffer\n        function tgaParse(use_rle, use_pal, header, offset, data) {\n            let pixel_data, palettes;\n            const pixel_size = header.pixel_size >> 3;\n            const pixel_total = header.width * header.height * pixel_size;\n            // read palettes\n            if (use_pal) palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));\n            // read RLE\n            if (use_rle) {\n                pixel_data = new Uint8Array(pixel_total);\n                let c, count, i;\n                let shift = 0;\n                const pixels = new Uint8Array(pixel_size);\n                while(shift < pixel_total){\n                    c = data[offset++];\n                    count = (c & 0x7f) + 1;\n                    // RLE pixels\n                    if (c & 0x80) {\n                        // bind pixel tmp array\n                        for(i = 0; i < pixel_size; ++i)pixels[i] = data[offset++];\n                        // copy pixel array\n                        for(i = 0; i < count; ++i)pixel_data.set(pixels, shift + i * pixel_size);\n                        shift += pixel_size * count;\n                    } else {\n                        // raw pixels\n                        count *= pixel_size;\n                        for(i = 0; i < count; ++i)pixel_data[shift + i] = data[offset++];\n                        shift += count;\n                    }\n                }\n            } else // raw pixels\n            pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);\n            return {\n                pixel_data: pixel_data,\n                palettes: palettes\n            };\n        }\n        function tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\n            const colormap = palettes;\n            let color, i = 0, x, y;\n            const width = header.width;\n            for(y = y_start; y !== y_end; y += y_step)for(x = x_start; x !== x_end; x += x_step, i++){\n                color = image[i];\n                imageData[(x + width * y) * 4 + 3] = 255;\n                imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n                imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n                imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n            }\n            return imageData;\n        }\n        function tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n            let color, i = 0, x, y;\n            const width = header.width;\n            for(y = y_start; y !== y_end; y += y_step)for(x = x_start; x !== x_end; x += x_step, i += 2){\n                color = image[i + 0] + (image[i + 1] << 8);\n                imageData[(x + width * y) * 4 + 0] = (color & 0x7C00) >> 7;\n                imageData[(x + width * y) * 4 + 1] = (color & 0x03E0) >> 2;\n                imageData[(x + width * y) * 4 + 2] = (color & 0x001F) << 3;\n                imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\n            }\n            return imageData;\n        }\n        function tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n            let i = 0, x, y;\n            const width = header.width;\n            for(y = y_start; y !== y_end; y += y_step)for(x = x_start; x !== x_end; x += x_step, i += 3){\n                imageData[(x + width * y) * 4 + 3] = 255;\n                imageData[(x + width * y) * 4 + 2] = image[i + 0];\n                imageData[(x + width * y) * 4 + 1] = image[i + 1];\n                imageData[(x + width * y) * 4 + 0] = image[i + 2];\n            }\n            return imageData;\n        }\n        function tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n            let i = 0, x, y;\n            const width = header.width;\n            for(y = y_start; y !== y_end; y += y_step)for(x = x_start; x !== x_end; x += x_step, i += 4){\n                imageData[(x + width * y) * 4 + 2] = image[i + 0];\n                imageData[(x + width * y) * 4 + 1] = image[i + 1];\n                imageData[(x + width * y) * 4 + 0] = image[i + 2];\n                imageData[(x + width * y) * 4 + 3] = image[i + 3];\n            }\n            return imageData;\n        }\n        function tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n            let color, i = 0, x, y;\n            const width = header.width;\n            for(y = y_start; y !== y_end; y += y_step)for(x = x_start; x !== x_end; x += x_step, i++){\n                color = image[i];\n                imageData[(x + width * y) * 4 + 0] = color;\n                imageData[(x + width * y) * 4 + 1] = color;\n                imageData[(x + width * y) * 4 + 2] = color;\n                imageData[(x + width * y) * 4 + 3] = 255;\n            }\n            return imageData;\n        }\n        function tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n            let i = 0, x, y;\n            const width = header.width;\n            for(y = y_start; y !== y_end; y += y_step)for(x = x_start; x !== x_end; x += x_step, i += 2){\n                imageData[(x + width * y) * 4 + 0] = image[i + 0];\n                imageData[(x + width * y) * 4 + 1] = image[i + 0];\n                imageData[(x + width * y) * 4 + 2] = image[i + 0];\n                imageData[(x + width * y) * 4 + 3] = image[i + 1];\n            }\n            return imageData;\n        }\n        function getTgaRGBA(data, width, height, image, palette) {\n            let x_start, y_start, x_step, y_step, x_end, y_end;\n            switch((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT){\n                default:\n                case TGA_ORIGIN_UL:\n                    x_start = 0;\n                    x_step = 1;\n                    x_end = width;\n                    y_start = 0;\n                    y_step = 1;\n                    y_end = height;\n                    break;\n                case TGA_ORIGIN_BL:\n                    x_start = 0;\n                    x_step = 1;\n                    x_end = width;\n                    y_start = height - 1;\n                    y_step = -1;\n                    y_end = -1;\n                    break;\n                case TGA_ORIGIN_UR:\n                    x_start = width - 1;\n                    x_step = -1;\n                    x_end = -1;\n                    y_start = 0;\n                    y_step = 1;\n                    y_end = height;\n                    break;\n                case TGA_ORIGIN_BR:\n                    x_start = width - 1;\n                    x_step = -1;\n                    x_end = -1;\n                    y_start = height - 1;\n                    y_step = -1;\n                    y_end = -1;\n                    break;\n            }\n            if (use_grey) switch(header.pixel_size){\n                case 8:\n                    tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n                    break;\n                case 16:\n                    tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n                    break;\n                default:\n                    throw new Error(\"THREE.TGALoader: Format not supported.\");\n            }\n            else switch(header.pixel_size){\n                case 8:\n                    tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);\n                    break;\n                case 16:\n                    tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n                    break;\n                case 24:\n                    tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n                    break;\n                case 32:\n                    tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n                    break;\n                default:\n                    throw new Error(\"THREE.TGALoader: Format not supported.\");\n            }\n            // Load image data according to specific method\n            // let func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n            // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n            return data;\n        }\n        // TGA constants\n        const TGA_TYPE_NO_DATA = 0, TGA_TYPE_INDEXED = 1, TGA_TYPE_RGB = 2, TGA_TYPE_GREY = 3, TGA_TYPE_RLE_INDEXED = 9, TGA_TYPE_RLE_RGB = 10, TGA_TYPE_RLE_GREY = 11, TGA_ORIGIN_MASK = 0x30, TGA_ORIGIN_SHIFT = 0x04, TGA_ORIGIN_BL = 0x00, TGA_ORIGIN_BR = 0x01, TGA_ORIGIN_UL = 0x02, TGA_ORIGIN_UR = 0x03;\n        if (buffer.length < 19) throw new Error(\"THREE.TGALoader: Not enough data to contain header.\");\n        let offset = 0;\n        const content = new Uint8Array(buffer), header = {\n            id_length: content[offset++],\n            colormap_type: content[offset++],\n            image_type: content[offset++],\n            colormap_index: content[offset++] | content[offset++] << 8,\n            colormap_length: content[offset++] | content[offset++] << 8,\n            colormap_size: content[offset++],\n            origin: [\n                content[offset++] | content[offset++] << 8,\n                content[offset++] | content[offset++] << 8\n            ],\n            width: content[offset++] | content[offset++] << 8,\n            height: content[offset++] | content[offset++] << 8,\n            pixel_size: content[offset++],\n            flags: content[offset++]\n        };\n        // check tga if it is valid format\n        tgaCheckHeader(header);\n        if (header.id_length + offset > buffer.length) throw new Error(\"THREE.TGALoader: No data.\");\n        // skip the needn't data\n        offset += header.id_length;\n        // get targa information about RLE compression and palette\n        let use_rle = false, use_pal = false, use_grey = false;\n        switch(header.image_type){\n            case TGA_TYPE_RLE_INDEXED:\n                use_rle = true;\n                use_pal = true;\n                break;\n            case TGA_TYPE_INDEXED:\n                use_pal = true;\n                break;\n            case TGA_TYPE_RLE_RGB:\n                use_rle = true;\n                break;\n            case TGA_TYPE_RGB:\n                break;\n            case TGA_TYPE_RLE_GREY:\n                use_rle = true;\n                use_grey = true;\n                break;\n            case TGA_TYPE_GREY:\n                use_grey = true;\n                break;\n        }\n        //\n        const imageData = new Uint8Array(header.width * header.height * 4);\n        const result = tgaParse(use_rle, use_pal, header, offset, content);\n        getTgaRGBA(imageData, header.width, header.height, result.pixel_data, result.palettes);\n        return {\n            data: imageData,\n            width: header.width,\n            height: header.height,\n            flipY: true,\n            generateMipmaps: true,\n            minFilter: (0, $ilwiq.LinearMipmapLinearFilter)\n        };\n    }\n}\n\n\nclass $7f99d0845977052a$export$ce4e0fe932362815 extends (0, $ilwiq.Loader) {\n    load(url, onLoad, onProgress, onError) {\n        const scope = this;\n        const path = scope.path === \"\" ? (0, $ilwiq.LoaderUtils).extractUrlBase(url) : scope.path;\n        const loader = new (0, $ilwiq.FileLoader)(scope.manager);\n        loader.setPath(scope.path);\n        loader.setRequestHeader(scope.requestHeader);\n        loader.setWithCredentials(scope.withCredentials);\n        loader.load(url, function(text) {\n            try {\n                onLoad(scope.parse(text, path));\n            } catch (e) {\n                if (onError) onError(e);\n                else console.error(e);\n                scope.manager.itemError(url);\n            }\n        }, onProgress, onError);\n    }\n    parse(text, path) {\n        function getElementsByTagName(xml, name) {\n            // Non recursive xml.getElementsByTagName() ...\n            const array = [];\n            const childNodes = xml.childNodes;\n            for(let i = 0, l = childNodes.length; i < l; i++){\n                const child = childNodes[i];\n                if (child.nodeName === name) array.push(child);\n            }\n            return array;\n        }\n        function parseStrings(text) {\n            if (text.length === 0) return [];\n            const parts = text.trim().split(/\\s+/);\n            const array = new Array(parts.length);\n            for(let i = 0, l = parts.length; i < l; i++)array[i] = parts[i];\n            return array;\n        }\n        function parseFloats(text) {\n            if (text.length === 0) return [];\n            const parts = text.trim().split(/\\s+/);\n            const array = new Array(parts.length);\n            for(let i = 0, l = parts.length; i < l; i++)array[i] = parseFloat(parts[i]);\n            return array;\n        }\n        function parseInts(text) {\n            if (text.length === 0) return [];\n            const parts = text.trim().split(/\\s+/);\n            const array = new Array(parts.length);\n            for(let i = 0, l = parts.length; i < l; i++)array[i] = parseInt(parts[i]);\n            return array;\n        }\n        function parseId(text) {\n            return text.substring(1);\n        }\n        function generateId() {\n            return \"three_default_\" + count++;\n        }\n        function isEmpty(object) {\n            return Object.keys(object).length === 0;\n        }\n        // asset\n        function parseAsset(xml) {\n            return {\n                unit: parseAssetUnit(getElementsByTagName(xml, \"unit\")[0]),\n                upAxis: parseAssetUpAxis(getElementsByTagName(xml, \"up_axis\")[0])\n            };\n        }\n        function parseAssetUnit(xml) {\n            if (xml !== undefined && xml.hasAttribute(\"meter\") === true) return parseFloat(xml.getAttribute(\"meter\"));\n            else return 1; // default 1 meter\n        }\n        function parseAssetUpAxis(xml) {\n            return xml !== undefined ? xml.textContent : \"Y_UP\";\n        }\n        // library\n        function parseLibrary(xml, libraryName, nodeName, parser) {\n            const library = getElementsByTagName(xml, libraryName)[0];\n            if (library !== undefined) {\n                const elements = getElementsByTagName(library, nodeName);\n                for(let i = 0; i < elements.length; i++)parser(elements[i]);\n            }\n        }\n        function buildLibrary(data, builder) {\n            for(const name in data){\n                const object = data[name];\n                object.build = builder(data[name]);\n            }\n        }\n        // get\n        function getBuild(data, builder) {\n            if (data.build !== undefined) return data.build;\n            data.build = builder(data);\n            return data.build;\n        }\n        // animation\n        function parseAnimation(xml) {\n            const data = {\n                sources: {},\n                samplers: {},\n                channels: {}\n            };\n            let hasChildren = false;\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                let id;\n                switch(child.nodeName){\n                    case \"source\":\n                        id = child.getAttribute(\"id\");\n                        data.sources[id] = parseSource(child);\n                        break;\n                    case \"sampler\":\n                        id = child.getAttribute(\"id\");\n                        data.samplers[id] = parseAnimationSampler(child);\n                        break;\n                    case \"channel\":\n                        id = child.getAttribute(\"target\");\n                        data.channels[id] = parseAnimationChannel(child);\n                        break;\n                    case \"animation\":\n                        // hierarchy of related animations\n                        parseAnimation(child);\n                        hasChildren = true;\n                        break;\n                    default:\n                        console.log(child);\n                }\n            }\n            if (hasChildren === false) // since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n            library.animations[xml.getAttribute(\"id\") || (0, $ilwiq.MathUtils).generateUUID()] = data;\n        }\n        function parseAnimationSampler(xml) {\n            const data = {\n                inputs: {}\n            };\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"input\":\n                        const id = parseId(child.getAttribute(\"source\"));\n                        const semantic = child.getAttribute(\"semantic\");\n                        data.inputs[semantic] = id;\n                        break;\n                }\n            }\n            return data;\n        }\n        function parseAnimationChannel(xml) {\n            const data = {};\n            const target = xml.getAttribute(\"target\");\n            // parsing SID Addressing Syntax\n            let parts = target.split(\"/\");\n            const id = parts.shift();\n            let sid = parts.shift();\n            // check selection syntax\n            const arraySyntax = sid.indexOf(\"(\") !== -1;\n            const memberSyntax = sid.indexOf(\".\") !== -1;\n            if (memberSyntax) {\n                //  member selection access\n                parts = sid.split(\".\");\n                sid = parts.shift();\n                data.member = parts.shift();\n            } else if (arraySyntax) {\n                // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n                const indices = sid.split(\"(\");\n                sid = indices.shift();\n                for(let i = 0; i < indices.length; i++)indices[i] = parseInt(indices[i].replace(/\\)/, \"\"));\n                data.indices = indices;\n            }\n            data.id = id;\n            data.sid = sid;\n            data.arraySyntax = arraySyntax;\n            data.memberSyntax = memberSyntax;\n            data.sampler = parseId(xml.getAttribute(\"source\"));\n            return data;\n        }\n        function buildAnimation(data) {\n            const tracks = [];\n            const channels = data.channels;\n            const samplers = data.samplers;\n            const sources = data.sources;\n            for(const target in channels)if (channels.hasOwnProperty(target)) {\n                const channel = channels[target];\n                const sampler = samplers[channel.sampler];\n                const inputId = sampler.inputs.INPUT;\n                const outputId = sampler.inputs.OUTPUT;\n                const inputSource = sources[inputId];\n                const outputSource = sources[outputId];\n                const animation = buildAnimationChannel(channel, inputSource, outputSource);\n                createKeyframeTracks(animation, tracks);\n            }\n            return tracks;\n        }\n        function getAnimation(id) {\n            return getBuild(library.animations[id], buildAnimation);\n        }\n        function buildAnimationChannel(channel, inputSource, outputSource) {\n            const node = library.nodes[channel.id];\n            const object3D = getNode(node.id);\n            const transform = node.transforms[channel.sid];\n            const defaultMatrix = node.matrix.clone().transpose();\n            let time, stride;\n            let i, il, j, jl;\n            const data = {};\n            // the collada spec allows the animation of data in various ways.\n            // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n            switch(transform){\n                case \"matrix\":\n                    for(i = 0, il = inputSource.array.length; i < il; i++){\n                        time = inputSource.array[i];\n                        stride = i * outputSource.stride;\n                        if (data[time] === undefined) data[time] = {};\n                        if (channel.arraySyntax === true) {\n                            const value = outputSource.array[stride];\n                            const index = channel.indices[0] + 4 * channel.indices[1];\n                            data[time][index] = value;\n                        } else for(j = 0, jl = outputSource.stride; j < jl; j++)data[time][j] = outputSource.array[stride + j];\n                    }\n                    break;\n                case \"translate\":\n                    console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n                    break;\n                case \"rotate\":\n                    console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n                    break;\n                case \"scale\":\n                    console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n                    break;\n            }\n            const keyframes = prepareAnimationData(data, defaultMatrix);\n            const animation = {\n                name: object3D.uuid,\n                keyframes: keyframes\n            };\n            return animation;\n        }\n        function prepareAnimationData(data, defaultMatrix) {\n            const keyframes = [];\n            // transfer data into a sortable array\n            for(const time in data)keyframes.push({\n                time: parseFloat(time),\n                value: data[time]\n            });\n            // ensure keyframes are sorted by time\n            keyframes.sort(ascending);\n            // now we clean up all animation data, so we can use them for keyframe tracks\n            for(let i = 0; i < 16; i++)transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n            return keyframes;\n            // array sort function\n            function ascending(a, b) {\n                return a.time - b.time;\n            }\n        }\n        const position = new (0, $ilwiq.Vector3)();\n        const scale = new (0, $ilwiq.Vector3)();\n        const quaternion = new (0, $ilwiq.Quaternion)();\n        function createKeyframeTracks(animation, tracks) {\n            const keyframes = animation.keyframes;\n            const name = animation.name;\n            const times = [];\n            const positionData = [];\n            const quaternionData = [];\n            const scaleData = [];\n            for(let i = 0, l = keyframes.length; i < l; i++){\n                const keyframe = keyframes[i];\n                const time = keyframe.time;\n                const value = keyframe.value;\n                matrix.fromArray(value).transpose();\n                matrix.decompose(position, quaternion, scale);\n                times.push(time);\n                positionData.push(position.x, position.y, position.z);\n                quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n                scaleData.push(scale.x, scale.y, scale.z);\n            }\n            if (positionData.length > 0) tracks.push(new (0, $ilwiq.VectorKeyframeTrack)(name + \".position\", times, positionData));\n            if (quaternionData.length > 0) tracks.push(new (0, $ilwiq.QuaternionKeyframeTrack)(name + \".quaternion\", times, quaternionData));\n            if (scaleData.length > 0) tracks.push(new (0, $ilwiq.VectorKeyframeTrack)(name + \".scale\", times, scaleData));\n            return tracks;\n        }\n        function transformAnimationData(keyframes, property, defaultValue) {\n            let keyframe;\n            let empty = true;\n            let i, l;\n            // check, if values of a property are missing in our keyframes\n            for(i = 0, l = keyframes.length; i < l; i++){\n                keyframe = keyframes[i];\n                if (keyframe.value[property] === undefined) keyframe.value[property] = null; // mark as missing\n                else empty = false;\n            }\n            if (empty === true) // no values at all, so we set a default value\n            for(i = 0, l = keyframes.length; i < l; i++){\n                keyframe = keyframes[i];\n                keyframe.value[property] = defaultValue;\n            }\n            else // filling gaps\n            createMissingKeyframes(keyframes, property);\n        }\n        function createMissingKeyframes(keyframes, property) {\n            let prev, next;\n            for(let i = 0, l = keyframes.length; i < l; i++){\n                const keyframe = keyframes[i];\n                if (keyframe.value[property] === null) {\n                    prev = getPrev(keyframes, i, property);\n                    next = getNext(keyframes, i, property);\n                    if (prev === null) {\n                        keyframe.value[property] = next.value[property];\n                        continue;\n                    }\n                    if (next === null) {\n                        keyframe.value[property] = prev.value[property];\n                        continue;\n                    }\n                    interpolate(keyframe, prev, next, property);\n                }\n            }\n        }\n        function getPrev(keyframes, i, property) {\n            while(i >= 0){\n                const keyframe = keyframes[i];\n                if (keyframe.value[property] !== null) return keyframe;\n                i--;\n            }\n            return null;\n        }\n        function getNext(keyframes, i, property) {\n            while(i < keyframes.length){\n                const keyframe = keyframes[i];\n                if (keyframe.value[property] !== null) return keyframe;\n                i++;\n            }\n            return null;\n        }\n        function interpolate(key, prev, next, property) {\n            if (next.time - prev.time === 0) {\n                key.value[property] = prev.value[property];\n                return;\n            }\n            key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n        }\n        // animation clips\n        function parseAnimationClip(xml) {\n            const data = {\n                name: xml.getAttribute(\"id\") || \"default\",\n                start: parseFloat(xml.getAttribute(\"start\") || 0),\n                end: parseFloat(xml.getAttribute(\"end\") || 0),\n                animations: []\n            };\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"instance_animation\":\n                        data.animations.push(parseId(child.getAttribute(\"url\")));\n                        break;\n                }\n            }\n            library.clips[xml.getAttribute(\"id\")] = data;\n        }\n        function buildAnimationClip(data) {\n            const tracks = [];\n            const name = data.name;\n            const duration = data.end - data.start || -1;\n            const animations = data.animations;\n            for(let i = 0, il = animations.length; i < il; i++){\n                const animationTracks = getAnimation(animations[i]);\n                for(let j = 0, jl = animationTracks.length; j < jl; j++)tracks.push(animationTracks[j]);\n            }\n            return new (0, $ilwiq.AnimationClip)(name, duration, tracks);\n        }\n        function getAnimationClip(id) {\n            return getBuild(library.clips[id], buildAnimationClip);\n        }\n        // controller\n        function parseController(xml) {\n            const data = {};\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"skin\":\n                        // there is exactly one skin per controller\n                        data.id = parseId(child.getAttribute(\"source\"));\n                        data.skin = parseSkin(child);\n                        break;\n                    case \"morph\":\n                        data.id = parseId(child.getAttribute(\"source\"));\n                        console.warn(\"THREE.ColladaLoader: Morph target animation not supported yet.\");\n                        break;\n                }\n            }\n            library.controllers[xml.getAttribute(\"id\")] = data;\n        }\n        function parseSkin(xml) {\n            const data = {\n                sources: {}\n            };\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"bind_shape_matrix\":\n                        data.bindShapeMatrix = parseFloats(child.textContent);\n                        break;\n                    case \"source\":\n                        const id = child.getAttribute(\"id\");\n                        data.sources[id] = parseSource(child);\n                        break;\n                    case \"joints\":\n                        data.joints = parseJoints(child);\n                        break;\n                    case \"vertex_weights\":\n                        data.vertexWeights = parseVertexWeights(child);\n                        break;\n                }\n            }\n            return data;\n        }\n        function parseJoints(xml) {\n            const data = {\n                inputs: {}\n            };\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"input\":\n                        const semantic = child.getAttribute(\"semantic\");\n                        const id = parseId(child.getAttribute(\"source\"));\n                        data.inputs[semantic] = id;\n                        break;\n                }\n            }\n            return data;\n        }\n        function parseVertexWeights(xml) {\n            const data = {\n                inputs: {}\n            };\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"input\":\n                        const semantic = child.getAttribute(\"semantic\");\n                        const id = parseId(child.getAttribute(\"source\"));\n                        const offset = parseInt(child.getAttribute(\"offset\"));\n                        data.inputs[semantic] = {\n                            id: id,\n                            offset: offset\n                        };\n                        break;\n                    case \"vcount\":\n                        data.vcount = parseInts(child.textContent);\n                        break;\n                    case \"v\":\n                        data.v = parseInts(child.textContent);\n                        break;\n                }\n            }\n            return data;\n        }\n        function buildController(data) {\n            const build = {\n                id: data.id\n            };\n            const geometry = library.geometries[build.id];\n            if (data.skin !== undefined) {\n                build.skin = buildSkin(data.skin);\n                // we enhance the 'sources' property of the corresponding geometry with our skin data\n                geometry.sources.skinIndices = build.skin.indices;\n                geometry.sources.skinWeights = build.skin.weights;\n            }\n            return build;\n        }\n        function buildSkin(data) {\n            const BONE_LIMIT = 4;\n            const build = {\n                joints: [],\n                indices: {\n                    array: [],\n                    stride: BONE_LIMIT\n                },\n                weights: {\n                    array: [],\n                    stride: BONE_LIMIT\n                }\n            };\n            const sources = data.sources;\n            const vertexWeights = data.vertexWeights;\n            const vcount = vertexWeights.vcount;\n            const v = vertexWeights.v;\n            const jointOffset = vertexWeights.inputs.JOINT.offset;\n            const weightOffset = vertexWeights.inputs.WEIGHT.offset;\n            const jointSource = data.sources[data.joints.inputs.JOINT];\n            const inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n            const weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n            let stride = 0;\n            let i, j, l;\n            // process skin data for each vertex\n            for(i = 0, l = vcount.length; i < l; i++){\n                const jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\n                const vertexSkinData = [];\n                for(j = 0; j < jointCount; j++){\n                    const skinIndex = v[stride + jointOffset];\n                    const weightId = v[stride + weightOffset];\n                    const skinWeight = weights[weightId];\n                    vertexSkinData.push({\n                        index: skinIndex,\n                        weight: skinWeight\n                    });\n                    stride += 2;\n                }\n                // we sort the joints in descending order based on the weights.\n                // this ensures, we only procced the most important joints of the vertex\n                vertexSkinData.sort(descending);\n                // now we provide for each vertex a set of four index and weight values.\n                // the order of the skin data matches the order of vertices\n                for(j = 0; j < BONE_LIMIT; j++){\n                    const d = vertexSkinData[j];\n                    if (d !== undefined) {\n                        build.indices.array.push(d.index);\n                        build.weights.array.push(d.weight);\n                    } else {\n                        build.indices.array.push(0);\n                        build.weights.array.push(0);\n                    }\n                }\n            }\n            // setup bind matrix\n            if (data.bindShapeMatrix) build.bindMatrix = new (0, $ilwiq.Matrix4)().fromArray(data.bindShapeMatrix).transpose();\n            else build.bindMatrix = new (0, $ilwiq.Matrix4)().identity();\n            // process bones and inverse bind matrix data\n            for(i = 0, l = jointSource.array.length; i < l; i++){\n                const name = jointSource.array[i];\n                const boneInverse = new (0, $ilwiq.Matrix4)().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n                build.joints.push({\n                    name: name,\n                    boneInverse: boneInverse\n                });\n            }\n            return build;\n            // array sort function\n            function descending(a, b) {\n                return b.weight - a.weight;\n            }\n        }\n        function getController(id) {\n            return getBuild(library.controllers[id], buildController);\n        }\n        // image\n        function parseImage(xml) {\n            const data = {\n                init_from: getElementsByTagName(xml, \"init_from\")[0].textContent\n            };\n            library.images[xml.getAttribute(\"id\")] = data;\n        }\n        function buildImage(data) {\n            if (data.build !== undefined) return data.build;\n            return data.init_from;\n        }\n        function getImage(id) {\n            const data = library.images[id];\n            if (data !== undefined) return getBuild(data, buildImage);\n            console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id);\n            return null;\n        }\n        // effect\n        function parseEffect(xml) {\n            const data = {};\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"profile_COMMON\":\n                        data.profile = parseEffectProfileCOMMON(child);\n                        break;\n                }\n            }\n            library.effects[xml.getAttribute(\"id\")] = data;\n        }\n        function parseEffectProfileCOMMON(xml) {\n            const data = {\n                surfaces: {},\n                samplers: {}\n            };\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"newparam\":\n                        parseEffectNewparam(child, data);\n                        break;\n                    case \"technique\":\n                        data.technique = parseEffectTechnique(child);\n                        break;\n                    case \"extra\":\n                        data.extra = parseEffectExtra(child);\n                        break;\n                }\n            }\n            return data;\n        }\n        function parseEffectNewparam(xml, data) {\n            const sid = xml.getAttribute(\"sid\");\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"surface\":\n                        data.surfaces[sid] = parseEffectSurface(child);\n                        break;\n                    case \"sampler2D\":\n                        data.samplers[sid] = parseEffectSampler(child);\n                        break;\n                }\n            }\n        }\n        function parseEffectSurface(xml) {\n            const data = {};\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"init_from\":\n                        data.init_from = child.textContent;\n                        break;\n                }\n            }\n            return data;\n        }\n        function parseEffectSampler(xml) {\n            const data = {};\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"source\":\n                        data.source = child.textContent;\n                        break;\n                }\n            }\n            return data;\n        }\n        function parseEffectTechnique(xml) {\n            const data = {};\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"constant\":\n                    case \"lambert\":\n                    case \"blinn\":\n                    case \"phong\":\n                        data.type = child.nodeName;\n                        data.parameters = parseEffectParameters(child);\n                        break;\n                    case \"extra\":\n                        data.extra = parseEffectExtra(child);\n                        break;\n                }\n            }\n            return data;\n        }\n        function parseEffectParameters(xml) {\n            const data = {};\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"emission\":\n                    case \"diffuse\":\n                    case \"specular\":\n                    case \"bump\":\n                    case \"ambient\":\n                    case \"shininess\":\n                    case \"transparency\":\n                        data[child.nodeName] = parseEffectParameter(child);\n                        break;\n                    case \"transparent\":\n                        data[child.nodeName] = {\n                            opaque: child.hasAttribute(\"opaque\") ? child.getAttribute(\"opaque\") : \"A_ONE\",\n                            data: parseEffectParameter(child)\n                        };\n                        break;\n                }\n            }\n            return data;\n        }\n        function parseEffectParameter(xml) {\n            const data = {};\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"color\":\n                        data[child.nodeName] = parseFloats(child.textContent);\n                        break;\n                    case \"float\":\n                        data[child.nodeName] = parseFloat(child.textContent);\n                        break;\n                    case \"texture\":\n                        data[child.nodeName] = {\n                            id: child.getAttribute(\"texture\"),\n                            extra: parseEffectParameterTexture(child)\n                        };\n                        break;\n                }\n            }\n            return data;\n        }\n        function parseEffectParameterTexture(xml) {\n            const data = {\n                technique: {}\n            };\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"extra\":\n                        parseEffectParameterTextureExtra(child, data);\n                        break;\n                }\n            }\n            return data;\n        }\n        function parseEffectParameterTextureExtra(xml, data) {\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"technique\":\n                        parseEffectParameterTextureExtraTechnique(child, data);\n                        break;\n                }\n            }\n        }\n        function parseEffectParameterTextureExtraTechnique(xml, data) {\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"repeatU\":\n                    case \"repeatV\":\n                    case \"offsetU\":\n                    case \"offsetV\":\n                        data.technique[child.nodeName] = parseFloat(child.textContent);\n                        break;\n                    case \"wrapU\":\n                    case \"wrapV\":\n                        // some files have values for wrapU/wrapV which become NaN via parseInt\n                        if (child.textContent.toUpperCase() === \"TRUE\") data.technique[child.nodeName] = 1;\n                        else if (child.textContent.toUpperCase() === \"FALSE\") data.technique[child.nodeName] = 0;\n                        else data.technique[child.nodeName] = parseInt(child.textContent);\n                        break;\n                    case \"bump\":\n                        data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n                        break;\n                }\n            }\n        }\n        function parseEffectExtra(xml) {\n            const data = {};\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"technique\":\n                        data.technique = parseEffectExtraTechnique(child);\n                        break;\n                }\n            }\n            return data;\n        }\n        function parseEffectExtraTechnique(xml) {\n            const data = {};\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"double_sided\":\n                        data[child.nodeName] = parseInt(child.textContent);\n                        break;\n                    case \"bump\":\n                        data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n                        break;\n                }\n            }\n            return data;\n        }\n        function parseEffectExtraTechniqueBump(xml) {\n            const data = {};\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"texture\":\n                        data[child.nodeName] = {\n                            id: child.getAttribute(\"texture\"),\n                            texcoord: child.getAttribute(\"texcoord\"),\n                            extra: parseEffectParameterTexture(child)\n                        };\n                        break;\n                }\n            }\n            return data;\n        }\n        function buildEffect(data) {\n            return data;\n        }\n        function getEffect(id) {\n            return getBuild(library.effects[id], buildEffect);\n        }\n        // material\n        function parseMaterial(xml) {\n            const data = {\n                name: xml.getAttribute(\"name\")\n            };\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"instance_effect\":\n                        data.url = parseId(child.getAttribute(\"url\"));\n                        break;\n                }\n            }\n            library.materials[xml.getAttribute(\"id\")] = data;\n        }\n        function getTextureLoader(image) {\n            let loader;\n            let extension = image.slice((image.lastIndexOf(\".\") - 1 >>> 0) + 2); // http://www.jstips.co/en/javascript/get-file-extension/\n            extension = extension.toLowerCase();\n            switch(extension){\n                case \"tga\":\n                    loader = tgaLoader;\n                    break;\n                default:\n                    loader = textureLoader;\n            }\n            return loader;\n        }\n        function buildMaterial(data) {\n            const effect = getEffect(data.url);\n            const technique = effect.profile.technique;\n            let material;\n            switch(technique.type){\n                case \"phong\":\n                case \"blinn\":\n                    material = new (0, $ilwiq.MeshPhongMaterial)();\n                    break;\n                case \"lambert\":\n                    material = new (0, $ilwiq.MeshLambertMaterial)();\n                    break;\n                default:\n                    material = new (0, $ilwiq.MeshBasicMaterial)();\n                    break;\n            }\n            material.name = data.name || \"\";\n            function getTexture(textureObject, colorSpace = null) {\n                const sampler = effect.profile.samplers[textureObject.id];\n                let image = null;\n                // get image\n                if (sampler !== undefined) {\n                    const surface = effect.profile.surfaces[sampler.source];\n                    image = getImage(surface.init_from);\n                } else {\n                    console.warn(\"THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).\");\n                    image = getImage(textureObject.id);\n                }\n                // create texture if image is avaiable\n                if (image !== null) {\n                    const loader = getTextureLoader(image);\n                    if (loader !== undefined) {\n                        const texture = loader.load(image);\n                        const extra = textureObject.extra;\n                        if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n                            const technique = extra.technique;\n                            texture.wrapS = technique.wrapU ? (0, $ilwiq.RepeatWrapping) : (0, $ilwiq.ClampToEdgeWrapping);\n                            texture.wrapT = technique.wrapV ? (0, $ilwiq.RepeatWrapping) : (0, $ilwiq.ClampToEdgeWrapping);\n                            texture.offset.set(technique.offsetU || 0, technique.offsetV || 0);\n                            texture.repeat.set(technique.repeatU || 1, technique.repeatV || 1);\n                        } else {\n                            texture.wrapS = (0, $ilwiq.RepeatWrapping);\n                            texture.wrapT = (0, $ilwiq.RepeatWrapping);\n                        }\n                        if (colorSpace !== null) texture.colorSpace = colorSpace;\n                        return texture;\n                    } else {\n                        console.warn(\"THREE.ColladaLoader: Loader for texture %s not found.\", image);\n                        return null;\n                    }\n                } else {\n                    console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id);\n                    return null;\n                }\n            }\n            const parameters = technique.parameters;\n            for(const key in parameters){\n                const parameter = parameters[key];\n                switch(key){\n                    case \"diffuse\":\n                        if (parameter.color) material.color.fromArray(parameter.color);\n                        if (parameter.texture) material.map = getTexture(parameter.texture, (0, $ilwiq.SRGBColorSpace));\n                        break;\n                    case \"specular\":\n                        if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n                        if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n                        break;\n                    case \"bump\":\n                        if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n                        break;\n                    case \"ambient\":\n                        if (parameter.texture) material.lightMap = getTexture(parameter.texture, (0, $ilwiq.SRGBColorSpace));\n                        break;\n                    case \"shininess\":\n                        if (parameter.float && material.shininess) material.shininess = parameter.float;\n                        break;\n                    case \"emission\":\n                        if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n                        if (parameter.texture) material.emissiveMap = getTexture(parameter.texture, (0, $ilwiq.SRGBColorSpace));\n                        break;\n                }\n            }\n            material.color.convertSRGBToLinear();\n            if (material.specular) material.specular.convertSRGBToLinear();\n            if (material.emissive) material.emissive.convertSRGBToLinear();\n            //\n            let transparent = parameters[\"transparent\"];\n            let transparency = parameters[\"transparency\"];\n            // <transparency> does not exist but <transparent>\n            if (transparency === undefined && transparent) transparency = {\n                float: 1\n            };\n            // <transparent> does not exist but <transparency>\n            if (transparent === undefined && transparency) transparent = {\n                opaque: \"A_ONE\",\n                data: {\n                    color: [\n                        1,\n                        1,\n                        1,\n                        1\n                    ]\n                }\n            };\n            if (transparent && transparency) {\n                // handle case if a texture exists but no color\n                if (transparent.data.texture) // we do not set an alpha map (see #13792)\n                material.transparent = true;\n                else {\n                    const color = transparent.data.color;\n                    switch(transparent.opaque){\n                        case \"A_ONE\":\n                            material.opacity = color[3] * transparency.float;\n                            break;\n                        case \"RGB_ZERO\":\n                            material.opacity = 1 - color[0] * transparency.float;\n                            break;\n                        case \"A_ZERO\":\n                            material.opacity = 1 - color[3] * transparency.float;\n                            break;\n                        case \"RGB_ONE\":\n                            material.opacity = color[0] * transparency.float;\n                            break;\n                        default:\n                            console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n                    }\n                    if (material.opacity < 1) material.transparent = true;\n                }\n            }\n            //\n            if (technique.extra !== undefined && technique.extra.technique !== undefined) {\n                const techniques = technique.extra.technique;\n                for(const k in techniques){\n                    const v = techniques[k];\n                    switch(k){\n                        case \"double_sided\":\n                            material.side = v === 1 ? (0, $ilwiq.DoubleSide) : (0, $ilwiq.FrontSide);\n                            break;\n                        case \"bump\":\n                            material.normalMap = getTexture(v.texture);\n                            material.normalScale = new (0, $ilwiq.Vector2)(1, 1);\n                            break;\n                    }\n                }\n            }\n            return material;\n        }\n        function getMaterial(id) {\n            return getBuild(library.materials[id], buildMaterial);\n        }\n        // camera\n        function parseCamera(xml) {\n            const data = {\n                name: xml.getAttribute(\"name\")\n            };\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"optics\":\n                        data.optics = parseCameraOptics(child);\n                        break;\n                }\n            }\n            library.cameras[xml.getAttribute(\"id\")] = data;\n        }\n        function parseCameraOptics(xml) {\n            for(let i = 0; i < xml.childNodes.length; i++){\n                const child = xml.childNodes[i];\n                switch(child.nodeName){\n                    case \"technique_common\":\n                        return parseCameraTechnique(child);\n                }\n            }\n            return {};\n        }\n        function parseCameraTechnique(xml) {\n            const data = {};\n            for(let i = 0; i < xml.childNodes.length; i++){\n                const child = xml.childNodes[i];\n                switch(child.nodeName){\n                    case \"perspective\":\n                    case \"orthographic\":\n                        data.technique = child.nodeName;\n                        data.parameters = parseCameraParameters(child);\n                        break;\n                }\n            }\n            return data;\n        }\n        function parseCameraParameters(xml) {\n            const data = {};\n            for(let i = 0; i < xml.childNodes.length; i++){\n                const child = xml.childNodes[i];\n                switch(child.nodeName){\n                    case \"xfov\":\n                    case \"yfov\":\n                    case \"xmag\":\n                    case \"ymag\":\n                    case \"znear\":\n                    case \"zfar\":\n                    case \"aspect_ratio\":\n                        data[child.nodeName] = parseFloat(child.textContent);\n                        break;\n                }\n            }\n            return data;\n        }\n        function buildCamera(data) {\n            let camera;\n            switch(data.optics.technique){\n                case \"perspective\":\n                    camera = new (0, $ilwiq.PerspectiveCamera)(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n                    break;\n                case \"orthographic\":\n                    let ymag = data.optics.parameters.ymag;\n                    let xmag = data.optics.parameters.xmag;\n                    const aspectRatio = data.optics.parameters.aspect_ratio;\n                    xmag = xmag === undefined ? ymag * aspectRatio : xmag;\n                    ymag = ymag === undefined ? xmag / aspectRatio : ymag;\n                    xmag *= 0.5;\n                    ymag *= 0.5;\n                    camera = new (0, $ilwiq.OrthographicCamera)(-xmag, xmag, ymag, -ymag, data.optics.parameters.znear, data.optics.parameters.zfar);\n                    break;\n                default:\n                    camera = new (0, $ilwiq.PerspectiveCamera)();\n                    break;\n            }\n            camera.name = data.name || \"\";\n            return camera;\n        }\n        function getCamera(id) {\n            const data = library.cameras[id];\n            if (data !== undefined) return getBuild(data, buildCamera);\n            console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id);\n            return null;\n        }\n        // light\n        function parseLight(xml) {\n            let data = {};\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"technique_common\":\n                        data = parseLightTechnique(child);\n                        break;\n                }\n            }\n            library.lights[xml.getAttribute(\"id\")] = data;\n        }\n        function parseLightTechnique(xml) {\n            const data = {};\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"directional\":\n                    case \"point\":\n                    case \"spot\":\n                    case \"ambient\":\n                        data.technique = child.nodeName;\n                        data.parameters = parseLightParameters(child);\n                }\n            }\n            return data;\n        }\n        function parseLightParameters(xml) {\n            const data = {};\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"color\":\n                        const array = parseFloats(child.textContent);\n                        data.color = new (0, $ilwiq.Color)().fromArray(array).convertSRGBToLinear();\n                        break;\n                    case \"falloff_angle\":\n                        data.falloffAngle = parseFloat(child.textContent);\n                        break;\n                    case \"quadratic_attenuation\":\n                        const f = parseFloat(child.textContent);\n                        data.distance = f ? Math.sqrt(1 / f) : 0;\n                        break;\n                }\n            }\n            return data;\n        }\n        function buildLight(data) {\n            let light;\n            switch(data.technique){\n                case \"directional\":\n                    light = new (0, $ilwiq.DirectionalLight)();\n                    break;\n                case \"point\":\n                    light = new (0, $ilwiq.PointLight)();\n                    break;\n                case \"spot\":\n                    light = new (0, $ilwiq.SpotLight)();\n                    break;\n                case \"ambient\":\n                    light = new (0, $ilwiq.AmbientLight)();\n                    break;\n            }\n            if (data.parameters.color) light.color.copy(data.parameters.color);\n            if (data.parameters.distance) light.distance = data.parameters.distance;\n            return light;\n        }\n        function getLight(id) {\n            const data = library.lights[id];\n            if (data !== undefined) return getBuild(data, buildLight);\n            console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id);\n            return null;\n        }\n        // geometry\n        function parseGeometry(xml) {\n            const data = {\n                name: xml.getAttribute(\"name\"),\n                sources: {},\n                vertices: {},\n                primitives: []\n            };\n            const mesh = getElementsByTagName(xml, \"mesh\")[0];\n            // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n            if (mesh === undefined) return;\n            for(let i = 0; i < mesh.childNodes.length; i++){\n                const child = mesh.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                const id = child.getAttribute(\"id\");\n                switch(child.nodeName){\n                    case \"source\":\n                        data.sources[id] = parseSource(child);\n                        break;\n                    case \"vertices\":\n                        // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n                        data.vertices = parseGeometryVertices(child);\n                        break;\n                    case \"polygons\":\n                        console.warn(\"THREE.ColladaLoader: Unsupported primitive type: \", child.nodeName);\n                        break;\n                    case \"lines\":\n                    case \"linestrips\":\n                    case \"polylist\":\n                    case \"triangles\":\n                        data.primitives.push(parseGeometryPrimitive(child));\n                        break;\n                    default:\n                        console.log(child);\n                }\n            }\n            library.geometries[xml.getAttribute(\"id\")] = data;\n        }\n        function parseSource(xml) {\n            const data = {\n                array: [],\n                stride: 3\n            };\n            for(let i = 0; i < xml.childNodes.length; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"float_array\":\n                        data.array = parseFloats(child.textContent);\n                        break;\n                    case \"Name_array\":\n                        data.array = parseStrings(child.textContent);\n                        break;\n                    case \"technique_common\":\n                        const accessor = getElementsByTagName(child, \"accessor\")[0];\n                        if (accessor !== undefined) data.stride = parseInt(accessor.getAttribute(\"stride\"));\n                        break;\n                }\n            }\n            return data;\n        }\n        function parseGeometryVertices(xml) {\n            const data = {};\n            for(let i = 0; i < xml.childNodes.length; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                data[child.getAttribute(\"semantic\")] = parseId(child.getAttribute(\"source\"));\n            }\n            return data;\n        }\n        function parseGeometryPrimitive(xml) {\n            const primitive = {\n                type: xml.nodeName,\n                material: xml.getAttribute(\"material\"),\n                count: parseInt(xml.getAttribute(\"count\")),\n                inputs: {},\n                stride: 0,\n                hasUV: false\n            };\n            for(let i = 0, l = xml.childNodes.length; i < l; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"input\":\n                        const id = parseId(child.getAttribute(\"source\"));\n                        const semantic = child.getAttribute(\"semantic\");\n                        const offset = parseInt(child.getAttribute(\"offset\"));\n                        const set = parseInt(child.getAttribute(\"set\"));\n                        const inputname = set > 0 ? semantic + set : semantic;\n                        primitive.inputs[inputname] = {\n                            id: id,\n                            offset: offset\n                        };\n                        primitive.stride = Math.max(primitive.stride, offset + 1);\n                        if (semantic === \"TEXCOORD\") primitive.hasUV = true;\n                        break;\n                    case \"vcount\":\n                        primitive.vcount = parseInts(child.textContent);\n                        break;\n                    case \"p\":\n                        primitive.p = parseInts(child.textContent);\n                        break;\n                }\n            }\n            return primitive;\n        }\n        function groupPrimitives(primitives) {\n            const build = {};\n            for(let i = 0; i < primitives.length; i++){\n                const primitive = primitives[i];\n                if (build[primitive.type] === undefined) build[primitive.type] = [];\n                build[primitive.type].push(primitive);\n            }\n            return build;\n        }\n        function checkUVCoordinates(primitives) {\n            let count = 0;\n            for(let i = 0, l = primitives.length; i < l; i++){\n                const primitive = primitives[i];\n                if (primitive.hasUV === true) count++;\n            }\n            if (count > 0 && count < primitives.length) primitives.uvsNeedsFix = true;\n        }\n        function buildGeometry(data) {\n            const build = {};\n            const sources = data.sources;\n            const vertices = data.vertices;\n            const primitives = data.primitives;\n            if (primitives.length === 0) return {};\n            // our goal is to create one buffer geometry for a single type of primitives\n            // first, we group all primitives by their type\n            const groupedPrimitives = groupPrimitives(primitives);\n            for(const type in groupedPrimitives){\n                const primitiveType = groupedPrimitives[type];\n                // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n                checkUVCoordinates(primitiveType);\n                // third, create a buffer geometry for each type of primitives\n                build[type] = buildGeometryType(primitiveType, sources, vertices);\n            }\n            return build;\n        }\n        function buildGeometryType(primitives, sources, vertices) {\n            const build = {};\n            const position = {\n                array: [],\n                stride: 0\n            };\n            const normal = {\n                array: [],\n                stride: 0\n            };\n            const uv = {\n                array: [],\n                stride: 0\n            };\n            const uv1 = {\n                array: [],\n                stride: 0\n            };\n            const color = {\n                array: [],\n                stride: 0\n            };\n            const skinIndex = {\n                array: [],\n                stride: 4\n            };\n            const skinWeight = {\n                array: [],\n                stride: 4\n            };\n            const geometry = new (0, $ilwiq.BufferGeometry)();\n            const materialKeys = [];\n            let start = 0;\n            for(let p = 0; p < primitives.length; p++){\n                const primitive = primitives[p];\n                const inputs = primitive.inputs;\n                // groups\n                let count = 0;\n                switch(primitive.type){\n                    case \"lines\":\n                    case \"linestrips\":\n                        count = primitive.count * 2;\n                        break;\n                    case \"triangles\":\n                        count = primitive.count * 3;\n                        break;\n                    case \"polylist\":\n                        for(let g = 0; g < primitive.count; g++){\n                            const vc = primitive.vcount[g];\n                            switch(vc){\n                                case 3:\n                                    count += 3; // single triangle\n                                    break;\n                                case 4:\n                                    count += 6; // quad, subdivided into two triangles\n                                    break;\n                                default:\n                                    count += (vc - 2) * 3; // polylist with more than four vertices\n                                    break;\n                            }\n                        }\n                        break;\n                    default:\n                        console.warn(\"THREE.ColladaLoader: Unknow primitive type:\", primitive.type);\n                }\n                geometry.addGroup(start, count, p);\n                start += count;\n                // material\n                if (primitive.material) materialKeys.push(primitive.material);\n                // geometry data\n                for(const name in inputs){\n                    const input = inputs[name];\n                    switch(name){\n                        case \"VERTEX\":\n                            for(const key in vertices){\n                                const id = vertices[key];\n                                switch(key){\n                                    case \"POSITION\":\n                                        const prevLength = position.array.length;\n                                        buildGeometryData(primitive, sources[id], input.offset, position.array);\n                                        position.stride = sources[id].stride;\n                                        if (sources.skinWeights && sources.skinIndices) {\n                                            buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                                            buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                                        }\n                                        // see #3803\n                                        if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                                            const count = (position.array.length - prevLength) / position.stride;\n                                            for(let i = 0; i < count; i++)// fill missing uv coordinates\n                                            uv.array.push(0, 0);\n                                        }\n                                        break;\n                                    case \"NORMAL\":\n                                        buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                                        normal.stride = sources[id].stride;\n                                        break;\n                                    case \"COLOR\":\n                                        buildGeometryData(primitive, sources[id], input.offset, color.array);\n                                        color.stride = sources[id].stride;\n                                        break;\n                                    case \"TEXCOORD\":\n                                        buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                                        uv.stride = sources[id].stride;\n                                        break;\n                                    case \"TEXCOORD1\":\n                                        buildGeometryData(primitive, sources[id], input.offset, uv1.array);\n                                        uv.stride = sources[id].stride;\n                                        break;\n                                    default:\n                                        console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                                }\n                            }\n                            break;\n                        case \"NORMAL\":\n                            buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n                            normal.stride = sources[input.id].stride;\n                            break;\n                        case \"COLOR\":\n                            buildGeometryData(primitive, sources[input.id], input.offset, color.array, true);\n                            color.stride = sources[input.id].stride;\n                            break;\n                        case \"TEXCOORD\":\n                            buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n                            uv.stride = sources[input.id].stride;\n                            break;\n                        case \"TEXCOORD1\":\n                            buildGeometryData(primitive, sources[input.id], input.offset, uv1.array);\n                            uv1.stride = sources[input.id].stride;\n                            break;\n                    }\n                }\n            }\n            // build geometry\n            if (position.array.length > 0) geometry.setAttribute(\"position\", new (0, $ilwiq.Float32BufferAttribute)(position.array, position.stride));\n            if (normal.array.length > 0) geometry.setAttribute(\"normal\", new (0, $ilwiq.Float32BufferAttribute)(normal.array, normal.stride));\n            if (color.array.length > 0) geometry.setAttribute(\"color\", new (0, $ilwiq.Float32BufferAttribute)(color.array, color.stride));\n            if (uv.array.length > 0) geometry.setAttribute(\"uv\", new (0, $ilwiq.Float32BufferAttribute)(uv.array, uv.stride));\n            if (uv1.array.length > 0) geometry.setAttribute(\"uv1\", new (0, $ilwiq.Float32BufferAttribute)(uv1.array, uv1.stride));\n            if (skinIndex.array.length > 0) geometry.setAttribute(\"skinIndex\", new (0, $ilwiq.Float32BufferAttribute)(skinIndex.array, skinIndex.stride));\n            if (skinWeight.array.length > 0) geometry.setAttribute(\"skinWeight\", new (0, $ilwiq.Float32BufferAttribute)(skinWeight.array, skinWeight.stride));\n            build.data = geometry;\n            build.type = primitives[0].type;\n            build.materialKeys = materialKeys;\n            return build;\n        }\n        function buildGeometryData(primitive, source, offset, array, isColor = false) {\n            const indices = primitive.p;\n            const stride = primitive.stride;\n            const vcount = primitive.vcount;\n            function pushVector(i) {\n                let index = indices[i + offset] * sourceStride;\n                const length = index + sourceStride;\n                for(; index < length; index++)array.push(sourceArray[index]);\n                if (isColor) {\n                    // convert the vertex colors from srgb to linear if present\n                    const startIndex = array.length - sourceStride - 1;\n                    tempColor.setRGB(array[startIndex + 0], array[startIndex + 1], array[startIndex + 2]).convertSRGBToLinear();\n                    array[startIndex + 0] = tempColor.r;\n                    array[startIndex + 1] = tempColor.g;\n                    array[startIndex + 2] = tempColor.b;\n                }\n            }\n            const sourceArray = source.array;\n            const sourceStride = source.stride;\n            if (primitive.vcount !== undefined) {\n                let index = 0;\n                for(let i = 0, l = vcount.length; i < l; i++){\n                    const count = vcount[i];\n                    if (count === 4) {\n                        const a = index + stride * 0;\n                        const b = index + stride * 1;\n                        const c = index + stride * 2;\n                        const d = index + stride * 3;\n                        pushVector(a);\n                        pushVector(b);\n                        pushVector(d);\n                        pushVector(b);\n                        pushVector(c);\n                        pushVector(d);\n                    } else if (count === 3) {\n                        const a = index + stride * 0;\n                        const b = index + stride * 1;\n                        const c = index + stride * 2;\n                        pushVector(a);\n                        pushVector(b);\n                        pushVector(c);\n                    } else if (count > 4) for(let k = 1, kl = count - 2; k <= kl; k++){\n                        const a = index + stride * 0;\n                        const b = index + stride * k;\n                        const c = index + stride * (k + 1);\n                        pushVector(a);\n                        pushVector(b);\n                        pushVector(c);\n                    }\n                    index += stride * count;\n                }\n            } else for(let i = 0, l = indices.length; i < l; i += stride)pushVector(i);\n        }\n        function getGeometry(id) {\n            return getBuild(library.geometries[id], buildGeometry);\n        }\n        // kinematics\n        function parseKinematicsModel(xml) {\n            const data = {\n                name: xml.getAttribute(\"name\") || \"\",\n                joints: {},\n                links: []\n            };\n            for(let i = 0; i < xml.childNodes.length; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"technique_common\":\n                        parseKinematicsTechniqueCommon(child, data);\n                        break;\n                }\n            }\n            library.kinematicsModels[xml.getAttribute(\"id\")] = data;\n        }\n        function buildKinematicsModel(data) {\n            if (data.build !== undefined) return data.build;\n            return data;\n        }\n        function getKinematicsModel(id) {\n            return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n        }\n        function parseKinematicsTechniqueCommon(xml, data) {\n            for(let i = 0; i < xml.childNodes.length; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"joint\":\n                        data.joints[child.getAttribute(\"sid\")] = parseKinematicsJoint(child);\n                        break;\n                    case \"link\":\n                        data.links.push(parseKinematicsLink(child));\n                        break;\n                }\n            }\n        }\n        function parseKinematicsJoint(xml) {\n            let data;\n            for(let i = 0; i < xml.childNodes.length; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"prismatic\":\n                    case \"revolute\":\n                        data = parseKinematicsJointParameter(child);\n                        break;\n                }\n            }\n            return data;\n        }\n        function parseKinematicsJointParameter(xml) {\n            const data = {\n                sid: xml.getAttribute(\"sid\"),\n                name: xml.getAttribute(\"name\") || \"\",\n                axis: new (0, $ilwiq.Vector3)(),\n                limits: {\n                    min: 0,\n                    max: 0\n                },\n                type: xml.nodeName,\n                static: false,\n                zeroPosition: 0,\n                middlePosition: 0\n            };\n            for(let i = 0; i < xml.childNodes.length; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"axis\":\n                        const array = parseFloats(child.textContent);\n                        data.axis.fromArray(array);\n                        break;\n                    case \"limits\":\n                        const max = child.getElementsByTagName(\"max\")[0];\n                        const min = child.getElementsByTagName(\"min\")[0];\n                        data.limits.max = parseFloat(max.textContent);\n                        data.limits.min = parseFloat(min.textContent);\n                        break;\n                }\n            }\n            // if min is equal to or greater than max, consider the joint static\n            if (data.limits.min >= data.limits.max) data.static = true;\n            // calculate middle position\n            data.middlePosition = (data.limits.min + data.limits.max) / 2.0;\n            return data;\n        }\n        function parseKinematicsLink(xml) {\n            const data = {\n                sid: xml.getAttribute(\"sid\"),\n                name: xml.getAttribute(\"name\") || \"\",\n                attachments: [],\n                transforms: []\n            };\n            for(let i = 0; i < xml.childNodes.length; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"attachment_full\":\n                        data.attachments.push(parseKinematicsAttachment(child));\n                        break;\n                    case \"matrix\":\n                    case \"translate\":\n                    case \"rotate\":\n                        data.transforms.push(parseKinematicsTransform(child));\n                        break;\n                }\n            }\n            return data;\n        }\n        function parseKinematicsAttachment(xml) {\n            const data = {\n                joint: xml.getAttribute(\"joint\").split(\"/\").pop(),\n                transforms: [],\n                links: []\n            };\n            for(let i = 0; i < xml.childNodes.length; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"link\":\n                        data.links.push(parseKinematicsLink(child));\n                        break;\n                    case \"matrix\":\n                    case \"translate\":\n                    case \"rotate\":\n                        data.transforms.push(parseKinematicsTransform(child));\n                        break;\n                }\n            }\n            return data;\n        }\n        function parseKinematicsTransform(xml) {\n            const data = {\n                type: xml.nodeName\n            };\n            const array = parseFloats(xml.textContent);\n            switch(data.type){\n                case \"matrix\":\n                    data.obj = new (0, $ilwiq.Matrix4)();\n                    data.obj.fromArray(array).transpose();\n                    break;\n                case \"translate\":\n                    data.obj = new (0, $ilwiq.Vector3)();\n                    data.obj.fromArray(array);\n                    break;\n                case \"rotate\":\n                    data.obj = new (0, $ilwiq.Vector3)();\n                    data.obj.fromArray(array);\n                    data.angle = (0, $ilwiq.MathUtils).degToRad(array[3]);\n                    break;\n            }\n            return data;\n        }\n        // physics\n        function parsePhysicsModel(xml) {\n            const data = {\n                name: xml.getAttribute(\"name\") || \"\",\n                rigidBodies: {}\n            };\n            for(let i = 0; i < xml.childNodes.length; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"rigid_body\":\n                        data.rigidBodies[child.getAttribute(\"name\")] = {};\n                        parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute(\"name\")]);\n                        break;\n                }\n            }\n            library.physicsModels[xml.getAttribute(\"id\")] = data;\n        }\n        function parsePhysicsRigidBody(xml, data) {\n            for(let i = 0; i < xml.childNodes.length; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"technique_common\":\n                        parsePhysicsTechniqueCommon(child, data);\n                        break;\n                }\n            }\n        }\n        function parsePhysicsTechniqueCommon(xml, data) {\n            for(let i = 0; i < xml.childNodes.length; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"inertia\":\n                        data.inertia = parseFloats(child.textContent);\n                        break;\n                    case \"mass\":\n                        data.mass = parseFloats(child.textContent)[0];\n                        break;\n                }\n            }\n        }\n        // scene\n        function parseKinematicsScene(xml) {\n            const data = {\n                bindJointAxis: []\n            };\n            for(let i = 0; i < xml.childNodes.length; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"bind_joint_axis\":\n                        data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n                        break;\n                }\n            }\n            library.kinematicsScenes[parseId(xml.getAttribute(\"url\"))] = data;\n        }\n        function parseKinematicsBindJointAxis(xml) {\n            const data = {\n                target: xml.getAttribute(\"target\").split(\"/\").pop()\n            };\n            for(let i = 0; i < xml.childNodes.length; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                switch(child.nodeName){\n                    case \"axis\":\n                        const param = child.getElementsByTagName(\"param\")[0];\n                        data.axis = param.textContent;\n                        const tmpJointIndex = data.axis.split(\"inst_\").pop().split(\"axis\")[0];\n                        data.jointIndex = tmpJointIndex.substring(0, tmpJointIndex.length - 1);\n                        break;\n                }\n            }\n            return data;\n        }\n        function buildKinematicsScene(data) {\n            if (data.build !== undefined) return data.build;\n            return data;\n        }\n        function getKinematicsScene(id) {\n            return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n        }\n        function setupKinematics() {\n            const kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n            const kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n            const visualSceneId = Object.keys(library.visualScenes)[0];\n            if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;\n            const kinematicsModel = getKinematicsModel(kinematicsModelId);\n            const kinematicsScene = getKinematicsScene(kinematicsSceneId);\n            const visualScene = getVisualScene(visualSceneId);\n            const bindJointAxis = kinematicsScene.bindJointAxis;\n            const jointMap = {};\n            for(let i = 0, l = bindJointAxis.length; i < l; i++){\n                const axis = bindJointAxis[i];\n                // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n                const targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n                if (targetElement) {\n                    // get the parent of the transform element\n                    const parentVisualElement = targetElement.parentElement;\n                    // connect the joint of the kinematics model with the element in the visual scene\n                    connect(axis.jointIndex, parentVisualElement);\n                }\n            }\n            function connect(jointIndex, visualElement) {\n                const visualElementName = visualElement.getAttribute(\"name\");\n                const joint = kinematicsModel.joints[jointIndex];\n                visualScene.traverse(function(object) {\n                    if (object.name === visualElementName) jointMap[jointIndex] = {\n                        object: object,\n                        transforms: buildTransformList(visualElement),\n                        joint: joint,\n                        position: joint.zeroPosition\n                    };\n                });\n            }\n            const m0 = new (0, $ilwiq.Matrix4)();\n            kinematics = {\n                joints: kinematicsModel && kinematicsModel.joints,\n                getJointValue: function(jointIndex) {\n                    const jointData = jointMap[jointIndex];\n                    if (jointData) return jointData.position;\n                    else console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" doesn't exist.\");\n                },\n                setJointValue: function(jointIndex, value) {\n                    const jointData = jointMap[jointIndex];\n                    if (jointData) {\n                        const joint = jointData.joint;\n                        if (value > joint.limits.max || value < joint.limits.min) console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" value \" + value + \" outside of limits (min: \" + joint.limits.min + \", max: \" + joint.limits.max + \").\");\n                        else if (joint.static) console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" is static.\");\n                        else {\n                            const object = jointData.object;\n                            const axis = joint.axis;\n                            const transforms = jointData.transforms;\n                            matrix.identity();\n                            // each update, we have to apply all transforms in the correct order\n                            for(let i = 0; i < transforms.length; i++){\n                                const transform = transforms[i];\n                                // if there is a connection of the transform node with a joint, apply the joint value\n                                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) switch(joint.type){\n                                    case \"revolute\":\n                                        matrix.multiply(m0.makeRotationAxis(axis, (0, $ilwiq.MathUtils).degToRad(value)));\n                                        break;\n                                    case \"prismatic\":\n                                        matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n                                        break;\n                                    default:\n                                        console.warn(\"THREE.ColladaLoader: Unknown joint type: \" + joint.type);\n                                        break;\n                                }\n                                else switch(transform.type){\n                                    case \"matrix\":\n                                        matrix.multiply(transform.obj);\n                                        break;\n                                    case \"translate\":\n                                        matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                                        break;\n                                    case \"scale\":\n                                        matrix.scale(transform.obj);\n                                        break;\n                                    case \"rotate\":\n                                        matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                                        break;\n                                }\n                            }\n                            object.matrix.copy(matrix);\n                            object.matrix.decompose(object.position, object.quaternion, object.scale);\n                            jointMap[jointIndex].position = value;\n                        }\n                    } else console.log(\"THREE.ColladaLoader: \" + jointIndex + \" does not exist.\");\n                }\n            };\n        }\n        function buildTransformList(node) {\n            const transforms = [];\n            const xml = collada.querySelector('[id=\"' + node.id + '\"]');\n            for(let i = 0; i < xml.childNodes.length; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                let array, vector;\n                switch(child.nodeName){\n                    case \"matrix\":\n                        array = parseFloats(child.textContent);\n                        const matrix = new (0, $ilwiq.Matrix4)().fromArray(array).transpose();\n                        transforms.push({\n                            sid: child.getAttribute(\"sid\"),\n                            type: child.nodeName,\n                            obj: matrix\n                        });\n                        break;\n                    case \"translate\":\n                    case \"scale\":\n                        array = parseFloats(child.textContent);\n                        vector = new (0, $ilwiq.Vector3)().fromArray(array);\n                        transforms.push({\n                            sid: child.getAttribute(\"sid\"),\n                            type: child.nodeName,\n                            obj: vector\n                        });\n                        break;\n                    case \"rotate\":\n                        array = parseFloats(child.textContent);\n                        vector = new (0, $ilwiq.Vector3)().fromArray(array);\n                        const angle = (0, $ilwiq.MathUtils).degToRad(array[3]);\n                        transforms.push({\n                            sid: child.getAttribute(\"sid\"),\n                            type: child.nodeName,\n                            obj: vector,\n                            angle: angle\n                        });\n                        break;\n                }\n            }\n            return transforms;\n        }\n        // nodes\n        function prepareNodes(xml) {\n            const elements = xml.getElementsByTagName(\"node\");\n            // ensure all node elements have id attributes\n            for(let i = 0; i < elements.length; i++){\n                const element = elements[i];\n                if (element.hasAttribute(\"id\") === false) element.setAttribute(\"id\", generateId());\n            }\n        }\n        const matrix = new (0, $ilwiq.Matrix4)();\n        const vector = new (0, $ilwiq.Vector3)();\n        function parseNode(xml) {\n            const data = {\n                name: xml.getAttribute(\"name\") || \"\",\n                type: xml.getAttribute(\"type\"),\n                id: xml.getAttribute(\"id\"),\n                sid: xml.getAttribute(\"sid\"),\n                matrix: new (0, $ilwiq.Matrix4)(),\n                nodes: [],\n                instanceCameras: [],\n                instanceControllers: [],\n                instanceLights: [],\n                instanceGeometries: [],\n                instanceNodes: [],\n                transforms: {}\n            };\n            for(let i = 0; i < xml.childNodes.length; i++){\n                const child = xml.childNodes[i];\n                if (child.nodeType !== 1) continue;\n                let array;\n                switch(child.nodeName){\n                    case \"node\":\n                        data.nodes.push(child.getAttribute(\"id\"));\n                        parseNode(child);\n                        break;\n                    case \"instance_camera\":\n                        data.instanceCameras.push(parseId(child.getAttribute(\"url\")));\n                        break;\n                    case \"instance_controller\":\n                        data.instanceControllers.push(parseNodeInstance(child));\n                        break;\n                    case \"instance_light\":\n                        data.instanceLights.push(parseId(child.getAttribute(\"url\")));\n                        break;\n                    case \"instance_geometry\":\n                        data.instanceGeometries.push(parseNodeInstance(child));\n                        break;\n                    case \"instance_node\":\n                        data.instanceNodes.push(parseId(child.getAttribute(\"url\")));\n                        break;\n                    case \"matrix\":\n                        array = parseFloats(child.textContent);\n                        data.matrix.multiply(matrix.fromArray(array).transpose());\n                        data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n                        break;\n                    case \"translate\":\n                        array = parseFloats(child.textContent);\n                        vector.fromArray(array);\n                        data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n                        data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n                        break;\n                    case \"rotate\":\n                        array = parseFloats(child.textContent);\n                        const angle = (0, $ilwiq.MathUtils).degToRad(array[3]);\n                        data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n                        data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n                        break;\n                    case \"scale\":\n                        array = parseFloats(child.textContent);\n                        data.matrix.scale(vector.fromArray(array));\n                        data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n                        break;\n                    case \"extra\":\n                        break;\n                    default:\n                        console.log(child);\n                }\n            }\n            if (hasNode(data.id)) console.warn(\"THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.\", data.id);\n            else library.nodes[data.id] = data;\n            return data;\n        }\n        function parseNodeInstance(xml) {\n            const data = {\n                id: parseId(xml.getAttribute(\"url\")),\n                materials: {},\n                skeletons: []\n            };\n            for(let i = 0; i < xml.childNodes.length; i++){\n                const child = xml.childNodes[i];\n                switch(child.nodeName){\n                    case \"bind_material\":\n                        const instances = child.getElementsByTagName(\"instance_material\");\n                        for(let j = 0; j < instances.length; j++){\n                            const instance = instances[j];\n                            const symbol = instance.getAttribute(\"symbol\");\n                            const target = instance.getAttribute(\"target\");\n                            data.materials[symbol] = parseId(target);\n                        }\n                        break;\n                    case \"skeleton\":\n                        data.skeletons.push(parseId(child.textContent));\n                        break;\n                    default:\n                        break;\n                }\n            }\n            return data;\n        }\n        function buildSkeleton(skeletons, joints) {\n            const boneData = [];\n            const sortedBoneData = [];\n            let i, j, data;\n            // a skeleton can have multiple root bones. collada expresses this\n            // situtation with multiple \"skeleton\" tags per controller instance\n            for(i = 0; i < skeletons.length; i++){\n                const skeleton = skeletons[i];\n                let root;\n                if (hasNode(skeleton)) {\n                    root = getNode(skeleton);\n                    buildBoneHierarchy(root, joints, boneData);\n                } else if (hasVisualScene(skeleton)) {\n                    // handle case where the skeleton refers to the visual scene (#13335)\n                    const visualScene = library.visualScenes[skeleton];\n                    const children = visualScene.children;\n                    for(let j = 0; j < children.length; j++){\n                        const child = children[j];\n                        if (child.type === \"JOINT\") {\n                            const root = getNode(child.id);\n                            buildBoneHierarchy(root, joints, boneData);\n                        }\n                    }\n                } else console.error(\"THREE.ColladaLoader: Unable to find root bone of skeleton with ID:\", skeleton);\n            }\n            // sort bone data (the order is defined in the corresponding controller)\n            for(i = 0; i < joints.length; i++)for(j = 0; j < boneData.length; j++){\n                data = boneData[j];\n                if (data.bone.name === joints[i].name) {\n                    sortedBoneData[i] = data;\n                    data.processed = true;\n                    break;\n                }\n            }\n            // add unprocessed bone data at the end of the list\n            for(i = 0; i < boneData.length; i++){\n                data = boneData[i];\n                if (data.processed === false) {\n                    sortedBoneData.push(data);\n                    data.processed = true;\n                }\n            }\n            // setup arrays for skeleton creation\n            const bones = [];\n            const boneInverses = [];\n            for(i = 0; i < sortedBoneData.length; i++){\n                data = sortedBoneData[i];\n                bones.push(data.bone);\n                boneInverses.push(data.boneInverse);\n            }\n            return new (0, $ilwiq.Skeleton)(bones, boneInverses);\n        }\n        function buildBoneHierarchy(root, joints, boneData) {\n            // setup bone data from visual scene\n            root.traverse(function(object) {\n                if (object.isBone === true) {\n                    let boneInverse;\n                    // retrieve the boneInverse from the controller data\n                    for(let i = 0; i < joints.length; i++){\n                        const joint = joints[i];\n                        if (joint.name === object.name) {\n                            boneInverse = joint.boneInverse;\n                            break;\n                        }\n                    }\n                    if (boneInverse === undefined) // Unfortunately, there can be joints in the visual scene that are not part of the\n                    // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n                    // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n                    // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n                    // ensure a correct animation of the model.\n                    boneInverse = new (0, $ilwiq.Matrix4)();\n                    boneData.push({\n                        bone: object,\n                        boneInverse: boneInverse,\n                        processed: false\n                    });\n                }\n            });\n        }\n        function buildNode(data) {\n            const objects = [];\n            const matrix = data.matrix;\n            const nodes = data.nodes;\n            const type = data.type;\n            const instanceCameras = data.instanceCameras;\n            const instanceControllers = data.instanceControllers;\n            const instanceLights = data.instanceLights;\n            const instanceGeometries = data.instanceGeometries;\n            const instanceNodes = data.instanceNodes;\n            // nodes\n            for(let i = 0, l = nodes.length; i < l; i++)objects.push(getNode(nodes[i]));\n            // instance cameras\n            for(let i = 0, l = instanceCameras.length; i < l; i++){\n                const instanceCamera = getCamera(instanceCameras[i]);\n                if (instanceCamera !== null) objects.push(instanceCamera.clone());\n            }\n            // instance controllers\n            for(let i = 0, l = instanceControllers.length; i < l; i++){\n                const instance = instanceControllers[i];\n                const controller = getController(instance.id);\n                const geometries = getGeometry(controller.id);\n                const newObjects = buildObjects(geometries, instance.materials);\n                const skeletons = instance.skeletons;\n                const joints = controller.skin.joints;\n                const skeleton = buildSkeleton(skeletons, joints);\n                for(let j = 0, jl = newObjects.length; j < jl; j++){\n                    const object = newObjects[j];\n                    if (object.isSkinnedMesh) {\n                        object.bind(skeleton, controller.skin.bindMatrix);\n                        object.normalizeSkinWeights();\n                    }\n                    objects.push(object);\n                }\n            }\n            // instance lights\n            for(let i = 0, l = instanceLights.length; i < l; i++){\n                const instanceLight = getLight(instanceLights[i]);\n                if (instanceLight !== null) objects.push(instanceLight.clone());\n            }\n            // instance geometries\n            for(let i = 0, l = instanceGeometries.length; i < l; i++){\n                const instance = instanceGeometries[i];\n                // a single geometry instance in collada can lead to multiple object3Ds.\n                // this is the case when primitives are combined like triangles and lines\n                const geometries = getGeometry(instance.id);\n                const newObjects = buildObjects(geometries, instance.materials);\n                for(let j = 0, jl = newObjects.length; j < jl; j++)objects.push(newObjects[j]);\n            }\n            // instance nodes\n            for(let i = 0, l = instanceNodes.length; i < l; i++)objects.push(getNode(instanceNodes[i]).clone());\n            let object;\n            if (nodes.length === 0 && objects.length === 1) object = objects[0];\n            else {\n                object = type === \"JOINT\" ? new (0, $ilwiq.Bone)() : new (0, $ilwiq.Group)();\n                for(let i = 0; i < objects.length; i++)object.add(objects[i]);\n            }\n            object.name = type === \"JOINT\" ? data.sid : data.name;\n            object.matrix.copy(matrix);\n            object.matrix.decompose(object.position, object.quaternion, object.scale);\n            return object;\n        }\n        const fallbackMaterial = new (0, $ilwiq.MeshBasicMaterial)({\n            name: (0, $ilwiq.Loader).DEFAULT_MATERIAL_NAME,\n            color: 0xff00ff\n        });\n        function resolveMaterialBinding(keys, instanceMaterials) {\n            const materials = [];\n            for(let i = 0, l = keys.length; i < l; i++){\n                const id = instanceMaterials[keys[i]];\n                if (id === undefined) {\n                    console.warn(\"THREE.ColladaLoader: Material with key %s not found. Apply fallback material.\", keys[i]);\n                    materials.push(fallbackMaterial);\n                } else materials.push(getMaterial(id));\n            }\n            return materials;\n        }\n        function buildObjects(geometries, instanceMaterials) {\n            const objects = [];\n            for(const type in geometries){\n                const geometry = geometries[type];\n                const materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);\n                // handle case if no materials are defined\n                if (materials.length === 0) {\n                    if (type === \"lines\" || type === \"linestrips\") materials.push(new (0, $ilwiq.LineBasicMaterial)());\n                    else materials.push(new (0, $ilwiq.MeshPhongMaterial)());\n                }\n                // Collada allows to use phong and lambert materials with lines. Replacing these cases with LineBasicMaterial.\n                if (type === \"lines\" || type === \"linestrips\") for(let i = 0, l = materials.length; i < l; i++){\n                    const material = materials[i];\n                    if (material.isMeshPhongMaterial === true || material.isMeshLambertMaterial === true) {\n                        const lineMaterial = new (0, $ilwiq.LineBasicMaterial)();\n                        // copy compatible properties\n                        lineMaterial.color.copy(material.color);\n                        lineMaterial.opacity = material.opacity;\n                        lineMaterial.transparent = material.transparent;\n                        // replace material\n                        materials[i] = lineMaterial;\n                    }\n                }\n                // regard skinning\n                const skinning = geometry.data.attributes.skinIndex !== undefined;\n                // choose between a single or multi materials (material array)\n                const material = materials.length === 1 ? materials[0] : materials;\n                // now create a specific 3D object\n                let object;\n                switch(type){\n                    case \"lines\":\n                        object = new (0, $ilwiq.LineSegments)(geometry.data, material);\n                        break;\n                    case \"linestrips\":\n                        object = new (0, $ilwiq.Line)(geometry.data, material);\n                        break;\n                    case \"triangles\":\n                    case \"polylist\":\n                        if (skinning) object = new (0, $ilwiq.SkinnedMesh)(geometry.data, material);\n                        else object = new (0, $ilwiq.Mesh)(geometry.data, material);\n                        break;\n                }\n                objects.push(object);\n            }\n            return objects;\n        }\n        function hasNode(id) {\n            return library.nodes[id] !== undefined;\n        }\n        function getNode(id) {\n            return getBuild(library.nodes[id], buildNode);\n        }\n        // visual scenes\n        function parseVisualScene(xml) {\n            const data = {\n                name: xml.getAttribute(\"name\"),\n                children: []\n            };\n            prepareNodes(xml);\n            const elements = getElementsByTagName(xml, \"node\");\n            for(let i = 0; i < elements.length; i++)data.children.push(parseNode(elements[i]));\n            library.visualScenes[xml.getAttribute(\"id\")] = data;\n        }\n        function buildVisualScene(data) {\n            const group = new (0, $ilwiq.Group)();\n            group.name = data.name;\n            const children = data.children;\n            for(let i = 0; i < children.length; i++){\n                const child = children[i];\n                group.add(getNode(child.id));\n            }\n            return group;\n        }\n        function hasVisualScene(id) {\n            return library.visualScenes[id] !== undefined;\n        }\n        function getVisualScene(id) {\n            return getBuild(library.visualScenes[id], buildVisualScene);\n        }\n        // scenes\n        function parseScene(xml) {\n            const instance = getElementsByTagName(xml, \"instance_visual_scene\")[0];\n            return getVisualScene(parseId(instance.getAttribute(\"url\")));\n        }\n        function setupAnimations() {\n            const clips = library.clips;\n            if (isEmpty(clips) === true) {\n                if (isEmpty(library.animations) === false) {\n                    // if there are animations but no clips, we create a default clip for playback\n                    const tracks = [];\n                    for(const id in library.animations){\n                        const animationTracks = getAnimation(id);\n                        for(let i = 0, l = animationTracks.length; i < l; i++)tracks.push(animationTracks[i]);\n                    }\n                    animations.push(new (0, $ilwiq.AnimationClip)(\"default\", -1, tracks));\n                }\n            } else for(const id in clips)animations.push(getAnimationClip(id));\n        }\n        // convert the parser error element into text with each child elements text\n        // separated by new lines.\n        function parserErrorToText(parserError) {\n            let result = \"\";\n            const stack = [\n                parserError\n            ];\n            while(stack.length){\n                const node = stack.shift();\n                if (node.nodeType === Node.TEXT_NODE) result += node.textContent;\n                else {\n                    result += \"\\n\";\n                    stack.push.apply(stack, node.childNodes);\n                }\n            }\n            return result.trim();\n        }\n        if (text.length === 0) return {\n            scene: new (0, $ilwiq.Scene)()\n        };\n        const xml = new DOMParser().parseFromString(text, \"application/xml\");\n        const collada = getElementsByTagName(xml, \"COLLADA\")[0];\n        const parserError = xml.getElementsByTagName(\"parsererror\")[0];\n        if (parserError !== undefined) {\n            // Chrome will return parser error with a div in it\n            const errorElement = getElementsByTagName(parserError, \"div\")[0];\n            let errorText;\n            if (errorElement) errorText = errorElement.textContent;\n            else errorText = parserErrorToText(parserError);\n            console.error(\"THREE.ColladaLoader: Failed to parse collada file.\\n\", errorText);\n            return null;\n        }\n        // metadata\n        const version = collada.getAttribute(\"version\");\n        console.debug(\"THREE.ColladaLoader: File version\", version);\n        const asset = parseAsset(getElementsByTagName(collada, \"asset\")[0]);\n        const textureLoader = new (0, $ilwiq.TextureLoader)(this.manager);\n        textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n        let tgaLoader;\n        if (0, $dc743e2081fd10a7$export$f133a99b4c3153a) {\n            tgaLoader = new (0, $dc743e2081fd10a7$export$f133a99b4c3153a)(this.manager);\n            tgaLoader.setPath(this.resourcePath || path);\n        }\n        //\n        const tempColor = new (0, $ilwiq.Color)();\n        const animations = [];\n        let kinematics = {};\n        let count = 0;\n        //\n        const library = {\n            animations: {},\n            clips: {},\n            controllers: {},\n            images: {},\n            effects: {},\n            materials: {},\n            cameras: {},\n            lights: {},\n            geometries: {},\n            nodes: {},\n            visualScenes: {},\n            kinematicsModels: {},\n            physicsModels: {},\n            kinematicsScenes: {}\n        };\n        parseLibrary(collada, \"library_animations\", \"animation\", parseAnimation);\n        parseLibrary(collada, \"library_animation_clips\", \"animation_clip\", parseAnimationClip);\n        parseLibrary(collada, \"library_controllers\", \"controller\", parseController);\n        parseLibrary(collada, \"library_images\", \"image\", parseImage);\n        parseLibrary(collada, \"library_effects\", \"effect\", parseEffect);\n        parseLibrary(collada, \"library_materials\", \"material\", parseMaterial);\n        parseLibrary(collada, \"library_cameras\", \"camera\", parseCamera);\n        parseLibrary(collada, \"library_lights\", \"light\", parseLight);\n        parseLibrary(collada, \"library_geometries\", \"geometry\", parseGeometry);\n        parseLibrary(collada, \"library_nodes\", \"node\", parseNode);\n        parseLibrary(collada, \"library_visual_scenes\", \"visual_scene\", parseVisualScene);\n        parseLibrary(collada, \"library_kinematics_models\", \"kinematics_model\", parseKinematicsModel);\n        parseLibrary(collada, \"library_physics_models\", \"physics_model\", parsePhysicsModel);\n        parseLibrary(collada, \"scene\", \"instance_kinematics_scene\", parseKinematicsScene);\n        buildLibrary(library.animations, buildAnimation);\n        buildLibrary(library.clips, buildAnimationClip);\n        buildLibrary(library.controllers, buildController);\n        buildLibrary(library.images, buildImage);\n        buildLibrary(library.effects, buildEffect);\n        buildLibrary(library.materials, buildMaterial);\n        buildLibrary(library.cameras, buildCamera);\n        buildLibrary(library.lights, buildLight);\n        buildLibrary(library.geometries, buildGeometry);\n        buildLibrary(library.visualScenes, buildVisualScene);\n        setupAnimations();\n        setupKinematics();\n        const scene = parseScene(getElementsByTagName(collada, \"scene\")[0]);\n        scene.animations = animations;\n        if (asset.upAxis === \"Z_UP\") {\n            console.warn(\"THREE.ColladaLoader: You are loading an asset with a Z-UP coordinate system. The loader just rotates the asset to transform it into Y-UP. The vertex data are not converted, see #24289.\");\n            scene.rotation.set(-Math.PI / 2, 0, 0);\n        }\n        scene.scale.multiplyScalar(asset.unit);\n        return {\n            get animations () {\n                console.warn(\"THREE.ColladaLoader: Please access animations over scene.animations now.\");\n                return animations;\n            },\n            kinematics: kinematics,\n            library: library,\n            scene: scene\n        };\n    }\n}\n\n\n\nvar $cpS3d = parcelRequire(\"cpS3d\");\n\nvar $9hfHi = parcelRequire(\"9hfHi\");\n\nvar $jiuw3 = parcelRequire(\"jiuw3\");\n\nvar $7MGRS = parcelRequire(\"7MGRS\");\n\nvar $1EdOY = parcelRequire(\"1EdOY\");\n\nvar $bHiTZ = parcelRequire(\"bHiTZ\");\nvar $8mHfG = parcelRequire(\"8mHfG\");\n\nvar $5Rd1x = parcelRequire(\"5Rd1x\");\n\nvar $cE5k3 = parcelRequire(\"cE5k3\");\n\nvar $e2Pv4 = parcelRequire(\"e2Pv4\");\n\nvar $kqOCM = parcelRequire(\"kqOCM\");\nconst $393e677ed3c566ae$var$envMaps = {\n    \"Royal Esplanade\": \"https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/royal_esplanade_1k.hdr\",\n    \"Moonless Golf\": \"https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/moonless_golf_1k.hdr\",\n    \"Overpass\": \"https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/pedestrian_overpass_1k.hdr\",\n    \"Venice Sunset\": \"https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/venice_sunset_1k.hdr\",\n    \"Small Studio\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/studio_small_05_1k.hdr\",\n    \"Pfalzer Forest\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/phalzer_forest_01_1k.hdr\",\n    \"Leadenhall Market\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/leadenhall_market_1k.hdr\",\n    \"Kloppenheim\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/kloppenheim_05_1k.hdr\",\n    \"Hilly Terrain\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/hilly_terrain_01_1k.hdr\",\n    \"Circus Arena\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/circus_arena_1k.hdr\",\n    \"Chinese Garden\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/chinese_garden_1k.hdr\",\n    \"Autoshop\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/autoshop_01_1k.hdr\",\n    \"Measuring Lab\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/vintage_measuring_lab_2k.hdr\",\n    \"Whale Skeleton\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/whale_skeleton_2k.hdr\",\n    \"Hall of Mammals\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/hall_of_mammals_2k.hdr\",\n    \"Drachenfels Cellar\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/drachenfels_cellar_2k.hdr\",\n    \"Adams Place Bridge\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/adams_place_bridge_2k.hdr\",\n    \"Sepulchral Chapel Rotunda\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/sepulchral_chapel_rotunda_2k.hdr\",\n    \"Peppermint Powerplant\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/peppermint_powerplant_2k.hdr\",\n    \"Noon Grass\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/noon_grass_2k.hdr\",\n    \"Narrow Moonlit Road\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/narrow_moonlit_road_2k.hdr\",\n    \"St Peters Square Night\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/st_peters_square_night_2k.hdr\",\n    \"Brown Photostudio 01\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/brown_photostudio_01_2k.hdr\",\n    \"Rainforest Trail\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/rainforest_trail_2k.hdr\",\n    \"Brown Photostudio 07\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/brown_photostudio_07_2k.hdr\",\n    \"Brown Photostudio 06\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/brown_photostudio_06_2k.hdr\",\n    \"Dancing Hall\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/dancing_hall_2k.hdr\",\n    \"Aristea Wreck Puresky\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/aristea_wreck_puresky_2k.hdr\",\n    \"Modern Buildings 2\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/modern_buildings_2_2k.hdr\",\n    \"Thatch Chapel\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/thatch_chapel_2k.hdr\",\n    \"Vestibule\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/vestibule_2k.hdr\",\n    \"Blocky Photo Studio\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/blocky_photo_studio_1k.hdr\",\n    \"Christmas Photo Studio 07\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/christmas_photo_studio_07_2k.hdr\",\n    \"Aerodynamics Workshop\": \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/aerodynamics_workshop_1k.hdr\"\n};\nconst $393e677ed3c566ae$var$models = window.MODEL_LIST || {};\nconst $393e677ed3c566ae$var$params = {\n    multipleImportanceSampling: true,\n    acesToneMapping: true,\n    renderScale: 1 / window.devicePixelRatio,\n    tiles: 2,\n    model: \"\",\n    envMap: $393e677ed3c566ae$var$envMaps[\"Aristea Wreck Puresky\"],\n    gradientTop: \"#bfd8ff\",\n    gradientBottom: \"#ffffff\",\n    environmentIntensity: 1.0,\n    environmentRotation: 0,\n    cameraProjection: \"Perspective\",\n    backgroundType: \"Gradient\",\n    bgGradientTop: \"#111111\",\n    bgGradientBottom: \"#000000\",\n    backgroundBlur: 0.0,\n    transparentBackground: false,\n    checkerboardTransparency: true,\n    enable: true,\n    bounces: 5,\n    filterGlossyFactor: 0.5,\n    pause: false,\n    floorColor: \"#111111\",\n    floorOpacity: 1.0,\n    floorRoughness: 0.2,\n    floorMetalness: 0.2,\n    ...(0, $cE5k3.getScaledSettings)()\n};\nlet $393e677ed3c566ae$var$floorPlane, $393e677ed3c566ae$var$gui, $393e677ed3c566ae$var$stats;\nlet $393e677ed3c566ae$var$pathTracer, $393e677ed3c566ae$var$renderer, $393e677ed3c566ae$var$orthoCamera, $393e677ed3c566ae$var$perspectiveCamera, $393e677ed3c566ae$var$activeCamera;\nlet $393e677ed3c566ae$var$controls, $393e677ed3c566ae$var$scene, $393e677ed3c566ae$var$model;\nlet $393e677ed3c566ae$var$gradientMap;\nlet $393e677ed3c566ae$var$loader;\nconst $393e677ed3c566ae$var$orthoWidth = 2;\n$393e677ed3c566ae$var$init();\nasync function $393e677ed3c566ae$var$init() {\n    $393e677ed3c566ae$var$loader = new (0, $e2Pv4.LoaderElement)();\n    $393e677ed3c566ae$var$loader.attach(document.body);\n    // renderer\n    $393e677ed3c566ae$var$renderer = new (0, $ilwiq.WebGLRenderer)({\n        antialias: true\n    });\n    $393e677ed3c566ae$var$renderer.toneMapping = (0, $ilwiq.ACESFilmicToneMapping);\n    document.body.appendChild($393e677ed3c566ae$var$renderer.domElement);\n    // path tracer\n    $393e677ed3c566ae$var$pathTracer = new (0, $8mHfG.WebGLPathTracer)($393e677ed3c566ae$var$renderer);\n    $393e677ed3c566ae$var$pathTracer.setBVHWorker(new (0, $kqOCM.ParallelMeshBVHWorker)());\n    $393e677ed3c566ae$var$pathTracer.physicallyCorrectLights = true;\n    $393e677ed3c566ae$var$pathTracer.tiles.set($393e677ed3c566ae$var$params.tiles, $393e677ed3c566ae$var$params.tiles);\n    $393e677ed3c566ae$var$pathTracer.multipleImportanceSampling = $393e677ed3c566ae$var$params.multipleImportanceSampling;\n    $393e677ed3c566ae$var$pathTracer.transmissiveBounces = 10;\n    // camera\n    const aspect = window.innerWidth / window.innerHeight;\n    $393e677ed3c566ae$var$perspectiveCamera = new (0, $ilwiq.PerspectiveCamera)(60, aspect, 0.025, 500);\n    $393e677ed3c566ae$var$perspectiveCamera.position.set(-1, 0.25, 1);\n    const orthoHeight = $393e677ed3c566ae$var$orthoWidth / aspect;\n    $393e677ed3c566ae$var$orthoCamera = new (0, $ilwiq.OrthographicCamera)($393e677ed3c566ae$var$orthoWidth / -2, $393e677ed3c566ae$var$orthoWidth / 2, orthoHeight / 2, orthoHeight / -2, 0, 100);\n    $393e677ed3c566ae$var$orthoCamera.position.set(-1, 0.25, 1);\n    // background map\n    $393e677ed3c566ae$var$gradientMap = new (0, $bHiTZ.GradientEquirectTexture)();\n    $393e677ed3c566ae$var$gradientMap.topColor.set($393e677ed3c566ae$var$params.bgGradientTop);\n    $393e677ed3c566ae$var$gradientMap.bottomColor.set($393e677ed3c566ae$var$params.bgGradientBottom);\n    $393e677ed3c566ae$var$gradientMap.update();\n    // controls\n    $393e677ed3c566ae$var$controls = new (0, $5Rd1x.OrbitControls)($393e677ed3c566ae$var$perspectiveCamera, $393e677ed3c566ae$var$renderer.domElement);\n    $393e677ed3c566ae$var$controls.addEventListener(\"change\", ()=>{\n        $393e677ed3c566ae$var$pathTracer.updateCamera();\n    });\n    // scene\n    $393e677ed3c566ae$var$scene = new (0, $ilwiq.Scene)();\n    $393e677ed3c566ae$var$scene.background = $393e677ed3c566ae$var$gradientMap;\n    const floorTex = (0, $1EdOY.generateRadialFloorTexture)(2048);\n    $393e677ed3c566ae$var$floorPlane = new (0, $ilwiq.Mesh)(new (0, $ilwiq.PlaneGeometry)(), new (0, $ilwiq.MeshStandardMaterial)({\n        map: floorTex,\n        transparent: true,\n        color: 0x111111,\n        roughness: 0.1,\n        metalness: 0.0,\n        side: (0, $ilwiq.DoubleSide)\n    }));\n    $393e677ed3c566ae$var$floorPlane.scale.setScalar(5);\n    $393e677ed3c566ae$var$floorPlane.rotation.x = -Math.PI / 2;\n    $393e677ed3c566ae$var$scene.add($393e677ed3c566ae$var$floorPlane);\n    $393e677ed3c566ae$var$stats = new (0, $7MGRS.default)();\n    document.body.appendChild($393e677ed3c566ae$var$stats.dom);\n    $393e677ed3c566ae$var$updateCameraProjection($393e677ed3c566ae$var$params.cameraProjection);\n    $393e677ed3c566ae$var$onHashChange();\n    $393e677ed3c566ae$var$updateEnvMap();\n    $393e677ed3c566ae$var$onResize();\n    $393e677ed3c566ae$var$animate();\n    window.addEventListener(\"resize\", $393e677ed3c566ae$var$onResize);\n    window.addEventListener(\"hashchange\", $393e677ed3c566ae$var$onHashChange);\n}\nfunction $393e677ed3c566ae$var$animate() {\n    requestAnimationFrame($393e677ed3c566ae$var$animate);\n    $393e677ed3c566ae$var$stats.update();\n    if (!$393e677ed3c566ae$var$model) return;\n    if ($393e677ed3c566ae$var$params.enable) {\n        if (!$393e677ed3c566ae$var$params.pause || $393e677ed3c566ae$var$pathTracer.samples < 1) $393e677ed3c566ae$var$pathTracer.renderSample();\n    } else $393e677ed3c566ae$var$renderer.render($393e677ed3c566ae$var$scene, $393e677ed3c566ae$var$activeCamera);\n    $393e677ed3c566ae$var$loader.setSamples($393e677ed3c566ae$var$pathTracer.samples, $393e677ed3c566ae$var$pathTracer.isCompiling);\n}\nfunction $393e677ed3c566ae$var$onParamsChange() {\n    $393e677ed3c566ae$var$pathTracer.multipleImportanceSampling = $393e677ed3c566ae$var$params.multipleImportanceSampling;\n    $393e677ed3c566ae$var$pathTracer.bounces = $393e677ed3c566ae$var$params.bounces;\n    $393e677ed3c566ae$var$pathTracer.filterGlossyFactor = $393e677ed3c566ae$var$params.filterGlossyFactor;\n    $393e677ed3c566ae$var$pathTracer.renderScale = $393e677ed3c566ae$var$params.renderScale;\n    $393e677ed3c566ae$var$floorPlane.material.color.set($393e677ed3c566ae$var$params.floorColor);\n    $393e677ed3c566ae$var$floorPlane.material.roughness = $393e677ed3c566ae$var$params.floorRoughness;\n    $393e677ed3c566ae$var$floorPlane.material.metalness = $393e677ed3c566ae$var$params.floorMetalness;\n    $393e677ed3c566ae$var$floorPlane.material.opacity = $393e677ed3c566ae$var$params.floorOpacity;\n    $393e677ed3c566ae$var$scene.environmentIntensity = $393e677ed3c566ae$var$params.environmentIntensity;\n    $393e677ed3c566ae$var$scene.environmentRotation.y = $393e677ed3c566ae$var$params.environmentRotation;\n    $393e677ed3c566ae$var$scene.backgroundBlurriness = $393e677ed3c566ae$var$params.backgroundBlur;\n    if ($393e677ed3c566ae$var$params.backgroundType === \"Gradient\") {\n        $393e677ed3c566ae$var$gradientMap.topColor.set($393e677ed3c566ae$var$params.bgGradientTop);\n        $393e677ed3c566ae$var$gradientMap.bottomColor.set($393e677ed3c566ae$var$params.bgGradientBottom);\n        $393e677ed3c566ae$var$gradientMap.update();\n        $393e677ed3c566ae$var$scene.background = $393e677ed3c566ae$var$gradientMap;\n        $393e677ed3c566ae$var$scene.backgroundIntensity = 1;\n        $393e677ed3c566ae$var$scene.environmentRotation.y = 0;\n    } else {\n        $393e677ed3c566ae$var$scene.background = $393e677ed3c566ae$var$scene.environment;\n        $393e677ed3c566ae$var$scene.backgroundIntensity = $393e677ed3c566ae$var$params.environmentIntensity;\n        $393e677ed3c566ae$var$scene.backgroundRotation.y = $393e677ed3c566ae$var$params.environmentRotation;\n    }\n    if ($393e677ed3c566ae$var$params.transparentBackground) {\n        $393e677ed3c566ae$var$scene.background = null;\n        $393e677ed3c566ae$var$renderer.setClearAlpha(0);\n    }\n    $393e677ed3c566ae$var$pathTracer.updateMaterials();\n    $393e677ed3c566ae$var$pathTracer.updateEnvironment();\n}\nfunction $393e677ed3c566ae$var$onHashChange() {\n    let hashModel = \"\";\n    if (window.location.hash) {\n        const modelName = decodeURI(window.location.hash.substring(1));\n        if (modelName in $393e677ed3c566ae$var$models) hashModel = modelName;\n    }\n    if (!(hashModel in $393e677ed3c566ae$var$models)) hashModel = Object.keys($393e677ed3c566ae$var$models)[0];\n    $393e677ed3c566ae$var$params.model = hashModel;\n    $393e677ed3c566ae$var$updateModel();\n}\nfunction $393e677ed3c566ae$var$onResize() {\n    const w = window.innerWidth;\n    const h = window.innerHeight;\n    const dpr = window.devicePixelRatio;\n    $393e677ed3c566ae$var$renderer.setSize(w, h);\n    $393e677ed3c566ae$var$renderer.setPixelRatio(dpr);\n    const aspect = w / h;\n    $393e677ed3c566ae$var$perspectiveCamera.aspect = aspect;\n    $393e677ed3c566ae$var$perspectiveCamera.updateProjectionMatrix();\n    const orthoHeight = $393e677ed3c566ae$var$orthoWidth / aspect;\n    $393e677ed3c566ae$var$orthoCamera.top = orthoHeight / 2;\n    $393e677ed3c566ae$var$orthoCamera.bottom = orthoHeight / -2;\n    $393e677ed3c566ae$var$orthoCamera.updateProjectionMatrix();\n    $393e677ed3c566ae$var$pathTracer.updateCamera();\n}\nfunction $393e677ed3c566ae$var$buildGui() {\n    if ($393e677ed3c566ae$var$gui) $393e677ed3c566ae$var$gui.destroy();\n    $393e677ed3c566ae$var$gui = new (0, $jiuw3.GUI)();\n    $393e677ed3c566ae$var$gui.add($393e677ed3c566ae$var$params, \"model\", Object.keys($393e677ed3c566ae$var$models).sort()).onChange((v)=>{\n        window.location.hash = v;\n    });\n    const pathTracingFolder = $393e677ed3c566ae$var$gui.addFolder(\"Path Tracer\");\n    pathTracingFolder.add($393e677ed3c566ae$var$params, \"enable\");\n    pathTracingFolder.add($393e677ed3c566ae$var$params, \"pause\");\n    pathTracingFolder.add($393e677ed3c566ae$var$params, \"multipleImportanceSampling\").onChange($393e677ed3c566ae$var$onParamsChange);\n    pathTracingFolder.add($393e677ed3c566ae$var$params, \"acesToneMapping\").onChange((v)=>{\n        $393e677ed3c566ae$var$renderer.toneMapping = v ? (0, $ilwiq.ACESFilmicToneMapping) : (0, $ilwiq.NoToneMapping);\n    });\n    pathTracingFolder.add($393e677ed3c566ae$var$params, \"bounces\", 1, 20, 1).onChange($393e677ed3c566ae$var$onParamsChange);\n    pathTracingFolder.add($393e677ed3c566ae$var$params, \"filterGlossyFactor\", 0, 1).onChange($393e677ed3c566ae$var$onParamsChange);\n    pathTracingFolder.add($393e677ed3c566ae$var$params, \"renderScale\", 0.1, 1.0, 0.01).onChange(()=>{\n        $393e677ed3c566ae$var$onParamsChange();\n    });\n    pathTracingFolder.add($393e677ed3c566ae$var$params, \"tiles\", 1, 10, 1).onChange((v)=>{\n        $393e677ed3c566ae$var$pathTracer.tiles.set(v, v);\n    });\n    pathTracingFolder.add($393e677ed3c566ae$var$params, \"cameraProjection\", [\n        \"Perspective\",\n        \"Orthographic\"\n    ]).onChange((v)=>{\n        $393e677ed3c566ae$var$updateCameraProjection(v);\n    });\n    pathTracingFolder.open();\n    const environmentFolder = $393e677ed3c566ae$var$gui.addFolder(\"environment\");\n    environmentFolder.add($393e677ed3c566ae$var$params, \"envMap\", $393e677ed3c566ae$var$envMaps).name(\"map\").onChange($393e677ed3c566ae$var$updateEnvMap);\n    environmentFolder.add($393e677ed3c566ae$var$params, \"environmentIntensity\", 0.0, 10.0).onChange($393e677ed3c566ae$var$onParamsChange).name(\"intensity\");\n    environmentFolder.add($393e677ed3c566ae$var$params, \"environmentRotation\", 0, 2 * Math.PI).onChange($393e677ed3c566ae$var$onParamsChange);\n    environmentFolder.open();\n    const backgroundFolder = $393e677ed3c566ae$var$gui.addFolder(\"background\");\n    backgroundFolder.add($393e677ed3c566ae$var$params, \"backgroundType\", [\n        \"Environment\",\n        \"Gradient\"\n    ]).onChange($393e677ed3c566ae$var$onParamsChange);\n    backgroundFolder.addColor($393e677ed3c566ae$var$params, \"bgGradientTop\").onChange($393e677ed3c566ae$var$onParamsChange);\n    backgroundFolder.addColor($393e677ed3c566ae$var$params, \"bgGradientBottom\").onChange($393e677ed3c566ae$var$onParamsChange);\n    backgroundFolder.add($393e677ed3c566ae$var$params, \"backgroundBlur\", 0, 1).onChange($393e677ed3c566ae$var$onParamsChange);\n    backgroundFolder.add($393e677ed3c566ae$var$params, \"transparentBackground\", 0, 1).onChange($393e677ed3c566ae$var$onParamsChange);\n    backgroundFolder.add($393e677ed3c566ae$var$params, \"checkerboardTransparency\").onChange((v)=>{\n        if (v) document.body.classList.add(\"checkerboard\");\n        else document.body.classList.remove(\"checkerboard\");\n    });\n    const floorFolder = $393e677ed3c566ae$var$gui.addFolder(\"floor\");\n    floorFolder.addColor($393e677ed3c566ae$var$params, \"floorColor\").onChange($393e677ed3c566ae$var$onParamsChange);\n    floorFolder.add($393e677ed3c566ae$var$params, \"floorRoughness\", 0, 1).onChange($393e677ed3c566ae$var$onParamsChange);\n    floorFolder.add($393e677ed3c566ae$var$params, \"floorMetalness\", 0, 1).onChange($393e677ed3c566ae$var$onParamsChange);\n    floorFolder.add($393e677ed3c566ae$var$params, \"floorOpacity\", 0, 1).onChange($393e677ed3c566ae$var$onParamsChange);\n    floorFolder.close();\n}\nfunction $393e677ed3c566ae$var$updateEnvMap() {\n    new (0, $891vQ.RGBELoader)().load($393e677ed3c566ae$var$params.envMap, (texture)=>{\n        if ($393e677ed3c566ae$var$scene.environment) $393e677ed3c566ae$var$scene.environment.dispose();\n        texture.mapping = (0, $ilwiq.EquirectangularReflectionMapping);\n        $393e677ed3c566ae$var$scene.environment = texture;\n        $393e677ed3c566ae$var$pathTracer.updateEnvironment();\n        $393e677ed3c566ae$var$onParamsChange();\n    });\n}\nfunction $393e677ed3c566ae$var$updateCameraProjection(cameraProjection) {\n    // sync position\n    if ($393e677ed3c566ae$var$activeCamera) {\n        $393e677ed3c566ae$var$perspectiveCamera.position.copy($393e677ed3c566ae$var$activeCamera.position);\n        $393e677ed3c566ae$var$orthoCamera.position.copy($393e677ed3c566ae$var$activeCamera.position);\n    }\n    // set active camera\n    if (cameraProjection === \"Perspective\") $393e677ed3c566ae$var$activeCamera = $393e677ed3c566ae$var$perspectiveCamera;\n    else $393e677ed3c566ae$var$activeCamera = $393e677ed3c566ae$var$orthoCamera;\n    $393e677ed3c566ae$var$controls.object = $393e677ed3c566ae$var$activeCamera;\n    $393e677ed3c566ae$var$controls.update();\n    $393e677ed3c566ae$var$pathTracer.setCamera($393e677ed3c566ae$var$activeCamera);\n}\nfunction $393e677ed3c566ae$var$convertOpacityToTransmission(model, ior) {\n    model.traverse((c)=>{\n        if (c.material) {\n            const material = c.material;\n            if (material.opacity < 0.65 && material.opacity > 0.2) {\n                const newMaterial = new (0, $ilwiq.MeshPhysicalMaterial)();\n                for(const key in material)if (key in material) {\n                    if (material[key] === null) continue;\n                    if (material[key].isTexture) newMaterial[key] = material[key];\n                    else if (material[key].copy && material[key].constructor === newMaterial[key].constructor) newMaterial[key].copy(material[key]);\n                    else if (typeof material[key] === \"number\") newMaterial[key] = material[key];\n                }\n                newMaterial.opacity = 1.0;\n                newMaterial.transmission = 1.0;\n                newMaterial.ior = ior;\n                const hsl = {};\n                newMaterial.color.getHSL(hsl);\n                hsl.l = Math.max(hsl.l, 0.35);\n                newMaterial.color.setHSL(hsl.h, hsl.s, hsl.l);\n                c.material = newMaterial;\n            }\n        }\n    });\n}\nasync function $393e677ed3c566ae$var$updateModel() {\n    if ($393e677ed3c566ae$var$gui) {\n        document.body.classList.remove(\"checkerboard\");\n        $393e677ed3c566ae$var$gui.destroy();\n        $393e677ed3c566ae$var$gui = null;\n    }\n    const modelInfo = $393e677ed3c566ae$var$models[$393e677ed3c566ae$var$params.model];\n    $393e677ed3c566ae$var$renderer.domElement.style.visibility = \"hidden\";\n    $393e677ed3c566ae$var$loader.setPercentage(0);\n    if ($393e677ed3c566ae$var$model) {\n        $393e677ed3c566ae$var$model.traverse((c)=>{\n            if (c.material) {\n                const material = c.material;\n                for(const key in material)if (material[key] && material[key].isTexture) material[key].dispose();\n            }\n        });\n        $393e677ed3c566ae$var$scene.remove($393e677ed3c566ae$var$model);\n        $393e677ed3c566ae$var$model = null;\n    }\n    try {\n        $393e677ed3c566ae$var$model = await $393e677ed3c566ae$var$loadModel(modelInfo.url, (v)=>{\n            $393e677ed3c566ae$var$loader.setPercentage(0.5 * v);\n        });\n    } catch (err) {\n        $393e677ed3c566ae$var$loader.setCredits(\"Failed to load model:\" + err.message);\n        $393e677ed3c566ae$var$loader.setPercentage(1);\n    }\n    // update after model load\n    // TODO: clean up\n    if (modelInfo.removeEmission) $393e677ed3c566ae$var$model.traverse((c)=>{\n        if (c.material) {\n            c.material.emissiveMap = null;\n            c.material.emissiveIntensity = 0;\n        }\n    });\n    if (modelInfo.opacityToTransmission) $393e677ed3c566ae$var$convertOpacityToTransmission($393e677ed3c566ae$var$model, modelInfo.ior || 1.5);\n    $393e677ed3c566ae$var$model.traverse((c)=>{\n        if (c.material) // set the thickness so we render the material as a volumetric object\n        c.material.thickness = 1.0;\n    });\n    if (modelInfo.postProcess) modelInfo.postProcess($393e677ed3c566ae$var$model);\n    // rotate model after so it doesn't affect the bounding sphere scale\n    if (modelInfo.rotation) $393e677ed3c566ae$var$model.rotation.set(...modelInfo.rotation);\n    // center the model\n    const box = new (0, $ilwiq.Box3)();\n    box.setFromObject($393e677ed3c566ae$var$model);\n    $393e677ed3c566ae$var$model.position.addScaledVector(box.min, -0.5).addScaledVector(box.max, -0.5);\n    const sphere = new (0, $ilwiq.Sphere)();\n    box.getBoundingSphere(sphere);\n    $393e677ed3c566ae$var$model.scale.setScalar(1 / sphere.radius);\n    $393e677ed3c566ae$var$model.position.multiplyScalar(1 / sphere.radius);\n    box.setFromObject($393e677ed3c566ae$var$model);\n    $393e677ed3c566ae$var$floorPlane.position.y = box.min.y;\n    $393e677ed3c566ae$var$scene.add($393e677ed3c566ae$var$model);\n    await $393e677ed3c566ae$var$pathTracer.setSceneAsync($393e677ed3c566ae$var$scene, $393e677ed3c566ae$var$activeCamera, {\n        onProgress: (v)=>$393e677ed3c566ae$var$loader.setPercentage(0.5 + 0.5 * v)\n    });\n    $393e677ed3c566ae$var$loader.setPercentage(1);\n    $393e677ed3c566ae$var$loader.setCredits(modelInfo.credit || \"\");\n    $393e677ed3c566ae$var$params.bounces = modelInfo.bounces || 5;\n    $393e677ed3c566ae$var$params.floorColor = modelInfo.floorColor || \"#111111\";\n    $393e677ed3c566ae$var$params.floorRoughness = modelInfo.floorRoughness || 0.2;\n    $393e677ed3c566ae$var$params.floorMetalness = modelInfo.floorMetalness || 0.2;\n    $393e677ed3c566ae$var$params.bgGradientTop = modelInfo.gradientTop || \"#111111\";\n    $393e677ed3c566ae$var$params.bgGradientBottom = modelInfo.gradientBot || \"#000000\";\n    $393e677ed3c566ae$var$buildGui();\n    $393e677ed3c566ae$var$onParamsChange();\n    $393e677ed3c566ae$var$renderer.domElement.style.visibility = \"visible\";\n    if ($393e677ed3c566ae$var$params.checkerboardTransparency) document.body.classList.add(\"checkerboard\");\n}\nasync function $393e677ed3c566ae$var$loadModel(url, onProgress) {\n    // TODO: clean up\n    const manager = new (0, $ilwiq.LoadingManager)();\n    if (/dae$/i.test(url)) {\n        const complete = new Promise((resolve)=>manager.onLoad = resolve);\n        const res = await new (0, $7f99d0845977052a$export$ce4e0fe932362815)(manager).loadAsync(url, (progress)=>{\n            if (progress.total !== 0 && progress.total >= progress.loaded) onProgress(progress.loaded / progress.total);\n        });\n        await complete;\n        res.scene.scale.setScalar(1);\n        res.scene.traverse((c)=>{\n            const { material: material } = c;\n            if (material && material.isMeshPhongMaterial) c.material = new (0, $ilwiq.MeshStandardMaterial)({\n                color: material.color,\n                roughness: material.roughness || 0,\n                metalness: material.metalness || 0,\n                map: material.map || null\n            });\n        });\n        return res.scene;\n    } else if (/(gltf|glb)$/i.test(url)) {\n        const complete = new Promise((resolve)=>manager.onLoad = resolve);\n        const gltf = await new (0, $7lx9d.GLTFLoader)(manager).setMeshoptDecoder((0, $kp7Te.MeshoptDecoder)).loadAsync(url, (progress)=>{\n            if (progress.total !== 0 && progress.total >= progress.loaded) onProgress(progress.loaded / progress.total);\n        });\n        await complete;\n        return gltf.scene;\n    } else if (/mpd$/i.test(url)) {\n        manager.onProgress = (url, loaded, total)=>{\n            onProgress(loaded / total);\n        };\n        const complete = new Promise((resolve)=>manager.onLoad = resolve);\n        const ldrawLoader = new (0, $cpS3d.LDrawLoader)(manager);\n        await ldrawLoader.preloadMaterials(\"https://raw.githubusercontent.com/gkjohnson/ldraw-parts-library/master/colors/ldcfgalt.ldr\");\n        const result = await ldrawLoader.setPartsLibraryPath(\"https://raw.githubusercontent.com/gkjohnson/ldraw-parts-library/master/complete/ldraw/\").loadAsync(url);\n        await complete;\n        const model = (0, $9hfHi.LDrawUtils).mergeObject(result);\n        model.rotation.set(Math.PI, 0, 0);\n        const toRemove = [];\n        model.traverse((c)=>{\n            if (c.isLineSegments) toRemove.push(c);\n            if (c.isMesh) c.material.roughness *= 0.25;\n        });\n        toRemove.forEach((c)=>{\n            c.parent.remove(c);\n        });\n        return model;\n    }\n}\n\n\n//# sourceMappingURL=index.7e44f4ab.js.map\n","import {\n\tDataTextureLoader,\n\tDataUtils,\n\tFloatType,\n\tHalfFloatType,\n\tLinearFilter,\n\tLinearSRGBColorSpace\n} from 'three';\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.type = HalfFloatType;\n\n\t}\n\n\t// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\tparse( buffer ) {\n\n\t\tconst\n\t\t\t/* default error routine.  change this to change error handling */\n\t\t\trgbe_read_error = 1,\n\t\t\trgbe_write_error = 2,\n\t\t\trgbe_format_error = 3,\n\t\t\trgbe_memory_error = 4,\n\t\t\trgbe_error = function ( rgbe_error_code, msg ) {\n\n\t\t\t\tswitch ( rgbe_error_code ) {\n\n\t\t\t\t\tcase rgbe_read_error: throw new Error( 'THREE.RGBELoader: Read Error: ' + ( msg || '' ) );\n\t\t\t\t\tcase rgbe_write_error: throw new Error( 'THREE.RGBELoader: Write Error: ' + ( msg || '' ) );\n\t\t\t\t\tcase rgbe_format_error: throw new Error( 'THREE.RGBELoader: Bad File Format: ' + ( msg || '' ) );\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase rgbe_memory_error: throw new Error( 'THREE.RGBELoader: Memory Error: ' + ( msg || '' ) );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\t/* offsets to red, green, and blue components in a data (float) pixel */\n\t\t\t//RGBE_DATA_RED = 0,\n\t\t\t//RGBE_DATA_GREEN = 1,\n\t\t\t//RGBE_DATA_BLUE = 2,\n\n\t\t\t/* number of floats per pixel, use 4 since stored in rgba image format */\n\t\t\t//RGBE_DATA_SIZE = 4,\n\n\t\t\t/* flags indicating which fields in an rgbe_header_info are valid */\n\t\t\tRGBE_VALID_PROGRAMTYPE = 1,\n\t\t\tRGBE_VALID_FORMAT = 2,\n\t\t\tRGBE_VALID_DIMENSIONS = 4,\n\n\t\t\tNEWLINE = '\\n',\n\n\t\t\tfgets = function ( buffer, lineLimit, consume ) {\n\n\t\t\t\tconst chunkSize = 128;\n\n\t\t\t\tlineLimit = ! lineLimit ? 1024 : lineLimit;\n\t\t\t\tlet p = buffer.pos,\n\t\t\t\t\ti = - 1, len = 0, s = '',\n\t\t\t\t\tchunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\twhile ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {\n\n\t\t\t\t\ts += chunk; len += chunk.length;\n\t\t\t\t\tp += chunkSize;\n\t\t\t\t\tchunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( - 1 < i ) {\n\n\t\t\t\t\t/*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n\t\t\t\t\tif ( false !== consume ) buffer.pos += len + i + 1;\n\t\t\t\t\treturn s + chunk.slice( 0, i );\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\t/* minimal header reading.  modify if you want to parse more information */\n\t\t\tRGBE_ReadHeader = function ( buffer ) {\n\n\n\t\t\t\t// regexes to parse header info fields\n\t\t\t\tconst magic_token_re = /^#\\?(\\S+)/,\n\t\t\t\t\tgamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\texposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\tformat_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n\t\t\t\t\tdimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n\n\t\t\t\t\t// RGBE format header struct\n\t\t\t\t\theader = {\n\n\t\t\t\t\t\tvalid: 0, /* indicate which fields are valid */\n\n\t\t\t\t\t\tstring: '', /* the actual header string */\n\n\t\t\t\t\t\tcomments: '', /* comments found in header */\n\n\t\t\t\t\t\tprogramtype: 'RGBE', /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n\n\t\t\t\t\t\tformat: '', /* RGBE format, default 32-bit_rle_rgbe */\n\n\t\t\t\t\t\tgamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n\n\t\t\t\t\t\texposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n\n\t\t\t\t\t\twidth: 0, height: 0 /* image dimensions, width/height */\n\n\t\t\t\t\t};\n\n\t\t\t\tlet line, match;\n\n\t\t\t\tif ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_read_error, 'no header found' );\n\n\t\t\t\t}\n\n\t\t\t\t/* if you want to require the magic token then uncomment the next line */\n\t\t\t\tif ( ! ( match = line.match( magic_token_re ) ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'bad initial token' );\n\n\t\t\t\t}\n\n\t\t\t\theader.valid |= RGBE_VALID_PROGRAMTYPE;\n\t\t\t\theader.programtype = match[ 1 ];\n\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\twhile ( true ) {\n\n\t\t\t\t\tline = fgets( buffer );\n\t\t\t\t\tif ( false === line ) break;\n\t\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\t\tif ( '#' === line.charAt( 0 ) ) {\n\n\t\t\t\t\t\theader.comments += line + '\\n';\n\t\t\t\t\t\tcontinue; // comment line\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( gamma_re ) ) {\n\n\t\t\t\t\t\theader.gamma = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( exposure_re ) ) {\n\n\t\t\t\t\t\theader.exposure = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( format_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_FORMAT;\n\t\t\t\t\t\theader.format = match[ 1 ];//'32-bit_rle_rgbe';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( dimensions_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_DIMENSIONS;\n\t\t\t\t\t\theader.height = parseInt( match[ 1 ], 10 );\n\t\t\t\t\t\theader.width = parseInt( match[ 2 ], 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'missing format specifier' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'missing image size specifier' );\n\n\t\t\t\t}\n\n\t\t\t\treturn header;\n\n\t\t\t},\n\n\t\t\tRGBE_ReadPixels_RLE = function ( buffer, w, h ) {\n\n\t\t\t\tconst scanline_width = w;\n\n\t\t\t\tif (\n\t\t\t\t\t// run length encoding is not allowed so read flat\n\t\t\t\t\t( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||\n\t\t\t\t\t// this file is not run length encoded\n\t\t\t\t\t( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )\n\t\t\t\t) {\n\n\t\t\t\t\t// return the flat buffer\n\t\t\t\t\treturn new Uint8Array( buffer );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'wrong scanline width' );\n\n\t\t\t\t}\n\n\t\t\t\tconst data_rgba = new Uint8Array( 4 * w * h );\n\n\t\t\t\tif ( ! data_rgba.length ) {\n\n\t\t\t\t\trgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );\n\n\t\t\t\t}\n\n\t\t\t\tlet offset = 0, pos = 0;\n\n\t\t\t\tconst ptr_end = 4 * scanline_width;\n\t\t\t\tconst rgbeStart = new Uint8Array( 4 );\n\t\t\t\tconst scanline_buffer = new Uint8Array( ptr_end );\n\t\t\t\tlet num_scanlines = h;\n\n\t\t\t\t// read in each successive scanline\n\t\t\t\twhile ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\tif ( pos + 4 > buffer.byteLength ) {\n\n\t\t\t\t\t\trgbe_error( rgbe_read_error );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trgbeStart[ 0 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 1 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 2 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 3 ] = buffer[ pos ++ ];\n\n\t\t\t\t\tif ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {\n\n\t\t\t\t\t\trgbe_error( rgbe_format_error, 'bad rgbe scanline format' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// read each of the four channels for the scanline into the buffer\n\t\t\t\t\t// first red, then green, then blue, then exponent\n\t\t\t\t\tlet ptr = 0, count;\n\n\t\t\t\t\twhile ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\t\tcount = buffer[ pos ++ ];\n\t\t\t\t\t\tconst isEncodedRun = count > 128;\n\t\t\t\t\t\tif ( isEncodedRun ) count -= 128;\n\n\t\t\t\t\t\tif ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {\n\n\t\t\t\t\t\t\trgbe_error( rgbe_format_error, 'bad scanline data' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( isEncodedRun ) {\n\n\t\t\t\t\t\t\t// a (encoded) run of the same value\n\t\t\t\t\t\t\tconst byteValue = buffer[ pos ++ ];\n\t\t\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\tscanline_buffer[ ptr ++ ] = byteValue;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//ptr += count;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// a literal-run\n\t\t\t\t\t\t\tscanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );\n\t\t\t\t\t\t\tptr += count; pos += count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// now convert data from buffer into rgba\n\t\t\t\t\t// first red, then green, then blue, then exponent (alpha)\n\t\t\t\t\tconst l = scanline_width; //scanline_buffer.byteLength;\n\t\t\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\t\t\tlet off = 0;\n\t\t\t\t\t\tdata_rgba[ offset ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 1 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 2 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 3 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnum_scanlines --;\n\n\t\t\t\t}\n\n\t\t\t\treturn data_rgba;\n\n\t\t\t};\n\n\t\tconst RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\tdestArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;\n\t\t\tdestArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;\n\t\t\tdestArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;\n\t\t\tdestArray[ destOffset + 3 ] = 1;\n\n\t\t};\n\n\t\tconst RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\t// clamping to 65504, the maximum representable value in float16\n\t\t\tdestArray[ destOffset + 0 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 1 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 2 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 3 ] = DataUtils.toHalfFloat( 1 );\n\n\t\t};\n\n\t\tconst byteArray = new Uint8Array( buffer );\n\t\tbyteArray.pos = 0;\n\t\tconst rgbe_header_info = RGBE_ReadHeader( byteArray );\n\n\t\tconst w = rgbe_header_info.width,\n\t\t\th = rgbe_header_info.height,\n\t\t\timage_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );\n\n\n\t\tlet data, type;\n\t\tlet numElements;\n\n\t\tswitch ( this.type ) {\n\n\t\t\tcase FloatType:\n\n\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\tconst floatArray = new Float32Array( numElements * 4 );\n\n\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\tRGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );\n\n\t\t\t\t}\n\n\t\t\t\tdata = floatArray;\n\t\t\t\ttype = FloatType;\n\t\t\t\tbreak;\n\n\t\t\tcase HalfFloatType:\n\n\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\tconst halfArray = new Uint16Array( numElements * 4 );\n\n\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\tRGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );\n\n\t\t\t\t}\n\n\t\t\t\tdata = halfArray;\n\t\t\t\ttype = HalfFloatType;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tthrow new Error( 'THREE.RGBELoader: Unsupported type: ' + this.type );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\treturn {\n\t\t\twidth: w, height: h,\n\t\t\tdata: data,\n\t\t\theader: rgbe_header_info.string,\n\t\t\tgamma: rgbe_header_info.gamma,\n\t\t\texposure: rgbe_header_info.exposure,\n\t\t\ttype: type\n\t\t};\n\n\t}\n\n\tsetDataType( value ) {\n\n\t\tthis.type = value;\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tfunction onLoadCallback( texture, texData ) {\n\n\t\t\tswitch ( texture.type ) {\n\n\t\t\t\tcase FloatType:\n\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\ttexture.colorSpace = LinearSRGBColorSpace;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}\n\n\t\treturn super.load( url, onLoadCallback, onProgress, onError );\n\n\t}\n\n}\n\nexport { RGBELoader };\n","var Stats = function () {\n\n\tvar mode = 0;\n\n\tvar container = document.createElement( 'div' );\n\tcontainer.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000';\n\tcontainer.addEventListener( 'click', function ( event ) {\n\n\t\tevent.preventDefault();\n\t\tshowPanel( ++ mode % container.children.length );\n\n\t}, false );\n\n\t//\n\n\tfunction addPanel( panel ) {\n\n\t\tcontainer.appendChild( panel.dom );\n\t\treturn panel;\n\n\t}\n\n\tfunction showPanel( id ) {\n\n\t\tfor ( var i = 0; i < container.children.length; i ++ ) {\n\n\t\t\tcontainer.children[ i ].style.display = i === id ? 'block' : 'none';\n\n\t\t}\n\n\t\tmode = id;\n\n\t}\n\n\t//\n\n\tvar beginTime = ( performance || Date ).now(), prevTime = beginTime, frames = 0;\n\n\tvar fpsPanel = addPanel( new Stats.Panel( 'FPS', '#0ff', '#002' ) );\n\tvar msPanel = addPanel( new Stats.Panel( 'MS', '#0f0', '#020' ) );\n\n\tif ( self.performance && self.performance.memory ) {\n\n\t\tvar memPanel = addPanel( new Stats.Panel( 'MB', '#f08', '#201' ) );\n\n\t}\n\n\tshowPanel( 0 );\n\n\treturn {\n\n\t\tREVISION: 16,\n\n\t\tdom: container,\n\n\t\taddPanel: addPanel,\n\t\tshowPanel: showPanel,\n\n\t\tbegin: function () {\n\n\t\t\tbeginTime = ( performance || Date ).now();\n\n\t\t},\n\n\t\tend: function () {\n\n\t\t\tframes ++;\n\n\t\t\tvar time = ( performance || Date ).now();\n\n\t\t\tmsPanel.update( time - beginTime, 200 );\n\n\t\t\tif ( time >= prevTime + 1000 ) {\n\n\t\t\t\tfpsPanel.update( ( frames * 1000 ) / ( time - prevTime ), 100 );\n\n\t\t\t\tprevTime = time;\n\t\t\t\tframes = 0;\n\n\t\t\t\tif ( memPanel ) {\n\n\t\t\t\t\tvar memory = performance.memory;\n\t\t\t\t\tmemPanel.update( memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn time;\n\n\t\t},\n\n\t\tupdate: function () {\n\n\t\t\tbeginTime = this.end();\n\n\t\t},\n\n\t\t// Backwards Compatibility\n\n\t\tdomElement: container,\n\t\tsetMode: showPanel\n\n\t};\n\n};\n\nStats.Panel = function ( name, fg, bg ) {\n\n\tvar min = Infinity, max = 0, round = Math.round;\n\tvar PR = round( window.devicePixelRatio || 1 );\n\n\tvar WIDTH = 80 * PR, HEIGHT = 48 * PR,\n\t\tTEXT_X = 3 * PR, TEXT_Y = 2 * PR,\n\t\tGRAPH_X = 3 * PR, GRAPH_Y = 15 * PR,\n\t\tGRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;\n\n\tvar canvas = document.createElement( 'canvas' );\n\tcanvas.width = WIDTH;\n\tcanvas.height = HEIGHT;\n\tcanvas.style.cssText = 'width:80px;height:48px';\n\n\tvar context = canvas.getContext( '2d' );\n\tcontext.font = 'bold ' + ( 9 * PR ) + 'px Helvetica,Arial,sans-serif';\n\tcontext.textBaseline = 'top';\n\n\tcontext.fillStyle = bg;\n\tcontext.fillRect( 0, 0, WIDTH, HEIGHT );\n\n\tcontext.fillStyle = fg;\n\tcontext.fillText( name, TEXT_X, TEXT_Y );\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\n\n\tcontext.fillStyle = bg;\n\tcontext.globalAlpha = 0.9;\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\n\n\treturn {\n\n\t\tdom: canvas,\n\n\t\tupdate: function ( value, maxValue ) {\n\n\t\t\tmin = Math.min( min, value );\n\t\t\tmax = Math.max( max, value );\n\n\t\t\tcontext.fillStyle = bg;\n\t\t\tcontext.globalAlpha = 1;\n\t\t\tcontext.fillRect( 0, 0, WIDTH, GRAPH_Y );\n\t\t\tcontext.fillStyle = fg;\n\t\t\tcontext.fillText( round( value ) + ' ' + name + ' (' + round( min ) + '-' + round( max ) + ')', TEXT_X, TEXT_Y );\n\n\t\t\tcontext.drawImage( canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT );\n\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT );\n\n\t\t\tcontext.fillStyle = bg;\n\t\t\tcontext.globalAlpha = 0.9;\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round( ( 1 - ( value / maxValue ) ) * GRAPH_HEIGHT ) );\n\n\t\t}\n\n\t};\n\n};\n\nexport default Stats;\n","import * as THREE from 'three';\n\nexport function generateRadialFloorTexture( dim ) {\n\n\tconst data = new Uint8Array( dim * dim * 4 );\n\n\tfor ( let x = 0; x < dim; x ++ ) {\n\n\t\tfor ( let y = 0; y < dim; y ++ ) {\n\n\t\t\tconst xNorm = x / ( dim - 1 );\n\t\t\tconst yNorm = y / ( dim - 1 );\n\n\t\t\tconst xCent = 2.0 * ( xNorm - 0.5 );\n\t\t\tconst yCent = 2.0 * ( yNorm - 0.5 );\n\t\t\tlet a = Math.max( Math.min( 1.0 - Math.sqrt( xCent ** 2 + yCent ** 2 ), 1.0 ), 0.0 );\n\t\t\ta = a ** 2;\n\t\t\ta = a * 1.5;\n\t\t\ta = Math.min( a, 1.0 );\n\n\t\t\tconst i = y * dim + x;\n\t\t\tdata[ i * 4 + 0 ] = 255;\n\t\t\tdata[ i * 4 + 1 ] = 255;\n\t\t\tdata[ i * 4 + 2 ] = 255;\n\t\t\tdata[ i * 4 + 3 ] = a * 255;\n\n\t\t}\n\n\t}\n\n\tconst tex = new THREE.DataTexture( data, dim, dim );\n\ttex.format = THREE.RGBAFormat;\n\ttex.type = THREE.UnsignedByteType;\n\ttex.minFilter = THREE.LinearFilter;\n\ttex.magFilter = THREE.LinearFilter;\n\ttex.wrapS = THREE.RepeatWrapping;\n\ttex.wrapT = THREE.RepeatWrapping;\n\ttex.needsUpdate = true;\n\treturn tex;\n\n}\n","export function getScaledSettings() {\n\n\tlet tiles = 3;\n\tlet renderScale = Math.max( 1 / window.devicePixelRatio, 0.5 );\n\n\t// adjust performance parameters for mobile\n\tconst aspectRatio = window.innerWidth / window.innerHeight;\n\tif ( aspectRatio < 0.65 ) {\n\n\t\ttiles = 4;\n\t\trenderScale = 0.5 / window.devicePixelRatio;\n\n\t}\n\n\treturn { tiles, renderScale };\n\n}\n","let _styleElement;\nfunction initializeStyles() {\n\n\tif ( _styleElement ) {\n\n\t\treturn;\n\n\t}\n\n\t_styleElement = document.createElement( 'style' );\n\t_styleElement.textContent = /* css */`\n\n\t\t.loader-container, .description {\n\t\t\tposition: absolute;\n\t\t\twidth: 100%;\n\t\t\tfont-family: 'Courier New', Courier, monospace;\n\t\t\tcolor: white;\n\t\t\tfont-weight: light;\n\t\t\talign-items: flex-start;\n\t\t\tfont-size: 14px;\n\t\t\tpointer-events: none;\n\t\t\tuser-select: none;\n\t\t}\n\n\t\t.loader-container {\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: column;\n\t\t\tbottom: 0;\n\t\t}\n\n\t\t.description {\n\t\t\ttop: 0;\n\t\t\twidth: 100%;\n\t\t\ttext-align: center;\n\t\t\tpadding: 5px 0;\n\t\t}\n\n\t\t.loader-container .bar {\n\t\t\theight: 2px;\n\t\t\tbackground: white;\n\t\t\twidth: 100%;\n\t\t}\n\n\t\t.loader-container .credits,\n\t\t.loader-container .samples,\n\t\t.loader-container .percentage {\n\t\t\tpadding: 5px;\n\t\t\tmargin: 0 0 1px 1px;\n\t\t\tbackground: rgba( 0, 0, 0, 0.2 );\n\t\t\tborder-radius: 2px;\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t.loader-container:not(.loading) .bar,\n\t\t.loader-container:not(.loading) .percentage,\n\t\t.loader-container.loading .credits,\n\t\t.loader-container.loading .samples,\n\t\t.loader-container .credits:empty {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t.loader-container .credits a,\n\t\t.loader-container .credits,\n\t\t.loader-container .samples {\n\t\t\tcolor: rgba( 255, 255, 255, 0.75 );\n\t\t}\n\t`;\n\tdocument.head.appendChild( _styleElement );\n\n}\n\nexport class LoaderElement {\n\n\tconstructor() {\n\n\t\tinitializeStyles();\n\n\t\tconst container = document.createElement( 'div' );\n\t\tcontainer.classList.add( 'loader-container' );\n\n\t\tconst percentageEl = document.createElement( 'div' );\n\t\tpercentageEl.classList.add( 'percentage' );\n\t\tcontainer.appendChild( percentageEl );\n\n\t\tconst samplesEl = document.createElement( 'div' );\n\t\tsamplesEl.classList.add( 'samples' );\n\t\tcontainer.appendChild( samplesEl );\n\n\t\tconst creditsEl = document.createElement( 'div' );\n\t\tcreditsEl.classList.add( 'credits' );\n\t\tcontainer.appendChild( creditsEl );\n\n\t\tconst loaderBarEl = document.createElement( 'div' );\n\t\tloaderBarEl.classList.add( 'bar' );\n\t\tcontainer.appendChild( loaderBarEl );\n\n\t\tconst descriptionEl = document.createElement( 'div' );\n\t\tdescriptionEl.classList.add( 'description' );\n\t\tcontainer.appendChild( descriptionEl );\n\n\t\tthis._description = descriptionEl;\n\t\tthis._loaderBar = loaderBarEl;\n\t\tthis._percentage = percentageEl;\n\t\tthis._credits = creditsEl;\n\t\tthis._samples = samplesEl;\n\t\tthis._container = container;\n\n\t\tthis.setPercentage( 0 );\n\n\t}\n\n\tattach( container ) {\n\n\t\tcontainer.appendChild( this._container );\n\t\tcontainer.appendChild( this._description );\n\n\t}\n\n\tsetPercentage( perc ) {\n\n\t\tthis._loaderBar.style.width = `${ perc * 100 }%`;\n\n\t\tif ( perc === 0 ) {\n\n\t\t\tthis._percentage.innerText = 'Loading...';\n\n\t\t} else {\n\n\t\t\tthis._percentage.innerText = `${ ( perc * 100 ).toFixed( 0 ) }%`;\n\n\t\t}\n\n\t\tif ( perc >= 1 ) {\n\n\t\t\tthis._container.classList.remove( 'loading' );\n\n\t\t} else {\n\n\t\t\tthis._container.classList.add( 'loading' );\n\n\t\t}\n\n\t}\n\n\tsetSamples( count, compiling = false ) {\n\n\t\tif ( compiling ) {\n\n\t\t\tthis._samples.innerText = 'compiling shader...';\n\n\t\t} else {\n\n\t\t\tthis._samples.innerText = `${ Math.floor( count ) } samples`;\n\n\t\t}\n\n\t}\n\n\tsetCredits( credits ) {\n\n\t\tthis._credits.innerHTML = credits;\n\n\t}\n\n\tsetDescription( description ) {\n\n\t\tthis._description.innerHTML = description;\n\n\t}\n\n}\n","import { Box3, BufferAttribute } from 'three';\nimport { MeshBVH } from '../core/MeshBVH.js';\nimport { WorkerBase } from './utils/WorkerBase.js';\nimport { convertToBufferType, isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { GenerateMeshBVHWorker } from './GenerateMeshBVHWorker.js';\nimport { ensureIndex } from '../core/build/geometryUtils.js';\n\nconst DEFAULT_WORKER_COUNT = typeof navigator !== 'undefined' ? navigator.hardwareConcurrency : 4;\nclass _ParallelMeshBVHWorker extends WorkerBase {\n\n\tconstructor() {\n\n\t\tconst worker = new Worker( new URL( './parallelMeshBVH.worker.js', import.meta.url ), { type: 'module' } );\n\t\tsuper( worker );\n\n\t\tthis.name = 'ParallelMeshBVHWorker';\n\t\tthis.maxWorkerCount = Math.max( DEFAULT_WORKER_COUNT, 4 );\n\n\t\tif ( ! isSharedArrayBufferSupported() ) {\n\n\t\t\tthrow new Error( 'ParallelMeshBVHWorker: Shared Array Buffers are not supported.' );\n\n\t\t}\n\n\t}\n\n\trunTask( worker, geometry, options = {} ) {\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tif ( ! geometry.index && ! options.indirect ) {\n\n\t\t\t\tensureIndex( geometry, options );\n\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tgeometry.getAttribute( 'position' ).isInterleavedBufferAttribute ||\n\t\t\t\tgeometry.index && geometry.index.isInterleavedBufferAttribute\n\t\t\t) {\n\n\t\t\t\tthrow new Error( 'ParallelMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.' );\n\n\t\t\t}\n\n\t\t\tworker.onerror = e => {\n\n\t\t\t\treject( new Error( `ParallelMeshBVHWorker: ${ e.message }` ) );\n\n\t\t\t};\n\n\t\t\tworker.onmessage = e => {\n\n\t\t\t\tconst { data } = e;\n\n\t\t\t\tif ( data.error ) {\n\n\t\t\t\t\treject( new Error( data.error ) );\n\t\t\t\t\tworker.onmessage = null;\n\n\t\t\t\t} else if ( data.serialized ) {\n\n\t\t\t\t\tconst { serialized, position } = data;\n\t\t\t\t\tconst bvh = MeshBVH.deserialize( serialized, geometry, { setIndex: false } );\n\t\t\t\t\tconst boundsOptions = {\n\t\t\t\t\t\tsetBoundingBox: true,\n\t\t\t\t\t\t...options,\n\t\t\t\t\t};\n\n\t\t\t\t\t// we need to replace the arrays because they're neutered entirely by the\n\t\t\t\t\t// webworker transfer.\n\t\t\t\t\tgeometry.attributes.position.array = position;\n\t\t\t\t\tif ( serialized.index ) {\n\n\t\t\t\t\t\tif ( geometry.index ) {\n\n\t\t\t\t\t\t\tgeometry.index.array = serialized.index;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconst newIndex = new BufferAttribute( serialized.index, 1, false );\n\t\t\t\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( boundsOptions.setBoundingBox ) {\n\n\t\t\t\t\t\tgeometry.boundingBox = bvh.getBoundingBox( new Box3() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.onProgress ) {\n\n\t\t\t\t\t\toptions.onProgress( data.progress );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( bvh );\n\t\t\t\t\tworker.onmessage = null;\n\n\t\t\t\t} else if ( options.onProgress ) {\n\n\t\t\t\t\toptions.onProgress( data.progress );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tconst index = geometry.index ? geometry.index.array : null;\n\t\t\tconst position = geometry.attributes.position.array;\n\t\t\tworker.postMessage( {\n\n\t\t\t\toperation: 'BUILD_BVH',\n\t\t\t\tmaxWorkerCount: this.maxWorkerCount,\n\t\t\t\tindex: convertToBufferType( index, SharedArrayBuffer ),\n\t\t\t\tposition: convertToBufferType( position, SharedArrayBuffer ),\n\t\t\t\toptions: {\n\t\t\t\t\t...options,\n\t\t\t\t\tonProgress: null,\n\t\t\t\t\tincludedProgressCallback: Boolean( options.onProgress ),\n\t\t\t\t\tgroups: [ ... geometry.groups ],\n\t\t\t\t},\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n\nexport class ParallelMeshBVHWorker {\n\n\tconstructor() {\n\n\t\tif ( isSharedArrayBufferSupported() ) {\n\n\t\t\treturn new _ParallelMeshBVHWorker();\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'ParallelMeshBVHWorker: SharedArrayBuffers not supported. Falling back to single-threaded GenerateMeshBVHWorker.' );\n\n\t\t\tconst object = new GenerateMeshBVHWorker();\n\t\t\tobject.maxWorkerCount = DEFAULT_WORKER_COUNT;\n\t\t\treturn object;\n\n\t\t}\n\n\t}\n\n}\n","export class WorkerBase {\n\n\tconstructor( worker ) {\n\n\t\tthis.name = 'WorkerBase';\n\t\tthis.running = false;\n\t\tthis.worker = worker;\n\t\tthis.worker.onerror = e => {\n\n\t\t\tif ( e.message ) {\n\n\t\t\t\tthrow new Error( `${ this.name }: Could not create Web Worker with error \"${ e.message }\"` );\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( `${ this.name }: Could not create Web Worker.` );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\trunTask() {}\n\n\tgenerate( ...args ) {\n\n\t\tif ( this.running ) {\n\n\t\t\tthrow new Error( 'GenerateMeshBVHWorker: Already running job.' );\n\n\t\t}\n\n\t\tif ( this.worker === null ) {\n\n\t\t\tthrow new Error( 'GenerateMeshBVHWorker: Worker has been disposed.' );\n\n\t\t}\n\n\t\tthis.running = true;\n\n\t\tconst promise = this.runTask( this.worker, ...args );\n\t\tpromise.finally( () => {\n\n\t\t\tthis.running = false;\n\n\t\t} );\n\n\t\treturn promise;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.worker.terminate();\n\t\tthis.worker = null;\n\n\t}\n\n}\n","import { Box3, BufferAttribute } from 'three';\nimport { MeshBVH } from '../core/MeshBVH.js';\nimport { WorkerBase } from './utils/WorkerBase.js';\n\nexport class GenerateMeshBVHWorker extends WorkerBase {\n\n\tconstructor() {\n\n\t\tconst worker = new Worker( new URL( './generateMeshBVH.worker.js', import.meta.url ), { type: 'module' } );\n\t\tsuper( worker );\n\t\tthis.name = 'GenerateMeshBVHWorker';\n\n\t}\n\n\trunTask( worker, geometry, options = {} ) {\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tif (\n\t\t\t\tgeometry.getAttribute( 'position' ).isInterleavedBufferAttribute ||\n\t\t\t\tgeometry.index && geometry.index.isInterleavedBufferAttribute\n\t\t\t) {\n\n\t\t\t\tthrow new Error( 'GenerateMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.' );\n\n\t\t\t}\n\n\t\t\tworker.onerror = e => {\n\n\t\t\t\treject( new Error( `GenerateMeshBVHWorker: ${ e.message }` ) );\n\n\t\t\t};\n\n\t\t\tworker.onmessage = e => {\n\n\t\t\t\tconst { data } = e;\n\n\t\t\t\tif ( data.error ) {\n\n\t\t\t\t\treject( new Error( data.error ) );\n\t\t\t\t\tworker.onmessage = null;\n\n\t\t\t\t} else if ( data.serialized ) {\n\n\t\t\t\t\tconst { serialized, position } = data;\n\t\t\t\t\tconst bvh = MeshBVH.deserialize( serialized, geometry, { setIndex: false } );\n\t\t\t\t\tconst boundsOptions = Object.assign( {\n\n\t\t\t\t\t\tsetBoundingBox: true,\n\n\t\t\t\t\t}, options );\n\n\t\t\t\t\t// we need to replace the arrays because they're neutered entirely by the\n\t\t\t\t\t// webworker transfer.\n\t\t\t\t\tgeometry.attributes.position.array = position;\n\t\t\t\t\tif ( serialized.index ) {\n\n\t\t\t\t\t\tif ( geometry.index ) {\n\n\t\t\t\t\t\t\tgeometry.index.array = serialized.index;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconst newIndex = new BufferAttribute( serialized.index, 1, false );\n\t\t\t\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( boundsOptions.setBoundingBox ) {\n\n\t\t\t\t\t\tgeometry.boundingBox = bvh.getBoundingBox( new Box3() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.onProgress ) {\n\n\t\t\t\t\t\toptions.onProgress( data.progress );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( bvh );\n\t\t\t\t\tworker.onmessage = null;\n\n\t\t\t\t} else if ( options.onProgress ) {\n\n\t\t\t\t\toptions.onProgress( data.progress );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tconst index = geometry.index ? geometry.index.array : null;\n\t\t\tconst position = geometry.attributes.position.array;\n\t\t\tconst transferable = [ position ];\n\t\t\tif ( index ) {\n\n\t\t\t\ttransferable.push( index );\n\n\t\t\t}\n\n\t\t\tworker.postMessage( {\n\n\t\t\t\tindex,\n\t\t\t\tposition,\n\t\t\t\toptions: {\n\t\t\t\t\t...options,\n\t\t\t\t\tonProgress: null,\n\t\t\t\t\tincludedProgressCallback: Boolean( options.onProgress ),\n\t\t\t\t\tgroups: [ ... geometry.groups ],\n\t\t\t\t},\n\n\t\t\t}, transferable.map( arr => arr.buffer ).filter( v => ( typeof SharedArrayBuffer === 'undefined' ) || ! ( v instanceof SharedArrayBuffer ) ) );\n\n\t\t} );\n\n\t}\n\n}\n","let workerURL = require('./helpers/get-worker-url');\nlet url = new __parcel__URL__(\"generateMeshBVH.worker.373f3c58.js\");\nmodule.exports = workerURL(url.toString(), url.origin, true);","\"use strict\";\n\nmodule.exports = function (workerUrl, origin, isESM) {\n  if (origin === self.location.origin) {\n    // If the worker bundle's url is on the same origin as the document,\n    // use the worker bundle's own url.\n    return workerUrl;\n  } else {\n    // Otherwise, create a blob URL which loads the worker bundle with `importScripts`.\n    var source = isESM ? 'import ' + JSON.stringify(workerUrl) + ';' : 'importScripts(' + JSON.stringify(workerUrl) + ');';\n    return URL.createObjectURL(new Blob([source], {\n      type: 'application/javascript'\n    }));\n  }\n};","let workerURL = require('./helpers/get-worker-url');\nlet url = new __parcel__URL__(\"parallelMeshBVH.worker.22cf4bb0.js\");\nmodule.exports = workerURL(url.toString(), url.origin, true);","import { ShaderMaterial } from 'three';\n\nexport class MaterialBase extends ShaderMaterial {\n\n\tset needsUpdate( v ) {\n\n\t\tsuper.needsUpdate = true;\n\t\tthis.dispatchEvent( {\n\n\t\t\ttype: 'recompilation',\n\n\t\t} );\n\n\t}\n\n\tconstructor( shader ) {\n\n\t\tsuper( shader );\n\n\t\tfor ( const key in this.uniforms ) {\n\n\t\t\tObject.defineProperty( this, key, {\n\n\t\t\t\tget() {\n\n\t\t\t\t\treturn this.uniforms[ key ].value;\n\n\t\t\t\t},\n\n\t\t\t\tset( v ) {\n\n\t\t\t\t\tthis.uniforms[ key ].value = v;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// sets the given named define value and sets \"needsUpdate\" to true if it's different\n\tsetDefine( name, value = undefined ) {\n\n\t\tif ( value === undefined || value === null ) {\n\n\t\t\tif ( name in this.defines ) {\n\n\t\t\t\tdelete this.defines[ name ];\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.defines[ name ] !== value ) {\n\n\t\t\t\tthis.defines[ name ] = value;\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n}\n","export const math_functions = /* glsl */`\n\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\n\t// For more information see: https://github.com/gkjohnson/three-gpu-pathtracer/pull/171#issuecomment-1152275248\n\tfloat acosApprox( float x ) {\n\n\t\tx = clamp( x, -1.0, 1.0 );\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\n\n\t}\n\n\t// An acos with input values bound to the range [-1, 1].\n\tfloat acosSafe( float x ) {\n\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\n\n\t}\n\n\tfloat saturateCos( float val ) {\n\n\t\treturn clamp( val, 0.001, 1.0 );\n\n\t}\n\n\tfloat square( float t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 square( vec2 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec3 square( vec3 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec4 square( vec4 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 rotateVector( vec2 v, float t ) {\n\n\t\tfloat ac = cos( t );\n\t\tfloat as = sin( t );\n\t\treturn vec2(\n\t\t\tv.x * ac - v.y * as,\n\t\t\tv.x * as + v.y * ac\n\t\t);\n\n\t}\n\n\t// forms a basis with the normal vector as Z\n\tmat3 getBasisFromNormal( vec3 normal ) {\n\n\t\tvec3 other;\n\t\tif ( abs( normal.x ) > 0.5 ) {\n\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\n\n\t\t} else {\n\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\n\n\t\t}\n\n\t\tvec3 ortho = normalize( cross( normal, other ) );\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\n\t\treturn mat3( ortho2, ortho, normal );\n\n\t}\n\n`;\n","export const util_functions = /* glsl */`\n\n\t// TODO: possibly this should be renamed something related to material or path tracing logic\n\n\t#ifndef RAY_OFFSET\n\t#define RAY_OFFSET 1e-4\n\t#endif\n\n\t// adjust the hit point by the surface normal by a factor of some offset and the\n\t// maximum component-wise value of the current point to accommodate floating point\n\t// error as values increase.\n\tvec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {\n\n\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\tvec3 absPoint = abs( point );\n\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\treturn point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;\n\n\t}\n\n\t// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\n\tvec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {\n\n\t\tvec3 ot = - log( attColor ) / attDist;\n\t\treturn exp( - ot * dist );\n\n\t}\n\n\tvec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {\n\n\t\t// get the half vector - assuming if the light incident vector is on the other side\n\t\t// of the that it's transmissive.\n\t\tvec3 h;\n\t\tif ( wi.z > 0.0 ) {\n\n\t\t\th = normalize( wi + wo );\n\n\t\t} else {\n\n\t\t\t// Scale by the ior ratio to retrieve the appropriate half vector\n\t\t\t// From Section 2.2 on computing the transmission half vector:\n\t\t\t// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\n\t\t\th = normalize( wi + wo * eta );\n\n\t\t}\n\n\t\th *= sign( h.z );\n\t\treturn h;\n\n\t}\n\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\n\n\t\treturn normalize( a + b );\n\n\t}\n\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\n\t// we find a ray like that we ignore it to avoid artifacts.\n\t// This function returns if the direction is on the same side of both planes.\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\n\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\n\n\t}\n\n\t// ray sampling x and z are swapped to align with expected background view\n\tvec2 equirectDirectionToUv( vec3 direction ) {\n\n\t\t// from Spherical.setFromCartesianCoords\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\n\t\tuv /= vec2( 2.0 * PI, PI );\n\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\n\t\tuv.x += 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\t\treturn uv;\n\n\t}\n\n\tvec3 equirectUvToDirection( vec2 uv ) {\n\n\t\t// undo above adjustments\n\t\tuv.x -= 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\n\t\t// from Vector3.setFromSphericalCoords\n\t\tfloat theta = uv.x * 2.0 * PI;\n\t\tfloat phi = uv.y * PI;\n\n\t\tfloat sinPhi = sin( phi );\n\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\n\n\t}\n\n\t// power heuristic for multiple importance sampling\n\tfloat misHeuristic( float a, float b ) {\n\n\t\tfloat aa = a * a;\n\t\tfloat bb = b * b;\n\t\treturn aa / ( aa + bb );\n\n\t}\n\n\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\n\t// erichlof/THREE.js-PathTracing-Renderer/\n\tfloat tentFilter( float x ) {\n\n\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\n\n\t}\n`;\n","export const ggx_functions = /* glsl */`\n\n\t// The GGX functions provide sampling and distribution information for normals as output so\n\t// in order to get probability of scatter direction the half vector must be computed and provided.\n\t// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\t// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n\t// [2] http://jcgt.org/published/0007/04/01/\n\t// [4] http://jcgt.org/published/0003/02/03/\n\n\t// trowbridge-reitz === GGX === GTR\n\n\tvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\n\n\t\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t\t// function below, as well\n\n\t\t// Implementation from reference [1]\n\t\t// stretch view\n\t\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\n\n\t\t// orthonormal basis\n\t\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\n\t\tvec3 T2 = cross( T1, V );\n\n\t\t// sample point with polar coordinates (r, phi)\n\t\tfloat a = 1.0 / ( 1.0 + V.z );\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\n\t\tfloat P1 = r * cos( phi );\n\t\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\n\n\t\t// compute normal\n\t\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\n\n\t\t// unstretch\n\t\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\n\n\t\treturn N;\n\n\t}\n\n\t// Below are PDF and related functions for use in a Monte Carlo path tracer\n\t// as specified in Appendix B of the following paper\n\t// See equation (34) from reference [0]\n\tfloat ggxLamda( float theta, float roughness ) {\n\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = tanTheta * tanTheta;\n\t\tfloat alpha2 = roughness * roughness;\n\n\t\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\n\t\treturn numerator / 2.0;\n\n\t}\n\n\t// See equation (34) from reference [0]\n\tfloat ggxShadowMaskG1( float theta, float roughness ) {\n\n\t\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n\t}\n\n\t// See equation (125) from reference [4]\n\tfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat scatterTheta = acos( wo.z );\n\t\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n\t}\n\n\t// See equation (33) from reference [0]\n\tfloat ggxDistribution( vec3 halfVector, float roughness ) {\n\n\t\tfloat a2 = roughness * roughness;\n\t\ta2 = max( EPSILON, a2 );\n\t\tfloat cosTheta = halfVector.z;\n\t\tfloat cosTheta4 = pow( cosTheta, 4.0 );\n\n\t\tif ( cosTheta == 0.0 ) return 0.0;\n\n\t\tfloat theta = acosSafe( halfVector.z );\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = pow( tanTheta, 2.0 );\n\n\t\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\n\t\treturn ( a2 / denom );\n\n\t}\n\n\t// See equation (3) from reference [2]\n\tfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat D = ggxDistribution( halfVector, roughness );\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\t\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\n\n\t}\n\n`;\n","import {\n\tACESFilmicToneMapping,\n\tNoToneMapping,\n\tBox3,\n\tLoadingManager,\n\tSphere,\n\tDoubleSide,\n\tMesh,\n\tMeshStandardMaterial,\n\tPlaneGeometry,\n\tMeshPhysicalMaterial,\n\tScene,\n\tPerspectiveCamera,\n\tOrthographicCamera,\n\tWebGLRenderer,\n\tEquirectangularReflectionMapping,\n} from 'three';\nimport { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { ColladaLoader } from 'three/examples/jsm/loaders/ColladaLoader.js';\nimport { LDrawLoader } from 'three/examples/jsm/loaders/LDrawLoader.js';\nimport { LDrawUtils } from 'three/examples/jsm/utils/LDrawUtils.js';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport Stats from 'three/examples/jsm/libs/stats.module.js';\nimport { generateRadialFloorTexture } from './utils/generateRadialFloorTexture.js';\nimport { GradientEquirectTexture, WebGLPathTracer } from '../src/index.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { getScaledSettings } from './utils/getScaledSettings.js';\nimport { LoaderElement } from './utils/LoaderElement.js';\nimport { ParallelMeshBVHWorker } from 'three-mesh-bvh/src/workers/ParallelMeshBVHWorker.js';\n\nconst envMaps = {\n\t'Royal Esplanade': 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/royal_esplanade_1k.hdr',\n\t'Moonless Golf': 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/moonless_golf_1k.hdr',\n\t'Overpass': 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/pedestrian_overpass_1k.hdr',\n\t'Venice Sunset': 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/venice_sunset_1k.hdr',\n\t'Small Studio': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/studio_small_05_1k.hdr',\n\t'Pfalzer Forest': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/phalzer_forest_01_1k.hdr',\n\t'Leadenhall Market': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/leadenhall_market_1k.hdr',\n\t'Kloppenheim': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/kloppenheim_05_1k.hdr',\n\t'Hilly Terrain': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/hilly_terrain_01_1k.hdr',\n\t'Circus Arena': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/circus_arena_1k.hdr',\n\t'Chinese Garden': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/chinese_garden_1k.hdr',\n\t'Autoshop': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/autoshop_01_1k.hdr',\n\n\t'Measuring Lab': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/vintage_measuring_lab_2k.hdr',\n\t'Whale Skeleton': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/whale_skeleton_2k.hdr',\n\t'Hall of Mammals': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/hall_of_mammals_2k.hdr',\n\n\t'Drachenfels Cellar': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/drachenfels_cellar_2k.hdr',\n\t'Adams Place Bridge': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/adams_place_bridge_2k.hdr',\n\t'Sepulchral Chapel Rotunda': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/sepulchral_chapel_rotunda_2k.hdr',\n\t'Peppermint Powerplant': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/peppermint_powerplant_2k.hdr',\n\t'Noon Grass': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/noon_grass_2k.hdr',\n\t'Narrow Moonlit Road': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/narrow_moonlit_road_2k.hdr',\n\t'St Peters Square Night': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/st_peters_square_night_2k.hdr',\n\t'Brown Photostudio 01': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/brown_photostudio_01_2k.hdr',\n\t'Rainforest Trail': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/rainforest_trail_2k.hdr',\n\t'Brown Photostudio 07': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/brown_photostudio_07_2k.hdr',\n\t'Brown Photostudio 06': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/brown_photostudio_06_2k.hdr',\n\t'Dancing Hall': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/dancing_hall_2k.hdr',\n\t'Aristea Wreck Puresky': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/aristea_wreck_puresky_2k.hdr',\n\t'Modern Buildings 2': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/modern_buildings_2_2k.hdr',\n\t'Thatch Chapel': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/thatch_chapel_2k.hdr',\n\t'Vestibule': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/vestibule_2k.hdr',\n\t'Blocky Photo Studio': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/blocky_photo_studio_1k.hdr',\n\t'Christmas Photo Studio 07': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/christmas_photo_studio_07_2k.hdr',\n\t'Aerodynamics Workshop': 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/aerodynamics_workshop_1k.hdr',\n\n};\n\nconst models = window.MODEL_LIST || {};\n\nconst params = {\n\n\tmultipleImportanceSampling: true,\n\tacesToneMapping: true,\n\trenderScale: 1 / window.devicePixelRatio,\n\ttiles: 2,\n\n\tmodel: '',\n\n\tenvMap: envMaps[ 'Aristea Wreck Puresky' ],\n\n\tgradientTop: '#bfd8ff',\n\tgradientBottom: '#ffffff',\n\n\tenvironmentIntensity: 1.0,\n\tenvironmentRotation: 0,\n\n\tcameraProjection: 'Perspective',\n\n\tbackgroundType: 'Gradient',\n\tbgGradientTop: '#111111',\n\tbgGradientBottom: '#000000',\n\tbackgroundBlur: 0.0,\n\ttransparentBackground: false,\n\tcheckerboardTransparency: true,\n\n\tenable: true,\n\tbounces: 5,\n\tfilterGlossyFactor: 0.5,\n\tpause: false,\n\n\tfloorColor: '#111111',\n\tfloorOpacity: 1.0,\n\tfloorRoughness: 0.2,\n\tfloorMetalness: 0.2,\n\n\t...getScaledSettings(),\n\n};\n\nlet floorPlane, gui, stats;\nlet pathTracer, renderer, orthoCamera, perspectiveCamera, activeCamera;\nlet controls, scene, model;\nlet gradientMap;\nlet loader;\n\nconst orthoWidth = 2;\n\ninit();\n\nasync function init() {\n\n\tloader = new LoaderElement();\n\tloader.attach( document.body );\n\n\t// renderer\n\trenderer = new WebGLRenderer( { antialias: true } );\n\trenderer.toneMapping = ACESFilmicToneMapping;\n\tdocument.body.appendChild( renderer.domElement );\n\n\t// path tracer\n\tpathTracer = new WebGLPathTracer( renderer );\n\tpathTracer.setBVHWorker( new ParallelMeshBVHWorker() );\n\tpathTracer.physicallyCorrectLights = true;\n\tpathTracer.tiles.set( params.tiles, params.tiles );\n\tpathTracer.multipleImportanceSampling = params.multipleImportanceSampling;\n\tpathTracer.transmissiveBounces = 10;\n\n\t// camera\n\tconst aspect = window.innerWidth / window.innerHeight;\n\tperspectiveCamera = new PerspectiveCamera( 60, aspect, 0.025, 500 );\n\tperspectiveCamera.position.set( - 1, 0.25, 1 );\n\n\tconst orthoHeight = orthoWidth / aspect;\n\torthoCamera = new OrthographicCamera( orthoWidth / - 2, orthoWidth / 2, orthoHeight / 2, orthoHeight / - 2, 0, 100 );\n\torthoCamera.position.set( - 1, 0.25, 1 );\n\n\t// background map\n\tgradientMap = new GradientEquirectTexture();\n\tgradientMap.topColor.set( params.bgGradientTop );\n\tgradientMap.bottomColor.set( params.bgGradientBottom );\n\tgradientMap.update();\n\n\t// controls\n\tcontrols = new OrbitControls( perspectiveCamera, renderer.domElement );\n\tcontrols.addEventListener( 'change', () => {\n\n\t\tpathTracer.updateCamera();\n\n\t} );\n\n\t// scene\n\tscene = new Scene();\n\tscene.background = gradientMap;\n\n\tconst floorTex = generateRadialFloorTexture( 2048 );\n\tfloorPlane = new Mesh(\n\t\tnew PlaneGeometry(),\n\t\tnew MeshStandardMaterial( {\n\t\t\tmap: floorTex,\n\t\t\ttransparent: true,\n\t\t\tcolor: 0x111111,\n\t\t\troughness: 0.1,\n\t\t\tmetalness: 0.0,\n\t\t\tside: DoubleSide,\n\t\t} )\n\t);\n\tfloorPlane.scale.setScalar( 5 );\n\tfloorPlane.rotation.x = - Math.PI / 2;\n\tscene.add( floorPlane );\n\n\tstats = new Stats();\n\tdocument.body.appendChild( stats.dom );\n\n\tupdateCameraProjection( params.cameraProjection );\n\tonHashChange();\n\tupdateEnvMap();\n\tonResize();\n\n\tanimate();\n\n\twindow.addEventListener( 'resize', onResize );\n\twindow.addEventListener( 'hashchange', onHashChange );\n\n}\n\nfunction animate() {\n\n\trequestAnimationFrame( animate );\n\n\tstats.update();\n\n\tif ( ! model ) {\n\n\t\treturn;\n\n\t}\n\n\tif ( params.enable ) {\n\n\t\tif ( ! params.pause || pathTracer.samples < 1 ) {\n\n\t\t\tpathTracer.renderSample();\n\n\t\t}\n\n\t} else {\n\n\t\trenderer.render( scene, activeCamera );\n\n\t}\n\n\tloader.setSamples( pathTracer.samples, pathTracer.isCompiling );\n\n}\n\nfunction onParamsChange() {\n\n\tpathTracer.multipleImportanceSampling = params.multipleImportanceSampling;\n\tpathTracer.bounces = params.bounces;\n\tpathTracer.filterGlossyFactor = params.filterGlossyFactor;\n\tpathTracer.renderScale = params.renderScale;\n\n\tfloorPlane.material.color.set( params.floorColor );\n\tfloorPlane.material.roughness = params.floorRoughness;\n\tfloorPlane.material.metalness = params.floorMetalness;\n\tfloorPlane.material.opacity = params.floorOpacity;\n\n\tscene.environmentIntensity = params.environmentIntensity;\n\tscene.environmentRotation.y = params.environmentRotation;\n\tscene.backgroundBlurriness = params.backgroundBlur;\n\n\tif ( params.backgroundType === 'Gradient' ) {\n\n\t\tgradientMap.topColor.set( params.bgGradientTop );\n\t\tgradientMap.bottomColor.set( params.bgGradientBottom );\n\t\tgradientMap.update();\n\n\t\tscene.background = gradientMap;\n\t\tscene.backgroundIntensity = 1;\n\t\tscene.environmentRotation.y = 0;\n\n\t} else {\n\n\t\tscene.background = scene.environment;\n\t\tscene.backgroundIntensity = params.environmentIntensity;\n\t\tscene.backgroundRotation.y = params.environmentRotation;\n\n\t}\n\n\tif ( params.transparentBackground ) {\n\n\t\tscene.background = null;\n\t\trenderer.setClearAlpha( 0 );\n\n\t}\n\n\tpathTracer.updateMaterials();\n\tpathTracer.updateEnvironment();\n\n}\n\nfunction onHashChange() {\n\n\tlet hashModel = '';\n\tif ( window.location.hash ) {\n\n\t\tconst modelName = decodeURI( window.location.hash.substring( 1 ) );\n\t\tif ( modelName in models ) {\n\n\t\t\thashModel = modelName;\n\n\t\t}\n\n\t}\n\n\tif ( ! ( hashModel in models ) ) {\n\n\t\thashModel = Object.keys( models )[ 0 ];\n\n\t}\n\n\tparams.model = hashModel;\n\tupdateModel();\n\n}\n\nfunction onResize() {\n\n\tconst w = window.innerWidth;\n\tconst h = window.innerHeight;\n\tconst dpr = window.devicePixelRatio;\n\n\trenderer.setSize( w, h );\n\trenderer.setPixelRatio( dpr );\n\n\tconst aspect = w / h;\n\tperspectiveCamera.aspect = aspect;\n\tperspectiveCamera.updateProjectionMatrix();\n\n\tconst orthoHeight = orthoWidth / aspect;\n\torthoCamera.top = orthoHeight / 2;\n\torthoCamera.bottom = orthoHeight / - 2;\n\torthoCamera.updateProjectionMatrix();\n\n\tpathTracer.updateCamera();\n\n}\n\nfunction buildGui() {\n\n\tif ( gui ) {\n\n\t\tgui.destroy();\n\n\t}\n\n\tgui = new GUI();\n\n\tgui.add( params, 'model', Object.keys( models ).sort() ).onChange( v => {\n\n\t\twindow.location.hash = v;\n\n\t} );\n\n\tconst pathTracingFolder = gui.addFolder( 'Path Tracer' );\n\tpathTracingFolder.add( params, 'enable' );\n\tpathTracingFolder.add( params, 'pause' );\n\tpathTracingFolder.add( params, 'multipleImportanceSampling' ).onChange( onParamsChange );\n\tpathTracingFolder.add( params, 'acesToneMapping' ).onChange( v => {\n\n\t\trenderer.toneMapping = v ? ACESFilmicToneMapping : NoToneMapping;\n\n\t} );\n\tpathTracingFolder.add( params, 'bounces', 1, 20, 1 ).onChange( onParamsChange );\n\tpathTracingFolder.add( params, 'filterGlossyFactor', 0, 1 ).onChange( onParamsChange );\n\tpathTracingFolder.add( params, 'renderScale', 0.1, 1.0, 0.01 ).onChange( () => {\n\n\t\tonParamsChange();\n\n\t} );\n\tpathTracingFolder.add( params, 'tiles', 1, 10, 1 ).onChange( v => {\n\n\t\tpathTracer.tiles.set( v, v );\n\n\t} );\n\tpathTracingFolder.add( params, 'cameraProjection', [ 'Perspective', 'Orthographic' ] ).onChange( v => {\n\n\t\tupdateCameraProjection( v );\n\n\t} );\n\tpathTracingFolder.open();\n\n\tconst environmentFolder = gui.addFolder( 'environment' );\n\tenvironmentFolder.add( params, 'envMap', envMaps ).name( 'map' ).onChange( updateEnvMap );\n\tenvironmentFolder.add( params, 'environmentIntensity', 0.0, 10.0 ).onChange( onParamsChange ).name( 'intensity' );\n\tenvironmentFolder.add( params, 'environmentRotation', 0, 2 * Math.PI ).onChange( onParamsChange );\n\tenvironmentFolder.open();\n\n\tconst backgroundFolder = gui.addFolder( 'background' );\n\tbackgroundFolder.add( params, 'backgroundType', [ 'Environment', 'Gradient' ] ).onChange( onParamsChange );\n\tbackgroundFolder.addColor( params, 'bgGradientTop' ).onChange( onParamsChange );\n\tbackgroundFolder.addColor( params, 'bgGradientBottom' ).onChange( onParamsChange );\n\tbackgroundFolder.add( params, 'backgroundBlur', 0, 1 ).onChange( onParamsChange );\n\tbackgroundFolder.add( params, 'transparentBackground', 0, 1 ).onChange( onParamsChange );\n\tbackgroundFolder.add( params, 'checkerboardTransparency' ).onChange( v => {\n\n\t\tif ( v ) document.body.classList.add( 'checkerboard' );\n\t\telse document.body.classList.remove( 'checkerboard' );\n\n\t} );\n\n\tconst floorFolder = gui.addFolder( 'floor' );\n\tfloorFolder.addColor( params, 'floorColor' ).onChange( onParamsChange );\n\tfloorFolder.add( params, 'floorRoughness', 0, 1 ).onChange( onParamsChange );\n\tfloorFolder.add( params, 'floorMetalness', 0, 1 ).onChange( onParamsChange );\n\tfloorFolder.add( params, 'floorOpacity', 0, 1 ).onChange( onParamsChange );\n\tfloorFolder.close();\n\n}\n\nfunction updateEnvMap() {\n\n\tnew RGBELoader()\n\t\t.load( params.envMap, texture => {\n\n\t\t\tif ( scene.environment ) {\n\n\t\t\t\tscene.environment.dispose();\n\n\t\t\t}\n\n\t\t\ttexture.mapping = EquirectangularReflectionMapping;\n\t\t\tscene.environment = texture;\n\t\t\tpathTracer.updateEnvironment();\n\t\t\tonParamsChange();\n\n\t\t} );\n\n}\n\nfunction updateCameraProjection( cameraProjection ) {\n\n\t// sync position\n\tif ( activeCamera ) {\n\n\t\tperspectiveCamera.position.copy( activeCamera.position );\n\t\torthoCamera.position.copy( activeCamera.position );\n\n\t}\n\n\t// set active camera\n\tif ( cameraProjection === 'Perspective' ) {\n\n\t\tactiveCamera = perspectiveCamera;\n\n\t} else {\n\n\t\tactiveCamera = orthoCamera;\n\n\t}\n\n\tcontrols.object = activeCamera;\n\tcontrols.update();\n\n\tpathTracer.setCamera( activeCamera );\n\n}\n\nfunction convertOpacityToTransmission( model, ior ) {\n\n\tmodel.traverse( c => {\n\n\t\tif ( c.material ) {\n\n\t\t\tconst material = c.material;\n\t\t\tif ( material.opacity < 0.65 && material.opacity > 0.2 ) {\n\n\t\t\t\tconst newMaterial = new MeshPhysicalMaterial();\n\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\tif ( key in material ) {\n\n\t\t\t\t\t\tif ( material[ key ] === null ) {\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( material[ key ].isTexture ) {\n\n\t\t\t\t\t\t\tnewMaterial[ key ] = material[ key ];\n\n\t\t\t\t\t\t} else if ( material[ key ].copy && material[ key ].constructor === newMaterial[ key ].constructor ) {\n\n\t\t\t\t\t\t\tnewMaterial[ key ].copy( material[ key ] );\n\n\t\t\t\t\t\t} else if ( ( typeof material[ key ] ) === 'number' ) {\n\n\t\t\t\t\t\t\tnewMaterial[ key ] = material[ key ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnewMaterial.opacity = 1.0;\n\t\t\t\tnewMaterial.transmission = 1.0;\n\t\t\t\tnewMaterial.ior = ior;\n\n\t\t\t\tconst hsl = {};\n\t\t\t\tnewMaterial.color.getHSL( hsl );\n\t\t\t\thsl.l = Math.max( hsl.l, 0.35 );\n\t\t\t\tnewMaterial.color.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\t\t\tc.material = newMaterial;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n}\n\nasync function updateModel() {\n\n\tif ( gui ) {\n\n\t\tdocument.body.classList.remove( 'checkerboard' );\n\t\tgui.destroy();\n\t\tgui = null;\n\n\t}\n\n\tconst modelInfo = models[ params.model ];\n\n\trenderer.domElement.style.visibility = 'hidden';\n\tloader.setPercentage( 0 );\n\n\tif ( model ) {\n\n\t\tmodel.traverse( c => {\n\n\t\t\tif ( c.material ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\tif ( material[ key ] && material[ key ].isTexture ) {\n\n\t\t\t\t\t\tmaterial[ key ].dispose();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tscene.remove( model );\n\t\tmodel = null;\n\n\t}\n\n\ttry {\n\n\t\tmodel = await loadModel( modelInfo.url, v => {\n\n\t\t\tloader.setPercentage( 0.5 * v );\n\n\t\t} );\n\n\t} catch ( err ) {\n\n\t\tloader.setCredits( 'Failed to load model:' + err.message );\n\t\tloader.setPercentage( 1 );\n\n\t}\n\n\t// update after model load\n\t// TODO: clean up\n\tif ( modelInfo.removeEmission ) {\n\n\t\tmodel.traverse( c => {\n\n\t\t\tif ( c.material ) {\n\n\t\t\t\tc.material.emissiveMap = null;\n\t\t\t\tc.material.emissiveIntensity = 0;\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tif ( modelInfo.opacityToTransmission ) {\n\n\t\tconvertOpacityToTransmission( model, modelInfo.ior || 1.5 );\n\n\t}\n\n\tmodel.traverse( c => {\n\n\t\tif ( c.material ) {\n\n\t\t\t// set the thickness so we render the material as a volumetric object\n\t\t\tc.material.thickness = 1.0;\n\n\t\t}\n\n\t} );\n\n\tif ( modelInfo.postProcess ) {\n\n\t\tmodelInfo.postProcess( model );\n\n\t}\n\n\t// rotate model after so it doesn't affect the bounding sphere scale\n\tif ( modelInfo.rotation ) {\n\n\t\tmodel.rotation.set( ...modelInfo.rotation );\n\n\t}\n\n\t// center the model\n\tconst box = new Box3();\n\tbox.setFromObject( model );\n\tmodel.position\n\t\t.addScaledVector( box.min, - 0.5 )\n\t\t.addScaledVector( box.max, - 0.5 );\n\n\tconst sphere = new Sphere();\n\tbox.getBoundingSphere( sphere );\n\n\tmodel.scale.setScalar( 1 / sphere.radius );\n\tmodel.position.multiplyScalar( 1 / sphere.radius );\n\tbox.setFromObject( model );\n\tfloorPlane.position.y = box.min.y;\n\n\tscene.add( model );\n\n\tawait pathTracer.setSceneAsync( scene, activeCamera, {\n\n\t\tonProgress: v => loader.setPercentage( 0.5 + 0.5 * v ),\n\n\t} );\n\n\tloader.setPercentage( 1 );\n\tloader.setCredits( modelInfo.credit || '' );\n\tparams.bounces = modelInfo.bounces || 5;\n\tparams.floorColor = modelInfo.floorColor || '#111111';\n\tparams.floorRoughness = modelInfo.floorRoughness || 0.2;\n\tparams.floorMetalness = modelInfo.floorMetalness || 0.2;\n\tparams.bgGradientTop = modelInfo.gradientTop || '#111111';\n\tparams.bgGradientBottom = modelInfo.gradientBot || '#000000';\n\n\tbuildGui();\n\tonParamsChange();\n\n\trenderer.domElement.style.visibility = 'visible';\n\tif ( params.checkerboardTransparency ) {\n\n\t\tdocument.body.classList.add( 'checkerboard' );\n\n\t}\n\n}\n\nasync function loadModel( url, onProgress ) {\n\n\t// TODO: clean up\n\tconst manager = new LoadingManager();\n\tif ( /dae$/i.test( url ) ) {\n\n\t\tconst complete = new Promise( resolve => manager.onLoad = resolve );\n\t\tconst res = await new ColladaLoader( manager ).loadAsync( url, progress => {\n\n\t\t\tif ( progress.total !== 0 && progress.total >= progress.loaded ) {\n\n\t\t\t\tonProgress( progress.loaded / progress.total );\n\n\t\t\t}\n\n\t\t} );\n\t\tawait complete;\n\n\t\tres.scene.scale.setScalar( 1 );\n\t\tres.scene.traverse( c => {\n\n\t\t\tconst { material } = c;\n\t\t\tif ( material && material.isMeshPhongMaterial ) {\n\n\t\t\t\tc.material = new MeshStandardMaterial( {\n\n\t\t\t\t\tcolor: material.color,\n\t\t\t\t\troughness: material.roughness || 0,\n\t\t\t\t\tmetalness: material.metalness || 0,\n\t\t\t\t\tmap: material.map || null,\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn res.scene;\n\n\t} else if ( /(gltf|glb)$/i.test( url ) ) {\n\n\t\tconst complete = new Promise( resolve => manager.onLoad = resolve );\n\t\tconst gltf = await new GLTFLoader( manager ).setMeshoptDecoder( MeshoptDecoder ).loadAsync( url, progress => {\n\n\t\t\tif ( progress.total !== 0 && progress.total >= progress.loaded ) {\n\n\t\t\t\tonProgress( progress.loaded / progress.total );\n\n\t\t\t}\n\n\t\t} );\n\t\tawait complete;\n\n\t\treturn gltf.scene;\n\n\t} else if ( /mpd$/i.test( url ) ) {\n\n\t\tmanager.onProgress = ( url, loaded, total ) => {\n\n\t\t\tonProgress( loaded / total );\n\n\t\t};\n\n\t\tconst complete = new Promise( resolve => manager.onLoad = resolve );\n\t\tconst ldrawLoader = new LDrawLoader( manager );\n\t\tawait ldrawLoader.preloadMaterials( 'https://raw.githubusercontent.com/gkjohnson/ldraw-parts-library/master/colors/ldcfgalt.ldr' );\n\t\tconst result = await ldrawLoader\n\t\t\t.setPartsLibraryPath( 'https://raw.githubusercontent.com/gkjohnson/ldraw-parts-library/master/complete/ldraw/' )\n\t\t\t.loadAsync( url );\n\t\tawait complete;\n\n\t\tconst model = LDrawUtils.mergeObject( result );\n\t\tmodel.rotation.set( Math.PI, 0, 0 );\n\n\t\tconst toRemove = [];\n\t\tmodel.traverse( c => {\n\n\t\t\tif ( c.isLineSegments ) {\n\n\t\t\t\ttoRemove.push( c );\n\n\t\t\t}\n\n\t\t\tif ( c.isMesh ) {\n\n\t\t\t\tc.material.roughness *= 0.25;\n\n\t\t\t}\n\n\t\t} );\n\n\t\ttoRemove.forEach( c => {\n\n\t\t\tc.parent.remove( c );\n\n\t\t} );\n\n\t\treturn model;\n\n\t}\n\n}\n","import {\n\tAmbientLight,\n\tAnimationClip,\n\tBone,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tDirectionalLight,\n\tDoubleSide,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tFrontSide,\n\tGroup,\n\tLine,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader,\n\tLoaderUtils,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tMeshBasicMaterial,\n\tMeshLambertMaterial,\n\tMeshPhongMaterial,\n\tOrthographicCamera,\n\tPerspectiveCamera,\n\tPointLight,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tRepeatWrapping,\n\tScene,\n\tSkeleton,\n\tSkinnedMesh,\n\tSpotLight,\n\tTextureLoader,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack,\n\tSRGBColorSpace\n} from 'three';\nimport { TGALoader } from '../loaders/TGALoader.js';\n\nclass ColladaLoader extends Loader {\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( scope.path === '' ) ? LoaderUtils.extractUrlBase( url ) : scope.path;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( text, path ) {\n\n\t\tfunction getElementsByTagName( xml, name ) {\n\n\t\t\t// Non recursive xml.getElementsByTagName() ...\n\n\t\t\tconst array = [];\n\t\t\tconst childNodes = xml.childNodes;\n\n\t\t\tfor ( let i = 0, l = childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = childNodes[ i ];\n\n\t\t\t\tif ( child.nodeName === name ) {\n\n\t\t\t\t\tarray.push( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseStrings( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tconst parts = text.trim().split( /\\s+/ );\n\t\t\tconst array = new Array( parts.length );\n\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parts[ i ];\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseFloats( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tconst parts = text.trim().split( /\\s+/ );\n\t\t\tconst array = new Array( parts.length );\n\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parseFloat( parts[ i ] );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseInts( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tconst parts = text.trim().split( /\\s+/ );\n\t\t\tconst array = new Array( parts.length );\n\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parseInt( parts[ i ] );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseId( text ) {\n\n\t\t\treturn text.substring( 1 );\n\n\t\t}\n\n\t\tfunction generateId() {\n\n\t\t\treturn 'three_default_' + ( count ++ );\n\n\t\t}\n\n\t\tfunction isEmpty( object ) {\n\n\t\t\treturn Object.keys( object ).length === 0;\n\n\t\t}\n\n\t\t// asset\n\n\t\tfunction parseAsset( xml ) {\n\n\t\t\treturn {\n\t\t\t\tunit: parseAssetUnit( getElementsByTagName( xml, 'unit' )[ 0 ] ),\n\t\t\t\tupAxis: parseAssetUpAxis( getElementsByTagName( xml, 'up_axis' )[ 0 ] )\n\t\t\t};\n\n\t\t}\n\n\t\tfunction parseAssetUnit( xml ) {\n\n\t\t\tif ( ( xml !== undefined ) && ( xml.hasAttribute( 'meter' ) === true ) ) {\n\n\t\t\t\treturn parseFloat( xml.getAttribute( 'meter' ) );\n\n\t\t\t} else {\n\n\t\t\t\treturn 1; // default 1 meter\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAssetUpAxis( xml ) {\n\n\t\t\treturn xml !== undefined ? xml.textContent : 'Y_UP';\n\n\t\t}\n\n\t\t// library\n\n\t\tfunction parseLibrary( xml, libraryName, nodeName, parser ) {\n\n\t\t\tconst library = getElementsByTagName( xml, libraryName )[ 0 ];\n\n\t\t\tif ( library !== undefined ) {\n\n\t\t\t\tconst elements = getElementsByTagName( library, nodeName );\n\n\t\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\t\tparser( elements[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildLibrary( data, builder ) {\n\n\t\t\tfor ( const name in data ) {\n\n\t\t\t\tconst object = data[ name ];\n\t\t\t\tobject.build = builder( data[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get\n\n\t\tfunction getBuild( data, builder ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\tdata.build = builder( data );\n\n\t\t\treturn data.build;\n\n\t\t}\n\n\t\t// animation\n\n\t\tfunction parseAnimation( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsources: {},\n\t\t\t\tsamplers: {},\n\t\t\t\tchannels: {}\n\t\t\t};\n\n\t\t\tlet hasChildren = false;\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tlet id;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler':\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.samplers[ id ] = parseAnimationSampler( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'channel':\n\t\t\t\t\t\tid = child.getAttribute( 'target' );\n\t\t\t\t\t\tdata.channels[ id ] = parseAnimationChannel( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'animation':\n\t\t\t\t\t\t// hierarchy of related animations\n\t\t\t\t\t\tparseAnimation( child );\n\t\t\t\t\t\thasChildren = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasChildren === false ) {\n\n\t\t\t\t// since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n\n\t\t\t\tlibrary.animations[ xml.getAttribute( 'id' ) || MathUtils.generateUUID() ] = data;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAnimationSampler( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinputs: {},\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseAnimationChannel( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tconst target = xml.getAttribute( 'target' );\n\n\t\t\t// parsing SID Addressing Syntax\n\n\t\t\tlet parts = target.split( '/' );\n\n\t\t\tconst id = parts.shift();\n\t\t\tlet sid = parts.shift();\n\n\t\t\t// check selection syntax\n\n\t\t\tconst arraySyntax = ( sid.indexOf( '(' ) !== - 1 );\n\t\t\tconst memberSyntax = ( sid.indexOf( '.' ) !== - 1 );\n\n\t\t\tif ( memberSyntax ) {\n\n\t\t\t\t//  member selection access\n\n\t\t\t\tparts = sid.split( '.' );\n\t\t\t\tsid = parts.shift();\n\t\t\t\tdata.member = parts.shift();\n\n\t\t\t} else if ( arraySyntax ) {\n\n\t\t\t\t// array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\n\t\t\t\tconst indices = sid.split( '(' );\n\t\t\t\tsid = indices.shift();\n\n\t\t\t\tfor ( let i = 0; i < indices.length; i ++ ) {\n\n\t\t\t\t\tindices[ i ] = parseInt( indices[ i ].replace( /\\)/, '' ) );\n\n\t\t\t\t}\n\n\t\t\t\tdata.indices = indices;\n\n\t\t\t}\n\n\t\t\tdata.id = id;\n\t\t\tdata.sid = sid;\n\n\t\t\tdata.arraySyntax = arraySyntax;\n\t\t\tdata.memberSyntax = memberSyntax;\n\n\t\t\tdata.sampler = parseId( xml.getAttribute( 'source' ) );\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildAnimation( data ) {\n\n\t\t\tconst tracks = [];\n\n\t\t\tconst channels = data.channels;\n\t\t\tconst samplers = data.samplers;\n\t\t\tconst sources = data.sources;\n\n\t\t\tfor ( const target in channels ) {\n\n\t\t\t\tif ( channels.hasOwnProperty( target ) ) {\n\n\t\t\t\t\tconst channel = channels[ target ];\n\t\t\t\t\tconst sampler = samplers[ channel.sampler ];\n\n\t\t\t\t\tconst inputId = sampler.inputs.INPUT;\n\t\t\t\t\tconst outputId = sampler.inputs.OUTPUT;\n\n\t\t\t\t\tconst inputSource = sources[ inputId ];\n\t\t\t\t\tconst outputSource = sources[ outputId ];\n\n\t\t\t\t\tconst animation = buildAnimationChannel( channel, inputSource, outputSource );\n\n\t\t\t\t\tcreateKeyframeTracks( animation, tracks );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn tracks;\n\n\t\t}\n\n\t\tfunction getAnimation( id ) {\n\n\t\t\treturn getBuild( library.animations[ id ], buildAnimation );\n\n\t\t}\n\n\t\tfunction buildAnimationChannel( channel, inputSource, outputSource ) {\n\n\t\t\tconst node = library.nodes[ channel.id ];\n\t\t\tconst object3D = getNode( node.id );\n\n\t\t\tconst transform = node.transforms[ channel.sid ];\n\t\t\tconst defaultMatrix = node.matrix.clone().transpose();\n\n\t\t\tlet time, stride;\n\t\t\tlet i, il, j, jl;\n\n\t\t\tconst data = {};\n\n\t\t\t// the collada spec allows the animation of data in various ways.\n\t\t\t// depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n\t\t\tswitch ( transform ) {\n\n\t\t\t\tcase 'matrix':\n\n\t\t\t\t\tfor ( i = 0, il = inputSource.array.length; i < il; i ++ ) {\n\n\t\t\t\t\t\ttime = inputSource.array[ i ];\n\t\t\t\t\t\tstride = i * outputSource.stride;\n\n\t\t\t\t\t\tif ( data[ time ] === undefined ) data[ time ] = {};\n\n\t\t\t\t\t\tif ( channel.arraySyntax === true ) {\n\n\t\t\t\t\t\t\tconst value = outputSource.array[ stride ];\n\t\t\t\t\t\t\tconst index = channel.indices[ 0 ] + 4 * channel.indices[ 1 ];\n\n\t\t\t\t\t\t\tdata[ time ][ index ] = value;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( j = 0, jl = outputSource.stride; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tdata[ time ][ j ] = outputSource.array[ stride + j ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'scale':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tconst keyframes = prepareAnimationData( data, defaultMatrix );\n\n\t\t\tconst animation = {\n\t\t\t\tname: object3D.uuid,\n\t\t\t\tkeyframes: keyframes\n\t\t\t};\n\n\t\t\treturn animation;\n\n\t\t}\n\n\t\tfunction prepareAnimationData( data, defaultMatrix ) {\n\n\t\t\tconst keyframes = [];\n\n\t\t\t// transfer data into a sortable array\n\n\t\t\tfor ( const time in data ) {\n\n\t\t\t\tkeyframes.push( { time: parseFloat( time ), value: data[ time ] } );\n\n\t\t\t}\n\n\t\t\t// ensure keyframes are sorted by time\n\n\t\t\tkeyframes.sort( ascending );\n\n\t\t\t// now we clean up all animation data, so we can use them for keyframe tracks\n\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\ttransformAnimationData( keyframes, i, defaultMatrix.elements[ i ] );\n\n\t\t\t}\n\n\t\t\treturn keyframes;\n\n\t\t\t// array sort function\n\n\t\t\tfunction ascending( a, b ) {\n\n\t\t\t\treturn a.time - b.time;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst position = new Vector3();\n\t\tconst scale = new Vector3();\n\t\tconst quaternion = new Quaternion();\n\n\t\tfunction createKeyframeTracks( animation, tracks ) {\n\n\t\t\tconst keyframes = animation.keyframes;\n\t\t\tconst name = animation.name;\n\n\t\t\tconst times = [];\n\t\t\tconst positionData = [];\n\t\t\tconst quaternionData = [];\n\t\t\tconst scaleData = [];\n\n\t\t\tfor ( let i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tconst time = keyframe.time;\n\t\t\t\tconst value = keyframe.value;\n\n\t\t\t\tmatrix.fromArray( value ).transpose();\n\t\t\t\tmatrix.decompose( position, quaternion, scale );\n\n\t\t\t\ttimes.push( time );\n\t\t\t\tpositionData.push( position.x, position.y, position.z );\n\t\t\t\tquaternionData.push( quaternion.x, quaternion.y, quaternion.z, quaternion.w );\n\t\t\t\tscaleData.push( scale.x, scale.y, scale.z );\n\n\t\t\t}\n\n\t\t\tif ( positionData.length > 0 ) tracks.push( new VectorKeyframeTrack( name + '.position', times, positionData ) );\n\t\t\tif ( quaternionData.length > 0 ) tracks.push( new QuaternionKeyframeTrack( name + '.quaternion', times, quaternionData ) );\n\t\t\tif ( scaleData.length > 0 ) tracks.push( new VectorKeyframeTrack( name + '.scale', times, scaleData ) );\n\n\t\t\treturn tracks;\n\n\t\t}\n\n\t\tfunction transformAnimationData( keyframes, property, defaultValue ) {\n\n\t\t\tlet keyframe;\n\n\t\t\tlet empty = true;\n\t\t\tlet i, l;\n\n\t\t\t// check, if values of a property are missing in our keyframes\n\n\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] === undefined ) {\n\n\t\t\t\t\tkeyframe.value[ property ] = null; // mark as missing\n\n\t\t\t\t} else {\n\n\t\t\t\t\tempty = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( empty === true ) {\n\n\t\t\t\t// no values at all, so we set a default value\n\n\t\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\t\tkeyframe.value[ property ] = defaultValue;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// filling gaps\n\n\t\t\t\tcreateMissingKeyframes( keyframes, property );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createMissingKeyframes( keyframes, property ) {\n\n\t\t\tlet prev, next;\n\n\t\t\tfor ( let i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] === null ) {\n\n\t\t\t\t\tprev = getPrev( keyframes, i, property );\n\t\t\t\t\tnext = getNext( keyframes, i, property );\n\n\t\t\t\t\tif ( prev === null ) {\n\n\t\t\t\t\t\tkeyframe.value[ property ] = next.value[ property ];\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( next === null ) {\n\n\t\t\t\t\t\tkeyframe.value[ property ] = prev.value[ property ];\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tinterpolate( keyframe, prev, next, property );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getPrev( keyframes, i, property ) {\n\n\t\t\twhile ( i >= 0 ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\ti --;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction getNext( keyframes, i, property ) {\n\n\t\t\twhile ( i < keyframes.length ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction interpolate( key, prev, next, property ) {\n\n\t\t\tif ( ( next.time - prev.time ) === 0 ) {\n\n\t\t\t\tkey.value[ property ] = prev.value[ property ];\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tkey.value[ property ] = ( ( key.time - prev.time ) * ( next.value[ property ] - prev.value[ property ] ) / ( next.time - prev.time ) ) + prev.value[ property ];\n\n\t\t}\n\n\t\t// animation clips\n\n\t\tfunction parseAnimationClip( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'id' ) || 'default',\n\t\t\t\tstart: parseFloat( xml.getAttribute( 'start' ) || 0 ),\n\t\t\t\tend: parseFloat( xml.getAttribute( 'end' ) || 0 ),\n\t\t\t\tanimations: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'instance_animation':\n\t\t\t\t\t\tdata.animations.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.clips[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildAnimationClip( data ) {\n\n\t\t\tconst tracks = [];\n\n\t\t\tconst name = data.name;\n\t\t\tconst duration = ( data.end - data.start ) || - 1;\n\t\t\tconst animations = data.animations;\n\n\t\t\tfor ( let i = 0, il = animations.length; i < il; i ++ ) {\n\n\t\t\t\tconst animationTracks = getAnimation( animations[ i ] );\n\n\t\t\t\tfor ( let j = 0, jl = animationTracks.length; j < jl; j ++ ) {\n\n\t\t\t\t\ttracks.push( animationTracks[ j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( name, duration, tracks );\n\n\t\t}\n\n\t\tfunction getAnimationClip( id ) {\n\n\t\t\treturn getBuild( library.clips[ id ], buildAnimationClip );\n\n\t\t}\n\n\t\t// controller\n\n\t\tfunction parseController( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'skin':\n\t\t\t\t\t\t// there is exactly one skin per controller\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tdata.skin = parseSkin( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'morph':\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Morph target animation not supported yet.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.controllers[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseSkin( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsources: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_shape_matrix':\n\t\t\t\t\t\tdata.bindShapeMatrix = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tconst id = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'joints':\n\t\t\t\t\t\tdata.joints = parseJoints( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertex_weights':\n\t\t\t\t\t\tdata.vertexWeights = parseVertexWeights( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseJoints( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseVertexWeights( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconst offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\tdata.inputs[ semantic ] = { id: id, offset: offset };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tdata.vcount = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tdata.v = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildController( data ) {\n\n\t\t\tconst build = {\n\t\t\t\tid: data.id\n\t\t\t};\n\n\t\t\tconst geometry = library.geometries[ build.id ];\n\n\t\t\tif ( data.skin !== undefined ) {\n\n\t\t\t\tbuild.skin = buildSkin( data.skin );\n\n\t\t\t\t// we enhance the 'sources' property of the corresponding geometry with our skin data\n\n\t\t\t\tgeometry.sources.skinIndices = build.skin.indices;\n\t\t\t\tgeometry.sources.skinWeights = build.skin.weights;\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildSkin( data ) {\n\n\t\t\tconst BONE_LIMIT = 4;\n\n\t\t\tconst build = {\n\t\t\t\tjoints: [], // this must be an array to preserve the joint order\n\t\t\t\tindices: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t},\n\t\t\t\tweights: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst sources = data.sources;\n\t\t\tconst vertexWeights = data.vertexWeights;\n\n\t\t\tconst vcount = vertexWeights.vcount;\n\t\t\tconst v = vertexWeights.v;\n\t\t\tconst jointOffset = vertexWeights.inputs.JOINT.offset;\n\t\t\tconst weightOffset = vertexWeights.inputs.WEIGHT.offset;\n\n\t\t\tconst jointSource = data.sources[ data.joints.inputs.JOINT ];\n\t\t\tconst inverseSource = data.sources[ data.joints.inputs.INV_BIND_MATRIX ];\n\n\t\t\tconst weights = sources[ vertexWeights.inputs.WEIGHT.id ].array;\n\t\t\tlet stride = 0;\n\n\t\t\tlet i, j, l;\n\n\t\t\t// process skin data for each vertex\n\n\t\t\tfor ( i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\tconst jointCount = vcount[ i ]; // this is the amount of joints that affect a single vertex\n\t\t\t\tconst vertexSkinData = [];\n\n\t\t\t\tfor ( j = 0; j < jointCount; j ++ ) {\n\n\t\t\t\t\tconst skinIndex = v[ stride + jointOffset ];\n\t\t\t\t\tconst weightId = v[ stride + weightOffset ];\n\t\t\t\t\tconst skinWeight = weights[ weightId ];\n\n\t\t\t\t\tvertexSkinData.push( { index: skinIndex, weight: skinWeight } );\n\n\t\t\t\t\tstride += 2;\n\n\t\t\t\t}\n\n\t\t\t\t// we sort the joints in descending order based on the weights.\n\t\t\t\t// this ensures, we only procced the most important joints of the vertex\n\n\t\t\t\tvertexSkinData.sort( descending );\n\n\t\t\t\t// now we provide for each vertex a set of four index and weight values.\n\t\t\t\t// the order of the skin data matches the order of vertices\n\n\t\t\t\tfor ( j = 0; j < BONE_LIMIT; j ++ ) {\n\n\t\t\t\t\tconst d = vertexSkinData[ j ];\n\n\t\t\t\t\tif ( d !== undefined ) {\n\n\t\t\t\t\t\tbuild.indices.array.push( d.index );\n\t\t\t\t\t\tbuild.weights.array.push( d.weight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuild.indices.array.push( 0 );\n\t\t\t\t\t\tbuild.weights.array.push( 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// setup bind matrix\n\n\t\t\tif ( data.bindShapeMatrix ) {\n\n\t\t\t\tbuild.bindMatrix = new Matrix4().fromArray( data.bindShapeMatrix ).transpose();\n\n\t\t\t} else {\n\n\t\t\t\tbuild.bindMatrix = new Matrix4().identity();\n\n\t\t\t}\n\n\t\t\t// process bones and inverse bind matrix data\n\n\t\t\tfor ( i = 0, l = jointSource.array.length; i < l; i ++ ) {\n\n\t\t\t\tconst name = jointSource.array[ i ];\n\t\t\t\tconst boneInverse = new Matrix4().fromArray( inverseSource.array, i * inverseSource.stride ).transpose();\n\n\t\t\t\tbuild.joints.push( { name: name, boneInverse: boneInverse } );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t\t// array sort function\n\n\t\t\tfunction descending( a, b ) {\n\n\t\t\t\treturn b.weight - a.weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getController( id ) {\n\n\t\t\treturn getBuild( library.controllers[ id ], buildController );\n\n\t\t}\n\n\t\t// image\n\n\t\tfunction parseImage( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinit_from: getElementsByTagName( xml, 'init_from' )[ 0 ].textContent\n\t\t\t};\n\n\t\t\tlibrary.images[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildImage( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data.init_from;\n\n\t\t}\n\n\t\tfunction getImage( id ) {\n\n\t\t\tconst data = library.images[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildImage );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find image with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// effect\n\n\t\tfunction parseEffect( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'profile_COMMON':\n\t\t\t\t\t\tdata.profile = parseEffectProfileCOMMON( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.effects[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseEffectProfileCOMMON( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsurfaces: {},\n\t\t\t\tsamplers: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'newparam':\n\t\t\t\t\t\tparseEffectNewparam( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tdata.extra = parseEffectExtra( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectNewparam( xml, data ) {\n\n\t\t\tconst sid = xml.getAttribute( 'sid' );\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'surface':\n\t\t\t\t\t\tdata.surfaces[ sid ] = parseEffectSurface( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler2D':\n\t\t\t\t\t\tdata.samplers[ sid ] = parseEffectSampler( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectSurface( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'init_from':\n\t\t\t\t\t\tdata.init_from = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectSampler( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.source = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'constant':\n\t\t\t\t\tcase 'lambert':\n\t\t\t\t\tcase 'blinn':\n\t\t\t\t\tcase 'phong':\n\t\t\t\t\t\tdata.type = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseEffectParameters( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tdata.extra = parseEffectExtra( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameters( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\tcase 'ambient':\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectParameter( child );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tdata[ child.nodeName ] = {\n\t\t\t\t\t\t\topaque: child.hasAttribute( 'opaque' ) ? child.getAttribute( 'opaque' ) : 'A_ONE',\n\t\t\t\t\t\t\tdata: parseEffectParameter( child )\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameter( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tdata[ child.nodeName ] = { id: child.getAttribute( 'texture' ), extra: parseEffectParameterTexture( child ) };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameterTexture( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\ttechnique: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tparseEffectParameterTextureExtra( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtra( xml, data ) {\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tparseEffectParameterTextureExtraTechnique( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtraTechnique( xml, data ) {\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'repeatU':\n\t\t\t\t\tcase 'repeatV':\n\t\t\t\t\tcase 'offsetU':\n\t\t\t\t\tcase 'offsetV':\n\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'wrapU':\n\t\t\t\t\tcase 'wrapV':\n\n\t\t\t\t\t\t// some files have values for wrapU/wrapV which become NaN via parseInt\n\n\t\t\t\t\t\tif ( child.textContent.toUpperCase() === 'TRUE' ) {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 1;\n\n\t\t\t\t\t\t} else if ( child.textContent.toUpperCase() === 'FALSE' ) {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 0;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseInt( child.textContent );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectExtraTechniqueBump( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectExtra( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectExtraTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectExtraTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'double_sided':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseInt( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectExtraTechniqueBump( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectExtraTechniqueBump( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tdata[ child.nodeName ] = { id: child.getAttribute( 'texture' ), texcoord: child.getAttribute( 'texcoord' ), extra: parseEffectParameterTexture( child ) };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildEffect( data ) {\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getEffect( id ) {\n\n\t\t\treturn getBuild( library.effects[ id ], buildEffect );\n\n\t\t}\n\n\t\t// material\n\n\t\tfunction parseMaterial( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'instance_effect':\n\t\t\t\t\t\tdata.url = parseId( child.getAttribute( 'url' ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.materials[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction getTextureLoader( image ) {\n\n\t\t\tlet loader;\n\n\t\t\tlet extension = image.slice( ( image.lastIndexOf( '.' ) - 1 >>> 0 ) + 2 ); // http://www.jstips.co/en/javascript/get-file-extension/\n\t\t\textension = extension.toLowerCase();\n\n\t\t\tswitch ( extension ) {\n\n\t\t\t\tcase 'tga':\n\t\t\t\t\tloader = tgaLoader;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tloader = textureLoader;\n\n\t\t\t}\n\n\t\t\treturn loader;\n\n\t\t}\n\n\t\tfunction buildMaterial( data ) {\n\n\t\t\tconst effect = getEffect( data.url );\n\t\t\tconst technique = effect.profile.technique;\n\n\t\t\tlet material;\n\n\t\t\tswitch ( technique.type ) {\n\n\t\t\t\tcase 'phong':\n\t\t\t\tcase 'blinn':\n\t\t\t\t\tmaterial = new MeshPhongMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'lambert':\n\t\t\t\t\tmaterial = new MeshLambertMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tmaterial = new MeshBasicMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tmaterial.name = data.name || '';\n\n\t\t\tfunction getTexture( textureObject, colorSpace = null ) {\n\n\t\t\t\tconst sampler = effect.profile.samplers[ textureObject.id ];\n\t\t\t\tlet image = null;\n\n\t\t\t\t// get image\n\n\t\t\t\tif ( sampler !== undefined ) {\n\n\t\t\t\t\tconst surface = effect.profile.surfaces[ sampler.source ];\n\t\t\t\t\timage = getImage( surface.init_from );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).' );\n\t\t\t\t\timage = getImage( textureObject.id );\n\n\t\t\t\t}\n\n\t\t\t\t// create texture if image is avaiable\n\n\t\t\t\tif ( image !== null ) {\n\n\t\t\t\t\tconst loader = getTextureLoader( image );\n\n\t\t\t\t\tif ( loader !== undefined ) {\n\n\t\t\t\t\t\tconst texture = loader.load( image );\n\n\t\t\t\t\t\tconst extra = textureObject.extra;\n\n\t\t\t\t\t\tif ( extra !== undefined && extra.technique !== undefined && isEmpty( extra.technique ) === false ) {\n\n\t\t\t\t\t\t\tconst technique = extra.technique;\n\n\t\t\t\t\t\t\ttexture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n\t\t\t\t\t\t\ttexture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n\n\t\t\t\t\t\t\ttexture.offset.set( technique.offsetU || 0, technique.offsetV || 0 );\n\t\t\t\t\t\t\ttexture.repeat.set( technique.repeatU || 1, technique.repeatV || 1 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttexture.wrapS = RepeatWrapping;\n\t\t\t\t\t\t\ttexture.wrapT = RepeatWrapping;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( colorSpace !== null ) {\n\n\t\t\t\t\t\t\ttexture.colorSpace = colorSpace;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn texture;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Loader for texture %s not found.', image );\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id );\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst parameters = technique.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tconst parameter = parameters[ key ];\n\n\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\t\tif ( parameter.color ) material.color.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.map = getTexture( parameter.texture, SRGBColorSpace );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\t\tif ( parameter.color && material.specular ) material.specular.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.specularMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tif ( parameter.texture ) material.normalMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'ambient':\n\t\t\t\t\t\tif ( parameter.texture ) material.lightMap = getTexture( parameter.texture, SRGBColorSpace );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\tif ( parameter.float && material.shininess ) material.shininess = parameter.float;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\t\tif ( parameter.color && material.emissive ) material.emissive.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.emissiveMap = getTexture( parameter.texture, SRGBColorSpace );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmaterial.color.convertSRGBToLinear();\n\t\t\tif ( material.specular ) material.specular.convertSRGBToLinear();\n\t\t\tif ( material.emissive ) material.emissive.convertSRGBToLinear();\n\n\t\t\t//\n\n\t\t\tlet transparent = parameters[ 'transparent' ];\n\t\t\tlet transparency = parameters[ 'transparency' ];\n\n\t\t\t// <transparency> does not exist but <transparent>\n\n\t\t\tif ( transparency === undefined && transparent ) {\n\n\t\t\t\ttransparency = {\n\t\t\t\t\tfloat: 1\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t// <transparent> does not exist but <transparency>\n\n\t\t\tif ( transparent === undefined && transparency ) {\n\n\t\t\t\ttransparent = {\n\t\t\t\t\topaque: 'A_ONE',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tcolor: [ 1, 1, 1, 1 ]\n\t\t\t\t\t} };\n\n\t\t\t}\n\n\t\t\tif ( transparent && transparency ) {\n\n\t\t\t\t// handle case if a texture exists but no color\n\n\t\t\t\tif ( transparent.data.texture ) {\n\n\t\t\t\t\t// we do not set an alpha map (see #13792)\n\n\t\t\t\t\tmaterial.transparent = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst color = transparent.data.color;\n\n\t\t\t\t\tswitch ( transparent.opaque ) {\n\n\t\t\t\t\t\tcase 'A_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[ 3 ] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 0 ] * transparency.float );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 3 ] * transparency.float );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[ 0 ] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( material.opacity < 1 ) material.transparent = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\n\t\t\tif ( technique.extra !== undefined && technique.extra.technique !== undefined ) {\n\n\t\t\t\tconst techniques = technique.extra.technique;\n\n\t\t\t\tfor ( const k in techniques ) {\n\n\t\t\t\t\tconst v = techniques[ k ];\n\n\t\t\t\t\tswitch ( k ) {\n\n\t\t\t\t\t\tcase 'double_sided':\n\t\t\t\t\t\t\tmaterial.side = ( v === 1 ? DoubleSide : FrontSide );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\t\tmaterial.normalMap = getTexture( v.texture );\n\t\t\t\t\t\t\tmaterial.normalScale = new Vector2( 1, 1 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tfunction getMaterial( id ) {\n\n\t\t\treturn getBuild( library.materials[ id ], buildMaterial );\n\n\t\t}\n\n\t\t// camera\n\n\t\tfunction parseCamera( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'optics':\n\t\t\t\t\t\tdata.optics = parseCameraOptics( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.cameras[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseCameraOptics( xml ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\treturn parseCameraTechnique( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {};\n\n\t\t}\n\n\t\tfunction parseCameraTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'perspective':\n\t\t\t\t\tcase 'orthographic':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseCameraParameters( child );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseCameraParameters( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'xfov':\n\t\t\t\t\tcase 'yfov':\n\t\t\t\t\tcase 'xmag':\n\t\t\t\t\tcase 'ymag':\n\t\t\t\t\tcase 'znear':\n\t\t\t\t\tcase 'zfar':\n\t\t\t\t\tcase 'aspect_ratio':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildCamera( data ) {\n\n\t\t\tlet camera;\n\n\t\t\tswitch ( data.optics.technique ) {\n\n\t\t\t\tcase 'perspective':\n\t\t\t\t\tcamera = new PerspectiveCamera(\n\t\t\t\t\t\tdata.optics.parameters.yfov,\n\t\t\t\t\t\tdata.optics.parameters.aspect_ratio,\n\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'orthographic':\n\t\t\t\t\tlet ymag = data.optics.parameters.ymag;\n\t\t\t\t\tlet xmag = data.optics.parameters.xmag;\n\t\t\t\t\tconst aspectRatio = data.optics.parameters.aspect_ratio;\n\n\t\t\t\t\txmag = ( xmag === undefined ) ? ( ymag * aspectRatio ) : xmag;\n\t\t\t\t\tymag = ( ymag === undefined ) ? ( xmag / aspectRatio ) : ymag;\n\n\t\t\t\t\txmag *= 0.5;\n\t\t\t\t\tymag *= 0.5;\n\n\t\t\t\t\tcamera = new OrthographicCamera(\n\t\t\t\t\t\t- xmag, xmag, ymag, - ymag, // left, right, top, bottom\n\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tcamera = new PerspectiveCamera();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcamera.name = data.name || '';\n\n\t\t\treturn camera;\n\n\t\t}\n\n\t\tfunction getCamera( id ) {\n\n\t\t\tconst data = library.cameras[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildCamera );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find camera with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// light\n\n\t\tfunction parseLight( xml ) {\n\n\t\t\tlet data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tdata = parseLightTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.lights[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseLightTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'directional':\n\t\t\t\t\tcase 'point':\n\t\t\t\t\tcase 'spot':\n\t\t\t\t\tcase 'ambient':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseLightParameters( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseLightParameters( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tconst array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.color = new Color().fromArray( array ).convertSRGBToLinear();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'falloff_angle':\n\t\t\t\t\t\tdata.falloffAngle = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'quadratic_attenuation':\n\t\t\t\t\t\tconst f = parseFloat( child.textContent );\n\t\t\t\t\t\tdata.distance = f ? Math.sqrt( 1 / f ) : 0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildLight( data ) {\n\n\t\t\tlet light;\n\n\t\t\tswitch ( data.technique ) {\n\n\t\t\t\tcase 'directional':\n\t\t\t\t\tlight = new DirectionalLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'point':\n\t\t\t\t\tlight = new PointLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'spot':\n\t\t\t\t\tlight = new SpotLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ambient':\n\t\t\t\t\tlight = new AmbientLight();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( data.parameters.color ) light.color.copy( data.parameters.color );\n\t\t\tif ( data.parameters.distance ) light.distance = data.parameters.distance;\n\n\t\t\treturn light;\n\n\t\t}\n\n\t\tfunction getLight( id ) {\n\n\t\t\tconst data = library.lights[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildLight );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find light with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// geometry\n\n\t\tfunction parseGeometry( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\tsources: {},\n\t\t\t\tvertices: {},\n\t\t\t\tprimitives: []\n\t\t\t};\n\n\t\t\tconst mesh = getElementsByTagName( xml, 'mesh' )[ 0 ];\n\n\t\t\t// the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\t\t\tif ( mesh === undefined ) return;\n\n\t\t\tfor ( let i = 0; i < mesh.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = mesh.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tconst id = child.getAttribute( 'id' );\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertices':\n\t\t\t\t\t\t// data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n\t\t\t\t\t\tdata.vertices = parseGeometryVertices( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polygons':\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tdata.primitives.push( parseGeometryPrimitive( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.geometries[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseSource( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tarray: [],\n\t\t\t\tstride: 3\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'float_array':\n\t\t\t\t\t\tdata.array = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Name_array':\n\t\t\t\t\t\tdata.array = parseStrings( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tconst accessor = getElementsByTagName( child, 'accessor' )[ 0 ];\n\n\t\t\t\t\t\tif ( accessor !== undefined ) {\n\n\t\t\t\t\t\t\tdata.stride = parseInt( accessor.getAttribute( 'stride' ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseGeometryVertices( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tdata[ child.getAttribute( 'semantic' ) ] = parseId( child.getAttribute( 'source' ) );\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseGeometryPrimitive( xml ) {\n\n\t\t\tconst primitive = {\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tmaterial: xml.getAttribute( 'material' ),\n\t\t\t\tcount: parseInt( xml.getAttribute( 'count' ) ),\n\t\t\t\tinputs: {},\n\t\t\t\tstride: 0,\n\t\t\t\thasUV: false\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tconst offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\tconst set = parseInt( child.getAttribute( 'set' ) );\n\t\t\t\t\t\tconst inputname = ( set > 0 ? semantic + set : semantic );\n\t\t\t\t\t\tprimitive.inputs[ inputname ] = { id: id, offset: offset };\n\t\t\t\t\t\tprimitive.stride = Math.max( primitive.stride, offset + 1 );\n\t\t\t\t\t\tif ( semantic === 'TEXCOORD' ) primitive.hasUV = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tprimitive.vcount = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tprimitive.p = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn primitive;\n\n\t\t}\n\n\t\tfunction groupPrimitives( primitives ) {\n\n\t\t\tconst build = {};\n\n\t\t\tfor ( let i = 0; i < primitives.length; i ++ ) {\n\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\tif ( build[ primitive.type ] === undefined ) build[ primitive.type ] = [];\n\n\t\t\t\tbuild[ primitive.type ].push( primitive );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction checkUVCoordinates( primitives ) {\n\n\t\t\tlet count = 0;\n\n\t\t\tfor ( let i = 0, l = primitives.length; i < l; i ++ ) {\n\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\tif ( primitive.hasUV === true ) {\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( count > 0 && count < primitives.length ) {\n\n\t\t\t\tprimitives.uvsNeedsFix = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildGeometry( data ) {\n\n\t\t\tconst build = {};\n\n\t\t\tconst sources = data.sources;\n\t\t\tconst vertices = data.vertices;\n\t\t\tconst primitives = data.primitives;\n\n\t\t\tif ( primitives.length === 0 ) return {};\n\n\t\t\t// our goal is to create one buffer geometry for a single type of primitives\n\t\t\t// first, we group all primitives by their type\n\n\t\t\tconst groupedPrimitives = groupPrimitives( primitives );\n\n\t\t\tfor ( const type in groupedPrimitives ) {\n\n\t\t\t\tconst primitiveType = groupedPrimitives[ type ];\n\n\t\t\t\t// second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n\t\t\t\tcheckUVCoordinates( primitiveType );\n\n\t\t\t\t// third, create a buffer geometry for each type of primitives\n\n\t\t\t\tbuild[ type ] = buildGeometryType( primitiveType, sources, vertices );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGeometryType( primitives, sources, vertices ) {\n\n\t\t\tconst build = {};\n\n\t\t\tconst position = { array: [], stride: 0 };\n\t\t\tconst normal = { array: [], stride: 0 };\n\t\t\tconst uv = { array: [], stride: 0 };\n\t\t\tconst uv1 = { array: [], stride: 0 };\n\t\t\tconst color = { array: [], stride: 0 };\n\n\t\t\tconst skinIndex = { array: [], stride: 4 };\n\t\t\tconst skinWeight = { array: [], stride: 4 };\n\n\t\t\tconst geometry = new BufferGeometry();\n\n\t\t\tconst materialKeys = [];\n\n\t\t\tlet start = 0;\n\n\t\t\tfor ( let p = 0; p < primitives.length; p ++ ) {\n\n\t\t\t\tconst primitive = primitives[ p ];\n\t\t\t\tconst inputs = primitive.inputs;\n\n\t\t\t\t// groups\n\n\t\t\t\tlet count = 0;\n\n\t\t\t\tswitch ( primitive.type ) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tcount = primitive.count * 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tcount = primitive.count * 3;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polylist':\n\n\t\t\t\t\t\tfor ( let g = 0; g < primitive.count; g ++ ) {\n\n\t\t\t\t\t\t\tconst vc = primitive.vcount[ g ];\n\n\t\t\t\t\t\t\tswitch ( vc ) {\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\tcount += 3; // single triangle\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\tcount += 6; // quad, subdivided into two triangles\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tcount += ( vc - 2 ) * 3; // polylist with more than four vertices\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknow primitive type:', primitive.type );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addGroup( start, count, p );\n\t\t\t\tstart += count;\n\n\t\t\t\t// material\n\n\t\t\t\tif ( primitive.material ) {\n\n\t\t\t\t\tmaterialKeys.push( primitive.material );\n\n\t\t\t\t}\n\n\t\t\t\t// geometry data\n\n\t\t\t\tfor ( const name in inputs ) {\n\n\t\t\t\t\tconst input = inputs[ name ];\n\n\t\t\t\t\tswitch ( name )\t{\n\n\t\t\t\t\t\tcase 'VERTEX':\n\t\t\t\t\t\t\tfor ( const key in vertices ) {\n\n\t\t\t\t\t\t\t\tconst id = vertices[ key ];\n\n\t\t\t\t\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\t\t\t\t\tcase 'POSITION':\n\t\t\t\t\t\t\t\t\t\tconst prevLength = position.array.length;\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, position.array );\n\t\t\t\t\t\t\t\t\t\tposition.stride = sources[ id ].stride;\n\n\t\t\t\t\t\t\t\t\t\tif ( sources.skinWeights && sources.skinIndices ) {\n\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinIndices, input.offset, skinIndex.array );\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinWeights, input.offset, skinWeight.array );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// see #3803\n\n\t\t\t\t\t\t\t\t\t\tif ( primitive.hasUV === false && primitives.uvsNeedsFix === true ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconst count = ( position.array.length - prevLength ) / position.stride;\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// fill missing uv coordinates\n\n\t\t\t\t\t\t\t\t\t\t\t\tuv.array.push( 0, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, normal.array );\n\t\t\t\t\t\t\t\t\t\tnormal.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, color.array );\n\t\t\t\t\t\t\t\t\t\tcolor.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv.array );\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv1.array );\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, normal.array );\n\t\t\t\t\t\t\tnormal.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, color.array, true );\n\t\t\t\t\t\t\tcolor.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv.array );\n\t\t\t\t\t\t\tuv.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv1.array );\n\t\t\t\t\t\t\tuv1.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tif ( position.array.length > 0 ) geometry.setAttribute( 'position', new Float32BufferAttribute( position.array, position.stride ) );\n\t\t\tif ( normal.array.length > 0 ) geometry.setAttribute( 'normal', new Float32BufferAttribute( normal.array, normal.stride ) );\n\t\t\tif ( color.array.length > 0 ) geometry.setAttribute( 'color', new Float32BufferAttribute( color.array, color.stride ) );\n\t\t\tif ( uv.array.length > 0 ) geometry.setAttribute( 'uv', new Float32BufferAttribute( uv.array, uv.stride ) );\n\t\t\tif ( uv1.array.length > 0 ) geometry.setAttribute( 'uv1', new Float32BufferAttribute( uv1.array, uv1.stride ) );\n\n\t\t\tif ( skinIndex.array.length > 0 ) geometry.setAttribute( 'skinIndex', new Float32BufferAttribute( skinIndex.array, skinIndex.stride ) );\n\t\t\tif ( skinWeight.array.length > 0 ) geometry.setAttribute( 'skinWeight', new Float32BufferAttribute( skinWeight.array, skinWeight.stride ) );\n\n\t\t\tbuild.data = geometry;\n\t\t\tbuild.type = primitives[ 0 ].type;\n\t\t\tbuild.materialKeys = materialKeys;\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGeometryData( primitive, source, offset, array, isColor = false ) {\n\n\t\t\tconst indices = primitive.p;\n\t\t\tconst stride = primitive.stride;\n\t\t\tconst vcount = primitive.vcount;\n\n\t\t\tfunction pushVector( i ) {\n\n\t\t\t\tlet index = indices[ i + offset ] * sourceStride;\n\t\t\t\tconst length = index + sourceStride;\n\n\t\t\t\tfor ( ; index < length; index ++ ) {\n\n\t\t\t\t\tarray.push( sourceArray[ index ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( isColor ) {\n\n\t\t\t\t\t// convert the vertex colors from srgb to linear if present\n\t\t\t\t\tconst startIndex = array.length - sourceStride - 1;\n\t\t\t\t\ttempColor.setRGB(\n\t\t\t\t\t\tarray[ startIndex + 0 ],\n\t\t\t\t\t\tarray[ startIndex + 1 ],\n\t\t\t\t\t\tarray[ startIndex + 2 ]\n\t\t\t\t\t).convertSRGBToLinear();\n\n\t\t\t\t\tarray[ startIndex + 0 ] = tempColor.r;\n\t\t\t\t\tarray[ startIndex + 1 ] = tempColor.g;\n\t\t\t\t\tarray[ startIndex + 2 ] = tempColor.b;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst sourceArray = source.array;\n\t\t\tconst sourceStride = source.stride;\n\n\t\t\tif ( primitive.vcount !== undefined ) {\n\n\t\t\t\tlet index = 0;\n\n\t\t\t\tfor ( let i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst count = vcount[ i ];\n\n\t\t\t\t\tif ( count === 4 ) {\n\n\t\t\t\t\t\tconst a = index + stride * 0;\n\t\t\t\t\t\tconst b = index + stride * 1;\n\t\t\t\t\t\tconst c = index + stride * 2;\n\t\t\t\t\t\tconst d = index + stride * 3;\n\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( d );\n\t\t\t\t\t\tpushVector( b ); pushVector( c ); pushVector( d );\n\n\t\t\t\t\t} else if ( count === 3 ) {\n\n\t\t\t\t\t\tconst a = index + stride * 0;\n\t\t\t\t\t\tconst b = index + stride * 1;\n\t\t\t\t\t\tconst c = index + stride * 2;\n\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t} else if ( count > 4 ) {\n\n\t\t\t\t\t\tfor ( let k = 1, kl = ( count - 2 ); k <= kl; k ++ ) {\n\n\t\t\t\t\t\t\tconst a = index + stride * 0;\n\t\t\t\t\t\t\tconst b = index + stride * k;\n\t\t\t\t\t\t\tconst c = index + stride * ( k + 1 );\n\n\t\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindex += stride * count;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0, l = indices.length; i < l; i += stride ) {\n\n\t\t\t\t\tpushVector( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getGeometry( id ) {\n\n\t\t\treturn getBuild( library.geometries[ id ], buildGeometry );\n\n\t\t}\n\n\t\t// kinematics\n\n\t\tfunction parseKinematicsModel( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\tjoints: {},\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparseKinematicsTechniqueCommon( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.kinematicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildKinematicsModel( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getKinematicsModel( id ) {\n\n\t\t\treturn getBuild( library.kinematicsModels[ id ], buildKinematicsModel );\n\n\t\t}\n\n\t\tfunction parseKinematicsTechniqueCommon( xml, data ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'joint':\n\t\t\t\t\t\tdata.joints[ child.getAttribute( 'sid' ) ] = parseKinematicsJoint( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseKinematicsJoint( xml ) {\n\n\t\t\tlet data;\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\tdata = parseKinematicsJointParameter( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsJointParameter( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\taxis: new Vector3(),\n\t\t\t\tlimits: {\n\t\t\t\t\tmin: 0,\n\t\t\t\t\tmax: 0\n\t\t\t\t},\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tstatic: false,\n\t\t\t\tzeroPosition: 0,\n\t\t\t\tmiddlePosition: 0\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tconst array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.axis.fromArray( array );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'limits':\n\t\t\t\t\t\tconst max = child.getElementsByTagName( 'max' )[ 0 ];\n\t\t\t\t\t\tconst min = child.getElementsByTagName( 'min' )[ 0 ];\n\n\t\t\t\t\t\tdata.limits.max = parseFloat( max.textContent );\n\t\t\t\t\t\tdata.limits.min = parseFloat( min.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// if min is equal to or greater than max, consider the joint static\n\n\t\t\tif ( data.limits.min >= data.limits.max ) {\n\n\t\t\t\tdata.static = true;\n\n\t\t\t}\n\n\t\t\t// calculate middle position\n\n\t\t\tdata.middlePosition = ( data.limits.min + data.limits.max ) / 2.0;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsLink( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\tattachments: [],\n\t\t\t\ttransforms: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'attachment_full':\n\t\t\t\t\t\tdata.attachments.push( parseKinematicsAttachment( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsAttachment( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tjoint: xml.getAttribute( 'joint' ).split( '/' ).pop(),\n\t\t\t\ttransforms: [],\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsTransform( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\ttype: xml.nodeName\n\t\t\t};\n\n\t\t\tconst array = parseFloats( xml.textContent );\n\n\t\t\tswitch ( data.type ) {\n\n\t\t\t\tcase 'matrix':\n\t\t\t\t\tdata.obj = new Matrix4();\n\t\t\t\t\tdata.obj.fromArray( array ).transpose();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tdata.obj = new Vector3();\n\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tdata.obj = new Vector3();\n\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\tdata.angle = MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// physics\n\n\t\tfunction parsePhysicsModel( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\trigidBodies: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'rigid_body':\n\t\t\t\t\t\tdata.rigidBodies[ child.getAttribute( 'name' ) ] = {};\n\t\t\t\t\t\tparsePhysicsRigidBody( child, data.rigidBodies[ child.getAttribute( 'name' ) ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.physicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parsePhysicsRigidBody( xml, data ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparsePhysicsTechniqueCommon( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePhysicsTechniqueCommon( xml, data ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'inertia':\n\t\t\t\t\t\tdata.inertia = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'mass':\n\t\t\t\t\t\tdata.mass = parseFloats( child.textContent )[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// scene\n\n\t\tfunction parseKinematicsScene( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tbindJointAxis: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_joint_axis':\n\t\t\t\t\t\tdata.bindJointAxis.push( parseKinematicsBindJointAxis( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.kinematicsScenes[ parseId( xml.getAttribute( 'url' ) ) ] = data;\n\n\t\t}\n\n\t\tfunction parseKinematicsBindJointAxis( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\ttarget: xml.getAttribute( 'target' ).split( '/' ).pop()\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tconst param = child.getElementsByTagName( 'param' )[ 0 ];\n\t\t\t\t\t\tdata.axis = param.textContent;\n\t\t\t\t\t\tconst tmpJointIndex = data.axis.split( 'inst_' ).pop().split( 'axis' )[ 0 ];\n\t\t\t\t\t\tdata.jointIndex = tmpJointIndex.substring( 0, tmpJointIndex.length - 1 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildKinematicsScene( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getKinematicsScene( id ) {\n\n\t\t\treturn getBuild( library.kinematicsScenes[ id ], buildKinematicsScene );\n\n\t\t}\n\n\t\tfunction setupKinematics() {\n\n\t\t\tconst kinematicsModelId = Object.keys( library.kinematicsModels )[ 0 ];\n\t\t\tconst kinematicsSceneId = Object.keys( library.kinematicsScenes )[ 0 ];\n\t\t\tconst visualSceneId = Object.keys( library.visualScenes )[ 0 ];\n\n\t\t\tif ( kinematicsModelId === undefined || kinematicsSceneId === undefined ) return;\n\n\t\t\tconst kinematicsModel = getKinematicsModel( kinematicsModelId );\n\t\t\tconst kinematicsScene = getKinematicsScene( kinematicsSceneId );\n\t\t\tconst visualScene = getVisualScene( visualSceneId );\n\n\t\t\tconst bindJointAxis = kinematicsScene.bindJointAxis;\n\t\t\tconst jointMap = {};\n\n\t\t\tfor ( let i = 0, l = bindJointAxis.length; i < l; i ++ ) {\n\n\t\t\t\tconst axis = bindJointAxis[ i ];\n\n\t\t\t\t// the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n\t\t\t\tconst targetElement = collada.querySelector( '[sid=\"' + axis.target + '\"]' );\n\n\t\t\t\tif ( targetElement ) {\n\n\t\t\t\t\t// get the parent of the transform element\n\n\t\t\t\t\tconst parentVisualElement = targetElement.parentElement;\n\n\t\t\t\t\t// connect the joint of the kinematics model with the element in the visual scene\n\n\t\t\t\t\tconnect( axis.jointIndex, parentVisualElement );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction connect( jointIndex, visualElement ) {\n\n\t\t\t\tconst visualElementName = visualElement.getAttribute( 'name' );\n\t\t\t\tconst joint = kinematicsModel.joints[ jointIndex ];\n\n\t\t\t\tvisualScene.traverse( function ( object ) {\n\n\t\t\t\t\tif ( object.name === visualElementName ) {\n\n\t\t\t\t\t\tjointMap[ jointIndex ] = {\n\t\t\t\t\t\t\tobject: object,\n\t\t\t\t\t\t\ttransforms: buildTransformList( visualElement ),\n\t\t\t\t\t\t\tjoint: joint,\n\t\t\t\t\t\t\tposition: joint.zeroPosition\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst m0 = new Matrix4();\n\n\t\t\tkinematics = {\n\n\t\t\t\tjoints: kinematicsModel && kinematicsModel.joints,\n\n\t\t\t\tgetJointValue: function ( jointIndex ) {\n\n\t\t\t\t\tconst jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\treturn jointData.position;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetJointValue: function ( jointIndex, value ) {\n\n\t\t\t\t\tconst jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\tconst joint = jointData.joint;\n\n\t\t\t\t\t\tif ( value > joint.limits.max || value < joint.limits.min ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').' );\n\n\t\t\t\t\t\t} else if ( joint.static ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' is static.' );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconst object = jointData.object;\n\t\t\t\t\t\t\tconst axis = joint.axis;\n\t\t\t\t\t\t\tconst transforms = jointData.transforms;\n\n\t\t\t\t\t\t\tmatrix.identity();\n\n\t\t\t\t\t\t\t// each update, we have to apply all transforms in the correct order\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < transforms.length; i ++ ) {\n\n\t\t\t\t\t\t\t\tconst transform = transforms[ i ];\n\n\t\t\t\t\t\t\t\t// if there is a connection of the transform node with a joint, apply the joint value\n\n\t\t\t\t\t\t\t\tif ( transform.sid && transform.sid.indexOf( jointIndex ) !== - 1 ) {\n\n\t\t\t\t\t\t\t\t\tswitch ( joint.type ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( axis, MathUtils.degToRad( value ) ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( axis.x * value, axis.y * value, axis.z * value ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknown joint type: ' + joint.type );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tswitch ( transform.type ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.scale( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( transform.obj, transform.angle ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobject.matrix.copy( matrix );\n\t\t\t\t\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t\t\t\t\tjointMap[ jointIndex ].position = value;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.log( 'THREE.ColladaLoader: ' + jointIndex + ' does not exist.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction buildTransformList( node ) {\n\n\t\t\tconst transforms = [];\n\n\t\t\tconst xml = collada.querySelector( '[id=\"' + node.id + '\"]' );\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tlet array, vector;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tconst matrix = new Matrix4().fromArray( array ).transpose();\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: matrix\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tvector = new Vector3().fromArray( array );\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tvector = new Vector3().fromArray( array );\n\t\t\t\t\t\tconst angle = MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector,\n\t\t\t\t\t\t\tangle: angle\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transforms;\n\n\t\t}\n\n\t\t// nodes\n\n\t\tfunction prepareNodes( xml ) {\n\n\t\t\tconst elements = xml.getElementsByTagName( 'node' );\n\n\t\t\t// ensure all node elements have id attributes\n\n\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\tconst element = elements[ i ];\n\n\t\t\t\tif ( element.hasAttribute( 'id' ) === false ) {\n\n\t\t\t\t\telement.setAttribute( 'id', generateId() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst matrix = new Matrix4();\n\t\tconst vector = new Vector3();\n\n\t\tfunction parseNode( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\ttype: xml.getAttribute( 'type' ),\n\t\t\t\tid: xml.getAttribute( 'id' ),\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tmatrix: new Matrix4(),\n\t\t\t\tnodes: [],\n\t\t\t\tinstanceCameras: [],\n\t\t\t\tinstanceControllers: [],\n\t\t\t\tinstanceLights: [],\n\t\t\t\tinstanceGeometries: [],\n\t\t\t\tinstanceNodes: [],\n\t\t\t\ttransforms: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tlet array;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'node':\n\t\t\t\t\t\tdata.nodes.push( child.getAttribute( 'id' ) );\n\t\t\t\t\t\tparseNode( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_camera':\n\t\t\t\t\t\tdata.instanceCameras.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_controller':\n\t\t\t\t\t\tdata.instanceControllers.push( parseNodeInstance( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_light':\n\t\t\t\t\t\tdata.instanceLights.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_geometry':\n\t\t\t\t\t\tdata.instanceGeometries.push( parseNodeInstance( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_node':\n\t\t\t\t\t\tdata.instanceNodes.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.fromArray( array ).transpose() );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tvector.fromArray( array );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeTranslation( vector.x, vector.y, vector.z ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tconst angle = MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeRotationAxis( vector.fromArray( array ), angle ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.matrix.scale( vector.fromArray( array ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasNode( data.id ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id );\n\n\t\t\t} else {\n\n\t\t\t\tlibrary.nodes[ data.id ] = data;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseNodeInstance( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tid: parseId( xml.getAttribute( 'url' ) ),\n\t\t\t\tmaterials: {},\n\t\t\t\tskeletons: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_material':\n\t\t\t\t\t\tconst instances = child.getElementsByTagName( 'instance_material' );\n\n\t\t\t\t\t\tfor ( let j = 0; j < instances.length; j ++ ) {\n\n\t\t\t\t\t\t\tconst instance = instances[ j ];\n\t\t\t\t\t\t\tconst symbol = instance.getAttribute( 'symbol' );\n\t\t\t\t\t\t\tconst target = instance.getAttribute( 'target' );\n\n\t\t\t\t\t\t\tdata.materials[ symbol ] = parseId( target );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skeleton':\n\t\t\t\t\t\tdata.skeletons.push( parseId( child.textContent ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildSkeleton( skeletons, joints ) {\n\n\t\t\tconst boneData = [];\n\t\t\tconst sortedBoneData = [];\n\n\t\t\tlet i, j, data;\n\n\t\t\t// a skeleton can have multiple root bones. collada expresses this\n\t\t\t// situtation with multiple \"skeleton\" tags per controller instance\n\n\t\t\tfor ( i = 0; i < skeletons.length; i ++ ) {\n\n\t\t\t\tconst skeleton = skeletons[ i ];\n\n\t\t\t\tlet root;\n\n\t\t\t\tif ( hasNode( skeleton ) ) {\n\n\t\t\t\t\troot = getNode( skeleton );\n\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t} else if ( hasVisualScene( skeleton ) ) {\n\n\t\t\t\t\t// handle case where the skeleton refers to the visual scene (#13335)\n\n\t\t\t\t\tconst visualScene = library.visualScenes[ skeleton ];\n\t\t\t\t\tconst children = visualScene.children;\n\n\t\t\t\t\tfor ( let j = 0; j < children.length; j ++ ) {\n\n\t\t\t\t\t\tconst child = children[ j ];\n\n\t\t\t\t\t\tif ( child.type === 'JOINT' ) {\n\n\t\t\t\t\t\t\tconst root = getNode( child.id );\n\t\t\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// sort bone data (the order is defined in the corresponding controller)\n\n\t\t\tfor ( i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j < boneData.length; j ++ ) {\n\n\t\t\t\t\tdata = boneData[ j ];\n\n\t\t\t\t\tif ( data.bone.name === joints[ i ].name ) {\n\n\t\t\t\t\t\tsortedBoneData[ i ] = data;\n\t\t\t\t\t\tdata.processed = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add unprocessed bone data at the end of the list\n\n\t\t\tfor ( i = 0; i < boneData.length; i ++ ) {\n\n\t\t\t\tdata = boneData[ i ];\n\n\t\t\t\tif ( data.processed === false ) {\n\n\t\t\t\t\tsortedBoneData.push( data );\n\t\t\t\t\tdata.processed = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// setup arrays for skeleton creation\n\n\t\t\tconst bones = [];\n\t\t\tconst boneInverses = [];\n\n\t\t\tfor ( i = 0; i < sortedBoneData.length; i ++ ) {\n\n\t\t\t\tdata = sortedBoneData[ i ];\n\n\t\t\t\tbones.push( data.bone );\n\t\t\t\tboneInverses.push( data.boneInverse );\n\n\t\t\t}\n\n\t\t\treturn new Skeleton( bones, boneInverses );\n\n\t\t}\n\n\t\tfunction buildBoneHierarchy( root, joints, boneData ) {\n\n\t\t\t// setup bone data from visual scene\n\n\t\t\troot.traverse( function ( object ) {\n\n\t\t\t\tif ( object.isBone === true ) {\n\n\t\t\t\t\tlet boneInverse;\n\n\t\t\t\t\t// retrieve the boneInverse from the controller data\n\n\t\t\t\t\tfor ( let i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\t\t\tconst joint = joints[ i ];\n\n\t\t\t\t\t\tif ( joint.name === object.name ) {\n\n\t\t\t\t\t\t\tboneInverse = joint.boneInverse;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( boneInverse === undefined ) {\n\n\t\t\t\t\t\t// Unfortunately, there can be joints in the visual scene that are not part of the\n\t\t\t\t\t\t// corresponding controller. In this case, we have to create a dummy boneInverse matrix\n\t\t\t\t\t\t// for the respective bone. This bone won't affect any vertices, because there are no skin indices\n\t\t\t\t\t\t// and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n\t\t\t\t\t\t// ensure a correct animation of the model.\n\n\t\t\t\t\t\tboneInverse = new Matrix4();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.push( { bone: object, boneInverse: boneInverse, processed: false } );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction buildNode( data ) {\n\n\t\t\tconst objects = [];\n\n\t\t\tconst matrix = data.matrix;\n\t\t\tconst nodes = data.nodes;\n\t\t\tconst type = data.type;\n\t\t\tconst instanceCameras = data.instanceCameras;\n\t\t\tconst instanceControllers = data.instanceControllers;\n\t\t\tconst instanceLights = data.instanceLights;\n\t\t\tconst instanceGeometries = data.instanceGeometries;\n\t\t\tconst instanceNodes = data.instanceNodes;\n\n\t\t\t// nodes\n\n\t\t\tfor ( let i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\tobjects.push( getNode( nodes[ i ] ) );\n\n\t\t\t}\n\n\t\t\t// instance cameras\n\n\t\t\tfor ( let i = 0, l = instanceCameras.length; i < l; i ++ ) {\n\n\t\t\t\tconst instanceCamera = getCamera( instanceCameras[ i ] );\n\n\t\t\t\tif ( instanceCamera !== null ) {\n\n\t\t\t\t\tobjects.push( instanceCamera.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance controllers\n\n\t\t\tfor ( let i = 0, l = instanceControllers.length; i < l; i ++ ) {\n\n\t\t\t\tconst instance = instanceControllers[ i ];\n\t\t\t\tconst controller = getController( instance.id );\n\t\t\t\tconst geometries = getGeometry( controller.id );\n\t\t\t\tconst newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\tconst skeletons = instance.skeletons;\n\t\t\t\tconst joints = controller.skin.joints;\n\n\t\t\t\tconst skeleton = buildSkeleton( skeletons, joints );\n\n\t\t\t\tfor ( let j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst object = newObjects[ j ];\n\n\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t\tobject.bind( skeleton, controller.skin.bindMatrix );\n\t\t\t\t\t\tobject.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance lights\n\n\t\t\tfor ( let i = 0, l = instanceLights.length; i < l; i ++ ) {\n\n\t\t\t\tconst instanceLight = getLight( instanceLights[ i ] );\n\n\t\t\t\tif ( instanceLight !== null ) {\n\n\t\t\t\t\tobjects.push( instanceLight.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance geometries\n\n\t\t\tfor ( let i = 0, l = instanceGeometries.length; i < l; i ++ ) {\n\n\t\t\t\tconst instance = instanceGeometries[ i ];\n\n\t\t\t\t// a single geometry instance in collada can lead to multiple object3Ds.\n\t\t\t\t// this is the case when primitives are combined like triangles and lines\n\n\t\t\t\tconst geometries = getGeometry( instance.id );\n\t\t\t\tconst newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\tfor ( let j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tobjects.push( newObjects[ j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance nodes\n\n\t\t\tfor ( let i = 0, l = instanceNodes.length; i < l; i ++ ) {\n\n\t\t\t\tobjects.push( getNode( instanceNodes[ i ] ).clone() );\n\n\t\t\t}\n\n\t\t\tlet object;\n\n\t\t\tif ( nodes.length === 0 && objects.length === 1 ) {\n\n\t\t\t\tobject = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tobject = ( type === 'JOINT' ) ? new Bone() : new Group();\n\n\t\t\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\tobject.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tobject.name = ( type === 'JOINT' ) ? data.sid : data.name;\n\t\t\tobject.matrix.copy( matrix );\n\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\treturn object;\n\n\t\t}\n\n\t\tconst fallbackMaterial = new MeshBasicMaterial( {\n\t\t\tname: Loader.DEFAULT_MATERIAL_NAME,\n\t\t\tcolor: 0xff00ff\n\t\t} );\n\n\t\tfunction resolveMaterialBinding( keys, instanceMaterials ) {\n\n\t\t\tconst materials = [];\n\n\t\t\tfor ( let i = 0, l = keys.length; i < l; i ++ ) {\n\n\t\t\t\tconst id = instanceMaterials[ keys[ i ] ];\n\n\t\t\t\tif ( id === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[ i ] );\n\t\t\t\t\tmaterials.push( fallbackMaterial );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterials.push( getMaterial( id ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materials;\n\n\t\t}\n\n\t\tfunction buildObjects( geometries, instanceMaterials ) {\n\n\t\t\tconst objects = [];\n\n\t\t\tfor ( const type in geometries ) {\n\n\t\t\t\tconst geometry = geometries[ type ];\n\n\t\t\t\tconst materials = resolveMaterialBinding( geometry.materialKeys, instanceMaterials );\n\n\t\t\t\t// handle case if no materials are defined\n\n\t\t\t\tif ( materials.length === 0 ) {\n\n\t\t\t\t\tif ( type === 'lines' || type === 'linestrips' ) {\n\n\t\t\t\t\t\tmaterials.push( new LineBasicMaterial() );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push( new MeshPhongMaterial() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Collada allows to use phong and lambert materials with lines. Replacing these cases with LineBasicMaterial.\n\n\t\t\t\tif ( type === 'lines' || type === 'linestrips' ) {\n\n\t\t\t\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst material = materials[ i ];\n\n\t\t\t\t\t\tif ( material.isMeshPhongMaterial === true || material.isMeshLambertMaterial === true ) {\n\n\t\t\t\t\t\t\tconst lineMaterial = new LineBasicMaterial();\n\n\t\t\t\t\t\t\t// copy compatible properties\n\n\t\t\t\t\t\t\tlineMaterial.color.copy( material.color );\n\t\t\t\t\t\t\tlineMaterial.opacity = material.opacity;\n\t\t\t\t\t\t\tlineMaterial.transparent = material.transparent;\n\n\t\t\t\t\t\t\t// replace material\n\n\t\t\t\t\t\t\tmaterials[ i ] = lineMaterial;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// regard skinning\n\n\t\t\t\tconst skinning = ( geometry.data.attributes.skinIndex !== undefined );\n\n\t\t\t\t// choose between a single or multi materials (material array)\n\n\t\t\t\tconst material = ( materials.length === 1 ) ? materials[ 0 ] : materials;\n\n\t\t\t\t// now create a specific 3D object\n\n\t\t\t\tlet object;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\t\tobject = new LineSegments( geometry.data, material );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tobject = new Line( geometry.data, material );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\t\tif ( skinning ) {\n\n\t\t\t\t\t\t\tobject = new SkinnedMesh( geometry.data, material );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject = new Mesh( geometry.data, material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tobjects.push( object );\n\n\t\t\t}\n\n\t\t\treturn objects;\n\n\t\t}\n\n\t\tfunction hasNode( id ) {\n\n\t\t\treturn library.nodes[ id ] !== undefined;\n\n\t\t}\n\n\t\tfunction getNode( id ) {\n\n\t\t\treturn getBuild( library.nodes[ id ], buildNode );\n\n\t\t}\n\n\t\t// visual scenes\n\n\t\tfunction parseVisualScene( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\tchildren: []\n\t\t\t};\n\n\t\t\tprepareNodes( xml );\n\n\t\t\tconst elements = getElementsByTagName( xml, 'node' );\n\n\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\tdata.children.push( parseNode( elements[ i ] ) );\n\n\t\t\t}\n\n\t\t\tlibrary.visualScenes[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildVisualScene( data ) {\n\n\t\t\tconst group = new Group();\n\t\t\tgroup.name = data.name;\n\n\t\t\tconst children = data.children;\n\n\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\n\t\t\t\tgroup.add( getNode( child.id ) );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t}\n\n\t\tfunction hasVisualScene( id ) {\n\n\t\t\treturn library.visualScenes[ id ] !== undefined;\n\n\t\t}\n\n\t\tfunction getVisualScene( id ) {\n\n\t\t\treturn getBuild( library.visualScenes[ id ], buildVisualScene );\n\n\t\t}\n\n\t\t// scenes\n\n\t\tfunction parseScene( xml ) {\n\n\t\t\tconst instance = getElementsByTagName( xml, 'instance_visual_scene' )[ 0 ];\n\t\t\treturn getVisualScene( parseId( instance.getAttribute( 'url' ) ) );\n\n\t\t}\n\n\t\tfunction setupAnimations() {\n\n\t\t\tconst clips = library.clips;\n\n\t\t\tif ( isEmpty( clips ) === true ) {\n\n\t\t\t\tif ( isEmpty( library.animations ) === false ) {\n\n\t\t\t\t\t// if there are animations but no clips, we create a default clip for playback\n\n\t\t\t\t\tconst tracks = [];\n\n\t\t\t\t\tfor ( const id in library.animations ) {\n\n\t\t\t\t\t\tconst animationTracks = getAnimation( id );\n\n\t\t\t\t\t\tfor ( let i = 0, l = animationTracks.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\ttracks.push( animationTracks[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimations.push( new AnimationClip( 'default', - 1, tracks ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( const id in clips ) {\n\n\t\t\t\t\tanimations.push( getAnimationClip( id ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// convert the parser error element into text with each child elements text\n\t\t// separated by new lines.\n\n\t\tfunction parserErrorToText( parserError ) {\n\n\t\t\tlet result = '';\n\t\t\tconst stack = [ parserError ];\n\n\t\t\twhile ( stack.length ) {\n\n\t\t\t\tconst node = stack.shift();\n\n\t\t\t\tif ( node.nodeType === Node.TEXT_NODE ) {\n\n\t\t\t\t\tresult += node.textContent;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult += '\\n';\n\t\t\t\t\tstack.push.apply( stack, node.childNodes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result.trim();\n\n\t\t}\n\n\t\tif ( text.length === 0 ) {\n\n\t\t\treturn { scene: new Scene() };\n\n\t\t}\n\n\t\tconst xml = new DOMParser().parseFromString( text, 'application/xml' );\n\n\t\tconst collada = getElementsByTagName( xml, 'COLLADA' )[ 0 ];\n\n\t\tconst parserError = xml.getElementsByTagName( 'parsererror' )[ 0 ];\n\t\tif ( parserError !== undefined ) {\n\n\t\t\t// Chrome will return parser error with a div in it\n\n\t\t\tconst errorElement = getElementsByTagName( parserError, 'div' )[ 0 ];\n\t\t\tlet errorText;\n\n\t\t\tif ( errorElement ) {\n\n\t\t\t\terrorText = errorElement.textContent;\n\n\t\t\t} else {\n\n\t\t\t\terrorText = parserErrorToText( parserError );\n\n\t\t\t}\n\n\t\t\tconsole.error( 'THREE.ColladaLoader: Failed to parse collada file.\\n', errorText );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// metadata\n\n\t\tconst version = collada.getAttribute( 'version' );\n\t\tconsole.debug( 'THREE.ColladaLoader: File version', version );\n\n\t\tconst asset = parseAsset( getElementsByTagName( collada, 'asset' )[ 0 ] );\n\t\tconst textureLoader = new TextureLoader( this.manager );\n\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\tlet tgaLoader;\n\n\t\tif ( TGALoader ) {\n\n\t\t\ttgaLoader = new TGALoader( this.manager );\n\t\t\ttgaLoader.setPath( this.resourcePath || path );\n\n\t\t}\n\n\t\t//\n\n\t\tconst tempColor = new Color();\n\t\tconst animations = [];\n\t\tlet kinematics = {};\n\t\tlet count = 0;\n\n\t\t//\n\n\t\tconst library = {\n\t\t\tanimations: {},\n\t\t\tclips: {},\n\t\t\tcontrollers: {},\n\t\t\timages: {},\n\t\t\teffects: {},\n\t\t\tmaterials: {},\n\t\t\tcameras: {},\n\t\t\tlights: {},\n\t\t\tgeometries: {},\n\t\t\tnodes: {},\n\t\t\tvisualScenes: {},\n\t\t\tkinematicsModels: {},\n\t\t\tphysicsModels: {},\n\t\t\tkinematicsScenes: {}\n\t\t};\n\n\t\tparseLibrary( collada, 'library_animations', 'animation', parseAnimation );\n\t\tparseLibrary( collada, 'library_animation_clips', 'animation_clip', parseAnimationClip );\n\t\tparseLibrary( collada, 'library_controllers', 'controller', parseController );\n\t\tparseLibrary( collada, 'library_images', 'image', parseImage );\n\t\tparseLibrary( collada, 'library_effects', 'effect', parseEffect );\n\t\tparseLibrary( collada, 'library_materials', 'material', parseMaterial );\n\t\tparseLibrary( collada, 'library_cameras', 'camera', parseCamera );\n\t\tparseLibrary( collada, 'library_lights', 'light', parseLight );\n\t\tparseLibrary( collada, 'library_geometries', 'geometry', parseGeometry );\n\t\tparseLibrary( collada, 'library_nodes', 'node', parseNode );\n\t\tparseLibrary( collada, 'library_visual_scenes', 'visual_scene', parseVisualScene );\n\t\tparseLibrary( collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel );\n\t\tparseLibrary( collada, 'library_physics_models', 'physics_model', parsePhysicsModel );\n\t\tparseLibrary( collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene );\n\n\t\tbuildLibrary( library.animations, buildAnimation );\n\t\tbuildLibrary( library.clips, buildAnimationClip );\n\t\tbuildLibrary( library.controllers, buildController );\n\t\tbuildLibrary( library.images, buildImage );\n\t\tbuildLibrary( library.effects, buildEffect );\n\t\tbuildLibrary( library.materials, buildMaterial );\n\t\tbuildLibrary( library.cameras, buildCamera );\n\t\tbuildLibrary( library.lights, buildLight );\n\t\tbuildLibrary( library.geometries, buildGeometry );\n\t\tbuildLibrary( library.visualScenes, buildVisualScene );\n\n\t\tsetupAnimations();\n\t\tsetupKinematics();\n\n\t\tconst scene = parseScene( getElementsByTagName( collada, 'scene' )[ 0 ] );\n\t\tscene.animations = animations;\n\n\t\tif ( asset.upAxis === 'Z_UP' ) {\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: You are loading an asset with a Z-UP coordinate system. The loader just rotates the asset to transform it into Y-UP. The vertex data are not converted, see #24289.' );\n\t\t\tscene.rotation.set( - Math.PI / 2, 0, 0 );\n\n\t\t}\n\n\t\tscene.scale.multiplyScalar( asset.unit );\n\n\t\treturn {\n\t\t\tget animations() {\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Please access animations over scene.animations now.' );\n\t\t\t\treturn animations;\n\n\t\t\t},\n\t\t\tkinematics: kinematics,\n\t\t\tlibrary: library,\n\t\t\tscene: scene\n\t\t};\n\n\t}\n\n}\n\nexport { ColladaLoader };\n","import {\n\tDataTextureLoader,\n\tLinearMipmapLinearFilter\n} from 'three';\n\nclass TGALoader extends DataTextureLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tparse( buffer ) {\n\n\t\t// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n\n\t\tfunction tgaCheckHeader( header ) {\n\n\t\t\tswitch ( header.image_type ) {\n\n\t\t\t\t// check indexed type\n\n\t\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\t\tif ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.TGALoader: Invalid type colormap data for indexed type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// check colormap type\n\n\t\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\t\tif ( header.colormap_type ) {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.TGALoader: Invalid type colormap data for colormap type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// What the need of a file without data ?\n\n\t\t\t\tcase TGA_TYPE_NO_DATA:\n\t\t\t\t\tthrow new Error( 'THREE.TGALoader: No data.' );\n\n\t\t\t\t\t// Invalid type ?\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'THREE.TGALoader: Invalid type ' + header.image_type );\n\n\t\t\t}\n\n\t\t\t// check image width and height\n\n\t\t\tif ( header.width <= 0 || header.height <= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.TGALoader: Invalid image size.' );\n\n\t\t\t}\n\n\t\t\t// check image pixel size\n\n\t\t\tif ( header.pixel_size !== 8 && header.pixel_size !== 16 &&\n\t\t\t\theader.pixel_size !== 24 && header.pixel_size !== 32 ) {\n\n\t\t\t\tthrow new Error( 'THREE.TGALoader: Invalid pixel size ' + header.pixel_size );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// parse tga image buffer\n\n\t\tfunction tgaParse( use_rle, use_pal, header, offset, data ) {\n\n\t\t\tlet pixel_data,\n\t\t\t\tpalettes;\n\n\t\t\tconst pixel_size = header.pixel_size >> 3;\n\t\t\tconst pixel_total = header.width * header.height * pixel_size;\n\n\t\t\t // read palettes\n\n\t\t\t if ( use_pal ) {\n\n\t\t\t\t palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) );\n\n\t\t\t }\n\n\t\t\t // read RLE\n\n\t\t\t if ( use_rle ) {\n\n\t\t\t\t pixel_data = new Uint8Array( pixel_total );\n\n\t\t\t\tlet c, count, i;\n\t\t\t\tlet shift = 0;\n\t\t\t\tconst pixels = new Uint8Array( pixel_size );\n\n\t\t\t\twhile ( shift < pixel_total ) {\n\n\t\t\t\t\tc = data[ offset ++ ];\n\t\t\t\t\tcount = ( c & 0x7f ) + 1;\n\n\t\t\t\t\t// RLE pixels\n\n\t\t\t\t\tif ( c & 0x80 ) {\n\n\t\t\t\t\t\t// bind pixel tmp array\n\n\t\t\t\t\t\tfor ( i = 0; i < pixel_size; ++ i ) {\n\n\t\t\t\t\t\t\tpixels[ i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// copy pixel array\n\n\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\tpixel_data.set( pixels, shift + i * pixel_size );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshift += pixel_size * count;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// raw pixels\n\n\t\t\t\t\t\tcount *= pixel_size;\n\n\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\tpixel_data[ shift + i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshift += count;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t } else {\n\n\t\t\t\t// raw pixels\n\n\t\t\t\tpixel_data = data.subarray(\n\t\t\t\t\t offset, offset += ( use_pal ? header.width * header.height : pixel_total )\n\t\t\t\t);\n\n\t\t\t }\n\n\t\t\t return {\n\t\t\t\tpixel_data: pixel_data,\n\t\t\t\tpalettes: palettes\n\t\t\t };\n\n\t\t}\n\n\t\tfunction tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) {\n\n\t\t\tconst colormap = palettes;\n\t\t\tlet color, i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet color, i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\tcolor = image[ i + 0 ] + ( image[ i + 1 ] << 8 );\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) << 3;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 3 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 4 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet color, i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction getTgaRGBA( data, width, height, image, palette ) {\n\n\t\t\tlet x_start,\n\t\t\t\ty_start,\n\t\t\t\tx_step,\n\t\t\t\ty_step,\n\t\t\t\tx_end,\n\t\t\t\ty_end;\n\n\t\t\tswitch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) {\n\n\t\t\t\tdefault:\n\t\t\t\tcase TGA_ORIGIN_UL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = - 1;\n\t\t\t\t\ty_end = - 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_UR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = - 1;\n\t\t\t\t\tx_end = - 1;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = - 1;\n\t\t\t\t\tx_end = - 1;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = - 1;\n\t\t\t\t\ty_end = - 1;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( use_grey ) {\n\n\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 24:\n\t\t\t\t\t\ttgaGetImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\ttgaGetImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Load image data according to specific method\n\t\t\t// let func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n\t\t\t// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// TGA constants\n\n\t\tconst TGA_TYPE_NO_DATA = 0,\n\t\t\tTGA_TYPE_INDEXED = 1,\n\t\t\tTGA_TYPE_RGB = 2,\n\t\t\tTGA_TYPE_GREY = 3,\n\t\t\tTGA_TYPE_RLE_INDEXED = 9,\n\t\t\tTGA_TYPE_RLE_RGB = 10,\n\t\t\tTGA_TYPE_RLE_GREY = 11,\n\n\t\t\tTGA_ORIGIN_MASK = 0x30,\n\t\t\tTGA_ORIGIN_SHIFT = 0x04,\n\t\t\tTGA_ORIGIN_BL = 0x00,\n\t\t\tTGA_ORIGIN_BR = 0x01,\n\t\t\tTGA_ORIGIN_UL = 0x02,\n\t\t\tTGA_ORIGIN_UR = 0x03;\n\n\t\tif ( buffer.length < 19 ) throw new Error( 'THREE.TGALoader: Not enough data to contain header.' );\n\n\t\tlet offset = 0;\n\n\t\tconst content = new Uint8Array( buffer ),\n\t\t\theader = {\n\t\t\t\tid_length: content[ offset ++ ],\n\t\t\t\tcolormap_type: content[ offset ++ ],\n\t\t\t\timage_type: content[ offset ++ ],\n\t\t\t\tcolormap_index: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tcolormap_length: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tcolormap_size: content[ offset ++ ],\n\t\t\t\torigin: [\n\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8\n\t\t\t\t],\n\t\t\t\twidth: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\theight: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tpixel_size: content[ offset ++ ],\n\t\t\t\tflags: content[ offset ++ ]\n\t\t\t};\n\n\t\t// check tga if it is valid format\n\n\t\ttgaCheckHeader( header );\n\n\t\tif ( header.id_length + offset > buffer.length ) {\n\n\t\t\tthrow new Error( 'THREE.TGALoader: No data.' );\n\n\t\t}\n\n\t\t// skip the needn't data\n\n\t\toffset += header.id_length;\n\n\t\t// get targa information about RLE compression and palette\n\n\t\tlet use_rle = false,\n\t\t\tuse_pal = false,\n\t\t\tuse_grey = false;\n\n\t\tswitch ( header.image_type ) {\n\n\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tuse_rle = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t//\n\n\t\tconst imageData = new Uint8Array( header.width * header.height * 4 );\n\t\tconst result = tgaParse( use_rle, use_pal, header, offset, content );\n\t\tgetTgaRGBA( imageData, header.width, header.height, result.pixel_data, result.palettes );\n\n\t\treturn {\n\n\t\t\tdata: imageData,\n\t\t\twidth: header.width,\n\t\t\theight: header.height,\n\t\t\tflipY: true,\n\t\t\tgenerateMipmaps: true,\n\t\t\tminFilter: LinearMipmapLinearFilter,\n\n\t\t};\n\n\t}\n\n}\n\nexport { TGALoader };\n"],"names":["$393e677ed3c566ae$var$floorPlane","$393e677ed3c566ae$var$gui","$393e677ed3c566ae$var$stats","$393e677ed3c566ae$var$pathTracer","$393e677ed3c566ae$var$renderer","$393e677ed3c566ae$var$orthoCamera","$393e677ed3c566ae$var$perspectiveCamera","$393e677ed3c566ae$var$activeCamera","$393e677ed3c566ae$var$controls","$393e677ed3c566ae$var$scene","$393e677ed3c566ae$var$model","$393e677ed3c566ae$var$gradientMap","$393e677ed3c566ae$var$loader","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$5ee05658f4b0e3bf$export$d076a711b55c758a","$ilwiq","DataTextureLoader","constructor","manager","type","HalfFloatType","parse","buffer","data","numElements","rgbe_error","rgbe_error_code","msg","fgets","lineLimit","consume","p","pos","i","len","chunk","String","fromCharCode","apply","Uint16Array","subarray","indexOf","byteLength","length","slice","byteArray","Uint8Array","rgbe_header_info","RGBE_ReadHeader","line","match","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","format","gamma","exposure","width","height","charAt","parseFloat","parseInt","w","h","image_rgba_data","RGBE_ReadPixels_RLE","scanline_width","data_rgba","offset","ptr_end","rgbeStart","scanline_buffer","num_scanlines","ptr","count","isEncodedRun","byteValue","off","FloatType","floatArray","Float32Array","j","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","scale","Math","pow","halfArray","RGBEByteToRGBHalf","DataUtils","toHalfFloat","min","setDataType","value","load","url","onLoad","onProgress","onError","texture","texData","colorSpace","LinearSRGBColorSpace","minFilter","LinearFilter","magFilter","generateMipmaps","flipY","$5aae44c9b1864d53$export$2e2bcd8739ae039","$5aae44c9b1864d53$var$Stats","mode","container","document","createElement","addPanel","panel","appendChild","dom","showPanel","children","style","display","cssText","addEventListener","event","preventDefault","beginTime","performance","Date","now","prevTime","frames","fpsPanel","Panel","msPanel","self","memory","memPanel","REVISION","begin","end","time","update","usedJSHeapSize","jsHeapSizeLimit","domElement","setMode","name","fg","bg","Infinity","max","round","PR","window","devicePixelRatio","WIDTH","HEIGHT","TEXT_X","TEXT_Y","GRAPH_X","GRAPH_Y","GRAPH_WIDTH","GRAPH_HEIGHT","canvas","context","getContext","font","textBaseline","fillStyle","fillRect","fillText","globalAlpha","maxValue","drawImage","$13343f7d1c4dd8ec$export$92750171fb06fc99","dim","x","y","a","sqrt","xCent","xNorm","yCent","yNorm","tex","DataTexture","RGBAFormat","UnsignedByteType","wrapS","RepeatWrapping","wrapT","needsUpdate","$934d596524c3e5a8$export$5bc756cb1c628b75","tiles","renderScale","innerWidth","innerHeight","$a399336cf50451da$var$_styleElement","$a399336cf50451da$export$c2252eb3bc5ad0b7","textContent","head","classList","add","percentageEl","samplesEl","creditsEl","loaderBarEl","descriptionEl","_description","_loaderBar","_percentage","_credits","_samples","_container","setPercentage","attach","perc","innerText","toFixed","remove","setSamples","compiling","floor","setCredits","credits","innerHTML","setDescription","description","$edfd8156d2dff8d2$export$1369cce09af89668","$6KVZ3","$3ePKg","$cSOJe","$a8VBx","$5Gkg5","$edfd8156d2dff8d2$var$DEFAULT_WORKER_COUNT","navigator","hardwareConcurrency","$edfd8156d2dff8d2$var$_ParallelMeshBVHWorker","WorkerBase","Worker","maxWorkerCount","isSharedArrayBufferSupported","runTask","worker","geometry","options","Promise","resolve","reject","index","indirect","ensureIndex","getAttribute","isInterleavedBufferAttribute","onerror","message","onmessage","error","serialized","position","bvh","MeshBVH","deserialize","setIndex","boundsOptions","setBoundingBox","attributes","array","newIndex","BufferAttribute","boundingBox","getBoundingBox","Box3","progress","postMessage","operation","convertToBufferType","SharedArrayBuffer","includedProgressCallback","Boolean","groups","console","warn","object","GenerateMeshBVHWorker","$25bad171b6c71f9d$export$8dbf7c43841b75b7","running","generate","args","promise","finally","dispose","terminate","$762755cd5891d020$export$426cc6213ad628cf","assign","transferable","push","map","arr","filter","$7ryUf","$e82cb97686acadc5$var$url","URL","toString","origin","workerUrl","isESM","location","source","JSON","stringify","createObjectURL","Blob","$1ce6f7437f671131$var$url","$6bd4eb2914ee2835$export$f1ac3a587b6cbb5d","ShaderMaterial","dispatchEvent","shader","key","uniforms","setDefine","defines","$ba14a4aaa0cde19b$export$98323a006d35be35","$a21c9b4177584031$export$fe1d788deccfbee3","$60fb6dc3c6495c33$export$4c711108e2e8ef5e","$kp7Te","$891vQ","$7lx9d","$dc743e2081fd10a7$export$f133a99b4c3153a","content","id_length","colormap_type","image_type","colormap_index","colormap_length","colormap_size","pixel_size","flags","tgaCheckHeader","use_rle","use_pal","use_grey","imageData","result","tgaParse","pixel_data","palettes","pixel_total","c","shift","pixels","getTgaRGBA","image","palette","x_start","y_start","x_step","y_step","x_end","y_end","tgaGetImageDataGrey8bits","color","tgaGetImageDataGrey16bits","tgaGetImageData8bits","colormap","tgaGetImageData16bits","tgaGetImageData24bits","tgaGetImageData32bits","LinearMipmapLinearFilter","$7f99d0845977052a$export$ce4e0fe932362815","Loader","scope","path","LoaderUtils","extractUrlBase","loader","FileLoader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","itemError","xml","tgaLoader","getElementsByTagName","childNodes","l","child","nodeName","parseFloats","parts","trim","split","Array","parseInts","parseId","substring","isEmpty","keys","parseLibrary","libraryName","parser","library","undefined","elements","buildLibrary","builder","build","getBuild","buildAnimation","tracks","channels","samplers","sources","target","hasOwnProperty","channel","sampler","inputId","inputs","INPUT","outputId","OUTPUT","createKeyframeTracks","animation","keyframes","times","positionData","quaternionData","scaleData","keyframe","matrix","fromArray","transpose","decompose","quaternion","z","VectorKeyframeTrack","QuaternionKeyframeTrack","buildAnimationChannel","inputSource","outputSource","stride","il","jl","node","nodes","object3D","getNode","transform","transforms","sid","defaultMatrix","clone","arraySyntax","indices","prepareAnimationData","sort","b","transformAnimationData","property","defaultValue","empty","createMissingKeyframes","prev","next","getPrev","getNext","interpolate","uuid","getAnimation","animations","Vector3","Quaternion","buildAnimationClip","duration","start","animationTracks","AnimationClip","buildController","geometries","skin","buildSkin","joints","weights","vertexWeights","vcount","jointOffset","JOINT","weightOffset","WEIGHT","jointSource","inverseSource","INV_BIND_MATRIX","jointCount","vertexSkinData","skinIndex","skinWeight","weight","descending","d","bindShapeMatrix","bindMatrix","Matrix4","identity","boneInverse","skinIndices","skinWeights","buildImage","init_from","getImage","images","parseEffectParameter","nodeType","extra","parseEffectParameterTexture","technique","parseEffectParameterTextureExtra","parseEffectParameterTextureExtraTechnique","toUpperCase","parseEffectExtraTechniqueBump","parseEffectExtra","parseEffectExtraTechnique","texcoord","buildEffect","buildMaterial","material","effect","effects","profile","MeshPhongMaterial","MeshLambertMaterial","MeshBasicMaterial","getTexture","textureObject","surface","surfaces","extension","lastIndexOf","toLowerCase","textureLoader","wrapU","ClampToEdgeWrapping","wrapV","offsetU","offsetV","repeat","repeatU","repeatV","parameters","parameter","SRGBColorSpace","specular","specularMap","normalMap","lightMap","float","shininess","emissive","emissiveMap","convertSRGBToLinear","transparent","transparency","opaque","opacity","techniques","k","side","DoubleSide","FrontSide","normalScale","Vector2","buildCamera","camera","optics","PerspectiveCamera","yfov","aspect_ratio","znear","zfar","ymag","xmag","aspectRatio","OrthographicCamera","buildLight","light","DirectionalLight","PointLight","SpotLight","AmbientLight","copy","distance","parseSource","parseStrings","accessor","buildGeometry","vertices","primitives","groupedPrimitives","groupPrimitives","primitive","primitiveType","checkUVCoordinates","hasUV","uvsNeedsFix","buildGeometryType","normal","uv","uv1","BufferGeometry","materialKeys","g","vc","addGroup","input","prevLength","buildGeometryData","setAttribute","Float32BufferAttribute","isColor","pushVector","sourceStride","startIndex","tempColor","setRGB","r","kl","getGeometry","buildKinematicsModel","parseKinematicsTransform","obj","angle","MathUtils","degToRad","buildKinematicsScene","vector","parseNode","instanceCameras","instanceControllers","instanceLights","instanceGeometries","instanceNodes","parseNodeInstance","multiply","makeTranslation","makeRotationAxis","log","hasNode","materials","skeletons","instances","instance","symbol","buildBoneHierarchy","root","boneData","traverse","isBone","joint","bone","processed","buildNode","objects","instanceCamera","getCamera","cameras","controller","controllers","newObjects","buildObjects","skeleton","buildSkeleton","sortedBoneData","visualScenes","visualScene","bones","boneInverses","Skeleton","isSkinnedMesh","bind","normalizeSkinWeights","instanceLight","getLight","lights","Bone","Group","fallbackMaterial","DEFAULT_MATERIAL_NAME","instanceMaterials","resolveMaterialBinding","LineBasicMaterial","isMeshPhongMaterial","isMeshLambertMaterial","lineMaterial","skinning","LineSegments","Line","SkinnedMesh","Mesh","buildVisualScene","group","getVisualScene","scene","Scene","DOMParser","parseFromString","collada","parserError","errorElement","parserErrorToText","stack","Node","TEXT_NODE","debug","asset","unit","hasAttribute","upAxis","TextureLoader","resourcePath","setCrossOrigin","crossOrigin","Color","kinematics","clips","kinematicsModels","physicsModels","kinematicsScenes","parseAnimation","hasChildren","parseAnimationSampler","semantic","parseAnimationChannel","memberSyntax","member","replace","generateUUID","parseSkin","parseJoints","parseVertexWeights","parseEffectProfileCOMMON","parseEffectNewparam","parseEffectSurface","parseEffectSampler","parseEffectTechnique","parseEffectParameters","parseCameraOptics","parseCameraTechnique","parseCameraParameters","parseLightTechnique","parseLightParameters","falloffAngle","f","mesh","parseGeometryVertices","parseGeometryPrimitive","inputname","prepareNodes","element","links","parseKinematicsTechniqueCommon","parseKinematicsJoint","parseKinematicsJointParameter","axis","limits","static","zeroPosition","middlePosition","parseKinematicsLink","attachments","parseKinematicsAttachment","pop","rigidBodies","parsePhysicsRigidBody","parsePhysicsTechniqueCommon","inertia","mass","bindJointAxis","parseKinematicsBindJointAxis","param","tmpJointIndex","jointIndex","setupAnimations","setupKinematics","kinematicsModelId","kinematicsSceneId","visualSceneId","kinematicsModel","kinematicsScene","jointMap","targetElement","querySelector","parentVisualElement","parentElement","connect","visualElement","visualElementName","buildTransformList","m0","getJointValue","jointData","setJointValue","rotation","PI","multiplyScalar","$cpS3d","$9hfHi","$jiuw3","$7MGRS","$1EdOY","$bHiTZ","$8mHfG","$5Rd1x","$cE5k3","$e2Pv4","$kqOCM","$393e677ed3c566ae$var$envMaps","$393e677ed3c566ae$var$models","MODEL_LIST","$393e677ed3c566ae$var$params","multipleImportanceSampling","acesToneMapping","model","envMap","gradientTop","gradientBottom","environmentIntensity","environmentRotation","cameraProjection","backgroundType","bgGradientTop","bgGradientBottom","backgroundBlur","transparentBackground","checkerboardTransparency","enable","bounces","filterGlossyFactor","pause","floorColor","floorOpacity","floorRoughness","floorMetalness","getScaledSettings","$393e677ed3c566ae$var$onParamsChange","roughness","metalness","backgroundBlurriness","topColor","bottomColor","background","backgroundIntensity","environment","backgroundRotation","setClearAlpha","updateMaterials","updateEnvironment","$393e677ed3c566ae$var$onHashChange","hashModel","hash","modelName","decodeURI","$393e677ed3c566ae$var$updateModel","$393e677ed3c566ae$var$onResize","dpr","setSize","setPixelRatio","aspect","updateProjectionMatrix","orthoHeight","$393e677ed3c566ae$var$orthoWidth","top","bottom","updateCamera","$393e677ed3c566ae$var$updateEnvMap","RGBELoader","mapping","EquirectangularReflectionMapping","$393e677ed3c566ae$var$updateCameraProjection","setCamera","body","destroy","modelInfo","visibility","isTexture","$393e677ed3c566ae$var$loadModel","removeEmission","emissiveIntensity","opacityToTransmission","$393e677ed3c566ae$var$convertOpacityToTransmission","ior","newMaterial","MeshPhysicalMaterial","transmission","hsl","getHSL","setHSL","thickness","postProcess","box","setFromObject","addScaledVector","sphere","Sphere","getBoundingSphere","setScalar","radius","setSceneAsync","credit","gradientBot","$393e677ed3c566ae$var$buildGui","GUI","onChange","pathTracingFolder","addFolder","toneMapping","ACESFilmicToneMapping","NoToneMapping","open","environmentFolder","backgroundFolder","addColor","floorFolder","close","LoadingManager","test","complete","res","loadAsync","total","loaded","MeshStandardMaterial","gltf","GLTFLoader","setMeshoptDecoder","MeshoptDecoder","ldrawLoader","LDrawLoader","preloadMaterials","setPartsLibraryPath","LDrawUtils","mergeObject","toRemove","isLineSegments","isMesh","forEach","parent","$393e677ed3c566ae$var$init","LoaderElement","WebGLRenderer","antialias","WebGLPathTracer","setBVHWorker","ParallelMeshBVHWorker","physicallyCorrectLights","transmissiveBounces","GradientEquirectTexture","OrbitControls","floorTex","generateRadialFloorTexture","PlaneGeometry","default","$393e677ed3c566ae$var$animate","requestAnimationFrame","samples","renderSample","render","isCompiling"],"version":3,"file":"index.7e44f4ab.js.map"}