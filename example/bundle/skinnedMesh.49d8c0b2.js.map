{"mappings":"IU2BI,EAAY,EAAU,EAAU,EAAQ,EAAO,EAC/C,EAAO,EACP,E,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,yB,I,G,I,E,E,S,E,E,S,E,E,S,E,E,QTxBJ,OAAM,UAA0B,EAAA,YAAW,CAE1C,aAAc,CAEb,KAAK,CAAE,CAEN,SAAU,CAET,OAAQ,CAAE,MAAO,IAAK,EACtB,KAAM,CAAE,MAAO,CAAE,CAElB,EAEA,aAAwB,CAAC;;;;;;;;GAQzB,CAAC,CAED,eAA0B,CAAC;;;;;IAK1B,EAAG,EAAA,cAAA,CAA2B;;;;;;;;;;;;GAY/B,CAAC,AAEF,EAED,CAED,CAEO,MAAM,EAEZ,YAAa,CAAQ,CAAG,CAEvB,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,cAAc,CAAG,IAAI,EAAA,cAAa,CAAG,GAC1C,IAAI,CAAC,QAAQ,CAAG,IAAI,EAAA,cAAa,CAAG,IAAI,GACxC,IAAI,CAAC,YAAY,CAAG,IAAI,EAAA,iBAAgB,CAAG,EAAG,EAAG,CAAE,KAAM,EAAA,SAAQ,CAAG,OAAQ,EAAA,UAAS,AAAE,EAExF,CAEA,SAAU,CAET,IAAI,CAAC,cAAc,CAAC,OAAO,GAC3B,IAAI,CAAC,QAAQ,CAAC,OAAO,GACrB,IAAI,CAAC,YAAY,CAAC,OAAO,EAE1B,CAEA,SAAU,CAAO,CAAE,CAAI,CAAG,CAEzB,GAAM,CAAA,eAAE,CAAc,CAAA,aAAE,CAAY,CAAA,SAAE,CAAQ,CAAA,SAAE,CAAQ,CAAE,CAAG,IAAI,CAG3D,EAAc,EAAe,mBAAmB,CAAE,GAGlD,CAAA,MAAE,CAAK,CAAA,OAAE,CAAM,CAAE,CAAG,EAAQ,KAAK,CACvC,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","sources":["<anon>","src/utils/BlurredEnvMapGenerator.js","src/materials/MaterialBase.js","src/shader/common/util_functions.glsl.js","node_modules/three/examples/jsm/loaders/RGBELoader.js","example/utils/generateRadialFloorTexture.js","example/utils/getScaledSettings.js","example/utils/LoaderElement.js","src/shader/common/math_functions.glsl.js","src/shader/bsdf/ggx_functions.glsl.js","example/skinnedMesh.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5b70\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5b70\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"eLX8K\", function(module, exports) {\n\n$parcel$export(module.exports, \"BlurredEnvMapGenerator\", () => $ac13547279de9cd0$export$13ef63fd7e562136);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $RPVlj = parcelRequire(\"RPVlj\");\n\nvar $9fZ6X = parcelRequire(\"9fZ6X\");\n\nvar $dUUQZ = parcelRequire(\"dUUQZ\");\nclass $ac13547279de9cd0$var$PMREMCopyMaterial extends (0, $9fZ6X.MaterialBase) {\n    constructor(){\n        super({\n            uniforms: {\n                envMap: {\n                    value: null\n                },\n                blur: {\n                    value: 0\n                }\n            },\n            vertexShader: /* glsl */ `\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}\n\n\t\t\t`,\n            fragmentShader: /* glsl */ `\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t\t${$dUUQZ.util_functions}\n\n\t\t\t\tuniform sampler2D envMap;\n\t\t\t\tuniform float blur;\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 rayDirection = equirectUvToDirection( vUv );\n\t\t\t\t\tgl_FragColor = textureCubeUV( envMap, rayDirection, blur );\n\n\t\t\t\t}\n\n\t\t\t`\n        });\n    }\n}\nclass $ac13547279de9cd0$export$13ef63fd7e562136 {\n    constructor(renderer){\n        this.renderer = renderer;\n        this.pmremGenerator = new (0, $ilwiq.PMREMGenerator)(renderer);\n        this.copyQuad = new (0, $RPVlj.FullScreenQuad)(new $ac13547279de9cd0$var$PMREMCopyMaterial());\n        this.renderTarget = new (0, $ilwiq.WebGLRenderTarget)(1, 1, {\n            type: (0, $ilwiq.FloatType),\n            format: (0, $ilwiq.RGBAFormat)\n        });\n    }\n    dispose() {\n        this.pmremGenerator.dispose();\n        this.copyQuad.dispose();\n        this.renderTarget.dispose();\n    }\n    generate(texture, blur) {\n        const { pmremGenerator: pmremGenerator, renderTarget: renderTarget, copyQuad: copyQuad, renderer: renderer } = this;\n        // get the pmrem target\n        const pmremTarget = pmremGenerator.fromEquirectangular(texture);\n        // set up the material\n        const { width: width, height: height } = texture.image;\n        renderTarget.setSize(width, height);\n        copyQuad.material.envMap = pmremTarget.texture;\n        copyQuad.material.blur = blur;\n        // render\n        const prevRenderTarget = renderer.getRenderTarget();\n        const prevClear = renderer.autoClear;\n        renderer.setRenderTarget(renderTarget);\n        renderer.autoClear = true;\n        copyQuad.render(renderer);\n        renderer.setRenderTarget(prevRenderTarget);\n        renderer.autoClear = prevClear;\n        // read the data back\n        const buffer = new Uint16Array(width * height * 4);\n        const readBuffer = new Float32Array(width * height * 4);\n        renderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, readBuffer);\n        for(let i = 0, l = readBuffer.length; i < l; i++)buffer[i] = (0, $ilwiq.DataUtils).toHalfFloat(readBuffer[i]);\n        const result = new (0, $ilwiq.DataTexture)(buffer, width, height, (0, $ilwiq.RGBAFormat), (0, $ilwiq.HalfFloatType));\n        result.minFilter = texture.minFilter;\n        result.magFilter = texture.magFilter;\n        result.wrapS = texture.wrapS;\n        result.wrapT = texture.wrapT;\n        result.mapping = (0, $ilwiq.EquirectangularReflectionMapping);\n        result.needsUpdate = true;\n        // dispose of the now unneeded target\n        pmremTarget.dispose();\n        return result;\n    }\n}\n\n});\nparcelRegister(\"9fZ6X\", function(module, exports) {\n\n$parcel$export(module.exports, \"MaterialBase\", () => $6bd4eb2914ee2835$export$f1ac3a587b6cbb5d);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $6bd4eb2914ee2835$export$f1ac3a587b6cbb5d extends (0, $ilwiq.ShaderMaterial) {\n    set needsUpdate(v) {\n        super.needsUpdate = true;\n        this.dispatchEvent({\n            type: \"recompilation\"\n        });\n    }\n    constructor(shader){\n        super(shader);\n        for(const key in this.uniforms)Object.defineProperty(this, key, {\n            get () {\n                return this.uniforms[key].value;\n            },\n            set (v) {\n                this.uniforms[key].value = v;\n            }\n        });\n    }\n    // sets the given named define value and sets \"needsUpdate\" to true if it's different\n    setDefine(name, value) {\n        if (value === undefined || value === null) {\n            if (name in this.defines) {\n                delete this.defines[name];\n                this.needsUpdate = true;\n                return true;\n            }\n        } else if (this.defines[name] !== value) {\n            this.defines[name] = value;\n            this.needsUpdate = true;\n            return true;\n        }\n        return false;\n    }\n}\n\n});\n\nparcelRegister(\"dUUQZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"util_functions\", () => $a21c9b4177584031$export$fe1d788deccfbee3);\nconst $a21c9b4177584031$export$fe1d788deccfbee3 = /* glsl */ `\n\n\t// TODO: possibly this should be renamed something related to material or path tracing logic\n\n\t#ifndef RAY_OFFSET\n\t#define RAY_OFFSET 1e-4\n\t#endif\n\n\t// adjust the hit point by the surface normal by a factor of some offset and the\n\t// maximum component-wise value of the current point to accommodate floating point\n\t// error as values increase.\n\tvec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {\n\n\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\tvec3 absPoint = abs( point );\n\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\treturn point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;\n\n\t}\n\n\t// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\n\tvec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {\n\n\t\tvec3 ot = - log( attColor ) / attDist;\n\t\treturn exp( - ot * dist );\n\n\t}\n\n\tvec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {\n\n\t\t// get the half vector - assuming if the light incident vector is on the other side\n\t\t// of the that it's transmissive.\n\t\tvec3 h;\n\t\tif ( wi.z > 0.0 ) {\n\n\t\t\th = normalize( wi + wo );\n\n\t\t} else {\n\n\t\t\t// Scale by the ior ratio to retrieve the appropriate half vector\n\t\t\t// From Section 2.2 on computing the transmission half vector:\n\t\t\t// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\n\t\t\th = normalize( wi + wo * eta );\n\n\t\t}\n\n\t\th *= sign( h.z );\n\t\treturn h;\n\n\t}\n\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\n\n\t\treturn normalize( a + b );\n\n\t}\n\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\n\t// we find a ray like that we ignore it to avoid artifacts.\n\t// This function returns if the direction is on the same side of both planes.\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\n\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\n\n\t}\n\n\t// ray sampling x and z are swapped to align with expected background view\n\tvec2 equirectDirectionToUv( vec3 direction ) {\n\n\t\t// from Spherical.setFromCartesianCoords\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\n\t\tuv /= vec2( 2.0 * PI, PI );\n\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\n\t\tuv.x += 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\t\treturn uv;\n\n\t}\n\n\tvec3 equirectUvToDirection( vec2 uv ) {\n\n\t\t// undo above adjustments\n\t\tuv.x -= 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\n\t\t// from Vector3.setFromSphericalCoords\n\t\tfloat theta = uv.x * 2.0 * PI;\n\t\tfloat phi = uv.y * PI;\n\n\t\tfloat sinPhi = sin( phi );\n\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\n\n\t}\n\n\t// power heuristic for multiple importance sampling\n\tfloat misHeuristic( float a, float b ) {\n\n\t\tfloat aa = a * a;\n\t\tfloat bb = b * b;\n\t\treturn aa / ( aa + bb );\n\n\t}\n\n\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\n\t// erichlof/THREE.js-PathTracing-Renderer/\n\tfloat tentFilter( float x ) {\n\n\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\n\n\t}\n`;\n\n});\n\n\nparcelRegister(\"891vQ\", function(module, exports) {\n\n$parcel$export(module.exports, \"RGBELoader\", () => $5ee05658f4b0e3bf$export$d076a711b55c758a);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\nclass $5ee05658f4b0e3bf$export$d076a711b55c758a extends (0, $ilwiq.DataTextureLoader) {\n    constructor(manager){\n        super(manager);\n        this.type = (0, $ilwiq.HalfFloatType);\n    }\n    // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n    parse(buffer) {\n        const /* default error routine.  change this to change error handling */ rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {\n            switch(rgbe_error_code){\n                case rgbe_read_error:\n                    throw new Error(\"THREE.RGBELoader: Read Error: \" + (msg || \"\"));\n                case rgbe_write_error:\n                    throw new Error(\"THREE.RGBELoader: Write Error: \" + (msg || \"\"));\n                case rgbe_format_error:\n                    throw new Error(\"THREE.RGBELoader: Bad File Format: \" + (msg || \"\"));\n                default:\n                case rgbe_memory_error:\n                    throw new Error(\"THREE.RGBELoader: Memory Error: \" + (msg || \"\"));\n            }\n        }, /* offsets to red, green, and blue components in a data (float) pixel */ //RGBE_DATA_RED = 0,\n        //RGBE_DATA_GREEN = 1,\n        //RGBE_DATA_BLUE = 2,\n        /* number of floats per pixel, use 4 since stored in rgba image format */ //RGBE_DATA_SIZE = 4,\n        /* flags indicating which fields in an rgbe_header_info are valid */ RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = \"\\n\", fgets = function(buffer, lineLimit, consume) {\n            const chunkSize = 128;\n            lineLimit = !lineLimit ? 1024 : lineLimit;\n            let p = buffer.pos, i = -1, len = 0, s = \"\", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n            while(0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength){\n                s += chunk;\n                len += chunk.length;\n                p += chunkSize;\n                chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n            }\n            if (-1 < i) {\n                /*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/ if (false !== consume) buffer.pos += len + i + 1;\n                return s + chunk.slice(0, i);\n            }\n            return false;\n        }, /* minimal header reading.  modify if you want to parse more information */ RGBE_ReadHeader = function(buffer) {\n            // regexes to parse header info fields\n            const magic_token_re = /^#\\?(\\S+)/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, // RGBE format header struct\n            header = {\n                valid: 0,\n                /* indicate which fields are valid */ string: \"\",\n                /* the actual header string */ comments: \"\",\n                /* comments found in header */ programtype: \"RGBE\",\n                /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */ format: \"\",\n                /* RGBE format, default 32-bit_rle_rgbe */ gamma: 1.0,\n                /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */ exposure: 1.0,\n                /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */ width: 0,\n                height: 0 /* image dimensions, width/height */ \n            };\n            let line, match;\n            if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) rgbe_error(rgbe_read_error, \"no header found\");\n            /* if you want to require the magic token then uncomment the next line */ if (!(match = line.match(magic_token_re))) rgbe_error(rgbe_format_error, \"bad initial token\");\n            header.valid |= RGBE_VALID_PROGRAMTYPE;\n            header.programtype = match[1];\n            header.string += line + \"\\n\";\n            while(true){\n                line = fgets(buffer);\n                if (false === line) break;\n                header.string += line + \"\\n\";\n                if (\"#\" === line.charAt(0)) {\n                    header.comments += line + \"\\n\";\n                    continue; // comment line\n                }\n                if (match = line.match(gamma_re)) header.gamma = parseFloat(match[1]);\n                if (match = line.match(exposure_re)) header.exposure = parseFloat(match[1]);\n                if (match = line.match(format_re)) {\n                    header.valid |= RGBE_VALID_FORMAT;\n                    header.format = match[1]; //'32-bit_rle_rgbe';\n                }\n                if (match = line.match(dimensions_re)) {\n                    header.valid |= RGBE_VALID_DIMENSIONS;\n                    header.height = parseInt(match[1], 10);\n                    header.width = parseInt(match[2], 10);\n                }\n                if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n            }\n            if (!(header.valid & RGBE_VALID_FORMAT)) rgbe_error(rgbe_format_error, \"missing format specifier\");\n            if (!(header.valid & RGBE_VALID_DIMENSIONS)) rgbe_error(rgbe_format_error, \"missing image size specifier\");\n            return header;\n        }, RGBE_ReadPixels_RLE = function(buffer, w, h) {\n            const scanline_width = w;\n            if (scanline_width < 8 || scanline_width > 0x7fff || // this file is not run length encoded\n            2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) // return the flat buffer\n            return new Uint8Array(buffer);\n            if (scanline_width !== (buffer[2] << 8 | buffer[3])) rgbe_error(rgbe_format_error, \"wrong scanline width\");\n            const data_rgba = new Uint8Array(4 * w * h);\n            if (!data_rgba.length) rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n            let offset = 0, pos = 0;\n            const ptr_end = 4 * scanline_width;\n            const rgbeStart = new Uint8Array(4);\n            const scanline_buffer = new Uint8Array(ptr_end);\n            let num_scanlines = h;\n            // read in each successive scanline\n            while(num_scanlines > 0 && pos < buffer.byteLength){\n                if (pos + 4 > buffer.byteLength) rgbe_error(rgbe_read_error);\n                rgbeStart[0] = buffer[pos++];\n                rgbeStart[1] = buffer[pos++];\n                rgbeStart[2] = buffer[pos++];\n                rgbeStart[3] = buffer[pos++];\n                if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n                // read each of the four channels for the scanline into the buffer\n                // first red, then green, then blue, then exponent\n                let ptr = 0, count;\n                while(ptr < ptr_end && pos < buffer.byteLength){\n                    count = buffer[pos++];\n                    const isEncodedRun = count > 128;\n                    if (isEncodedRun) count -= 128;\n                    if (0 === count || ptr + count > ptr_end) rgbe_error(rgbe_format_error, \"bad scanline data\");\n                    if (isEncodedRun) {\n                        // a (encoded) run of the same value\n                        const byteValue = buffer[pos++];\n                        for(let i = 0; i < count; i++)scanline_buffer[ptr++] = byteValue;\n                    //ptr += count;\n                    } else {\n                        // a literal-run\n                        scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n                        ptr += count;\n                        pos += count;\n                    }\n                }\n                // now convert data from buffer into rgba\n                // first red, then green, then blue, then exponent (alpha)\n                const l = scanline_width; //scanline_buffer.byteLength;\n                for(let i = 0; i < l; i++){\n                    let off = 0;\n                    data_rgba[offset] = scanline_buffer[i + off];\n                    off += scanline_width; //1;\n                    data_rgba[offset + 1] = scanline_buffer[i + off];\n                    off += scanline_width; //1;\n                    data_rgba[offset + 2] = scanline_buffer[i + off];\n                    off += scanline_width; //1;\n                    data_rgba[offset + 3] = scanline_buffer[i + off];\n                    offset += 4;\n                }\n                num_scanlines--;\n            }\n            return data_rgba;\n        };\n        const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2.0, e - 128.0) / 255.0;\n            destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n            destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n            destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n            destArray[destOffset + 3] = 1;\n        };\n        const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2.0, e - 128.0) / 255.0;\n            // clamping to 65504, the maximum representable value in float16\n            destArray[destOffset + 0] = (0, $ilwiq.DataUtils).toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n            destArray[destOffset + 1] = (0, $ilwiq.DataUtils).toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n            destArray[destOffset + 2] = (0, $ilwiq.DataUtils).toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n            destArray[destOffset + 3] = (0, $ilwiq.DataUtils).toHalfFloat(1);\n        };\n        const byteArray = new Uint8Array(buffer);\n        byteArray.pos = 0;\n        const rgbe_header_info = RGBE_ReadHeader(byteArray);\n        const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n        let data, type;\n        let numElements;\n        switch(this.type){\n            case 0, $ilwiq.FloatType:\n                numElements = image_rgba_data.length / 4;\n                const floatArray = new Float32Array(numElements * 4);\n                for(let j = 0; j < numElements; j++)RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\n                data = floatArray;\n                type = (0, $ilwiq.FloatType);\n                break;\n            case 0, $ilwiq.HalfFloatType:\n                numElements = image_rgba_data.length / 4;\n                const halfArray = new Uint16Array(numElements * 4);\n                for(let j = 0; j < numElements; j++)RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);\n                data = halfArray;\n                type = (0, $ilwiq.HalfFloatType);\n                break;\n            default:\n                throw new Error(\"THREE.RGBELoader: Unsupported type: \" + this.type);\n        }\n        return {\n            width: w,\n            height: h,\n            data: data,\n            header: rgbe_header_info.string,\n            gamma: rgbe_header_info.gamma,\n            exposure: rgbe_header_info.exposure,\n            type: type\n        };\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            switch(texture.type){\n                case 0, $ilwiq.FloatType:\n                case 0, $ilwiq.HalfFloatType:\n                    texture.colorSpace = (0, $ilwiq.LinearSRGBColorSpace);\n                    texture.minFilter = (0, $ilwiq.LinearFilter);\n                    texture.magFilter = (0, $ilwiq.LinearFilter);\n                    texture.generateMipmaps = false;\n                    texture.flipY = true;\n                    break;\n            }\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n}\n\n});\n\nparcelRegister(\"1EdOY\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateRadialFloorTexture\", () => $13343f7d1c4dd8ec$export$92750171fb06fc99);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nfunction $13343f7d1c4dd8ec$export$92750171fb06fc99(dim) {\n    const data = new Uint8Array(dim * dim * 4);\n    for(let x = 0; x < dim; x++)for(let y = 0; y < dim; y++){\n        const xNorm = x / (dim - 1);\n        const yNorm = y / (dim - 1);\n        const xCent = 2.0 * (xNorm - 0.5);\n        const yCent = 2.0 * (yNorm - 0.5);\n        let a = Math.max(Math.min(1.0 - Math.sqrt(xCent ** 2 + yCent ** 2), 1.0), 0.0);\n        a = a ** 2;\n        a = a * 1.5;\n        a = Math.min(a, 1.0);\n        const i = y * dim + x;\n        data[i * 4 + 0] = 255;\n        data[i * 4 + 1] = 255;\n        data[i * 4 + 2] = 255;\n        data[i * 4 + 3] = a * 255;\n    }\n    const tex = new $ilwiq.DataTexture(data, dim, dim);\n    tex.format = $ilwiq.RGBAFormat;\n    tex.type = $ilwiq.UnsignedByteType;\n    tex.minFilter = $ilwiq.LinearFilter;\n    tex.magFilter = $ilwiq.LinearFilter;\n    tex.wrapS = $ilwiq.RepeatWrapping;\n    tex.wrapT = $ilwiq.RepeatWrapping;\n    tex.needsUpdate = true;\n    return tex;\n}\n\n});\n\nparcelRegister(\"cE5k3\", function(module, exports) {\n\n$parcel$export(module.exports, \"getScaledSettings\", () => $934d596524c3e5a8$export$5bc756cb1c628b75);\nfunction $934d596524c3e5a8$export$5bc756cb1c628b75() {\n    let tiles = 3;\n    let renderScale = Math.max(1 / window.devicePixelRatio, 0.5);\n    // adjust performance parameters for mobile\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    if (aspectRatio < 0.65) {\n        tiles = 4;\n        renderScale = 0.5 / window.devicePixelRatio;\n    }\n    return {\n        tiles: tiles,\n        renderScale: renderScale\n    };\n}\n\n});\n\nparcelRegister(\"e2Pv4\", function(module, exports) {\n\n$parcel$export(module.exports, \"LoaderElement\", () => $a399336cf50451da$export$c2252eb3bc5ad0b7);\nlet $a399336cf50451da$var$_styleElement;\nfunction $a399336cf50451da$var$initializeStyles() {\n    if ($a399336cf50451da$var$_styleElement) return;\n    $a399336cf50451da$var$_styleElement = document.createElement(\"style\");\n    $a399336cf50451da$var$_styleElement.textContent = /* css */ `\n\n\t\t.loader-container, .description {\n\t\t\tposition: absolute;\n\t\t\twidth: 100%;\n\t\t\tfont-family: 'Courier New', Courier, monospace;\n\t\t\tcolor: white;\n\t\t\tfont-weight: light;\n\t\t\talign-items: flex-start;\n\t\t\tfont-size: 14px;\n\t\t\tpointer-events: none;\n\t\t\tuser-select: none;\n\t\t}\n\n\t\t.loader-container {\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: column;\n\t\t\tbottom: 0;\n\t\t}\n\n\t\t.description {\n\t\t\ttop: 0;\n\t\t\twidth: 100%;\n\t\t\ttext-align: center;\n\t\t\tpadding: 5px 0;\n\t\t}\n\n\t\t.loader-container .bar {\n\t\t\theight: 2px;\n\t\t\tbackground: white;\n\t\t\twidth: 100%;\n\t\t}\n\n\t\t.loader-container .credits,\n\t\t.loader-container .samples,\n\t\t.loader-container .percentage {\n\t\t\tpadding: 5px;\n\t\t\tmargin: 0 0 1px 1px;\n\t\t\tbackground: rgba( 0, 0, 0, 0.2 );\n\t\t\tborder-radius: 2px;\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t.loader-container:not(.loading) .bar,\n\t\t.loader-container:not(.loading) .percentage,\n\t\t.loader-container.loading .credits,\n\t\t.loader-container.loading .samples,\n\t\t.loader-container .credits:empty {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t.loader-container .credits a,\n\t\t.loader-container .credits,\n\t\t.loader-container .samples {\n\t\t\tcolor: rgba( 255, 255, 255, 0.75 );\n\t\t}\n\t`;\n    document.head.appendChild($a399336cf50451da$var$_styleElement);\n}\nclass $a399336cf50451da$export$c2252eb3bc5ad0b7 {\n    constructor(){\n        $a399336cf50451da$var$initializeStyles();\n        const container = document.createElement(\"div\");\n        container.classList.add(\"loader-container\");\n        const percentageEl = document.createElement(\"div\");\n        percentageEl.classList.add(\"percentage\");\n        container.appendChild(percentageEl);\n        const samplesEl = document.createElement(\"div\");\n        samplesEl.classList.add(\"samples\");\n        container.appendChild(samplesEl);\n        const creditsEl = document.createElement(\"div\");\n        creditsEl.classList.add(\"credits\");\n        container.appendChild(creditsEl);\n        const loaderBarEl = document.createElement(\"div\");\n        loaderBarEl.classList.add(\"bar\");\n        container.appendChild(loaderBarEl);\n        const descriptionEl = document.createElement(\"div\");\n        descriptionEl.classList.add(\"description\");\n        container.appendChild(descriptionEl);\n        this._description = descriptionEl;\n        this._loaderBar = loaderBarEl;\n        this._percentage = percentageEl;\n        this._credits = creditsEl;\n        this._samples = samplesEl;\n        this._container = container;\n        this.setPercentage(0);\n    }\n    attach(container) {\n        container.appendChild(this._container);\n        container.appendChild(this._description);\n    }\n    setPercentage(perc) {\n        this._loaderBar.style.width = `${perc * 100}%`;\n        if (perc === 0) this._percentage.innerText = \"Loading...\";\n        else this._percentage.innerText = `${(perc * 100).toFixed(0)}%`;\n        if (perc >= 1) this._container.classList.remove(\"loading\");\n        else this._container.classList.add(\"loading\");\n    }\n    setSamples(count, compiling = false) {\n        if (compiling) this._samples.innerText = \"compiling shader...\";\n        else this._samples.innerText = `${Math.floor(count)} samples`;\n    }\n    setCredits(credits) {\n        this._credits.innerHTML = credits;\n    }\n    setDescription(description) {\n        this._description.innerHTML = description;\n    }\n}\n\n});\n\nparcelRegister(\"fYvb1\", function(module, exports) {\n\n$parcel$export(module.exports, \"math_functions\", () => $ba14a4aaa0cde19b$export$98323a006d35be35);\nconst $ba14a4aaa0cde19b$export$98323a006d35be35 = /* glsl */ `\n\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\n\t// For more information see: https://github.com/gkjohnson/three-gpu-pathtracer/pull/171#issuecomment-1152275248\n\tfloat acosApprox( float x ) {\n\n\t\tx = clamp( x, -1.0, 1.0 );\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\n\n\t}\n\n\t// An acos with input values bound to the range [-1, 1].\n\tfloat acosSafe( float x ) {\n\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\n\n\t}\n\n\tfloat saturateCos( float val ) {\n\n\t\treturn clamp( val, 0.001, 1.0 );\n\n\t}\n\n\tfloat square( float t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 square( vec2 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec3 square( vec3 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec4 square( vec4 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 rotateVector( vec2 v, float t ) {\n\n\t\tfloat ac = cos( t );\n\t\tfloat as = sin( t );\n\t\treturn vec2(\n\t\t\tv.x * ac - v.y * as,\n\t\t\tv.x * as + v.y * ac\n\t\t);\n\n\t}\n\n\t// forms a basis with the normal vector as Z\n\tmat3 getBasisFromNormal( vec3 normal ) {\n\n\t\tvec3 other;\n\t\tif ( abs( normal.x ) > 0.5 ) {\n\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\n\n\t\t} else {\n\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\n\n\t\t}\n\n\t\tvec3 ortho = normalize( cross( normal, other ) );\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\n\t\treturn mat3( ortho2, ortho, normal );\n\n\t}\n\n`;\n\n});\n\nparcelRegister(\"8keuf\", function(module, exports) {\n\n$parcel$export(module.exports, \"ggx_functions\", () => $60fb6dc3c6495c33$export$4c711108e2e8ef5e);\nconst $60fb6dc3c6495c33$export$4c711108e2e8ef5e = /* glsl */ `\n\n\t// The GGX functions provide sampling and distribution information for normals as output so\n\t// in order to get probability of scatter direction the half vector must be computed and provided.\n\t// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\t// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n\t// [2] http://jcgt.org/published/0007/04/01/\n\t// [4] http://jcgt.org/published/0003/02/03/\n\n\t// trowbridge-reitz === GGX === GTR\n\n\tvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\n\n\t\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t\t// function below, as well\n\n\t\t// Implementation from reference [1]\n\t\t// stretch view\n\t\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\n\n\t\t// orthonormal basis\n\t\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\n\t\tvec3 T2 = cross( T1, V );\n\n\t\t// sample point with polar coordinates (r, phi)\n\t\tfloat a = 1.0 / ( 1.0 + V.z );\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\n\t\tfloat P1 = r * cos( phi );\n\t\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\n\n\t\t// compute normal\n\t\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\n\n\t\t// unstretch\n\t\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\n\n\t\treturn N;\n\n\t}\n\n\t// Below are PDF and related functions for use in a Monte Carlo path tracer\n\t// as specified in Appendix B of the following paper\n\t// See equation (34) from reference [0]\n\tfloat ggxLamda( float theta, float roughness ) {\n\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = tanTheta * tanTheta;\n\t\tfloat alpha2 = roughness * roughness;\n\n\t\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\n\t\treturn numerator / 2.0;\n\n\t}\n\n\t// See equation (34) from reference [0]\n\tfloat ggxShadowMaskG1( float theta, float roughness ) {\n\n\t\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n\t}\n\n\t// See equation (125) from reference [4]\n\tfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat scatterTheta = acos( wo.z );\n\t\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n\t}\n\n\t// See equation (33) from reference [0]\n\tfloat ggxDistribution( vec3 halfVector, float roughness ) {\n\n\t\tfloat a2 = roughness * roughness;\n\t\ta2 = max( EPSILON, a2 );\n\t\tfloat cosTheta = halfVector.z;\n\t\tfloat cosTheta4 = pow( cosTheta, 4.0 );\n\n\t\tif ( cosTheta == 0.0 ) return 0.0;\n\n\t\tfloat theta = acosSafe( halfVector.z );\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = pow( tanTheta, 2.0 );\n\n\t\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\n\t\treturn ( a2 / denom );\n\n\t}\n\n\t// See equation (3) from reference [2]\n\tfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat D = ggxDistribution( halfVector, roughness );\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\t\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\n\n\t}\n\n`;\n\n});\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $7lx9d = parcelRequire(\"7lx9d\");\n\nvar $5Rd1x = parcelRequire(\"5Rd1x\");\n\nvar $eLX8K = parcelRequire(\"eLX8K\");\nvar $8mHfG = parcelRequire(\"8mHfG\");\n\nvar $891vQ = parcelRequire(\"891vQ\");\n\nvar $kp7Te = parcelRequire(\"kp7Te\");\n\nvar $jiuw3 = parcelRequire(\"jiuw3\");\n\nvar $1EdOY = parcelRequire(\"1EdOY\");\n\nvar $cE5k3 = parcelRequire(\"cE5k3\");\n\nvar $e2Pv4 = parcelRequire(\"e2Pv4\");\nconst $f06a0a82aa9331ef$var$ENV_URL = \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/aristea_wreck_puresky_2k.hdr\";\nconst $f06a0a82aa9331ef$var$MORPH_URL = \"https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/models/gltf/RobotExpressive/RobotExpressive.glb\";\nconst $f06a0a82aa9331ef$var$SKINNED_URL = \"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/main/models/trex/scene.gltf\";\nconst $f06a0a82aa9331ef$var$CREDITS = \"Model by DailyArt on Sketchfab\";\nconst $f06a0a82aa9331ef$var$DESCRIPTION = \"Rendering deformable geometry with path tracing.\";\nlet $f06a0a82aa9331ef$var$pathTracer, $f06a0a82aa9331ef$var$renderer, $f06a0a82aa9331ef$var$controls, $f06a0a82aa9331ef$var$camera, $f06a0a82aa9331ef$var$scene, $f06a0a82aa9331ef$var$clock;\nlet $f06a0a82aa9331ef$var$mixer, $f06a0a82aa9331ef$var$mixerAction;\nlet $f06a0a82aa9331ef$var$loader;\nlet $f06a0a82aa9331ef$var$counter = 0;\nconst $f06a0a82aa9331ef$var$params = {\n    bounces: 5,\n    samplesPerFrame: 1,\n    renderScale: 1 / window.devicePixelRatio,\n    tiles: 1,\n    autoPause: true,\n    pause: false,\n    continuous: false,\n    stableNoise: false,\n    ...(0, $cE5k3.getScaledSettings)()\n};\n$f06a0a82aa9331ef$var$init();\nasync function $f06a0a82aa9331ef$var$init() {\n    $f06a0a82aa9331ef$var$loader = new (0, $e2Pv4.LoaderElement)();\n    $f06a0a82aa9331ef$var$loader.setDescription($f06a0a82aa9331ef$var$DESCRIPTION);\n    $f06a0a82aa9331ef$var$loader.attach(document.body);\n    // renderer\n    $f06a0a82aa9331ef$var$renderer = new (0, $ilwiq.WebGLRenderer)({\n        antialias: true\n    });\n    $f06a0a82aa9331ef$var$renderer.toneMapping = (0, $ilwiq.ACESFilmicToneMapping);\n    document.body.appendChild($f06a0a82aa9331ef$var$renderer.domElement);\n    // path tracer\n    $f06a0a82aa9331ef$var$pathTracer = new (0, $8mHfG.WebGLPathTracer)($f06a0a82aa9331ef$var$renderer);\n    $f06a0a82aa9331ef$var$pathTracer.multipleImportanceSampling = false;\n    $f06a0a82aa9331ef$var$pathTracer.tiles.set($f06a0a82aa9331ef$var$params.tiles, $f06a0a82aa9331ef$var$params.tiles);\n    $f06a0a82aa9331ef$var$pathTracer.filterGlossyFactor = 0.25;\n    $f06a0a82aa9331ef$var$pathTracer.minSamples = 1;\n    $f06a0a82aa9331ef$var$pathTracer.renderDelay = 0;\n    $f06a0a82aa9331ef$var$pathTracer.fadeDuration = 0;\n    // scene\n    $f06a0a82aa9331ef$var$scene = new (0, $ilwiq.Scene)();\n    // camera\n    $f06a0a82aa9331ef$var$camera = new (0, $ilwiq.PerspectiveCamera)(75, window.innerWidth / window.innerHeight, 0.025, 500);\n    $f06a0a82aa9331ef$var$camera.position.set(5.5, 3.5, 7.5);\n    // controls\n    $f06a0a82aa9331ef$var$controls = new (0, $5Rd1x.OrbitControls)($f06a0a82aa9331ef$var$camera, $f06a0a82aa9331ef$var$renderer.domElement);\n    $f06a0a82aa9331ef$var$camera.lookAt($f06a0a82aa9331ef$var$controls.target);\n    $f06a0a82aa9331ef$var$controls.addEventListener(\"change\", ()=>$f06a0a82aa9331ef$var$pathTracer.updateCamera());\n    $f06a0a82aa9331ef$var$controls.update();\n    // clock\n    $f06a0a82aa9331ef$var$clock = new (0, $ilwiq.Clock)();\n    // load assets\n    const modelUrl = window.location.hash === \"#morphtarget\" ? $f06a0a82aa9331ef$var$MORPH_URL : $f06a0a82aa9331ef$var$SKINNED_URL;\n    const [envTexture, gltf] = await Promise.all([\n        new (0, $891vQ.RGBELoader)().loadAsync($f06a0a82aa9331ef$var$ENV_URL),\n        new (0, $7lx9d.GLTFLoader)().setMeshoptDecoder((0, $kp7Te.MeshoptDecoder)).loadAsync(modelUrl)\n    ]);\n    // update env map\n    const generator = new (0, $eLX8K.BlurredEnvMapGenerator)($f06a0a82aa9331ef$var$renderer);\n    const blurredTex = generator.generate(envTexture, 0.1);\n    $f06a0a82aa9331ef$var$scene.background = blurredTex;\n    $f06a0a82aa9331ef$var$scene.environment = blurredTex;\n    generator.dispose();\n    // animations\n    const animations = gltf.animations;\n    $f06a0a82aa9331ef$var$mixer = new (0, $ilwiq.AnimationMixer)(gltf.scene);\n    $f06a0a82aa9331ef$var$mixerAction = $f06a0a82aa9331ef$var$mixer.clipAction(animations[0]);\n    $f06a0a82aa9331ef$var$mixerAction.play();\n    $f06a0a82aa9331ef$var$mixerAction.paused = $f06a0a82aa9331ef$var$params.pause;\n    // initialize scene\n    $f06a0a82aa9331ef$var$scene.add(gltf.scene);\n    const floorTex = (0, $1EdOY.generateRadialFloorTexture)(2048);\n    const floorPlane = new (0, $ilwiq.Mesh)(new (0, $ilwiq.PlaneGeometry)(), new (0, $ilwiq.MeshStandardMaterial)({\n        map: floorTex,\n        transparent: true,\n        color: 0xdddddd,\n        roughness: 0.15,\n        metalness: 1.0\n    }));\n    floorPlane.scale.setScalar(50);\n    floorPlane.rotation.x = -Math.PI / 2;\n    floorPlane.position.y = 0.075;\n    $f06a0a82aa9331ef$var$scene.add(floorPlane);\n    // initial generation\n    $f06a0a82aa9331ef$var$pathTracer.setScene($f06a0a82aa9331ef$var$scene, $f06a0a82aa9331ef$var$camera);\n    $f06a0a82aa9331ef$var$loader.setPercentage(1);\n    $f06a0a82aa9331ef$var$loader.setCredits($f06a0a82aa9331ef$var$CREDITS);\n    $f06a0a82aa9331ef$var$onResize();\n    window.addEventListener(\"resize\", $f06a0a82aa9331ef$var$onResize);\n    // gui\n    const gui = new (0, $jiuw3.GUI)();\n    gui.add($f06a0a82aa9331ef$var$params, \"tiles\", 1, 4, 1).onChange((value)=>{\n        $f06a0a82aa9331ef$var$pathTracer.tiles.set(value, value);\n    });\n    gui.add($f06a0a82aa9331ef$var$params, \"bounces\", 1, 10, 1).onChange($f06a0a82aa9331ef$var$regenerateScene);\n    gui.add($f06a0a82aa9331ef$var$params, \"renderScale\", 0.1, 1).onChange((v)=>{\n        $f06a0a82aa9331ef$var$pathTracer.renderScale = v;\n        $f06a0a82aa9331ef$var$pathTracer.reset();\n    });\n    gui.add($f06a0a82aa9331ef$var$params, \"autoPause\").listen();\n    gui.add($f06a0a82aa9331ef$var$params, \"pause\").onChange((v)=>{\n        $f06a0a82aa9331ef$var$params.autoPause = false;\n        $f06a0a82aa9331ef$var$setPause(v);\n    }).listen();\n    gui.add($f06a0a82aa9331ef$var$params, \"continuous\").onChange(()=>{\n        $f06a0a82aa9331ef$var$params.autoPause = false;\n    });\n    gui.add($f06a0a82aa9331ef$var$params, \"stableNoise\").onChange((v)=>{\n        $f06a0a82aa9331ef$var$pathTracer.stableNoise = v;\n    });\n    $f06a0a82aa9331ef$var$animate();\n}\nfunction $f06a0a82aa9331ef$var$setPause(v) {\n    $f06a0a82aa9331ef$var$mixerAction.paused = v;\n    $f06a0a82aa9331ef$var$params.pause = v;\n    if (v) $f06a0a82aa9331ef$var$regenerateScene();\n}\nfunction $f06a0a82aa9331ef$var$onResize() {\n    $f06a0a82aa9331ef$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    $f06a0a82aa9331ef$var$renderer.setPixelRatio(window.devicePixelRatio);\n    $f06a0a82aa9331ef$var$camera.aspect = window.innerWidth / window.innerHeight;\n    $f06a0a82aa9331ef$var$camera.updateProjectionMatrix();\n    $f06a0a82aa9331ef$var$pathTracer.updateCamera();\n}\nfunction $f06a0a82aa9331ef$var$regenerateScene() {\n    $f06a0a82aa9331ef$var$pathTracer.bounces = $f06a0a82aa9331ef$var$params.bounces;\n    $f06a0a82aa9331ef$var$pathTracer.setScene($f06a0a82aa9331ef$var$scene, $f06a0a82aa9331ef$var$camera);\n}\nfunction $f06a0a82aa9331ef$var$animate() {\n    requestAnimationFrame($f06a0a82aa9331ef$var$animate);\n    // step the animation forward\n    const delta = Math.min($f06a0a82aa9331ef$var$clock.getDelta(), 0.03);\n    $f06a0a82aa9331ef$var$mixer.update(delta);\n    if ($f06a0a82aa9331ef$var$params.autoPause) {\n        // auto pause the animation\n        $f06a0a82aa9331ef$var$counter += delta;\n        if (!$f06a0a82aa9331ef$var$params.pause && $f06a0a82aa9331ef$var$counter >= 2.5 || $f06a0a82aa9331ef$var$params.pause && $f06a0a82aa9331ef$var$counter >= 5) {\n            $f06a0a82aa9331ef$var$setPause(!$f06a0a82aa9331ef$var$params.pause);\n            $f06a0a82aa9331ef$var$counter = 0;\n        }\n    } else $f06a0a82aa9331ef$var$counter = 0;\n    $f06a0a82aa9331ef$var$pathTracer.dynamicLowRes = $f06a0a82aa9331ef$var$params.continuous;\n    if (!$f06a0a82aa9331ef$var$params.pause && !$f06a0a82aa9331ef$var$params.continuous) {\n        $f06a0a82aa9331ef$var$renderer.render($f06a0a82aa9331ef$var$scene, $f06a0a82aa9331ef$var$camera);\n        $f06a0a82aa9331ef$var$loader.setSamples(0, $f06a0a82aa9331ef$var$pathTracer.isCompiling);\n    } else {\n        // if we're continuously path tracing then update the scene\n        if (!$f06a0a82aa9331ef$var$params.pause && $f06a0a82aa9331ef$var$params.continuous) $f06a0a82aa9331ef$var$regenerateScene();\n        $f06a0a82aa9331ef$var$pathTracer.renderSample();\n        $f06a0a82aa9331ef$var$loader.setSamples($f06a0a82aa9331ef$var$pathTracer.samples, $f06a0a82aa9331ef$var$pathTracer.isCompiling);\n    }\n}\n\n\n//# sourceMappingURL=skinnedMesh.49d8c0b2.js.map\n","import { WebGLRenderTarget, RGBAFormat, HalfFloatType, PMREMGenerator, DataTexture, EquirectangularReflectionMapping, FloatType, DataUtils } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { MaterialBase } from '../materials/MaterialBase.js';\nimport * as CommonGLSL from '../shader/common/index.js';\n\nclass PMREMCopyMaterial extends MaterialBase {\n\n\tconstructor() {\n\n\t\tsuper( {\n\n\t\t\tuniforms: {\n\n\t\t\t\tenvMap: { value: null },\n\t\t\t\tblur: { value: 0 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t\t${ CommonGLSL.util_functions }\n\n\t\t\t\tuniform sampler2D envMap;\n\t\t\t\tuniform float blur;\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 rayDirection = equirectUvToDirection( vUv );\n\t\t\t\t\tgl_FragColor = textureCubeUV( envMap, rayDirection, blur );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t} );\n\n\t}\n\n}\n\nexport class BlurredEnvMapGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis.renderer = renderer;\n\t\tthis.pmremGenerator = new PMREMGenerator( renderer );\n\t\tthis.copyQuad = new FullScreenQuad( new PMREMCopyMaterial() );\n\t\tthis.renderTarget = new WebGLRenderTarget( 1, 1, { type: FloatType, format: RGBAFormat } );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.pmremGenerator.dispose();\n\t\tthis.copyQuad.dispose();\n\t\tthis.renderTarget.dispose();\n\n\t}\n\n\tgenerate( texture, blur ) {\n\n\t\tconst { pmremGenerator, renderTarget, copyQuad, renderer } = this;\n\n\t\t// get the pmrem target\n\t\tconst pmremTarget = pmremGenerator.fromEquirectangular( texture );\n\n\t\t// set up the material\n\t\tconst { width, height } = texture.image;\n\t\trenderTarget.setSize( width, height );\n\t\tcopyQuad.material.envMap = pmremTarget.texture;\n\t\tcopyQuad.material.blur = blur;\n\n\t\t// render\n\t\tconst prevRenderTarget = renderer.getRenderTarget();\n\t\tconst prevClear = renderer.autoClear;\n\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.autoClear = true;\n\t\tcopyQuad.render( renderer );\n\n\t\trenderer.setRenderTarget( prevRenderTarget );\n\t\trenderer.autoClear = prevClear;\n\n\t\t// read the data back\n\t\tconst buffer = new Uint16Array( width * height * 4 );\n\t\tconst readBuffer = new Float32Array( width * height * 4 );\n\t\trenderer.readRenderTargetPixels( renderTarget, 0, 0, width, height, readBuffer );\n\n\t\tfor ( let i = 0, l = readBuffer.length; i < l; i ++ ) {\n\n\t\t\tbuffer[ i ] = DataUtils.toHalfFloat( readBuffer[ i ] );\n\n\t\t}\n\n\t\tconst result = new DataTexture( buffer, width, height, RGBAFormat, HalfFloatType );\n\t\tresult.minFilter = texture.minFilter;\n\t\tresult.magFilter = texture.magFilter;\n\t\tresult.wrapS = texture.wrapS;\n\t\tresult.wrapT = texture.wrapT;\n\t\tresult.mapping = EquirectangularReflectionMapping;\n\t\tresult.needsUpdate = true;\n\n\t\t// dispose of the now unneeded target\n\t\tpmremTarget.dispose();\n\n\t\treturn result;\n\n\t}\n\n}\n","import { ShaderMaterial } from 'three';\n\nexport class MaterialBase extends ShaderMaterial {\n\n\tset needsUpdate( v ) {\n\n\t\tsuper.needsUpdate = true;\n\t\tthis.dispatchEvent( {\n\n\t\t\ttype: 'recompilation',\n\n\t\t} );\n\n\t}\n\n\tconstructor( shader ) {\n\n\t\tsuper( shader );\n\n\t\tfor ( const key in this.uniforms ) {\n\n\t\t\tObject.defineProperty( this, key, {\n\n\t\t\t\tget() {\n\n\t\t\t\t\treturn this.uniforms[ key ].value;\n\n\t\t\t\t},\n\n\t\t\t\tset( v ) {\n\n\t\t\t\t\tthis.uniforms[ key ].value = v;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// sets the given named define value and sets \"needsUpdate\" to true if it's different\n\tsetDefine( name, value = undefined ) {\n\n\t\tif ( value === undefined || value === null ) {\n\n\t\t\tif ( name in this.defines ) {\n\n\t\t\t\tdelete this.defines[ name ];\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.defines[ name ] !== value ) {\n\n\t\t\t\tthis.defines[ name ] = value;\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n}\n","export const util_functions = /* glsl */`\n\n\t// TODO: possibly this should be renamed something related to material or path tracing logic\n\n\t#ifndef RAY_OFFSET\n\t#define RAY_OFFSET 1e-4\n\t#endif\n\n\t// adjust the hit point by the surface normal by a factor of some offset and the\n\t// maximum component-wise value of the current point to accommodate floating point\n\t// error as values increase.\n\tvec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {\n\n\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\tvec3 absPoint = abs( point );\n\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\treturn point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;\n\n\t}\n\n\t// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\n\tvec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {\n\n\t\tvec3 ot = - log( attColor ) / attDist;\n\t\treturn exp( - ot * dist );\n\n\t}\n\n\tvec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {\n\n\t\t// get the half vector - assuming if the light incident vector is on the other side\n\t\t// of the that it's transmissive.\n\t\tvec3 h;\n\t\tif ( wi.z > 0.0 ) {\n\n\t\t\th = normalize( wi + wo );\n\n\t\t} else {\n\n\t\t\t// Scale by the ior ratio to retrieve the appropriate half vector\n\t\t\t// From Section 2.2 on computing the transmission half vector:\n\t\t\t// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\n\t\t\th = normalize( wi + wo * eta );\n\n\t\t}\n\n\t\th *= sign( h.z );\n\t\treturn h;\n\n\t}\n\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\n\n\t\treturn normalize( a + b );\n\n\t}\n\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\n\t// we find a ray like that we ignore it to avoid artifacts.\n\t// This function returns if the direction is on the same side of both planes.\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\n\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\n\n\t}\n\n\t// ray sampling x and z are swapped to align with expected background view\n\tvec2 equirectDirectionToUv( vec3 direction ) {\n\n\t\t// from Spherical.setFromCartesianCoords\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\n\t\tuv /= vec2( 2.0 * PI, PI );\n\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\n\t\tuv.x += 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\t\treturn uv;\n\n\t}\n\n\tvec3 equirectUvToDirection( vec2 uv ) {\n\n\t\t// undo above adjustments\n\t\tuv.x -= 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\n\t\t// from Vector3.setFromSphericalCoords\n\t\tfloat theta = uv.x * 2.0 * PI;\n\t\tfloat phi = uv.y * PI;\n\n\t\tfloat sinPhi = sin( phi );\n\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\n\n\t}\n\n\t// power heuristic for multiple importance sampling\n\tfloat misHeuristic( float a, float b ) {\n\n\t\tfloat aa = a * a;\n\t\tfloat bb = b * b;\n\t\treturn aa / ( aa + bb );\n\n\t}\n\n\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\n\t// erichlof/THREE.js-PathTracing-Renderer/\n\tfloat tentFilter( float x ) {\n\n\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\n\n\t}\n`;\n","import {\n\tDataTextureLoader,\n\tDataUtils,\n\tFloatType,\n\tHalfFloatType,\n\tLinearFilter,\n\tLinearSRGBColorSpace\n} from 'three';\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.type = HalfFloatType;\n\n\t}\n\n\t// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\tparse( buffer ) {\n\n\t\tconst\n\t\t\t/* default error routine.  change this to change error handling */\n\t\t\trgbe_read_error = 1,\n\t\t\trgbe_write_error = 2,\n\t\t\trgbe_format_error = 3,\n\t\t\trgbe_memory_error = 4,\n\t\t\trgbe_error = function ( rgbe_error_code, msg ) {\n\n\t\t\t\tswitch ( rgbe_error_code ) {\n\n\t\t\t\t\tcase rgbe_read_error: throw new Error( 'THREE.RGBELoader: Read Error: ' + ( msg || '' ) );\n\t\t\t\t\tcase rgbe_write_error: throw new Error( 'THREE.RGBELoader: Write Error: ' + ( msg || '' ) );\n\t\t\t\t\tcase rgbe_format_error: throw new Error( 'THREE.RGBELoader: Bad File Format: ' + ( msg || '' ) );\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase rgbe_memory_error: throw new Error( 'THREE.RGBELoader: Memory Error: ' + ( msg || '' ) );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\t/* offsets to red, green, and blue components in a data (float) pixel */\n\t\t\t//RGBE_DATA_RED = 0,\n\t\t\t//RGBE_DATA_GREEN = 1,\n\t\t\t//RGBE_DATA_BLUE = 2,\n\n\t\t\t/* number of floats per pixel, use 4 since stored in rgba image format */\n\t\t\t//RGBE_DATA_SIZE = 4,\n\n\t\t\t/* flags indicating which fields in an rgbe_header_info are valid */\n\t\t\tRGBE_VALID_PROGRAMTYPE = 1,\n\t\t\tRGBE_VALID_FORMAT = 2,\n\t\t\tRGBE_VALID_DIMENSIONS = 4,\n\n\t\t\tNEWLINE = '\\n',\n\n\t\t\tfgets = function ( buffer, lineLimit, consume ) {\n\n\t\t\t\tconst chunkSize = 128;\n\n\t\t\t\tlineLimit = ! lineLimit ? 1024 : lineLimit;\n\t\t\t\tlet p = buffer.pos,\n\t\t\t\t\ti = - 1, len = 0, s = '',\n\t\t\t\t\tchunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\twhile ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {\n\n\t\t\t\t\ts += chunk; len += chunk.length;\n\t\t\t\t\tp += chunkSize;\n\t\t\t\t\tchunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( - 1 < i ) {\n\n\t\t\t\t\t/*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n\t\t\t\t\tif ( false !== consume ) buffer.pos += len + i + 1;\n\t\t\t\t\treturn s + chunk.slice( 0, i );\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\t/* minimal header reading.  modify if you want to parse more information */\n\t\t\tRGBE_ReadHeader = function ( buffer ) {\n\n\n\t\t\t\t// regexes to parse header info fields\n\t\t\t\tconst magic_token_re = /^#\\?(\\S+)/,\n\t\t\t\t\tgamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\texposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\tformat_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n\t\t\t\t\tdimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n\n\t\t\t\t\t// RGBE format header struct\n\t\t\t\t\theader = {\n\n\t\t\t\t\t\tvalid: 0, /* indicate which fields are valid */\n\n\t\t\t\t\t\tstring: '', /* the actual header string */\n\n\t\t\t\t\t\tcomments: '', /* comments found in header */\n\n\t\t\t\t\t\tprogramtype: 'RGBE', /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n\n\t\t\t\t\t\tformat: '', /* RGBE format, default 32-bit_rle_rgbe */\n\n\t\t\t\t\t\tgamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n\n\t\t\t\t\t\texposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n\n\t\t\t\t\t\twidth: 0, height: 0 /* image dimensions, width/height */\n\n\t\t\t\t\t};\n\n\t\t\t\tlet line, match;\n\n\t\t\t\tif ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_read_error, 'no header found' );\n\n\t\t\t\t}\n\n\t\t\t\t/* if you want to require the magic token then uncomment the next line */\n\t\t\t\tif ( ! ( match = line.match( magic_token_re ) ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'bad initial token' );\n\n\t\t\t\t}\n\n\t\t\t\theader.valid |= RGBE_VALID_PROGRAMTYPE;\n\t\t\t\theader.programtype = match[ 1 ];\n\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\twhile ( true ) {\n\n\t\t\t\t\tline = fgets( buffer );\n\t\t\t\t\tif ( false === line ) break;\n\t\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\t\tif ( '#' === line.charAt( 0 ) ) {\n\n\t\t\t\t\t\theader.comments += line + '\\n';\n\t\t\t\t\t\tcontinue; // comment line\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( gamma_re ) ) {\n\n\t\t\t\t\t\theader.gamma = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( exposure_re ) ) {\n\n\t\t\t\t\t\theader.exposure = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( format_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_FORMAT;\n\t\t\t\t\t\theader.format = match[ 1 ];//'32-bit_rle_rgbe';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( dimensions_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_DIMENSIONS;\n\t\t\t\t\t\theader.height = parseInt( match[ 1 ], 10 );\n\t\t\t\t\t\theader.width = parseInt( match[ 2 ], 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'missing format specifier' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'missing image size specifier' );\n\n\t\t\t\t}\n\n\t\t\t\treturn header;\n\n\t\t\t},\n\n\t\t\tRGBE_ReadPixels_RLE = function ( buffer, w, h ) {\n\n\t\t\t\tconst scanline_width = w;\n\n\t\t\t\tif (\n\t\t\t\t\t// run length encoding is not allowed so read flat\n\t\t\t\t\t( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||\n\t\t\t\t\t// this file is not run length encoded\n\t\t\t\t\t( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )\n\t\t\t\t) {\n\n\t\t\t\t\t// return the flat buffer\n\t\t\t\t\treturn new Uint8Array( buffer );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'wrong scanline width' );\n\n\t\t\t\t}\n\n\t\t\t\tconst data_rgba = new Uint8Array( 4 * w * h );\n\n\t\t\t\tif ( ! data_rgba.length ) {\n\n\t\t\t\t\trgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );\n\n\t\t\t\t}\n\n\t\t\t\tlet offset = 0, pos = 0;\n\n\t\t\t\tconst ptr_end = 4 * scanline_width;\n\t\t\t\tconst rgbeStart = new Uint8Array( 4 );\n\t\t\t\tconst scanline_buffer = new Uint8Array( ptr_end );\n\t\t\t\tlet num_scanlines = h;\n\n\t\t\t\t// read in each successive scanline\n\t\t\t\twhile ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\tif ( pos + 4 > buffer.byteLength ) {\n\n\t\t\t\t\t\trgbe_error( rgbe_read_error );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trgbeStart[ 0 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 1 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 2 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 3 ] = buffer[ pos ++ ];\n\n\t\t\t\t\tif ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {\n\n\t\t\t\t\t\trgbe_error( rgbe_format_error, 'bad rgbe scanline format' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// read each of the four channels for the scanline into the buffer\n\t\t\t\t\t// first red, then green, then blue, then exponent\n\t\t\t\t\tlet ptr = 0, count;\n\n\t\t\t\t\twhile ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\t\tcount = buffer[ pos ++ ];\n\t\t\t\t\t\tconst isEncodedRun = count > 128;\n\t\t\t\t\t\tif ( isEncodedRun ) count -= 128;\n\n\t\t\t\t\t\tif ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {\n\n\t\t\t\t\t\t\trgbe_error( rgbe_format_error, 'bad scanline data' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( isEncodedRun ) {\n\n\t\t\t\t\t\t\t// a (encoded) run of the same value\n\t\t\t\t\t\t\tconst byteValue = buffer[ pos ++ ];\n\t\t\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\tscanline_buffer[ ptr ++ ] = byteValue;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//ptr += count;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// a literal-run\n\t\t\t\t\t\t\tscanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );\n\t\t\t\t\t\t\tptr += count; pos += count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// now convert data from buffer into rgba\n\t\t\t\t\t// first red, then green, then blue, then exponent (alpha)\n\t\t\t\t\tconst l = scanline_width; //scanline_buffer.byteLength;\n\t\t\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\t\t\tlet off = 0;\n\t\t\t\t\t\tdata_rgba[ offset ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 1 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 2 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 3 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnum_scanlines --;\n\n\t\t\t\t}\n\n\t\t\t\treturn data_rgba;\n\n\t\t\t};\n\n\t\tconst RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\tdestArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;\n\t\t\tdestArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;\n\t\t\tdestArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;\n\t\t\tdestArray[ destOffset + 3 ] = 1;\n\n\t\t};\n\n\t\tconst RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\t// clamping to 65504, the maximum representable value in float16\n\t\t\tdestArray[ destOffset + 0 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 1 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 2 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 3 ] = DataUtils.toHalfFloat( 1 );\n\n\t\t};\n\n\t\tconst byteArray = new Uint8Array( buffer );\n\t\tbyteArray.pos = 0;\n\t\tconst rgbe_header_info = RGBE_ReadHeader( byteArray );\n\n\t\tconst w = rgbe_header_info.width,\n\t\t\th = rgbe_header_info.height,\n\t\t\timage_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );\n\n\n\t\tlet data, type;\n\t\tlet numElements;\n\n\t\tswitch ( this.type ) {\n\n\t\t\tcase FloatType:\n\n\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\tconst floatArray = new Float32Array( numElements * 4 );\n\n\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\tRGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );\n\n\t\t\t\t}\n\n\t\t\t\tdata = floatArray;\n\t\t\t\ttype = FloatType;\n\t\t\t\tbreak;\n\n\t\t\tcase HalfFloatType:\n\n\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\tconst halfArray = new Uint16Array( numElements * 4 );\n\n\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\tRGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );\n\n\t\t\t\t}\n\n\t\t\t\tdata = halfArray;\n\t\t\t\ttype = HalfFloatType;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tthrow new Error( 'THREE.RGBELoader: Unsupported type: ' + this.type );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\treturn {\n\t\t\twidth: w, height: h,\n\t\t\tdata: data,\n\t\t\theader: rgbe_header_info.string,\n\t\t\tgamma: rgbe_header_info.gamma,\n\t\t\texposure: rgbe_header_info.exposure,\n\t\t\ttype: type\n\t\t};\n\n\t}\n\n\tsetDataType( value ) {\n\n\t\tthis.type = value;\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tfunction onLoadCallback( texture, texData ) {\n\n\t\t\tswitch ( texture.type ) {\n\n\t\t\t\tcase FloatType:\n\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\ttexture.colorSpace = LinearSRGBColorSpace;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}\n\n\t\treturn super.load( url, onLoadCallback, onProgress, onError );\n\n\t}\n\n}\n\nexport { RGBELoader };\n","import * as THREE from 'three';\n\nexport function generateRadialFloorTexture( dim ) {\n\n\tconst data = new Uint8Array( dim * dim * 4 );\n\n\tfor ( let x = 0; x < dim; x ++ ) {\n\n\t\tfor ( let y = 0; y < dim; y ++ ) {\n\n\t\t\tconst xNorm = x / ( dim - 1 );\n\t\t\tconst yNorm = y / ( dim - 1 );\n\n\t\t\tconst xCent = 2.0 * ( xNorm - 0.5 );\n\t\t\tconst yCent = 2.0 * ( yNorm - 0.5 );\n\t\t\tlet a = Math.max( Math.min( 1.0 - Math.sqrt( xCent ** 2 + yCent ** 2 ), 1.0 ), 0.0 );\n\t\t\ta = a ** 2;\n\t\t\ta = a * 1.5;\n\t\t\ta = Math.min( a, 1.0 );\n\n\t\t\tconst i = y * dim + x;\n\t\t\tdata[ i * 4 + 0 ] = 255;\n\t\t\tdata[ i * 4 + 1 ] = 255;\n\t\t\tdata[ i * 4 + 2 ] = 255;\n\t\t\tdata[ i * 4 + 3 ] = a * 255;\n\n\t\t}\n\n\t}\n\n\tconst tex = new THREE.DataTexture( data, dim, dim );\n\ttex.format = THREE.RGBAFormat;\n\ttex.type = THREE.UnsignedByteType;\n\ttex.minFilter = THREE.LinearFilter;\n\ttex.magFilter = THREE.LinearFilter;\n\ttex.wrapS = THREE.RepeatWrapping;\n\ttex.wrapT = THREE.RepeatWrapping;\n\ttex.needsUpdate = true;\n\treturn tex;\n\n}\n","export function getScaledSettings() {\n\n\tlet tiles = 3;\n\tlet renderScale = Math.max( 1 / window.devicePixelRatio, 0.5 );\n\n\t// adjust performance parameters for mobile\n\tconst aspectRatio = window.innerWidth / window.innerHeight;\n\tif ( aspectRatio < 0.65 ) {\n\n\t\ttiles = 4;\n\t\trenderScale = 0.5 / window.devicePixelRatio;\n\n\t}\n\n\treturn { tiles, renderScale };\n\n}\n","let _styleElement;\nfunction initializeStyles() {\n\n\tif ( _styleElement ) {\n\n\t\treturn;\n\n\t}\n\n\t_styleElement = document.createElement( 'style' );\n\t_styleElement.textContent = /* css */`\n\n\t\t.loader-container, .description {\n\t\t\tposition: absolute;\n\t\t\twidth: 100%;\n\t\t\tfont-family: 'Courier New', Courier, monospace;\n\t\t\tcolor: white;\n\t\t\tfont-weight: light;\n\t\t\talign-items: flex-start;\n\t\t\tfont-size: 14px;\n\t\t\tpointer-events: none;\n\t\t\tuser-select: none;\n\t\t}\n\n\t\t.loader-container {\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: column;\n\t\t\tbottom: 0;\n\t\t}\n\n\t\t.description {\n\t\t\ttop: 0;\n\t\t\twidth: 100%;\n\t\t\ttext-align: center;\n\t\t\tpadding: 5px 0;\n\t\t}\n\n\t\t.loader-container .bar {\n\t\t\theight: 2px;\n\t\t\tbackground: white;\n\t\t\twidth: 100%;\n\t\t}\n\n\t\t.loader-container .credits,\n\t\t.loader-container .samples,\n\t\t.loader-container .percentage {\n\t\t\tpadding: 5px;\n\t\t\tmargin: 0 0 1px 1px;\n\t\t\tbackground: rgba( 0, 0, 0, 0.2 );\n\t\t\tborder-radius: 2px;\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t.loader-container:not(.loading) .bar,\n\t\t.loader-container:not(.loading) .percentage,\n\t\t.loader-container.loading .credits,\n\t\t.loader-container.loading .samples,\n\t\t.loader-container .credits:empty {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t.loader-container .credits a,\n\t\t.loader-container .credits,\n\t\t.loader-container .samples {\n\t\t\tcolor: rgba( 255, 255, 255, 0.75 );\n\t\t}\n\t`;\n\tdocument.head.appendChild( _styleElement );\n\n}\n\nexport class LoaderElement {\n\n\tconstructor() {\n\n\t\tinitializeStyles();\n\n\t\tconst container = document.createElement( 'div' );\n\t\tcontainer.classList.add( 'loader-container' );\n\n\t\tconst percentageEl = document.createElement( 'div' );\n\t\tpercentageEl.classList.add( 'percentage' );\n\t\tcontainer.appendChild( percentageEl );\n\n\t\tconst samplesEl = document.createElement( 'div' );\n\t\tsamplesEl.classList.add( 'samples' );\n\t\tcontainer.appendChild( samplesEl );\n\n\t\tconst creditsEl = document.createElement( 'div' );\n\t\tcreditsEl.classList.add( 'credits' );\n\t\tcontainer.appendChild( creditsEl );\n\n\t\tconst loaderBarEl = document.createElement( 'div' );\n\t\tloaderBarEl.classList.add( 'bar' );\n\t\tcontainer.appendChild( loaderBarEl );\n\n\t\tconst descriptionEl = document.createElement( 'div' );\n\t\tdescriptionEl.classList.add( 'description' );\n\t\tcontainer.appendChild( descriptionEl );\n\n\t\tthis._description = descriptionEl;\n\t\tthis._loaderBar = loaderBarEl;\n\t\tthis._percentage = percentageEl;\n\t\tthis._credits = creditsEl;\n\t\tthis._samples = samplesEl;\n\t\tthis._container = container;\n\n\t\tthis.setPercentage( 0 );\n\n\t}\n\n\tattach( container ) {\n\n\t\tcontainer.appendChild( this._container );\n\t\tcontainer.appendChild( this._description );\n\n\t}\n\n\tsetPercentage( perc ) {\n\n\t\tthis._loaderBar.style.width = `${ perc * 100 }%`;\n\n\t\tif ( perc === 0 ) {\n\n\t\t\tthis._percentage.innerText = 'Loading...';\n\n\t\t} else {\n\n\t\t\tthis._percentage.innerText = `${ ( perc * 100 ).toFixed( 0 ) }%`;\n\n\t\t}\n\n\t\tif ( perc >= 1 ) {\n\n\t\t\tthis._container.classList.remove( 'loading' );\n\n\t\t} else {\n\n\t\t\tthis._container.classList.add( 'loading' );\n\n\t\t}\n\n\t}\n\n\tsetSamples( count, compiling = false ) {\n\n\t\tif ( compiling ) {\n\n\t\t\tthis._samples.innerText = 'compiling shader...';\n\n\t\t} else {\n\n\t\t\tthis._samples.innerText = `${ Math.floor( count ) } samples`;\n\n\t\t}\n\n\t}\n\n\tsetCredits( credits ) {\n\n\t\tthis._credits.innerHTML = credits;\n\n\t}\n\n\tsetDescription( description ) {\n\n\t\tthis._description.innerHTML = description;\n\n\t}\n\n}\n","export const math_functions = /* glsl */`\n\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\n\t// For more information see: https://github.com/gkjohnson/three-gpu-pathtracer/pull/171#issuecomment-1152275248\n\tfloat acosApprox( float x ) {\n\n\t\tx = clamp( x, -1.0, 1.0 );\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\n\n\t}\n\n\t// An acos with input values bound to the range [-1, 1].\n\tfloat acosSafe( float x ) {\n\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\n\n\t}\n\n\tfloat saturateCos( float val ) {\n\n\t\treturn clamp( val, 0.001, 1.0 );\n\n\t}\n\n\tfloat square( float t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 square( vec2 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec3 square( vec3 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec4 square( vec4 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 rotateVector( vec2 v, float t ) {\n\n\t\tfloat ac = cos( t );\n\t\tfloat as = sin( t );\n\t\treturn vec2(\n\t\t\tv.x * ac - v.y * as,\n\t\t\tv.x * as + v.y * ac\n\t\t);\n\n\t}\n\n\t// forms a basis with the normal vector as Z\n\tmat3 getBasisFromNormal( vec3 normal ) {\n\n\t\tvec3 other;\n\t\tif ( abs( normal.x ) > 0.5 ) {\n\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\n\n\t\t} else {\n\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\n\n\t\t}\n\n\t\tvec3 ortho = normalize( cross( normal, other ) );\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\n\t\treturn mat3( ortho2, ortho, normal );\n\n\t}\n\n`;\n","export const ggx_functions = /* glsl */`\n\n\t// The GGX functions provide sampling and distribution information for normals as output so\n\t// in order to get probability of scatter direction the half vector must be computed and provided.\n\t// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\t// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n\t// [2] http://jcgt.org/published/0007/04/01/\n\t// [4] http://jcgt.org/published/0003/02/03/\n\n\t// trowbridge-reitz === GGX === GTR\n\n\tvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\n\n\t\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t\t// function below, as well\n\n\t\t// Implementation from reference [1]\n\t\t// stretch view\n\t\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\n\n\t\t// orthonormal basis\n\t\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\n\t\tvec3 T2 = cross( T1, V );\n\n\t\t// sample point with polar coordinates (r, phi)\n\t\tfloat a = 1.0 / ( 1.0 + V.z );\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\n\t\tfloat P1 = r * cos( phi );\n\t\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\n\n\t\t// compute normal\n\t\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\n\n\t\t// unstretch\n\t\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\n\n\t\treturn N;\n\n\t}\n\n\t// Below are PDF and related functions for use in a Monte Carlo path tracer\n\t// as specified in Appendix B of the following paper\n\t// See equation (34) from reference [0]\n\tfloat ggxLamda( float theta, float roughness ) {\n\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = tanTheta * tanTheta;\n\t\tfloat alpha2 = roughness * roughness;\n\n\t\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\n\t\treturn numerator / 2.0;\n\n\t}\n\n\t// See equation (34) from reference [0]\n\tfloat ggxShadowMaskG1( float theta, float roughness ) {\n\n\t\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n\t}\n\n\t// See equation (125) from reference [4]\n\tfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat scatterTheta = acos( wo.z );\n\t\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n\t}\n\n\t// See equation (33) from reference [0]\n\tfloat ggxDistribution( vec3 halfVector, float roughness ) {\n\n\t\tfloat a2 = roughness * roughness;\n\t\ta2 = max( EPSILON, a2 );\n\t\tfloat cosTheta = halfVector.z;\n\t\tfloat cosTheta4 = pow( cosTheta, 4.0 );\n\n\t\tif ( cosTheta == 0.0 ) return 0.0;\n\n\t\tfloat theta = acosSafe( halfVector.z );\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = pow( tanTheta, 2.0 );\n\n\t\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\n\t\treturn ( a2 / denom );\n\n\t}\n\n\t// See equation (3) from reference [2]\n\tfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat D = ggxDistribution( halfVector, roughness );\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\t\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\n\n\t}\n\n`;\n","import {\n\tWebGLRenderer,\n\tACESFilmicToneMapping,\n\tScene,\n\tPerspectiveCamera,\n\tClock,\n\tAnimationMixer,\n\tMesh,\n\tPlaneGeometry,\n\tMeshStandardMaterial,\n} from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { BlurredEnvMapGenerator, WebGLPathTracer } from '../src/index.js';\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';\nimport { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport { generateRadialFloorTexture } from './utils/generateRadialFloorTexture.js';\nimport { getScaledSettings } from './utils/getScaledSettings.js';\nimport { LoaderElement } from './utils/LoaderElement.js';\n\nconst ENV_URL = 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/aristea_wreck_puresky_2k.hdr';\nconst MORPH_URL = 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/models/gltf/RobotExpressive/RobotExpressive.glb';\nconst SKINNED_URL = 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/main/models/trex/scene.gltf';\nconst CREDITS = 'Model by DailyArt on Sketchfab';\nconst DESCRIPTION = 'Rendering deformable geometry with path tracing.';\n\nlet pathTracer, renderer, controls, camera, scene, clock;\nlet mixer, mixerAction;\nlet loader;\nlet counter = 0;\nconst params = {\n\n\tbounces: 5,\n\tsamplesPerFrame: 1,\n\trenderScale: 1 / window.devicePixelRatio,\n\ttiles: 1,\n\tautoPause: true,\n\tpause: false,\n\tcontinuous: false,\n\tstableNoise: false,\n\t...getScaledSettings(),\n\n};\n\ninit();\n\nasync function init() {\n\n\tloader = new LoaderElement();\n\tloader.setDescription( DESCRIPTION );\n\tloader.attach( document.body );\n\n\t// renderer\n\trenderer = new WebGLRenderer( { antialias: true } );\n\trenderer.toneMapping = ACESFilmicToneMapping;\n\tdocument.body.appendChild( renderer.domElement );\n\n\t// path tracer\n\tpathTracer = new WebGLPathTracer( renderer );\n\tpathTracer.multipleImportanceSampling = false;\n\tpathTracer.tiles.set( params.tiles, params.tiles );\n\tpathTracer.filterGlossyFactor = 0.25;\n\tpathTracer.minSamples = 1;\n\tpathTracer.renderDelay = 0;\n\tpathTracer.fadeDuration = 0;\n\n\t// scene\n\tscene = new Scene();\n\n\t// camera\n\tcamera = new PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.025, 500 );\n\tcamera.position.set( 5.5, 3.5, 7.5 );\n\n\t// controls\n\tcontrols = new OrbitControls( camera, renderer.domElement );\n\tcamera.lookAt( controls.target );\n\tcontrols.addEventListener( 'change', () => pathTracer.updateCamera() );\n\tcontrols.update();\n\n\t// clock\n\tclock = new Clock();\n\n\t// load assets\n\tconst modelUrl = window.location.hash === '#morphtarget' ? MORPH_URL : SKINNED_URL;\n\tconst [ envTexture, gltf ] = await Promise.all( [\n\t\tnew RGBELoader().loadAsync( ENV_URL ),\n\t\tnew GLTFLoader().setMeshoptDecoder( MeshoptDecoder ).loadAsync( modelUrl )\n\t] );\n\n\t// update env map\n\tconst generator = new BlurredEnvMapGenerator( renderer );\n\tconst blurredTex = generator.generate( envTexture, 0.1 );\n\tscene.background = blurredTex;\n\tscene.environment = blurredTex;\n\tgenerator.dispose();\n\n\t// animations\n\tconst animations = gltf.animations;\n\tmixer = new AnimationMixer( gltf.scene );\n\n\tmixerAction = mixer.clipAction( animations[ 0 ] );\n\tmixerAction.play();\n\tmixerAction.paused = params.pause;\n\n\t// initialize scene\n\tscene.add( gltf.scene );\n\n\tconst floorTex = generateRadialFloorTexture( 2048 );\n\tconst floorPlane = new Mesh(\n\t\tnew PlaneGeometry(),\n\t\tnew MeshStandardMaterial( {\n\t\t\tmap: floorTex,\n\t\t\ttransparent: true,\n\t\t\tcolor: 0xdddddd,\n\t\t\troughness: 0.15,\n\t\t\tmetalness: 1.0\n\t\t} )\n\t);\n\tfloorPlane.scale.setScalar( 50 );\n\tfloorPlane.rotation.x = - Math.PI / 2;\n\tfloorPlane.position.y = 0.075;\n\tscene.add( floorPlane );\n\n\t// initial generation\n\tpathTracer.setScene( scene, camera );\n\n\tloader.setPercentage( 1 );\n\tloader.setCredits( CREDITS );\n\n\tonResize();\n\twindow.addEventListener( 'resize', onResize );\n\n\t// gui\n\tconst gui = new GUI();\n\tgui.add( params, 'tiles', 1, 4, 1 ).onChange( value => {\n\n\t\tpathTracer.tiles.set( value, value );\n\n\t} );\n\tgui.add( params, 'bounces', 1, 10, 1 ).onChange( regenerateScene );\n\tgui.add( params, 'renderScale', 0.1, 1 ).onChange( v => {\n\n\t\tpathTracer.renderScale = v;\n\t\tpathTracer.reset();\n\n\t} );\n\tgui.add( params, 'autoPause' ).listen();\n\tgui.add( params, 'pause' ).onChange( v => {\n\n\t\tparams.autoPause = false;\n\t\tsetPause( v );\n\n\t} ).listen();\n\tgui.add( params, 'continuous' ).onChange( () => {\n\n\t\tparams.autoPause = false;\n\n\t} );\n\tgui.add( params, 'stableNoise' ).onChange( v => {\n\n\t\tpathTracer.stableNoise = v;\n\n\t} );\n\n\tanimate();\n\n}\n\nfunction setPause( v ) {\n\n\tmixerAction.paused = v;\n\tparams.pause = v;\n\tif ( v ) {\n\n\t\tregenerateScene();\n\n\t}\n\n}\n\nfunction onResize() {\n\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\n\tcamera.aspect = window.innerWidth / window.innerHeight;\n\tcamera.updateProjectionMatrix();\n\n\tpathTracer.updateCamera();\n\n}\n\nfunction regenerateScene() {\n\n\tpathTracer.bounces = params.bounces;\n\tpathTracer.setScene( scene, camera );\n\n}\n\nfunction animate() {\n\n\trequestAnimationFrame( animate );\n\n\t// step the animation forward\n\tconst delta = Math.min( clock.getDelta(), 30 * 0.001 );\n\tmixer.update( delta );\n\n\tif ( params.autoPause ) {\n\n\t\t// auto pause the animation\n\t\tcounter += delta;\n\t\tif ( ! params.pause && counter >= 2.5 || params.pause && counter >= 5 ) {\n\n\t\t\tsetPause( ! params.pause );\n\t\t\tcounter = 0;\n\n\t\t}\n\n\t} else {\n\n\t\tcounter = 0;\n\n\t}\n\n\tpathTracer.dynamicLowRes = params.continuous;\n\n\tif ( ! params.pause && ! params.continuous ) {\n\n\t\trenderer.render( scene, camera );\n\t\tloader.setSamples( 0, pathTracer.isCompiling );\n\n\t} else {\n\n\t\t// if we're continuously path tracing then update the scene\n\t\tif ( ! params.pause && params.continuous ) {\n\n\t\t\tregenerateScene();\n\n\t\t}\n\n\t\tpathTracer.renderSample();\n\t\tloader.setSamples( pathTracer.samples, pathTracer.isCompiling );\n\n\t}\n\n}\n"],"names":["$f06a0a82aa9331ef$var$pathTracer","$f06a0a82aa9331ef$var$renderer","$f06a0a82aa9331ef$var$controls","$f06a0a82aa9331ef$var$camera","$f06a0a82aa9331ef$var$scene","$f06a0a82aa9331ef$var$clock","$f06a0a82aa9331ef$var$mixer","$f06a0a82aa9331ef$var$mixerAction","$f06a0a82aa9331ef$var$loader","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$ac13547279de9cd0$export$13ef63fd7e562136","$ilwiq","$RPVlj","$9fZ6X","$dUUQZ","$ac13547279de9cd0$var$PMREMCopyMaterial","MaterialBase","constructor","uniforms","envMap","value","blur","vertexShader","fragmentShader","util_functions","renderer","pmremGenerator","PMREMGenerator","copyQuad","FullScreenQuad","renderTarget","WebGLRenderTarget","type","FloatType","format","RGBAFormat","dispose","generate","texture","pmremTarget","fromEquirectangular","width","height","image","setSize","material","prevRenderTarget","getRenderTarget","prevClear","autoClear","setRenderTarget","render","buffer","Uint16Array","readBuffer","Float32Array","readRenderTargetPixels","i","l","length","DataUtils","toHalfFloat","result","DataTexture","HalfFloatType","minFilter","magFilter","wrapS","wrapT","mapping","EquirectangularReflectionMapping","needsUpdate","$6bd4eb2914ee2835$export$f1ac3a587b6cbb5d","ShaderMaterial","dispatchEvent","shader","key","setDefine","name","defines","$a21c9b4177584031$export$fe1d788deccfbee3","$5ee05658f4b0e3bf$export$d076a711b55c758a","DataTextureLoader","manager","parse","data","numElements","rgbe_error","rgbe_error_code","msg","fgets","lineLimit","consume","p","pos","len","chunk","String","fromCharCode","apply","subarray","indexOf","byteLength","slice","byteArray","Uint8Array","rgbe_header_info","RGBE_ReadHeader","line","match","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","gamma","exposure","charAt","parseFloat","parseInt","w","h","image_rgba_data","RGBE_ReadPixels_RLE","scanline_width","data_rgba","offset","ptr_end","rgbeStart","scanline_buffer","num_scanlines","ptr","count","isEncodedRun","byteValue","off","floatArray","j","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","scale","Math","pow","halfArray","RGBEByteToRGBHalf","min","setDataType","load","url","onLoad","onProgress","onError","texData","colorSpace","LinearSRGBColorSpace","LinearFilter","generateMipmaps","flipY","$13343f7d1c4dd8ec$export$92750171fb06fc99","dim","x","y","a","max","sqrt","xCent","xNorm","yCent","yNorm","tex","UnsignedByteType","RepeatWrapping","$934d596524c3e5a8$export$5bc756cb1c628b75","tiles","renderScale","window","devicePixelRatio","innerWidth","innerHeight","$a399336cf50451da$var$_styleElement","$a399336cf50451da$export$c2252eb3bc5ad0b7","document","createElement","textContent","head","appendChild","container","classList","add","percentageEl","samplesEl","creditsEl","loaderBarEl","descriptionEl","_description","_loaderBar","_percentage","_credits","_samples","_container","setPercentage","attach","perc","style","innerText","toFixed","remove","setSamples","compiling","floor","setCredits","credits","innerHTML","setDescription","description","$ba14a4aaa0cde19b$export$98323a006d35be35","$60fb6dc3c6495c33$export$4c711108e2e8ef5e","$7lx9d","$5Rd1x","$eLX8K","$8mHfG","$891vQ","$kp7Te","$jiuw3","$1EdOY","$cE5k3","$e2Pv4","$f06a0a82aa9331ef$var$counter","$f06a0a82aa9331ef$var$params","bounces","samplesPerFrame","autoPause","pause","continuous","stableNoise","getScaledSettings","$f06a0a82aa9331ef$var$setPause","paused","$f06a0a82aa9331ef$var$regenerateScene","$f06a0a82aa9331ef$var$onResize","setPixelRatio","aspect","updateProjectionMatrix","updateCamera","setScene","$f06a0a82aa9331ef$var$init","LoaderElement","body","WebGLRenderer","antialias","toneMapping","ACESFilmicToneMapping","domElement","WebGLPathTracer","multipleImportanceSampling","filterGlossyFactor","minSamples","renderDelay","fadeDuration","Scene","PerspectiveCamera","position","OrbitControls","lookAt","target","addEventListener","update","Clock","modelUrl","location","hash","envTexture","gltf","Promise","all","RGBELoader","loadAsync","GLTFLoader","setMeshoptDecoder","MeshoptDecoder","generator","BlurredEnvMapGenerator","blurredTex","background","environment","animations","AnimationMixer","scene","clipAction","play","floorTex","generateRadialFloorTexture","floorPlane","Mesh","PlaneGeometry","MeshStandardMaterial","map","transparent","color","roughness","metalness","setScalar","rotation","PI","gui","GUI","onChange","reset","listen","$f06a0a82aa9331ef$var$animate","requestAnimationFrame","delta","getDelta","dynamicLowRes","renderSample","samples","isCompiling"],"version":3,"file":"skinnedMesh.49d8c0b2.js.map"}