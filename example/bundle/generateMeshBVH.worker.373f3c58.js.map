{"mappings":"I,E,E,E,E,E,E,E,C,E,E,C,E,O,E,C,E,Y,iB,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,E,Q,C,c,wC,E,E,S,E,E,SCMA,UAAY,CAAE,CAAA,KAAE,CAAI,CAAE,IAErB,IAAI,EAAW,YAAY,GAAG,GAuBxB,CAAA,MAAE,CAAK,CAAA,SAAE,CAAQ,CAAA,QAAE,CAAO,CAAE,CAAG,EACrC,GAAI,CAEH,IAAM,EAAW,IAAI,EAAA,cAAa,CAclC,GAbA,EAAS,YAAY,CAAE,WAAY,IAAI,EAAA,eAAc,CAAG,EAAU,EAAG,CAAA,IAChE,GAEJ,EAAS,QAAQ,CAAE,IAAI,EAAA,eAAc,CAAG,EAAO,EAAG,CAAA,IAI9C,EAAQ,wBAAwB,EAEpC,CAAA,EAAQ,UAAU,CAnCpB,SAA6B,CAAQ,EAGpC,EAAW,KAAK,GAAG,CAAE,EAAU,GAE/B,IAAM,EAAW,YAAY,GAAG,GAC3B,EAAW,GAAY,IAAM,AAAa,IAAb,IAEjC,YAAa,CAEZ,MAAO,KACP,WAAY,KACZ,SAAU,KACV,SAAA,CAED,GACA,EAAW,EAIb,CAaC,EAMK,EAAQ,MAAM,CAAG,CAErB,IAAM,EAAS,EAAQ,MAAM,CAC7B,IAAM,IAAM,KAAK,EAAS,CAEzB,IAAM,EAAQ,CAAM,CAAE,EAAG,CACzB,EAAS,QAAQ,CAAE,EAAM,KAAK,CAAE,EAAM,KAAK,CAAE,EAAM,aAAa,CAEjE,CAED,CAEA,IAAM,EAAM,IAAI,EAAA,OAAM,CAAG,EAAU,GAC7B,EAAa,AAAA,CAAA,EAAA,EAAA,OAAM,AAAN,EAAQ,SAAS,CAAE,EAAK,CAAE,gBAAiB,CAAA,CAAM,GAChE,EAAa,CAAE,EAAS,MAAM,IAAK,EAAW,KAAK,CAAE,AACpD,CAAA,EAAW,KAAK,EAEpB,EAAW,IAAI,CAAE,EAAW,KAAK,CAAC,MAAM,EAIzC,EAAa,EAAW,MAAM,CAAE,AAAA,GAAO,AAA6B,aAA7B,OAAO,mBAAuC,CAAI,CAAA,aAAa,iBAAA,GAEjG,EAAI,eAAe,EAEvB,EAAW,IAAI,CAAE,EAAW,cAAc,CAAC,MAAM,EAIlD,YAAa,CAEZ,MAAO,KACP,WAAA,EACA,SAAA,EACA,SAAU,CAEX,EAAG,EAEJ,CAAE,MAAQ,EAAQ,CAEjB,YAAa,CAEZ,MAAA,EACA,WAAY,KACZ,SAAU,KACV,SAAU,CAEX,EAED,CAED","sources":["<anon>","node_modules/three-mesh-bvh/src/workers/generateMeshBVH.worker.js"],"sourcesContent":["(() => {\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5b70\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5b70\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nimportScripts(\"./generateMeshBVH.worker.cd4b9fc6.js\");\nvar $ce42ceb4f4596adb$exports = {};\n\nvar $e06gU = parcelRequire(\"e06gU\");\n\nvar $i1Cyt = parcelRequire(\"i1Cyt\");\nonmessage = ({ data: data })=>{\n    let prevTime = performance.now();\n    function onProgressCallback(progress) {\n        // account for error\n        progress = Math.min(progress, 1);\n        const currTime = performance.now();\n        if (currTime - prevTime >= 10 && progress !== 1.0) {\n            postMessage({\n                error: null,\n                serialized: null,\n                position: null,\n                progress: progress\n            });\n            prevTime = currTime;\n        }\n    }\n    const { index: index, position: position, options: options } = data;\n    try {\n        const geometry = new (0, $e06gU.BufferGeometry)();\n        geometry.setAttribute(\"position\", new (0, $e06gU.BufferAttribute)(position, 3, false));\n        if (index) geometry.setIndex(new (0, $e06gU.BufferAttribute)(index, 1, false));\n        if (options.includedProgressCallback) options.onProgress = onProgressCallback;\n        if (options.groups) {\n            const groups = options.groups;\n            for(const i in groups){\n                const group = groups[i];\n                geometry.addGroup(group.start, group.count, group.materialIndex);\n            }\n        }\n        const bvh = new (0, $i1Cyt.MeshBVH)(geometry, options);\n        const serialized = (0, $i1Cyt.MeshBVH).serialize(bvh, {\n            copyIndexBuffer: false\n        });\n        let toTransfer = [\n            position.buffer,\n            ...serialized.roots\n        ];\n        if (serialized.index) toTransfer.push(serialized.index.buffer);\n        toTransfer = toTransfer.filter((v)=>typeof SharedArrayBuffer === \"undefined\" || !(v instanceof SharedArrayBuffer));\n        if (bvh._indirectBuffer) toTransfer.push(serialized.indirectBuffer.buffer);\n        postMessage({\n            error: null,\n            serialized: serialized,\n            position: position,\n            progress: 1\n        }, toTransfer);\n    } catch (error) {\n        postMessage({\n            error: error,\n            serialized: null,\n            position: null,\n            progress: 1\n        });\n    }\n};\n\n})();\n//# sourceMappingURL=generateMeshBVH.worker.373f3c58.js.map\n","import {\n\tBufferGeometry,\n\tBufferAttribute,\n} from 'three';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nonmessage = ( { data } ) => {\n\n\tlet prevTime = performance.now();\n\tfunction onProgressCallback( progress ) {\n\n\t\t// account for error\n\t\tprogress = Math.min( progress, 1 );\n\n\t\tconst currTime = performance.now();\n\t\tif ( currTime - prevTime >= 10 && progress !== 1.0 ) {\n\n\t\t\tpostMessage( {\n\n\t\t\t\terror: null,\n\t\t\t\tserialized: null,\n\t\t\t\tposition: null,\n\t\t\t\tprogress,\n\n\t\t\t} );\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t}\n\n\tconst { index, position, options } = data;\n\ttry {\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( position, 3, false ) );\n\t\tif ( index ) {\n\n\t\t\tgeometry.setIndex( new BufferAttribute( index, 1, false ) );\n\n\t\t}\n\n\t\tif ( options.includedProgressCallback ) {\n\n\t\t\toptions.onProgress = onProgressCallback;\n\n\t\t}\n\n\t\tif ( options.groups ) {\n\n\t\t\tconst groups = options.groups;\n\t\t\tfor ( const i in groups ) {\n\n\t\t\t\tconst group = groups[ i ];\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bvh = new MeshBVH( geometry, options );\n\t\tconst serialized = MeshBVH.serialize( bvh, { copyIndexBuffer: false } );\n\t\tlet toTransfer = [ position.buffer, ...serialized.roots ];\n\t\tif ( serialized.index ) {\n\n\t\t\ttoTransfer.push( serialized.index.buffer );\n\n\t\t}\n\n\t\ttoTransfer = toTransfer.filter( v => ( typeof SharedArrayBuffer === 'undefined' ) || ! ( v instanceof SharedArrayBuffer ) );\n\n\t\tif ( bvh._indirectBuffer ) {\n\n\t\t\ttoTransfer.push( serialized.indirectBuffer.buffer );\n\n\t\t}\n\n\t\tpostMessage( {\n\n\t\t\terror: null,\n\t\t\tserialized,\n\t\t\tposition,\n\t\t\tprogress: 1,\n\n\t\t}, toTransfer );\n\n\t} catch ( error ) {\n\n\t\tpostMessage( {\n\n\t\t\terror,\n\t\t\tserialized: null,\n\t\t\tposition: null,\n\t\t\tprogress: 1,\n\n\t\t} );\n\n\t}\n\n};\n"],"names":["$parcel$global","$parcel$modules","$parcel$inits","parcelRequire","$e06gU","$i1Cyt","globalThis","id","exports","init","module","call","err","Error","code","register","importScripts","onmessage","data","prevTime","performance","now","index","position","options","geometry","BufferGeometry","setAttribute","BufferAttribute","setIndex","includedProgressCallback","onProgress","progress","Math","min","currTime","postMessage","error","serialized","groups","i","group","addGroup","start","count","materialIndex","bvh","MeshBVH","serialize","copyIndexBuffer","toTransfer","buffer","roots","push","filter","v","SharedArrayBuffer","_indirectBuffer","indirectBuffer"],"version":3,"file":"generateMeshBVH.worker.373f3c58.js.map"}