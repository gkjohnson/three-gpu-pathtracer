{"mappings":"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","sources":["<anon>","node_modules/three-mesh-bvh/src/workers/parallelMeshBVH.worker.js","node_modules/three-mesh-bvh/src/workers/utils/WorkerPool.js","node_modules/@parcel/runtime-js/lib/runtime-b0ec6b9b11706c85.js","node_modules/@parcel/runtime-js/lib/helpers/get-worker-url.js","node_modules/@parcel/runtime-js/lib/helpers/bundle-url.js"],"sourcesContent":["(() => {\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5b70\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5b70\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nimportScripts(\"./generateMeshBVH.worker.cd4b9fc6.js\");\nvar $6e027ea0dcb28b31$exports = {};\n\nvar $e06gU = parcelRequire(\"e06gU\");\nclass $e8bf59bd281c1ceb$export$ddf9e847a113aa9c {\n    get workerCount() {\n        return this.workers.length;\n    }\n    constructor(getWorkerCallback){\n        this.workers = [];\n        this._getWorker = getWorkerCallback;\n    }\n    setWorkerCount(count) {\n        const workers = this.workers;\n        while(workers.length < count)workers.push(this._getWorker());\n        while(workers.length > count)workers.pop().terminate();\n    }\n    runSubTask(i, msg, onProgress) {\n        return new Promise((resolve, reject)=>{\n            const worker = this.workers[i];\n            if (worker.isRunning) throw new Error(`${this.name}: Worker ${i} is already running.`);\n            worker.isRunning = true;\n            worker.postMessage(msg);\n            worker.onerror = (e)=>{\n                worker.isRunning = false;\n                reject(e);\n            };\n            worker.onmessage = (e)=>{\n                if (e.data.type === \"progress\") {\n                    if (onProgress) onProgress(e.data.progress);\n                } else {\n                    if (onProgress) onProgress(1);\n                    worker.isRunning = false;\n                    resolve(e.data);\n                }\n            };\n        });\n    }\n}\n\n\n\nvar $gbfhP = parcelRequire(\"gbfhP\");\n\nvar $2lzJi = parcelRequire(\"2lzJi\");\n\nvar $271LZ = parcelRequire(\"271LZ\");\n\nvar $lxFhA = parcelRequire(\"lxFhA\");\n\nvar $6Y4FX = parcelRequire(\"6Y4FX\");\n\nvar $i1Cyt = parcelRequire(\"i1Cyt\");\nlet $6e027ea0dcb28b31$var$isRunning = false;\nlet $6e027ea0dcb28b31$var$prevTime = 0;\nvar $bb6982409d887d89$exports = {};\nvar $5cecff4549b14899$exports = {};\n\"use strict\";\n$5cecff4549b14899$exports = function(workerUrl, origin, isESM) {\n    if (origin === self.location.origin) // If the worker bundle's url is on the same origin as the document,\n    // use the worker bundle's own url.\n    return workerUrl;\n    else {\n        // Otherwise, create a blob URL which loads the worker bundle with `importScripts`.\n        var source = isESM ? \"import \" + JSON.stringify(workerUrl) + \";\" : \"importScripts(\" + JSON.stringify(workerUrl) + \");\";\n        return URL.createObjectURL(new Blob([\n            source\n        ], {\n            type: \"application/javascript\"\n        }));\n    }\n};\n\n\nvar $01a32f7bf710fe19$export$bdfd709ae4826697;\nvar $01a32f7bf710fe19$export$c9e73fbda7da57b6;\nvar $01a32f7bf710fe19$export$5a759dc7a1cfb72a;\n\"use strict\";\nvar $01a32f7bf710fe19$var$bundleURL = {};\nfunction $01a32f7bf710fe19$var$getBundleURLCached(id) {\n    var value = $01a32f7bf710fe19$var$bundleURL[id];\n    if (!value) {\n        value = $01a32f7bf710fe19$var$getBundleURL();\n        $01a32f7bf710fe19$var$bundleURL[id] = value;\n    }\n    return value;\n}\nfunction $01a32f7bf710fe19$var$getBundleURL() {\n    try {\n        throw new Error();\n    } catch (err) {\n        var matches = (\"\" + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/[^)\\n]+/g);\n        if (matches) // The first two stack frames will be this function and getBundleURLCached.\n        // Use the 3rd one, which will be a runtime in the original bundle.\n        return $01a32f7bf710fe19$var$getBaseURL(matches[2]);\n    }\n    return \"/\";\n}\nfunction $01a32f7bf710fe19$var$getBaseURL(url) {\n    return (\"\" + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/.+)\\/[^/]+$/, \"$1\") + \"/\";\n}\n// TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.\nfunction $01a32f7bf710fe19$var$getOrigin(url) {\n    var matches = (\"\" + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/[^/]+/);\n    if (!matches) throw new Error(\"Origin not found\");\n    return matches[0];\n}\n$01a32f7bf710fe19$export$bdfd709ae4826697 = $01a32f7bf710fe19$var$getBundleURLCached;\n$01a32f7bf710fe19$export$c9e73fbda7da57b6 = $01a32f7bf710fe19$var$getBaseURL;\n$01a32f7bf710fe19$export$5a759dc7a1cfb72a = $01a32f7bf710fe19$var$getOrigin;\n\n\nlet $bb6982409d887d89$var$url = $01a32f7bf710fe19$export$bdfd709ae4826697(\"512E4\") + \"parallelMeshBVH.worker.22cf4bb0.js\";\n$bb6982409d887d89$exports = $5cecff4549b14899$exports($bb6982409d887d89$var$url, $01a32f7bf710fe19$export$5a759dc7a1cfb72a($bb6982409d887d89$var$url), false);\n\n\nconst $6e027ea0dcb28b31$var$workerPool = new (0, $e8bf59bd281c1ceb$export$ddf9e847a113aa9c)(()=>new Worker($bb6982409d887d89$exports));\nonmessage = async ({ data: data })=>{\n    if ($6e027ea0dcb28b31$var$isRunning) throw new Error(\"Worker is already running a task.\");\n    const { operation: operation } = data;\n    if (operation === \"BUILD_BVH\") {\n        $6e027ea0dcb28b31$var$isRunning = true;\n        const { maxWorkerCount: maxWorkerCount, index: index, position: position, options: options } = data;\n        // initialize the number of workers balanced for a binary tree\n        $6e027ea0dcb28b31$var$workerPool.setWorkerCount((0, $e06gU.MathUtils).floorPowerOfTwo(maxWorkerCount));\n        // generate necessary buffers and objects\n        const geometry = $6e027ea0dcb28b31$var$getGeometry(index, position);\n        const geometryRanges = options.indirect ? (0, $6Y4FX.getFullGeometryRange)(geometry) : (0, $6Y4FX.getRootIndexRanges)(geometry);\n        const indirectBuffer = options.indirect ? (0, $2lzJi.generateIndirectBuffer)(geometry, true) : null;\n        const triCount = (0, $6Y4FX.getTriCount)(geometry);\n        const triangleBounds = new Float32Array(new SharedArrayBuffer(triCount * 24));\n        // generate portions of the triangle bounds buffer over multiple frames\n        const boundsPromises = [];\n        for(let i = 0, l = $6e027ea0dcb28b31$var$workerPool.workerCount; i < l; i++){\n            const countPerWorker = Math.ceil(triCount / l);\n            const offset = i * countPerWorker;\n            const count = Math.min(countPerWorker, triCount - offset);\n            boundsPromises.push($6e027ea0dcb28b31$var$workerPool.runSubTask(i, {\n                operation: \"BUILD_TRIANGLE_BOUNDS\",\n                offset: offset,\n                count: count,\n                index: index,\n                position: position,\n                triangleBounds: triangleBounds\n            }));\n        }\n        await Promise.all(boundsPromises);\n        // create a proxy bvh structure\n        const proxyBvh = {\n            _indirectBuffer: indirectBuffer,\n            geometry: geometry\n        };\n        let totalProgress = 0;\n        const localOptions = {\n            ...(0, $i1Cyt.DEFAULT_OPTIONS),\n            ...options,\n            verbose: false,\n            maxDepth: Math.round(Math.log2($6e027ea0dcb28b31$var$workerPool.workerCount)),\n            onProgress: options.includedProgressCallback ? $6e027ea0dcb28b31$var$getOnProgressDeltaCallback((delta)=>{\n                totalProgress += 0.1 * delta;\n                $6e027ea0dcb28b31$var$triggerOnProgress(totalProgress);\n            }) : null\n        };\n        // generate the ranges for all roots asynchronously\n        const packedRoots = [];\n        for(let i = 0, l = geometryRanges.length; i < l; i++){\n            // build the tree down to the necessary depth\n            const promises = [];\n            const range = geometryRanges[i];\n            const root = (0, $2lzJi.buildTree)(proxyBvh, triangleBounds, range.offset, range.count, localOptions);\n            const flatNodes = $6e027ea0dcb28b31$var$flattenNodes(root);\n            let bufferLengths = 0;\n            let remainingNodes = 0;\n            let nextWorker = 0;\n            // trigger workers for each generated leaf node\n            for(let j = 0, l = flatNodes.length; j < l; j++){\n                const node = flatNodes[j];\n                const isLeaf = Boolean(node.count);\n                if (isLeaf) {\n                    // adjust the maxDepth to account for the depth we've already traversed\n                    const workerOptions = {\n                        ...(0, $i1Cyt.DEFAULT_OPTIONS),\n                        ...options\n                    };\n                    workerOptions.maxDepth = workerOptions.maxDepth - node.depth;\n                    const pr = $6e027ea0dcb28b31$var$workerPool.runSubTask(nextWorker++, {\n                        operation: \"BUILD_SUBTREE\",\n                        offset: node.offset,\n                        count: node.count,\n                        indirectBuffer: indirectBuffer,\n                        index: index,\n                        position: position,\n                        triangleBounds: triangleBounds,\n                        options: workerOptions\n                    }, $6e027ea0dcb28b31$var$getOnProgressDeltaCallback((delta)=>{\n                        totalProgress += 0.9 * delta / nextWorker;\n                        $6e027ea0dcb28b31$var$triggerOnProgress(totalProgress);\n                    })).then((data)=>{\n                        const buffer = data.buffer;\n                        node.buffer = buffer;\n                        bufferLengths += buffer.byteLength;\n                    });\n                    promises.push(pr);\n                } else remainingNodes++;\n            }\n            // wait for the sub trees to complete\n            await Promise.all(promises);\n            const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n            const buffer = new BufferConstructor(bufferLengths + remainingNodes * (0, $gbfhP.BYTES_PER_NODE));\n            (0, $271LZ.populateBuffer)(0, root, buffer);\n            packedRoots.push(buffer);\n        }\n        // transfer the data back\n        postMessage({\n            error: null,\n            serialized: {\n                roots: packedRoots,\n                index: index,\n                indirectBuffer: indirectBuffer\n            },\n            position: position,\n            progress: 1\n        });\n        $6e027ea0dcb28b31$var$isRunning = false;\n    } else if (operation === \"BUILD_SUBTREE\") {\n        const { offset: offset, count: count, indirectBuffer: indirectBuffer, index: index, position: position, triangleBounds: triangleBounds, options: options } = data;\n        const proxyBvh = {\n            _indirectBuffer: indirectBuffer,\n            geometry: $6e027ea0dcb28b31$var$getGeometry(index, position)\n        };\n        const localOptions = {\n            ...(0, $i1Cyt.DEFAULT_OPTIONS),\n            ...options,\n            onProgress: options.includedProgressCallback ? $6e027ea0dcb28b31$var$triggerOnProgress : null\n        };\n        const root = (0, $2lzJi.buildTree)(proxyBvh, triangleBounds, offset, count, localOptions);\n        const nodeCount = (0, $271LZ.countNodes)(root);\n        const buffer = new ArrayBuffer((0, $gbfhP.BYTES_PER_NODE) * nodeCount);\n        (0, $271LZ.populateBuffer)(0, root, buffer);\n        postMessage({\n            type: \"result\",\n            buffer: buffer,\n            progress: 1\n        }, [\n            buffer\n        ]);\n    } else if (operation === \"BUILD_TRIANGLE_BOUNDS\") {\n        const { index: index, position: position, triangleBounds: triangleBounds, offset: offset, count: count } = data;\n        const geometry = $6e027ea0dcb28b31$var$getGeometry(index, position);\n        (0, $lxFhA.computeTriangleBounds)(geometry, triangleBounds, offset, count);\n        postMessage({\n            type: \"result\"\n        });\n    } else if (operation === \"REFIT\") ;\n    else operation;\n};\n// Helper functions and utils\nfunction $6e027ea0dcb28b31$var$getOnProgressDeltaCallback(cb) {\n    let lastProgress = 0;\n    return function onProgressDeltaCallback(progress) {\n        cb(progress - lastProgress);\n        lastProgress = progress;\n    };\n}\nfunction $6e027ea0dcb28b31$var$triggerOnProgress(progress) {\n    // account for error\n    progress = Math.min(progress, 1);\n    const currTime = performance.now();\n    if (currTime - $6e027ea0dcb28b31$var$prevTime >= 10 && progress !== 1.0) {\n        postMessage({\n            error: null,\n            progress: progress,\n            type: \"progress\"\n        });\n        $6e027ea0dcb28b31$var$prevTime = currTime;\n    }\n}\nfunction $6e027ea0dcb28b31$var$getGeometry(index, position) {\n    const geometry = new (0, $e06gU.BufferGeometry)();\n    if (index) geometry.index = new (0, $e06gU.BufferAttribute)(index, 1, false);\n    geometry.setAttribute(\"position\", new (0, $e06gU.BufferAttribute)(position, 3));\n    return geometry;\n}\nfunction $6e027ea0dcb28b31$var$flattenNodes(node) {\n    const arr = [];\n    traverse(node);\n    return arr;\n    function traverse(node, depth = 0) {\n        node.depth = depth;\n        arr.push(node);\n        const isLeaf = Boolean(node.count);\n        if (!isLeaf) {\n            traverse(node.left, depth + 1);\n            traverse(node.right, depth + 1);\n        }\n    }\n}\n\n})();\n//# sourceMappingURL=parallelMeshBVH.worker.22cf4bb0.js.map\n","import { MathUtils, BufferGeometry, BufferAttribute } from 'three';\nimport { WorkerPool } from './utils/WorkerPool.js';\nimport { BYTES_PER_NODE } from '../core/Constants.js';\nimport { buildTree, generateIndirectBuffer } from '../core/build/buildTree.js';\nimport { countNodes, populateBuffer } from '../core/build/buildUtils.js';\nimport { computeTriangleBounds } from '../core/build/computeBoundsUtils.js';\nimport { getFullGeometryRange, getRootIndexRanges, getTriCount } from '../core/build/geometryUtils.js';\nimport { DEFAULT_OPTIONS } from '../core/MeshBVH.js';\n\nlet isRunning = false;\nlet prevTime = 0;\nconst workerPool = new WorkerPool( () => new Worker( new URL( './parallelMeshBVH.worker.js', import.meta.url ), { type: 'module' } ) );\n\nonmessage = async ( { data } ) => {\n\n\tif ( isRunning ) {\n\n\t\tthrow new Error( 'Worker is already running a task.' );\n\n\t}\n\n\tconst { operation } = data;\n\tif ( operation === 'BUILD_BVH' ) {\n\n\t\tisRunning = true;\n\n\t\tconst {\n\t\t\tmaxWorkerCount,\n\t\t\tindex,\n\t\t\tposition,\n\t\t\toptions,\n\t\t} = data;\n\n\t\t// initialize the number of workers balanced for a binary tree\n\t\tworkerPool.setWorkerCount( MathUtils.floorPowerOfTwo( maxWorkerCount ) );\n\n\t\t// generate necessary buffers and objects\n\t\tconst geometry = getGeometry( index, position );\n\t\tconst geometryRanges = options.indirect ? getFullGeometryRange( geometry ) : getRootIndexRanges( geometry );\n\t\tconst indirectBuffer = options.indirect ? generateIndirectBuffer( geometry, true ) : null;\n\t\tconst triCount = getTriCount( geometry );\n\t\tconst triangleBounds = new Float32Array( new SharedArrayBuffer( triCount * 6 * 4 ) );\n\n\t\t// generate portions of the triangle bounds buffer over multiple frames\n\t\tconst boundsPromises = [];\n\t\tfor ( let i = 0, l = workerPool.workerCount; i < l; i ++ ) {\n\n\t\t\tconst countPerWorker = Math.ceil( triCount / l );\n\t\t\tconst offset = i * countPerWorker;\n\t\t\tconst count = Math.min( countPerWorker, triCount - offset );\n\n\t\t\tboundsPromises.push( workerPool.runSubTask(\n\t\t\t\ti,\n\t\t\t\t{\n\t\t\t\t\toperation: 'BUILD_TRIANGLE_BOUNDS',\n\t\t\t\t\toffset,\n\t\t\t\t\tcount,\n\t\t\t\t\tindex,\n\t\t\t\t\tposition,\n\t\t\t\t\ttriangleBounds,\n\t\t\t\t}\n\t\t\t) );\n\n\t\t}\n\n\t\tawait Promise.all( boundsPromises );\n\n\t\t// create a proxy bvh structure\n\t\tconst proxyBvh = {\n\t\t\t_indirectBuffer: indirectBuffer,\n\t\t\tgeometry: geometry,\n\t\t};\n\n\t\tlet totalProgress = 0;\n\n\t\tconst localOptions = {\n\t\t\t...DEFAULT_OPTIONS,\n\t\t\t...options,\n\t\t\tverbose: false,\n\t\t\tmaxDepth: Math.round( Math.log2( workerPool.workerCount ) ),\n\t\t\tonProgress: options.includedProgressCallback ?\n\t\t\t\tgetOnProgressDeltaCallback( delta => {\n\n\t\t\t\t\ttotalProgress += 0.1 * delta;\n\t\t\t\t\ttriggerOnProgress( totalProgress );\n\n\t\t\t\t} ) :\n\t\t\t\tnull,\n\t\t};\n\n\t\t// generate the ranges for all roots asynchronously\n\t\tconst packedRoots = [];\n\t\tfor ( let i = 0, l = geometryRanges.length; i < l; i ++ ) {\n\n\t\t\t// build the tree down to the necessary depth\n\t\t\tconst promises = [];\n\t\t\tconst range = geometryRanges[ i ];\n\t\t\tconst root = buildTree( proxyBvh, triangleBounds, range.offset, range.count, localOptions );\n\t\t\tconst flatNodes = flattenNodes( root );\n\t\t\tlet bufferLengths = 0;\n\t\t\tlet remainingNodes = 0;\n\t\t\tlet nextWorker = 0;\n\n\t\t\t// trigger workers for each generated leaf node\n\t\t\tfor ( let j = 0, l = flatNodes.length; j < l; j ++ ) {\n\n\t\t\t\tconst node = flatNodes[ j ];\n\t\t\t\tconst isLeaf = Boolean( node.count );\n\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t// adjust the maxDepth to account for the depth we've already traversed\n\t\t\t\t\tconst workerOptions = {\n\t\t\t\t\t\t...DEFAULT_OPTIONS,\n\t\t\t\t\t\t...options\n\t\t\t\t\t};\n\n\t\t\t\t\tworkerOptions.maxDepth = workerOptions.maxDepth - node.depth;\n\n\t\t\t\t\tconst pr = workerPool.runSubTask(\n\t\t\t\t\t\tnextWorker ++,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toperation: 'BUILD_SUBTREE',\n\t\t\t\t\t\t\toffset: node.offset,\n\t\t\t\t\t\t\tcount: node.count,\n\t\t\t\t\t\t\tindirectBuffer,\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\tposition,\n\t\t\t\t\t\t\ttriangleBounds,\n\t\t\t\t\t\t\toptions: workerOptions,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tgetOnProgressDeltaCallback( delta => {\n\n\t\t\t\t\t\t\ttotalProgress += 0.9 * delta / nextWorker;\n\t\t\t\t\t\t\ttriggerOnProgress( totalProgress );\n\n\t\t\t\t\t\t} ),\n\t\t\t\t\t).then( data => {\n\n\t\t\t\t\t\tconst buffer = data.buffer;\n\t\t\t\t\t\tnode.buffer = buffer;\n\t\t\t\t\t\tbufferLengths += buffer.byteLength;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tpromises.push( pr );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tremainingNodes ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// wait for the sub trees to complete\n\t\t\tawait Promise.all( promises );\n\n\t\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\t\tconst buffer = new BufferConstructor( bufferLengths + remainingNodes * BYTES_PER_NODE );\n\t\t\tpopulateBuffer( 0, root, buffer );\n\n\t\t\tpackedRoots.push( buffer );\n\n\t\t}\n\n\t\t// transfer the data back\n\t\tpostMessage( {\n\t\t\terror: null,\n\t\t\tserialized: {\n\t\t\t\troots: packedRoots,\n\t\t\t\tindex: index,\n\t\t\t\tindirectBuffer: indirectBuffer,\n\t\t\t},\n\t\t\tposition,\n\t\t\tprogress: 1,\n\t\t} );\n\n\t\tisRunning = false;\n\n\t} else if ( operation === 'BUILD_SUBTREE' ) {\n\n\t\tconst {\n\t\t\toffset,\n\t\t\tcount,\n\t\t\tindirectBuffer,\n\t\t\tindex,\n\t\t\tposition,\n\t\t\ttriangleBounds,\n\t\t\toptions,\n\t\t} = data;\n\n\t\tconst proxyBvh = {\n\t\t\t_indirectBuffer: indirectBuffer,\n\t\t\tgeometry: getGeometry( index, position ),\n\t\t};\n\n\t\tconst localOptions = {\n\t\t\t...DEFAULT_OPTIONS,\n\t\t\t...options,\n\t\t\tonProgress: options.includedProgressCallback ? triggerOnProgress : null,\n\t\t};\n\n\t\tconst root = buildTree( proxyBvh, triangleBounds, offset, count, localOptions );\n\t\tconst nodeCount = countNodes( root );\n\t\tconst buffer = new ArrayBuffer( BYTES_PER_NODE * nodeCount );\n\t\tpopulateBuffer( 0, root, buffer );\n\t\tpostMessage( { type: 'result', buffer, progress: 1 }, [ buffer ] );\n\n\t} else if ( operation === 'BUILD_TRIANGLE_BOUNDS' ) {\n\n\t\tconst {\n\t\t\tindex,\n\t\t\tposition,\n\t\t\ttriangleBounds,\n\t\t\toffset,\n\t\t\tcount,\n\t\t} = data;\n\n\t\tconst geometry = getGeometry( index, position );\n\t\tcomputeTriangleBounds( geometry, triangleBounds, offset, count );\n\t\tpostMessage( { type: 'result' } );\n\n\t} else if ( operation === 'REFIT' ) {\n\n\t\t// TODO\n\n\t} else if ( operation === 'REFIT_SUBTREE' ) {\n\n\t\t// TODO\n\n\t}\n\n};\n\n// Helper functions and utils\nfunction getOnProgressDeltaCallback( cb ) {\n\n\tlet lastProgress = 0;\n\treturn function onProgressDeltaCallback( progress ) {\n\n\t\tcb( progress - lastProgress );\n\t\tlastProgress = progress;\n\n\t};\n\n}\n\nfunction triggerOnProgress( progress ) {\n\n\t// account for error\n\tprogress = Math.min( progress, 1 );\n\n\tconst currTime = performance.now();\n\tif ( currTime - prevTime >= 10 && progress !== 1.0 ) {\n\n\t\tpostMessage( {\n\n\t\t\terror: null,\n\t\t\tprogress,\n\t\t\ttype: 'progress'\n\n\t\t} );\n\t\tprevTime = currTime;\n\n\t}\n\n}\n\nfunction getGeometry( index, position ) {\n\n\tconst geometry = new BufferGeometry();\n\tif ( index ) {\n\n\t\tgeometry.index = new BufferAttribute( index, 1, false );\n\n\t}\n\n\tgeometry.setAttribute( 'position', new BufferAttribute( position, 3 ) );\n\treturn geometry;\n\n}\n\nfunction flattenNodes( node ) {\n\n\tconst arr = [];\n\ttraverse( node );\n\treturn arr;\n\n\tfunction traverse( node, depth = 0 ) {\n\n\t\tnode.depth = depth;\n\t\tarr.push( node );\n\n\t\tconst isLeaf = Boolean( node.count );\n\t\tif ( ! isLeaf ) {\n\n\t\t\ttraverse( node.left, depth + 1 );\n\t\t\ttraverse( node.right, depth + 1 );\n\n\t\t}\n\n\t}\n\n}\n","export class WorkerPool {\n\n\tget workerCount() {\n\n\t\treturn this.workers.length;\n\n\t}\n\n\tconstructor( getWorkerCallback ) {\n\n\t\tthis.workers = [];\n\t\tthis._getWorker = getWorkerCallback;\n\n\t}\n\n\tsetWorkerCount( count ) {\n\n\t\tconst workers = this.workers;\n\t\twhile ( workers.length < count ) {\n\n\t\t\tworkers.push( this._getWorker() );\n\n\t\t}\n\n\t\twhile ( workers.length > count ) {\n\n\t\t\tworkers.pop().terminate();\n\n\t\t}\n\n\t}\n\n\trunSubTask( i, msg, onProgress ) {\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tconst worker = this.workers[ i ];\n\t\t\tif ( worker.isRunning ) {\n\n\t\t\t\tthrow new Error( `${ this.name }: Worker ${ i } is already running.` );\n\n\t\t\t}\n\n\t\t\tworker.isRunning = true;\n\t\t\tworker.postMessage( msg );\n\t\t\tworker.onerror = e => {\n\n\t\t\t\tworker.isRunning = false;\n\t\t\t\treject( e );\n\n\t\t\t};\n\n\t\t\tworker.onmessage = e => {\n\n\t\t\t\tif ( e.data.type === 'progress' ) {\n\n\t\t\t\t\tif ( onProgress ) {\n\n\t\t\t\t\t\tonProgress( e.data.progress );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( onProgress ) {\n\n\t\t\t\t\t\tonProgress( 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tworker.isRunning = false;\n\t\t\t\t\tresolve( e.data );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t} );\n\n\t}\n\n}\n","let workerURL = require('./helpers/get-worker-url');\nlet bundleURL = require('./helpers/bundle-url');\nlet url = bundleURL.getBundleURL('512E4') + \"parallelMeshBVH.worker.22cf4bb0.js\";module.exports = workerURL(url, bundleURL.getOrigin(url), false);","\"use strict\";\n\nmodule.exports = function (workerUrl, origin, isESM) {\n  if (origin === self.location.origin) {\n    // If the worker bundle's url is on the same origin as the document,\n    // use the worker bundle's own url.\n    return workerUrl;\n  } else {\n    // Otherwise, create a blob URL which loads the worker bundle with `importScripts`.\n    var source = isESM ? 'import ' + JSON.stringify(workerUrl) + ';' : 'importScripts(' + JSON.stringify(workerUrl) + ');';\n    return URL.createObjectURL(new Blob([source], {\n      type: 'application/javascript'\n    }));\n  }\n};","\"use strict\";\n\nvar bundleURL = {};\nfunction getBundleURLCached(id) {\n  var value = bundleURL[id];\n  if (!value) {\n    value = getBundleURL();\n    bundleURL[id] = value;\n  }\n  return value;\n}\nfunction getBundleURL() {\n  try {\n    throw new Error();\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/[^)\\n]+/g);\n    if (matches) {\n      // The first two stack frames will be this function and getBundleURLCached.\n      // Use the 3rd one, which will be a runtime in the original bundle.\n      return getBaseURL(matches[2]);\n    }\n  }\n  return '/';\n}\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/.+)\\/[^/]+$/, '$1') + '/';\n}\n\n// TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.\nfunction getOrigin(url) {\n  var matches = ('' + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/[^/]+/);\n  if (!matches) {\n    throw new Error('Origin not found');\n  }\n  return matches[0];\n}\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\nexports.getOrigin = getOrigin;"],"names":["$01a32f7bf710fe19$export$bdfd709ae4826697","$01a32f7bf710fe19$export$5a759dc7a1cfb72a","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","importScripts","$e06gU","$gbfhP","$2lzJi","$271LZ","$lxFhA","$6Y4FX","$i1Cyt","$6e027ea0dcb28b31$var$isRunning","$6e027ea0dcb28b31$var$prevTime","$bb6982409d887d89$exports","$5cecff4549b14899$exports","workerUrl","origin","isESM","self","location","source","JSON","stringify","URL","createObjectURL","Blob","type","$01a32f7bf710fe19$var$bundleURL","value","$01a32f7bf710fe19$var$getBundleURL","matches","stack","match","replace","url","$bb6982409d887d89$var$url","$6e027ea0dcb28b31$var$workerPool","workerCount","workers","length","constructor","getWorkerCallback","_getWorker","setWorkerCount","count","push","pop","terminate","runSubTask","i","msg","onProgress","Promise","resolve","reject","worker","isRunning","name","postMessage","onerror","e","onmessage","data","progress","Worker","$6e027ea0dcb28b31$var$getOnProgressDeltaCallback","cb","lastProgress","$6e027ea0dcb28b31$var$triggerOnProgress","Math","min","currTime","performance","now","error","$6e027ea0dcb28b31$var$getGeometry","index","position","geometry","BufferGeometry","BufferAttribute","setAttribute","operation","maxWorkerCount","options","MathUtils","floorPowerOfTwo","geometryRanges","indirect","getFullGeometryRange","getRootIndexRanges","indirectBuffer","generateIndirectBuffer","triCount","getTriCount","triangleBounds","Float32Array","SharedArrayBuffer","boundsPromises","l","countPerWorker","ceil","offset","all","proxyBvh","_indirectBuffer","totalProgress","localOptions","DEFAULT_OPTIONS","verbose","maxDepth","round","log2","includedProgressCallback","delta","packedRoots","promises","range","root","buildTree","flatNodes","$6e027ea0dcb28b31$var$flattenNodes","node","arr","traverse","depth","left","right","bufferLengths","remainingNodes","nextWorker","j","workerOptions","pr","then","buffer","byteLength","useSharedArrayBuffer","ArrayBuffer","BYTES_PER_NODE","populateBuffer","serialized","roots","nodeCount","countNodes","computeTriangleBounds"],"version":3,"file":"parallelMeshBVH.worker.22cf4bb0.js.map"}