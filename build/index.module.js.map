{"version":3,"file":"index.module.js","sources":["../src/materials/MaterialBase.js","../src/materials/BlendMaterial.js","../src/core/PathTracingRenderer.js","../src/utils/GeometryPreparationUtils.js","../src/core/PathTracingSceneGenerator.js","../src/core/DynamicPathTracingSceneGenerator.js","../src/core/MaterialReducer.js","../src/core/PhysicalCamera.js","../src/uniforms/MaterialsTexture.js","../src/uniforms/RenderTarget2DArray.js","../src/uniforms/EquirectHdrInfoUniform.js","../src/uniforms/PhysicalCameraUniform.js","../src/shader/shaderUtils.js","../src/utils/BlurredEnvMapGenerator.js","../src/shader/shaderStructs.js","../src/shader/shaderGGXFunctions.js","../src/shader/shaderMaterialSampling.js","../src/shader/shaderEnvMapSampling.js","../src/materials/PhysicalPathTracingMaterial.js","../src/index.js"],"sourcesContent":["import { ShaderMaterial } from 'three';\n\nexport class MaterialBase extends ShaderMaterial {\n\n\tconstructor( shader ) {\n\n\t\tsuper( shader );\n\n\t\tfor ( const key in this.uniforms ) {\n\n\t\t\tObject.defineProperty( this, key, {\n\n\t\t\t\tget() {\n\n\t\t\t\t\treturn this.uniforms[ key ].value;\n\n\t\t\t\t},\n\n\t\t\t\tset( v ) {\n\n\t\t\t\t\tthis.uniforms[ key ].value = v;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// sets the given named define value and sets \"needsUpdate\" to true if it's different\n\tsetDefine( name, value = undefined ) {\n\n\t\tif ( value === undefined || value === null ) {\n\n\t\t\tif ( name in this.defines ) {\n\n\t\t\t\tdelete this.defines[ name ];\n\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.defines[ name ] !== value ) {\n\n\t\t\t\tthis.defines[ name ] = value;\n\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","import { NoBlending } from 'three';\nimport { MaterialBase } from './MaterialBase.js';\n\nexport class BlendMaterial extends MaterialBase {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tblending: NoBlending,\n\n\t\t\tuniforms: {\n\n\t\t\t\ttarget1: { value: null },\n\t\t\t\ttarget2: { value: null },\n\t\t\t\topacity: { value: 1.0 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tuniform sampler2D target1;\n\t\t\t\tuniform sampler2D target2;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 color1 = texture2D( target1, vUv );\n\t\t\t\t\tvec4 color2 = texture2D( target2, vUv );\n\n\t\t\t\t\tfloat invOpacity = 1.0 - opacity;\n\t\t\t\t\tfloat totalAlpha = color1.a * invOpacity + color2.a * opacity;\n\n\t\t\t\t\tif ( color1.a != 0.0 || color2.a != 0.0 ) {\n\n\t\t\t\t\t\tgl_FragColor.rgb = color1.rgb * ( invOpacity * color1.a / totalAlpha ) + color2.rgb * ( opacity * color2.a / totalAlpha );\n\t\t\t\t\t\tgl_FragColor.a = totalAlpha;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}`\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n","import { RGBAFormat, FloatType, Color, Vector2, WebGLRenderTarget, NoBlending, NormalBlending } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { BlendMaterial } from '../materials/BlendMaterial.js';\n\nfunction* renderTask() {\n\n\tconst {\n\t\t_renderer,\n\t\t_fsQuad,\n\t\t_blendQuad,\n\t\t_primaryTarget,\n\t\t_blendTargets,\n\t\talpha,\n\t\tcamera,\n\t\tmaterial,\n\t} = this;\n\n\tconst blendMaterial = _blendQuad.material;\n\tlet [ blendTarget1, blendTarget2 ] = _blendTargets;\n\n\twhile ( true ) {\n\n\t\tif ( alpha ) {\n\n\t\t\tblendMaterial.opacity = 1 / ( this.samples + 1 );\n\t\t\tmaterial.blending = NoBlending;\n\t\t\tmaterial.opacity = 1;\n\n\t\t} else {\n\n\t\t\tmaterial.opacity = 1 / ( this.samples + 1 );\n\t\t\tmaterial.blending = NormalBlending;\n\n\t\t}\n\n\t\tconst w = _primaryTarget.width;\n\t\tconst h = _primaryTarget.height;\n\t\tmaterial.resolution.set( w, h );\n\t\tmaterial.seed ++;\n\n\t\tconst tx = this.tiles.x || 1;\n\t\tconst ty = this.tiles.y || 1;\n\t\tconst totalTiles = tx * ty;\n\t\tconst dprInv = ( 1 / _renderer.getPixelRatio() );\n\t\tfor ( let y = 0; y < ty; y ++ ) {\n\n\t\t\tfor ( let x = 0; x < tx; x ++ ) {\n\n\t\t\t\tmaterial.cameraWorldMatrix.copy( camera.matrixWorld );\n\t\t\t\tmaterial.invProjectionMatrix.copy( camera.projectionMatrixInverse );\n\n\t\t\t\tconst ogRenderTarget = _renderer.getRenderTarget();\n\t\t\t\tconst ogAutoClear = _renderer.autoClear;\n\n\t\t\t\t// three.js renderer takes values relative to the current pixel ratio\n\t\t\t\t_renderer.setRenderTarget( _primaryTarget );\n\t\t\t\t_renderer.setScissorTest( true );\n\t\t\t\t_renderer.setScissor(\n\t\t\t\t\tdprInv * Math.ceil( x * w / tx ),\n\t\t\t\t\tdprInv * Math.ceil( ( ty - y - 1 ) * h / ty ),\n\t\t\t\t\tdprInv * Math.ceil( w / tx ),\n\t\t\t\t\tdprInv * Math.ceil( h / ty ) );\n\t\t\t\t_renderer.autoClear = false;\n\t\t\t\t_fsQuad.render( _renderer );\n\n\t\t\t\t_renderer.setScissorTest( false );\n\t\t\t\t_renderer.setRenderTarget( ogRenderTarget );\n\t\t\t\t_renderer.autoClear = ogAutoClear;\n\n\t\t\t\tif ( alpha ) {\n\n\t\t\t\t\tblendMaterial.target1 = blendTarget1.texture;\n\t\t\t\t\tblendMaterial.target2 = _primaryTarget.texture;\n\n\t\t\t\t\t_renderer.setRenderTarget( blendTarget2 );\n\t\t\t\t\t_blendQuad.render( _renderer );\n\t\t\t\t\t_renderer.setRenderTarget( ogRenderTarget );\n\n\t\t\t\t}\n\n\t\t\t\tthis.samples += ( 1 / totalTiles );\n\n\t\t\t\tyield;\n\n\t\t\t}\n\n\t\t}\n\n\t\t[ blendTarget1, blendTarget2 ] = [ blendTarget2, blendTarget1 ];\n\n\t\tthis.samples = Math.round( this.samples );\n\n\t}\n\n}\n\nconst ogClearColor = new Color();\nexport class PathTracingRenderer {\n\n\tget material() {\n\n\t\treturn this._fsQuad.material;\n\n\t}\n\n\tset material( v ) {\n\n\t\tthis._fsQuad.material = v;\n\n\t}\n\n\tget target() {\n\n\t\treturn this._alpha ? this._blendTargets[ 1 ] : this._primaryTarget;\n\n\t}\n\n\tset alpha( v ) {\n\n\t\tif ( ! v ) {\n\n\t\t\tthis._blendTargets[ 0 ].dispose();\n\t\t\tthis._blendTargets[ 1 ].dispose();\n\n\t\t}\n\n\t\tthis._alpha = v;\n\t\tthis.reset();\n\n\t}\n\n\tget alpha() {\n\n\t\treturn this._alpha;\n\n\t}\n\n\tconstructor( renderer ) {\n\n\t\tthis.camera = null;\n\t\tthis.tiles = new Vector2( 1, 1 );\n\n\t\tthis.samples = 0;\n\t\tthis.stableNoise = false;\n\t\tthis._renderer = renderer;\n\t\tthis._alpha = false;\n\t\tthis._fsQuad = new FullScreenQuad( null );\n\t\tthis._blendQuad = new FullScreenQuad( new BlendMaterial() );\n\t\tthis._task = null;\n\n\t\tthis._primaryTarget = new WebGLRenderTarget( 1, 1, {\n\t\t\tformat: RGBAFormat,\n\t\t\ttype: FloatType,\n\t\t} );\n\t\tthis._blendTargets = [\n\t\t\tnew WebGLRenderTarget( 1, 1, {\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\ttype: FloatType,\n\t\t\t} ),\n\t\t\tnew WebGLRenderTarget( 1, 1, {\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\ttype: FloatType,\n\t\t\t} ),\n\t\t];\n\n\t}\n\n\tsetSize( w, h ) {\n\n\t\tthis._primaryTarget.setSize( w, h );\n\t\tthis._blendTargets[ 0 ].setSize( w, h );\n\t\tthis._blendTargets[ 1 ].setSize( w, h );\n\t\tthis.reset();\n\n\t}\n\n\tdispose() {\n\n\t\tthis._primaryTarget.dispose();\n\t\tthis._blendTargets[ 0 ].dispose();\n\t\tthis._blendTargets[ 1 ].dispose();\n\n\t\tthis._fsQuad.dispose();\n\t\tthis._blendQuad.dispose();\n\t\tthis._task = null;\n\n\t}\n\n\treset() {\n\n\t\tconst { _renderer, _primaryTarget, _blendTargets } = this;\n\t\tconst ogRenderTarget = _renderer.getRenderTarget();\n\t\tconst ogClearAlpha = _renderer.getClearAlpha();\n\t\t_renderer.getClearColor( ogClearColor );\n\n\t\t_renderer.setRenderTarget( _primaryTarget );\n\t\t_renderer.setClearColor( 0, 0 );\n\t\t_renderer.clearColor();\n\n\t\t_renderer.setRenderTarget( _blendTargets[ 0 ] );\n\t\t_renderer.setClearColor( 0, 0 );\n\t\t_renderer.clearColor();\n\n\t\t_renderer.setRenderTarget( _blendTargets[ 1 ] );\n\t\t_renderer.setClearColor( 0, 0 );\n\t\t_renderer.clearColor();\n\n\t\t_renderer.setClearColor( ogClearColor, ogClearAlpha );\n\t\t_renderer.setRenderTarget( ogRenderTarget );\n\n\t\tthis.samples = 0;\n\t\tthis._task = null;\n\n\t\tif ( this.stableNoise ) {\n\n\t\t\tthis.material.seed = 0;\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tif ( ! this._task ) {\n\n\t\t\tthis._task = renderTask.call( this );\n\n\t\t}\n\n\t\tthis._task.next();\n\n\t}\n\n}\n","import { BufferAttribute } from 'three';\nimport { mergeBufferGeometries, mergeVertices } from 'three/examples/jsm/utils/BufferGeometryUtils.js';\nexport function getGroupMaterialIndicesAttribute( geometry, materials, allMaterials ) {\n\n\tconst indexAttr = geometry.index;\n\tconst posAttr = geometry.attributes.position;\n\tconst vertCount = posAttr.count;\n\tconst materialArray = new Uint8Array( vertCount );\n\tconst totalCount = indexAttr ? indexAttr.count : vertCount;\n\tlet groups = geometry.groups;\n\tif ( groups.length === 0 ) {\n\n\t\tgroups = [ { count: totalCount, start: 0, materialIndex: 0 } ];\n\n\t}\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst start = group.start;\n\t\tconst count = group.count;\n\t\tconst endCount = Math.min( count, totalCount - start );\n\n\t\tconst mat = Array.isArray( materials ) ? materials[ group.materialIndex ] : materials;\n\t\tconst materialIndex = allMaterials.indexOf( mat );\n\n\t\tfor ( let j = 0; j < endCount; j ++ ) {\n\n\t\t\tlet index = start + j;\n\t\t\tif ( indexAttr ) {\n\n\t\t\t\tindex = indexAttr.getX( index );\n\n\t\t\t}\n\n\t\t\tmaterialArray[ index ] = materialIndex;\n\n\t\t}\n\n\t}\n\n\treturn new BufferAttribute( materialArray, 1, false );\n\n}\n\nexport function trimToAttributes( geometry, attributes ) {\n\n\t// trim any unneeded attributes\n\tif ( attributes ) {\n\n\t\tfor ( const key in geometry.attributes ) {\n\n\t\t\tif ( ! attributes.includes( key ) ) {\n\n\t\t\t\tgeometry.deleteAttribute( key );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport function setCommonAttributes( geometry, options ) {\n\n\tconst { attributes = [], normalMapRequired = false } = options;\n\n\tif ( ! geometry.attributes.normal && ( attributes && attributes.includes( 'normal' ) ) ) {\n\n\t\tgeometry.computeVertexNormals();\n\n\t}\n\n\tif ( ! geometry.attributes.uv && ( attributes && attributes.includes( 'uv' ) ) ) {\n\n\t\tconst vertCount = geometry.attributes.position.count;\n\t\tgeometry.setAttribute( 'uv', new BufferAttribute( new Float32Array( vertCount * 2 ), 2, false ) );\n\n\t}\n\n\tif ( ! geometry.attributes.tangent && ( attributes && attributes.includes( 'tangent' ) ) ) {\n\n\t\tif ( normalMapRequired ) {\n\n\t\t\t// computeTangents requires an index buffer\n\t\t\tif ( geometry.index === null ) {\n\n\t\t\t\tgeometry = mergeVertices( geometry );\n\n\t\t\t}\n\n\t\t\tgeometry.computeTangents();\n\n\t\t} else {\n\n\t\t\tconst vertCount = geometry.attributes.position.count;\n\t\t\tgeometry.setAttribute( 'tangent', new BufferAttribute( new Float32Array( vertCount * 4 ), 4, false ) );\n\n\t\t}\n\n\t}\n\n\tif ( ! geometry.index ) {\n\n\t\t// TODO: compute a typed array\n\t\tconst indexCount = geometry.attributes.position.count;\n\t\tconst array = new Array( indexCount );\n\t\tfor ( let i = 0; i < indexCount; i ++ ) {\n\n\t\t\tarray[ i ] = i;\n\n\t\t}\n\n\t\tgeometry.setIndex( array );\n\n\t}\n\n}\n\nexport function mergeMeshes( meshes, options = {} ) {\n\n\toptions = { attributes: null, cloneGeometry: true, ...options };\n\n\tconst transformedGeometry = [];\n\tconst materialSet = new Set();\n\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t// save any materials\n\t\tconst mesh = meshes[ i ];\n\t\tif ( mesh.visible === false ) continue;\n\n\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\tmesh.material.forEach( m => materialSet.add( m ) );\n\n\t\t} else {\n\n\t\t\tmaterialSet.add( mesh.material );\n\n\t\t}\n\n\t}\n\n\tconst materials = Array.from( materialSet );\n\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t// ensure the matrix world is up to date\n\t\tconst mesh = meshes[ i ];\n\t\tif ( mesh.visible === false ) continue;\n\n\t\tmesh.updateMatrixWorld();\n\n\t\t// apply the matrix world to the geometry\n\t\tconst originalGeometry = meshes[ i ].geometry;\n\t\tlet geometry = options.cloneGeometry ? originalGeometry.clone() : originalGeometry;\n\t\tgeometry.applyMatrix4( mesh.matrixWorld );\n\n\t\t// ensure our geometry has common attributes\n\t\tsetCommonAttributes( geometry, {\n\t\t\tattributes: options.attributes,\n\t\t\tnormalMapRequired: ! ! mesh.material.normalMap,\n\t\t} );\n\t\ttrimToAttributes( geometry, options.attributes );\n\n\t\t// create the material index attribute\n\t\tconst materialIndexAttribute = getGroupMaterialIndicesAttribute( geometry, mesh.material, materials );\n\t\tgeometry.setAttribute( 'materialIndex', materialIndexAttribute );\n\n\t\ttransformedGeometry.push( geometry );\n\n\t}\n\n\tconst textureSet = new Set();\n\tmaterials.forEach( material => {\n\n\t\tfor ( const key in material ) {\n\n\t\t\tconst value = material[ key ];\n\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\ttextureSet.add( value );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\tconst geometry = mergeBufferGeometries( transformedGeometry, false );\n\tconst textures = Array.from( textureSet );\n\treturn { geometry, materials, textures };\n\n}\n","import { Mesh } from 'three';\nimport { SAH, MeshBVH, StaticGeometryGenerator } from 'three-mesh-bvh';\nimport { mergeMeshes } from '../utils/GeometryPreparationUtils.js';\n\nexport class PathTracingSceneGenerator {\n\n\tprepScene( scene ) {\n\n\t\tconst meshes = [];\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.isSkinnedMesh || c.isMesh && c.morphTargetInfluences ) {\n\n\t\t\t\tconst generator = new StaticGeometryGenerator( c );\n\t\t\t\tgenerator.applyWorldTransforms = false;\n\t\t\t\tconst mesh = new Mesh(\n\t\t\t\t\tgenerator.generate(),\n\t\t\t\t\tc.material,\n\t\t\t\t);\n\t\t\t\tmesh.matrixWorld.copy( c.matrixWorld );\n\t\t\t\tmesh.matrix.copy( c.matrixWorld );\n\t\t\t\tmesh.matrix.decompose( mesh.position, mesh.quaternion, mesh.scale );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t} else if ( c.isMesh ) {\n\n\t\t\t\tmeshes.push( c );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn mergeMeshes( meshes, {\n\t\t\tattributes: [ 'position', 'normal', 'tangent', 'uv' ],\n\t\t} );\n\n\t}\n\n\tgenerate( scene, options = {} ) {\n\n\t\tconst { materials, textures, geometry } = this.prepScene( scene );\n\t\tconst bvhOptions = { strategy: SAH, ...options, maxLeafTris: 1 };\n\t\treturn {\n\t\t\tscene,\n\t\t\tmaterials,\n\t\t\ttextures,\n\t\t\tbvh: new MeshBVH( geometry, bvhOptions ),\n\t\t};\n\n\t}\n\n}\n","import { BufferGeometry } from 'three';\nimport { StaticGeometryGenerator, MeshBVH } from 'three-mesh-bvh';\nimport { setCommonAttributes, getGroupMaterialIndicesAttribute } from '../utils/GeometryPreparationUtils.js';\n\nexport class DynamicPathTracingSceneGenerator {\n\n\tget initialized() {\n\n\t\treturn Boolean( this.bvh );\n\n\t}\n\n\tconstructor( scene ) {\n\n\t\tthis.scene = scene;\n\t\tthis.bvh = null;\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.materials = null;\n\t\tthis.textures = null;\n\t\tthis.staticGeometryGenerator = new StaticGeometryGenerator( scene );\n\n\t}\n\n\treset() {\n\n\t\tthis.bvh = null;\n\t\tthis.geometry.dispose();\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.materials = null;\n\t\tthis.textures = null;\n\t\tthis.staticGeometryGenerator = new StaticGeometryGenerator( this.scene );\n\n\t}\n\n\tdispose() {}\n\n\tgenerate() {\n\n\t\tconst { scene, staticGeometryGenerator, geometry } = this;\n\t\tif ( this.bvh === null ) {\n\n\t\t\tconst attributes = [ 'position', 'normal', 'tangent', 'uv' ];\n\t\t\tscene.traverse( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tconst normalMapRequired = ! ! c.material.normalMap;\n\t\t\t\t\tsetCommonAttributes( c.geometry, { attributes, normalMapRequired } );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tconst textureSet = new Set();\n\t\t\tconst materials = staticGeometryGenerator.getMaterials();\n\t\t\tmaterials.forEach( material => {\n\n\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\t\t\ttextureSet.add( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tstaticGeometryGenerator.attributes = attributes;\n\t\t\tstaticGeometryGenerator.generate( geometry );\n\n\t\t\tconst materialIndexAttribute = getGroupMaterialIndicesAttribute( geometry, materials, materials );\n\t\t\tgeometry.setAttribute( 'materialIndex', materialIndexAttribute );\n\t\t\tgeometry.clearGroups();\n\n\t\t\tthis.bvh = new MeshBVH( geometry );\n\t\t\tthis.materials = materials;\n\t\t\tthis.textures = Array.from( textureSet );\n\n\t\t\treturn {\n\t\t\t\tbvh: this.bvh,\n\t\t\t\tmaterials: this.materials,\n\t\t\t\ttextures: this.textures,\n\t\t\t\tscene,\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconst { bvh } = this;\n\t\t\tstaticGeometryGenerator.generate( geometry );\n\t\t\tbvh.refit();\n\t\t\treturn {\n\t\t\t\tbvh: this.bvh,\n\t\t\t\tmaterials: this.materials,\n\t\t\t\ttextures: this.textures,\n\t\t\t\tscene,\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\n}\n","// https://github.com/gkjohnson/webxr-sandbox/blob/main/skinned-mesh-batching/src/MaterialReducer.js\n\nfunction isTypedArray( arr ) {\n\n\treturn arr.buffer instanceof ArrayBuffer && 'BYTES_PER_ELEMENT' in arr;\n\n}\n\nexport class MaterialReducer {\n\n\tconstructor() {\n\n\t\tconst ignoreKeys = new Set();\n\t\tignoreKeys.add( 'uuid' );\n\n\t\tthis.ignoreKeys = ignoreKeys;\n\t\tthis.shareTextures = true;\n\t\tthis.textures = [];\n\t\tthis.materials = [];\n\n\t}\n\n\tareEqual( objectA, objectB ) {\n\n\t\tconst keySet = new Set();\n\t\tconst traverseSet = new Set();\n\t\tconst ignoreKeys = this.ignoreKeys;\n\n\t\tconst traverse = ( a, b ) => {\n\n\t\t\tif ( a === b ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tif ( a && b && a instanceof Object && b instanceof Object ) {\n\n\t\t\t\tif ( traverseSet.has( a ) || traverseSet.has( b ) ) {\n\n\t\t\t\t\tthrow new Error( 'MaterialReducer: Material is recursive.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsElement = a instanceof Element;\n\t\t\t\tconst bIsElement = b instanceof Element;\n\t\t\t\tif ( aIsElement || bIsElement ) {\n\n\t\t\t\t\tif ( aIsElement !== bIsElement || ! ( a instanceof Image ) || ! ( b instanceof Image ) ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn a.src === b.src;\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsImageBitmap = a instanceof ImageBitmap;\n\t\t\t\tconst bIsImageBitmap = b instanceof ImageBitmap;\n\t\t\t\tif ( aIsImageBitmap || bIsImageBitmap ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( a.equals ) {\n\n\t\t\t\t\treturn a.equals( b );\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsTypedArray = isTypedArray( a );\n\t\t\t\tconst bIsTypedArray = isTypedArray( b );\n\t\t\t\tif ( aIsTypedArray || bIsTypedArray ) {\n\n\t\t\t\t\tif ( aIsTypedArray !== bIsTypedArray || a.constructor !== b.constructor || a.length !== b.length ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( a[ i ] !== b[ i ] ) return false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\ttraverseSet.add( a );\n\t\t\t\ttraverseSet.add( b );\n\n\t\t\t\tkeySet.clear();\n\t\t\t\tfor ( const key in a ) {\n\n\t\t\t\t\tif ( ! a.hasOwnProperty( key ) || a[ key ] instanceof Function || ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkeySet.add( key );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( const key in b ) {\n\n\t\t\t\t\tif ( ! b.hasOwnProperty( key ) || b[ key ] instanceof Function || ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkeySet.add( key );\n\n\t\t\t\t}\n\n\t\t\t\tconst keys = Array.from( keySet.values() );\n\t\t\t\tlet result = true;\n\t\t\t\tfor ( const i in keys ) {\n\n\t\t\t\t\tconst key = keys[ i ];\n\t\t\t\t\tif ( ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = traverse( a[ key ], b[ key ] );\n\t\t\t\t\tif ( ! result ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttraverseSet.delete( a );\n\t\t\t\ttraverseSet.delete( b );\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t};\n\n\t\treturn traverse( objectA, objectB );\n\n\t}\n\n\tprocess( object ) {\n\n\t\tconst { textures, materials } = this;\n\t\tlet replaced = 0;\n\n\t\tconst processMaterial = material => {\n\n\t\t\t// Check if another material matches this one\n\t\t\tlet foundMaterial = null;\n\t\t\tfor ( const i in materials ) {\n\n\t\t\t\tconst otherMaterial = materials[ i ];\n\t\t\t\tif ( this.areEqual( material, otherMaterial ) ) {\n\n\t\t\t\t\tfoundMaterial = otherMaterial;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( foundMaterial ) {\n\n\t\t\t\treplaced ++;\n\t\t\t\treturn foundMaterial;\n\n\t\t\t} else {\n\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\tif ( this.shareTextures ) {\n\n\t\t\t\t\t// See if there's another texture that matches the ones on this material\n\t\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\t\tif ( ! material.hasOwnProperty( key ) ) continue;\n\n\t\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\t\tif ( value && value.isTexture && value.image instanceof Image ) {\n\n\t\t\t\t\t\t\tlet foundTexture = null;\n\t\t\t\t\t\t\tfor ( const i in textures ) {\n\n\t\t\t\t\t\t\t\tconst texture = textures[ i ];\n\t\t\t\t\t\t\t\tif ( this.areEqual( texture, value ) ) {\n\n\t\t\t\t\t\t\t\t\tfoundTexture = texture;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( foundTexture ) {\n\n\t\t\t\t\t\t\t\tmaterial[ key ] = foundTexture;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttextures.push( value );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t};\n\n\t\tobject.traverse( c => {\n\n\t\t\tif ( c.isMesh && c.material ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0; i < material.length; i ++ ) {\n\n\t\t\t\t\t\tmaterial[ i ] = processMaterial( material[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc.material = processMaterial( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn { replaced, retained: materials.length };\n\n\t}\n\n}\n","import { PerspectiveCamera } from 'three';\n\nexport class PhysicalCamera extends PerspectiveCamera {\n\n\tset bokehSize( size ) {\n\n\t\tthis.fStop = this.getFocalLength() / size;\n\n\t}\n\n\tget bokehSize() {\n\n\t\treturn this.getFocalLength() / this.fStop;\n\n\t}\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.fStop = 1.4;\n\t\tthis.apertureBlades = 0;\n\t\tthis.apertureRotation = 0;\n\t\tthis.focusDistance = 25;\n\t\tthis.anamorphicRatio = 1;\n\n\t}\n\n}\n","import { DataTexture, RGBAFormat, ClampToEdgeWrapping, FloatType, FrontSide, BackSide, DoubleSide, Matrix3 } from 'three';\n\nconst MATERIAL_PIXELS = 9;\nconst MATERIAL_STRIDE = MATERIAL_PIXELS * 4;\n\nexport class MaterialsTexture extends DataTexture {\n\n\tconstructor() {\n\n\t\tsuper( new Float32Array( 4 ), 1, 1 );\n\n\t\tthis.format = RGBAFormat;\n\t\tthis.type = FloatType;\n\t\tthis.wrapS = ClampToEdgeWrapping;\n\t\tthis.wrapT = ClampToEdgeWrapping;\n\t\tthis.generateMipmaps = false;\n\n\t}\n\n\tsetCastShadow( materialIndex, cast ) {\n\n\t\t// invert the shadow value so we default to \"true\" when initializing a material\n\t\tconst array = this.image.data;\n\t\tconst index = materialIndex * MATERIAL_STRIDE + 6 * 4 + 0;\n\t\tarray[ index ] = ! cast ? 1 : 0;\n\n\t}\n\n\tgetCastShadow( materialIndex ) {\n\n\t\tconst array = this.image.data;\n\t\tconst index = materialIndex * MATERIAL_STRIDE + 6 * 4 + 0;\n\t\treturn ! Boolean( array[ index ] );\n\n\t}\n\n\tsetSide( materialIndex, side ) {\n\n\t\tconst array = this.image.data;\n\t\tconst index = materialIndex * MATERIAL_STRIDE + 5 * 4 + 2;\n\t\tswitch ( side ) {\n\n\t\t\tcase FrontSide:\n\t\t\t\tarray[ index ] = 1;\n\t\t\t\tbreak;\n\t\t\tcase BackSide:\n\t\t\t\tarray[ index ] = - 1;\n\t\t\t\tbreak;\n\t\t\tcase DoubleSide:\n\t\t\t\tarray[ index ] = 0;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tgetSide( materialIndex ) {\n\n\t\tconst array = this.image.data;\n\t\tconst index = materialIndex * MATERIAL_STRIDE + 5 * 4 + 2;\n\t\tswitch ( array[ index ] ) {\n\n\t\t\tcase 0:\n\t\t\t\treturn DoubleSide;\n\t\t\tcase 1:\n\t\t\t\treturn FrontSide;\n\t\t\tcase - 1:\n\t\t\t\treturn BackSide;\n\n\t\t}\n\n\t\treturn 0;\n\n\t}\n\n\tsetMatte( materialIndex, matte ) {\n\n\t\tconst array = this.image.data;\n\t\tconst index = materialIndex * MATERIAL_STRIDE + 5 * 4 + 3;\n\t\tarray[ index ] = matte ? 1 : 0;\n\n\t}\n\n\tgetMatte( materialIndex ) {\n\n\t\tconst array = this.image.data;\n\t\tconst index = materialIndex * MATERIAL_STRIDE + 5 * 4 + 3;\n\t\treturn Boolean( array[ index ] );\n\n\t}\n\n\tupdateFrom( materials, textures ) {\n\n\t\tfunction getTexture( material, key, def = - 1 ) {\n\n\t\t\treturn key in material ? textures.indexOf( material[ key ] ) : def;\n\n\t\t}\n\n\t\tfunction getField( material, key, def ) {\n\n\t\t\treturn key in material ? material[ key ] : def;\n\n\t\t}\n\n\t\tlet index = 0;\n\t\tconst pixelCount = materials.length * MATERIAL_PIXELS;\n\t\tconst dimension = Math.ceil( Math.sqrt( pixelCount ) );\n\n\t\tif ( this.image.width !== dimension ) {\n\n\t\t\tthis.dispose();\n\n\t\t\tthis.image.data = new Float32Array( dimension * dimension * 4 );\n\t\t\tthis.image.width = dimension;\n\t\t\tthis.image.height = dimension;\n\n\t\t}\n\n\t\tconst floatArray = this.image.data;\n\n\t\t// on some devices (Google Pixel 6) the \"floatBitsToInt\" function does not work correctly so we\n\t\t// can't encode texture ids that way.\n\t\t// const intArray = new Int32Array( floatArray.buffer );\n\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tconst m = materials[ i ];\n\n\t\t\t// color\n\t\t\tfloatArray[ index ++ ] = m.color.r;\n\t\t\tfloatArray[ index ++ ] = m.color.g;\n\t\t\tfloatArray[ index ++ ] = m.color.b;\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'map' );\n\n\t\t\t// metalness & roughness\n\t\t\tfloatArray[ index ++ ] = getField( m, 'metalness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = textures.indexOf( m.metalnessMap );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'roughness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = textures.indexOf( m.roughnessMap );\n\n\t\t\t// transmission & emissiveIntensity\n\t\t\tfloatArray[ index ++ ] = getField( m, 'ior', 1.0 );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'transmission', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'transmissionMap' );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'emissiveIntensity', 0.0 );\n\n\t\t\t// emission\n\t\t\tif ( 'emissive' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.r;\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.g;\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.b;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\n\t\t\t}\n\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'emissiveMap' );\n\n\t\t\t// normals\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'normalMap' );\n\t\t\tif ( 'normalScale' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.normalScale.x;\n\t\t\t\tfloatArray[ index ++ ] = m.normalScale.y;\n\n \t\t\t} else {\n\n \t\t\t\tfloatArray[ index ++ ] = 1;\n \t\t\t\tfloatArray[ index ++ ] = 1;\n\n \t\t\t}\n\n\t\t\tindex ++;\n\n\t\t\t// side & matte\n\t\t\tfloatArray[ index ++ ] = m.opacity;\n\t\t\tfloatArray[ index ++ ] = m.alphaTest;\n\t\t\tindex ++; // side\n\t\t\tindex ++; // matte\n\n\t\t\tindex ++; // shadow\n\t\t\tindex ++;\n\t\t\tindex ++;\n\t\t\tindex ++;\n\n\t\t\t//initialize to identity\n\t\t\tlet elementsInRowOrder = new Matrix3().transpose().elements;\n\n\t\t\tif ( m.map ) {\n\n\t\t\t\t// console.log( m.map );\n\t\t\t\tm.map.matrix.transposeIntoArray( elementsInRowOrder );\n\n\n\t\t\t}\n\n\t\t\t//first row\n\t\t\tfloatArray[ index ++ ] = elementsInRowOrder[ 0 ];\n\t\t\tfloatArray[ index ++ ] = elementsInRowOrder[ 1 ];\n\t\t\tfloatArray[ index ++ ] = elementsInRowOrder[ 2 ];\n\t\t\tindex ++;\n\t\t\t//second row\n\t\t\tfloatArray[ index ++ ] = elementsInRowOrder[ 3 ];\n\t\t\tfloatArray[ index ++ ] = elementsInRowOrder[ 4 ];\n\t\t\tfloatArray[ index ++ ] = elementsInRowOrder[ 5 ];\n\t\t\tindex ++;\n\n\t\t}\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n","import {\n\tWebGLArrayRenderTarget,\n\tRGBAFormat,\n\tUnsignedByteType,\n\tMeshBasicMaterial,\n\tColor,\n\tRepeatWrapping,\n\tLinearFilter,\n\tNoToneMapping,\n\tMatrix3\n} from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\n\nconst prevColor = new Color();\nexport class RenderTarget2DArray extends WebGLArrayRenderTarget {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tconst tex = this.texture;\n\t\ttex.format = RGBAFormat;\n\t\ttex.type = UnsignedByteType;\n\t\ttex.minFilter = LinearFilter;\n\t\ttex.magFilter = LinearFilter;\n\t\ttex.wrapS = RepeatWrapping;\n\t\ttex.wrapT = RepeatWrapping;\n\t\ttex.setTextures = ( ...args ) => {\n\n\t\t\tthis.setTextures( ...args );\n\n\t\t};\n\n\t\tconst fsQuad = new FullScreenQuad( new MeshBasicMaterial() );\n\t\tthis.fsQuad = fsQuad;\n\n\t}\n\n\tsetTextures( renderer, width, height, textures ) {\n\n\t\t// save previous renderer state\n\t\tconst prevRenderTarget = renderer.getRenderTarget();\n\t\tconst prevToneMapping = renderer.toneMapping;\n\t\tconst prevAlpha = renderer.getClearAlpha();\n\t\trenderer.getClearColor( prevColor );\n\n\t\t// resize the render target and ensure we don't have an empty texture\n\t\tconst depth = textures.length || 1;\n\t\tthis.setSize( width, height, depth );\n\t\trenderer.setClearColor( 0, 0 );\n\t\trenderer.toneMapping = NoToneMapping;\n\n\t\t// render each texture into each layer of the target\n\t\tconst fsQuad = this.fsQuad;\n\t\tfor ( let i = 0, l = depth; i < l; i ++ ) {\n\n\t\t\tconst texture = textures[ i ];\n\t\t\t//save texture uv transform\n\t\t\ttexture.updateMatrix();\n\t\t\tconst uvTranform = texture.matrix;\n\t\t\ttexture.matrixAutoUpdate = false;\n\t\t\ttexture.matrix = new Matrix3();\n\n\t\t\tfsQuad.material.map = texture;\n\t\t\tfsQuad.material.transparent = true;\n\n\t\t\trenderer.setRenderTarget( this, i );\n\t\t\tfsQuad.render( renderer );\n\n\t\t\t//restore uv tranform\n\t\t\ttexture.matrix = uvTranform;\n\t\t\ttexture.matrixAutoUpdate = true;\n\n\t\t}\n\n\t\t// reset the renderer\n\t\tfsQuad.material.map = null;\n\t\trenderer.setClearColor( prevColor, prevAlpha );\n\t\trenderer.setRenderTarget( prevRenderTarget );\n\t\trenderer.toneMapping = prevToneMapping;\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\t\tthis.fsQuad.dispose();\n\n\t}\n\n}\n","import { DataTexture, FloatType, RedFormat, LinearFilter, DataUtils, HalfFloatType, Source, RepeatWrapping } from 'three';\n\nfunction binarySearchFindClosestIndexOf( array, targetValue, offset = 0, count = array.length ) {\n\n\tlet lower = 0;\n\tlet upper = count;\n\twhile ( lower < upper ) {\n\n\t\tconst mid = ~ ~ ( 0.5 * upper + 0.5 * lower );\n\n\n\t\t// check if the middle array value is above or below the target and shift\n\t\t// which half of the array we're looking at\n\t\tif ( array[ offset + mid ] < targetValue ) {\n\n\t\t\tlower = mid + 1;\n\n\t\t} else {\n\n\t\t\tupper = mid;\n\n\t\t}\n\n\t}\n\n\treturn lower;\n\n}\n\nfunction colorToLuminance( r, g, b ) {\n\n\t// https://en.wikipedia.org/wiki/Relative_luminance\n\treturn 0.2126 * r + 0.7152 * g + 0.0722 * b;\n\n}\n\n// ensures the data is all floating point values and flipY is false\nfunction preprocessEnvMap( envMap ) {\n\n\tconst map = envMap.clone();\n\tmap.source = new Source( { ...map.image } );\n\tconst { width, height, data } = map.image;\n\n\t// TODO: is there a simple way to avoid cloning and adjusting the env map data here?\n\t// convert the data from half float uint 16 arrays to float arrays for cdf computation\n\tlet newData = data;\n\tif ( map.type === HalfFloatType ) {\n\n\t\tnewData = new Float32Array( data.length );\n\t\tfor ( const i in data ) {\n\n\t\t\tnewData[ i ] = DataUtils.fromHalfFloat( data[ i ] );\n\n\t\t}\n\n\t\tmap.image.data = newData;\n\t\tmap.type = FloatType;\n\n\t}\n\n\t// remove any y flipping for cdf computation\n\tif ( map.flipY ) {\n\n\t\tconst ogData = newData;\n\t\tnewData = newData.slice();\n\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\tconst newY = height - y - 1;\n\t\t\t\tconst ogIndex = 4 * ( y * width + x );\n\t\t\t\tconst newIndex = 4 * ( newY * width + x );\n\n\t\t\t\tnewData[ newIndex + 0 ] = ogData[ ogIndex + 0 ];\n\t\t\t\tnewData[ newIndex + 1 ] = ogData[ ogIndex + 1 ];\n\t\t\t\tnewData[ newIndex + 2 ] = ogData[ ogIndex + 2 ];\n\t\t\t\tnewData[ newIndex + 3 ] = ogData[ ogIndex + 3 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tmap.flipY = false;\n\t\tmap.image.data = newData;\n\n\t}\n\n\treturn map;\n\n}\n\nexport class EquirectHdrInfoUniform {\n\n\tconstructor() {\n\n\t\t// Stores a map of [0, 1] value -> cumulative importance row & pdf\n\t\t// used to sampling a random value to a relevant row to sample from\n\t\tconst marginalWeights = new DataTexture();\n\t\tmarginalWeights.type = FloatType;\n\t\tmarginalWeights.format = RedFormat;\n\t\tmarginalWeights.minFilter = LinearFilter;\n\t\tmarginalWeights.magFilter = LinearFilter;\n\t\tmarginalWeights.generateMipmaps = false;\n\n\t\t// Stores a map of [0, 1] value -> cumulative importance column & pdf\n\t\t// used to sampling a random value to a relevant pixel to sample from\n\t\tconst conditionalWeights = new DataTexture();\n\t\tconditionalWeights.type = FloatType;\n\t\tconditionalWeights.format = RedFormat;\n\t\tconditionalWeights.minFilter = LinearFilter;\n\t\tconditionalWeights.magFilter = LinearFilter;\n\t\tconditionalWeights.generateMipmaps = false;\n\n\t\t// store the total sum in a 1x1 tex since some android mobile devices have issues\n\t\t// storing large values in structs.\n\t\tconst totalSumTex = new DataTexture();\n\t\ttotalSumTex.type = FloatType;\n\t\ttotalSumTex.format = RedFormat;\n\t\ttotalSumTex.minFilter = LinearFilter;\n\t\ttotalSumTex.magFilter = LinearFilter;\n\t\ttotalSumTex.generateMipmaps = false;\n\n\t\tthis.marginalWeights = marginalWeights;\n\t\tthis.conditionalWeights = conditionalWeights;\n\t\tthis.totalSum = totalSumTex;\n\t\tthis.map = null;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.marginalWeights.dispose();\n\t\tthis.conditionalWeights.dispose();\n\t\tthis.totalSum.dispose();\n\t\tif ( this.map ) this.map.dispose();\n\n\t}\n\n\tupdateFrom( hdr ) {\n\n\t\t// https://github.com/knightcrawler25/GLSL-PathTracer/blob/3c6fd9b6b3da47cd50c527eeb45845eef06c55c3/src/loaders/hdrloader.cpp\n\t\t// https://pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources#InfiniteAreaLights\n\t\tconst map = preprocessEnvMap( hdr );\n\t\tmap.wrapS = RepeatWrapping;\n\t\tmap.wrapT = RepeatWrapping;\n\n\t\tconst { width, height, data } = map.image;\n\n\t\t// \"conditional\" = \"pixel relative to row pixels sum\"\n\t\t// \"marginal\" = \"row relative to row sum\"\n\n\t\t// track the importance of any given pixel in the image by tracking its weight relative to other pixels in the image\n\t\tconst pdfConditional = new Float32Array( width * height );\n\t\tconst cdfConditional = new Float32Array( width * height );\n\n\t\tconst pdfMarginal = new Float32Array( height );\n\t\tconst cdfMarginal = new Float32Array( height );\n\n\t\tlet totalSumValue = 0.0;\n\t\tlet cumulativeWeightMarginal = 0.0;\n\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\tlet cumulativeRowWeight = 0.0;\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\tconst i = y * width + x;\n\t\t\t\tconst r = data[ 4 * i + 0 ];\n\t\t\t\tconst g = data[ 4 * i + 1 ];\n\t\t\t\tconst b = data[ 4 * i + 2 ];\n\n\t\t\t\t// the probability of the pixel being selected in this row is the\n\t\t\t\t// scale of the luminance relative to the rest of the pixels.\n\t\t\t\t// TODO: this should also account for the solid angle of the pixel when sampling\n\t\t\t\tconst weight = colorToLuminance( r, g, b );\n\t\t\t\tcumulativeRowWeight += weight;\n\t\t\t\ttotalSumValue += weight;\n\n\t\t\t\tpdfConditional[ i ] = weight;\n\t\t\t\tcdfConditional[ i ] = cumulativeRowWeight;\n\n\t\t\t}\n\n\t\t\t// can happen if the row is all black\n\t\t\tif ( cumulativeRowWeight !== 0 ) {\n\n\t\t\t\t// scale the pdf and cdf to [0.0, 1.0]\n\t\t\t\tfor ( let i = y * width, l = y * width + width; i < l; i ++ ) {\n\n\t\t\t\t\tpdfConditional[ i ] /= cumulativeRowWeight;\n\t\t\t\t\tcdfConditional[ i ] /= cumulativeRowWeight;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcumulativeWeightMarginal += cumulativeRowWeight;\n\n\t\t\t// compute the marginal pdf and cdf along the height of the map.\n\t\t\tpdfMarginal[ y ] = cumulativeRowWeight;\n\t\t\tcdfMarginal[ y ] = cumulativeWeightMarginal;\n\n\t\t}\n\n\t\t// can happen if the texture is all black\n\t\tif ( cumulativeWeightMarginal !== 0 ) {\n\n\t\t\t// scale the marginal pdf and cdf to [0.0, 1.0]\n\t\t\tfor ( let i = 0, l = pdfMarginal.length; i < l; i ++ ) {\n\n\t\t\t\tpdfMarginal[ i ] /= cumulativeWeightMarginal;\n\t\t\t\tcdfMarginal[ i ] /= cumulativeWeightMarginal;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute a sorted index of distributions and the probabilities along them for both\n\t\t// the marginal and conditional data. These will be used to sample with a random number\n\t\t// to retrieve a uv value to sample in the environment map.\n\t\t// These values continually increase so it's okay to interpolate between them.\n\t\tconst marginalDataArray = new Float32Array( height );\n\t\tconst conditionalDataArray = new Float32Array( width * height );\n\n\t\tfor ( let i = 0; i < height; i ++ ) {\n\n\t\t\tconst dist = ( i + 1 ) / height;\n\t\t\tconst row = binarySearchFindClosestIndexOf( cdfMarginal, dist );\n\n\t\t\tmarginalDataArray[ i ] = row / height;\n\n\t\t}\n\n\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\tconst i = y * width + x;\n\t\t\t\tconst dist = ( x + 1 ) / width;\n\t\t\t\tconst col = binarySearchFindClosestIndexOf( cdfConditional, dist, y * width, width );\n\n\t\t\t\tconditionalDataArray[ i ] = col / width;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.dispose();\n\n\t\tconst { marginalWeights, conditionalWeights, totalSum } = this;\n\t\tmarginalWeights.image = { width: height, height: 1, data: marginalDataArray };\n\t\tmarginalWeights.needsUpdate = true;\n\n\t\tconditionalWeights.image = { width, height, data: conditionalDataArray };\n\t\tconditionalWeights.needsUpdate = true;\n\n\t\ttotalSum.image = { width: 1, height: 1, data: new Float32Array( [ totalSumValue ] ) };\n\t\ttotalSum.needsUpdate = true;\n\n\t\tthis.map = map;\n\n\t}\n\n}\n","import { PhysicalCamera } from '../core/PhysicalCamera.js';\nexport class PhysicalCameraUniform {\n\n\tconstructor() {\n\n\t\tthis.bokehSize = 0;\n\t\tthis.apertureBlades = 0;\n\t\tthis.apertureRotation = 0;\n\t\tthis.focusDistance = 10;\n\t\tthis.anamorphicRatio = 1;\n\n\t}\n\n\tupdateFrom( camera ) {\n\n\t\tif ( camera instanceof PhysicalCamera ) {\n\n\t\t\tthis.bokehSize = camera.bokehSize;\n\t\t\tthis.apertureBlades = camera.apertureBlades;\n\t\t\tthis.apertureRotation = camera.apertureRotation;\n\t\t\tthis.focusDistance = camera.focusDistance;\n\t\t\tthis.anamorphicRatio = camera.anamorphicRatio;\n\n\t\t} else {\n\n\t\t\tthis.bokehSize = 0;\n\t\t\tthis.apertureRotation = 0;\n\t\t\tthis.apertureBlades = 0;\n\t\t\tthis.focusDistance = 10;\n\t\t\tthis.anamorphicRatio = 1;\n\n\t\t}\n\n\t}\n\n}\n","export const shaderUtils = /* glsl */`\n\n\t// https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf\n\tfloat schlickFresnel( float cosine, float f0 ) {\n\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\n\n\t}\n\n\t// https://raytracing.github.io/books/RayTracingInOneWeekend.html#dielectrics/schlickapproximation\n\tfloat schlickFresnelFromIor( float cosine, float iorRatio ) {\n\n\t\t// Schlick approximation\n\t\tfloat r_0 = pow( ( 1.0 - iorRatio ) / ( 1.0 + iorRatio ), 2.0 );\n\t\treturn schlickFresnel( cosine, r_0 );\n\n\t}\n\n\t// forms a basis with the normal vector as Z\n\tmat3 getBasisFromNormal( vec3 normal ) {\n\n\t\tvec3 other;\n\t\tif ( abs( normal.x ) > 0.5 ) {\n\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\n\n\t\t} else {\n\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\n\n\t\t}\n\n\t\tvec3 ortho = normalize( cross( normal, other ) );\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\n\t\treturn mat3( ortho2, ortho, normal );\n\n\t}\n\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\n\n\t\treturn normalize( a + b );\n\n\t}\n\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\n\t// we find a ray like that we ignore it to avoid artifacts.\n\t// This function returns if the direction is on the same side of both planes.\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\n\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\n\n\t}\n\n\tvec3 getHemisphereSample( vec3 n, vec2 uv ) {\n\n\t\t// https://www.rorydriscoll.com/2009/01/07/better-sampling/\n\t\t// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n\t\tfloat sign = n.z == 0.0 ? 1.0 : sign( n.z );\n\t\tfloat a = - 1.0 / ( sign + n.z );\n\t\tfloat b = n.x * n.y * a;\n\t\tvec3 b1 = vec3( 1.0 + sign * n.x * n.x * a, sign * b, - sign * n.x );\n\t\tvec3 b2 = vec3( b, sign + n.y * n.y * a, - n.y );\n\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat theta = 2.0 * PI * uv.y;\n\t\tfloat x = r * cos( theta );\n\t\tfloat y = r * sin( theta );\n\t\treturn x * b1 + y * b2 + sqrt( 1.0 - uv.x ) * n;\n\n\t}\n\n\t// https://www.shadertoy.com/view/wltcRS\n\tuvec4 s0;\n\n\tvoid rng_initialize(vec2 p, int frame) {\n\n\t\t// white noise seed\n\t\ts0 = uvec4( p, uint( frame ), uint( p.x ) + uint( p.y ) );\n\n\t}\n\n\t// https://www.pcg-random.org/\n\tvoid pcg4d( inout uvec4 v ) {\n\n\t\tv = v * 1664525u + 1013904223u;\n\t\tv.x += v.y * v.w;\n\t\tv.y += v.z * v.x;\n\t\tv.z += v.x * v.y;\n\t\tv.w += v.y * v.z;\n\t\tv = v ^ ( v >> 16u );\n\t\tv.x += v.y*v.w;\n\t\tv.y += v.z*v.x;\n\t\tv.z += v.x*v.y;\n\t\tv.w += v.y*v.z;\n\n\t}\n\n\t// returns [ 0, 1 ]\n\tfloat rand() {\n\n\t\tpcg4d(s0);\n\t\treturn float( s0.x ) / float( 0xffffffffu );\n\n\t}\n\n\tvec2 rand2() {\n\n\t\tpcg4d( s0 );\n\t\treturn vec2( s0.xy ) / float(0xffffffffu);\n\n\t}\n\n\tvec3 rand3() {\n\n\t\tpcg4d(s0);\n\t\treturn vec3( s0.xyz ) / float( 0xffffffffu );\n\n\t}\n\n\tvec4 rand4() {\n\n\t\tpcg4d(s0);\n\t\treturn vec4(s0)/float(0xffffffffu);\n\n\t}\n\n\t// https://github.com/mrdoob/three.js/blob/dev/src/math/Vector3.js#L724\n\tvec3 randDirection() {\n\n\t\tvec2 r = rand2();\n\t\tfloat u = ( r.x - 0.5 ) * 2.0;\n\t\tfloat t = r.y * PI * 2.0;\n\t\tfloat f = sqrt( 1.0 - u * u );\n\n\t\treturn vec3( f * cos( t ), f * sin( t ), u );\n\n\t}\n\n\tvec2 triangleSample( vec2 a, vec2 b, vec2 c ) {\n\n\t\t// get the edges of the triangle and the diagonal across the\n\t\t// center of the parallelogram\n\t\tvec2 e1 = a - b;\n\t\tvec2 e2 = c - b;\n\t\tvec2 diag = normalize( e1 + e2 );\n\n\t\t// pick a random point in the parallelogram\n\t\tvec2 r = rand2();\n\t\tif ( r.x + r.y > 1.0 ) {\n\n\t\t\tr = vec2( 1.0 ) - r;\n\n\t\t}\n\n\t\treturn e1 * r.x + e2 * r.y;\n\n\t}\n\n\t// samples an aperture shape with the given number of sides. 0 means circle\n\tvec2 sampleAperture( int blades ) {\n\n\t\tif ( blades == 0 ) {\n\n\t\t\tvec2 r = rand2();\n\t\t\tfloat angle = 2.0 * PI * r.x;\n\t\t\tfloat radius = sqrt( rand() );\n\t\t\treturn vec2( cos( angle ), sin( angle ) ) * radius;\n\n\t\t} else {\n\n\t\t\tblades = max( blades, 3 );\n\n\t\t\tvec3 r = rand3();\n\t\t\tfloat anglePerSegment = 2.0 * PI / float( blades );\n\t\t\tfloat segment = floor( float( blades ) * r.x );\n\n\t\t\tfloat angle1 = anglePerSegment * segment;\n\t\t\tfloat angle2 = angle1 + anglePerSegment;\n\t\t\tvec2 a = vec2( sin( angle1 ), cos( angle1 ) );\n\t\t\tvec2 b = vec2( 0.0, 0.0 );\n\t\t\tvec2 c = vec2( sin( angle2 ), cos( angle2 ) );\n\n\t\t\treturn triangleSample( a, b, c );\n\n\t\t}\n\n\t}\n\n\tfloat colorToLuminance( vec3 color ) {\n\n\t\t// https://en.wikipedia.org/wiki/Relative_luminance\n\t\treturn 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n\n\t}\n\n\t// ray sampling x and z are swapped to align with expected background view\n\tvec2 equirectDirectionToUv( vec3 direction ) {\n\n\t\t// from Spherical.setFromCartesianCoords\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\n\t\tuv /= vec2( 2.0 * PI, PI );\n\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\n\t\tuv.x += 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\t\treturn uv;\n\n\t}\n\n\tvec3 equirectUvToDirection( vec2 uv ) {\n\n\t\t// undo above adjustments\n\t\tuv.x -= 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\n\t\t// from Vector3.setFromSphericalCoords\n\t\tfloat theta = uv.x * 2.0 * PI;\n\t\tfloat phi = uv.y * PI;\n\n\t\tfloat sinPhi = sin( phi );\n\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\n\n\t}\n`;\n","import { WebGLRenderTarget, RGBAFormat, FloatType, PMREMGenerator, DataTexture, EquirectangularReflectionMapping } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { MaterialBase } from '../materials/MaterialBase.js';\nimport { shaderUtils } from '../shader/shaderUtils.js';\n\nclass PMREMCopyMaterial extends MaterialBase {\n\n\tconstructor() {\n\n\t\tsuper( {\n\n\t\t\tuniforms: {\n\n\t\t\t\tenvMap: { value: null },\n\t\t\t\tblur: { value: 0 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t\t${ shaderUtils }\n\n\t\t\t\tuniform sampler2D envMap;\n\t\t\t\tuniform float blur;\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 rayDirection = equirectUvToDirection( vUv );\n\t\t\t\t\tgl_FragColor = textureCubeUV( envMap, rayDirection, blur );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t} );\n\n\t}\n\n}\n\nexport class BlurredEnvMapGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis.renderer = renderer;\n\t\tthis.pmremGenerator = new PMREMGenerator( renderer );\n\t\tthis.copyQuad = new FullScreenQuad( new PMREMCopyMaterial() );\n\t\tthis.renderTarget = new WebGLRenderTarget( 1, 1, { type: FloatType, format: RGBAFormat } );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.pmremGenerator.dispose();\n\t\tthis.copyQuad.dispose();\n\t\tthis.renderTarget.dispose();\n\n\t}\n\n\tgenerate( texture, blur ) {\n\n\t\tconst { pmremGenerator, renderTarget, copyQuad, renderer } = this;\n\n\t\t// get the pmrem target\n\t\tconst pmremTarget = pmremGenerator.fromEquirectangular( texture );\n\n\t\t// set up the material\n\t\tconst { width, height } = texture.image;\n\t\trenderTarget.setSize( width, height );\n\t\tcopyQuad.material.envMap = pmremTarget.texture;\n\t\tcopyQuad.material.blur = blur;\n\n\t\t// render\n\t\tconst prevRenderTarget = renderer.getRenderTarget();\n\t\tconst prevClear = renderer.autoClear;\n\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.autoClear = true;\n\t\tcopyQuad.render( renderer );\n\n\t\trenderer.setRenderTarget( prevRenderTarget );\n\t\trenderer.autoClear = prevClear;\n\n\t\t// read the data back\n\t\tconst buffer = new Float32Array( width * height * 4 );\n\t\trenderer.readRenderTargetPixels( renderTarget, 0, 0, width, height, buffer );\n\n\t\tconst result = new DataTexture( buffer, width, height, RGBAFormat, FloatType );\n\t\tresult.minFilter = texture.minFilter;\n\t\tresult.magFilter = texture.magFilter;\n\t\tresult.wrapS = texture.wrapS;\n\t\tresult.wrapT = texture.wrapT;\n\t\tresult.mapping = EquirectangularReflectionMapping;\n\t\tresult.needsUpdate = true;\n\n\t\treturn result;\n\n\t}\n\n}\n","export const shaderMaterialStructs = /* glsl */ `\n\n\tstruct PhysicalCamera {\n\n\t\tfloat focusDistance;\n\t\tfloat anamorphicRatio;\n\t\tfloat bokehSize;\n\t\tint apertureBlades;\n\t\tfloat apertureRotation;\n\n\t};\n\n\tstruct EquirectHdrInfo {\n\n\t\tsampler2D marginalWeights;\n\t\tsampler2D conditionalWeights;\n\t\tsampler2D map;\n\t\tsampler2D totalSum;\n\n\t};\n\n\tstruct Material {\n\n\t\tvec3 color;\n\t\tint map;\n\n\t\tfloat metalness;\n\t\tint metalnessMap;\n\n\t\tfloat roughness;\n\t\tint roughnessMap;\n\n\t\tfloat ior;\n\t\tfloat transmission;\n\t\tint transmissionMap;\n\n\t\tfloat emissiveIntensity;\n\t\tvec3 emissive;\n\t\tint emissiveMap;\n\n\t\tint normalMap;\n\t\tvec2 normalScale;\n\n\t\tbool castShadow;\n\t\tfloat opacity;\n\t\tfloat alphaTest;\n\n\t\tfloat side;\n\t\tbool matte;\n\n\t\tmat3 matTransform;\n\n\t};\n\n\tMaterial readMaterialInfo( sampler2D tex, uint index ) {\n\n\t\tuint i = index * 9u;\n\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\n\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\n\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\n\t\tvec4 s6 = texelFetch1D( tex, i + 6u );\n\t\tvec4 s7 = texelFetch1D( tex, i + 7u );\n\t\tvec4 s8 = texelFetch1D( tex, i + 8u );\n\n\n\t\tMaterial m;\n\t\tm.color = s0.rgb;\n\t\tm.map = int( round( s0.a ) );\n\n\t\tm.metalness = s1.r;\n\t\tm.metalnessMap = int( round( s1.g ) );\n\t\tm.roughness = s1.b;\n\t\tm.roughnessMap = int( round( s1.a ) );\n\n\t\tm.ior = s2.r;\n\t\tm.transmission = s2.g;\n\t\tm.transmissionMap = int( round( s2.b ) );\n\t\tm.emissiveIntensity = s2.a;\n\n\t\tm.emissive = s3.rgb;\n\t\tm.emissiveMap = int( round( s3.a ) );\n\n\t\tm.normalMap = int( round( s4.r ) );\n\t\tm.normalScale = s4.gb;\n\n\t\tm.opacity = s5.r;\n\t\tm.alphaTest = s5.g;\n\t\tm.side = s5.b;\n\t\tm.matte = bool( s5.a );\n\n\t\tm.castShadow = ! bool( s6.r );\n\n\t\tm.matTransform[0] = vec3(s7.r, s8.r, 0.0);\n\t\tm.matTransform[1] = vec3(s7.g, s8.g, 0.0);\n\t\tm.matTransform[2] = vec3(s7.b, s8.b, 1.0);\n\n\t\treturn m;\n\n\t}\n\n`;\n","export const shaderGGXFunctions = /* glsl */`\n// The GGX functions provide sampling and distribution information for normals as output so\n// in order to get probability of scatter direction the half vector must be computed and provided.\n// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n// [2] http://jcgt.org/published/0007/04/01/\n// [4] http://jcgt.org/published/0003/02/03/\n\n// trowbridge-reitz === GGX === GTR\n\nvec3 ggxDirection( vec3 incidentDir, float roughnessX, float roughnessY, float random1, float random2 ) {\n\n\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t// function below, as well\n\n\t// Implementation from reference [1]\n\t// stretch view\n\tvec3 V = normalize( vec3( roughnessX * incidentDir.x, roughnessY * incidentDir.y, incidentDir.z ) );\n\n\t// orthonormal basis\n\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\n\tvec3 T2 = cross( T1, V );\n\n\t// sample point with polar coordinates (r, phi)\n\tfloat a = 1.0 / ( 1.0 + V.z );\n\tfloat r = sqrt( random1 );\n\tfloat phi = ( random2 < a ) ? random2 / a * PI : PI + ( random2 - a ) / ( 1.0 - a ) * PI;\n\tfloat P1 = r * cos( phi );\n\tfloat P2 = r * sin( phi ) * ( ( random2 < a ) ? 1.0 : V.z );\n\n\t// compute normal\n\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\n\n\t// unstretch\n\tN = normalize( vec3( roughnessX * N.x, roughnessY * N.y, max( 0.0, N.z ) ) );\n\n\treturn N;\n\n}\n\n// Below are PDF and related functions for use in a Monte Carlo path tracer\n// as specified in Appendix B of the following paper\n// See equation (2) from reference [2]\nfloat ggxLamda( float theta, float roughness ) {\n\n\tfloat tanTheta = tan( theta );\n\tfloat tanTheta2 = tanTheta * tanTheta;\n\tfloat alpha2 = roughness * roughness;\n\n\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\n\treturn numerator / 2.0;\n\n}\n\n// See equation (2) from reference [2]\nfloat ggxShadowMaskG1( float theta, float roughness ) {\n\n\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n}\n\n// See equation (125) from reference [4]\nfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\n\n\tfloat incidentTheta = acos( wi.z );\n\tfloat scatterTheta = acos( wo.z );\n\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n}\n\nfloat ggxDistribution( vec3 halfVector, float roughness ) {\n\n\t// See equation (33) from reference [0]\n\tfloat a2 = roughness * roughness;\n\tfloat cosTheta = halfVector.z;\n\tfloat cosTheta4 = pow( cosTheta, 4.0 );\n\n\tif ( cosTheta == 0.0 ) return 0.0;\n\n\tfloat theta = acos( halfVector.z );\n\tfloat tanTheta = tan( theta );\n\tfloat tanTheta2 = pow( tanTheta, 2.0 );\n\n\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\n\treturn a2 / denom;\n\n\t// See equation (1) from reference [2]\n\t// const { x, y, z } = halfVector;\n\t// const a2 = roughness * roughness;\n\t// const mult = x * x / a2 + y * y / a2 + z * z;\n\t// const mult2 = mult * mult;\n\n\t// return 1.0 / Math.PI * a2 * mult2;\n\n}\n\n// See equation (3) from reference [2]\nfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\n\n\tfloat incidentTheta = acos( wi.z );\n\tfloat D = ggxDistribution( halfVector, roughness );\n\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\n\n}\n`;\n","import { shaderGGXFunctions } from './shaderGGXFunctions.js';\n\nexport const shaderMaterialSampling = /* glsl */`\n\nstruct SurfaceRec {\n\tvec3 normal;\n\tvec3 faceNormal;\n\tbool frontFace;\n\tfloat roughness;\n\tfloat filteredRoughness;\n\tfloat metalness;\n\tvec3 color;\n\tvec3 emission;\n\tfloat transmission;\n\tfloat ior;\n};\n\nstruct SampleRec {\n\tfloat specularPdf;\n\tfloat pdf;\n\tvec3 direction;\n\tvec3 color;\n};\n\n${ shaderGGXFunctions }\n\n// diffuse\nfloat diffusePDF( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#lightscattering/thescatteringpdf\n\tfloat cosValue = wi.z;\n\treturn cosValue / PI;\n\n}\n\nvec3 diffuseDirection( vec3 wo, SurfaceRec surf ) {\n\n\tvec3 lightDirection = randDirection();\n\tlightDirection.z += 1.0;\n\tlightDirection = normalize( lightDirection );\n\n\treturn lightDirection;\n\n}\n\nvec3 diffuseColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// TODO: scale by 1 - F here\n\t// note on division by PI\n\t// https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n\tfloat metalFactor = ( 1.0 - surf.metalness ) * wi.z / ( PI * PI );\n\tfloat transmissionFactor = 1.0 - surf.transmission;\n\treturn surf.color * metalFactor * transmissionFactor;\n\n}\n\n// specular\nfloat specularPDF( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// See equation (17) in http://jcgt.org/published/0003/02/03/\n\tfloat filteredRoughness = surf.filteredRoughness;\n\tvec3 halfVector = getHalfVector( wi, wo );\n\treturn ggxPDF( wi, halfVector, filteredRoughness ) / ( 4.0 * dot( wi, halfVector ) );\n\n}\n\nvec3 specularDirection( vec3 wo, SurfaceRec surf ) {\n\n\t// sample ggx vndf distribution which gives a new normal\n\tfloat filteredRoughness = surf.filteredRoughness;\n\tvec3 halfVector = ggxDirection(\n\t\two,\n\t\tfilteredRoughness,\n\t\tfilteredRoughness,\n\t\trand(),\n\t\trand()\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\treturn - reflect( wo, halfVector );\n\n}\n\nvec3 specularColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// if roughness is set to 0 then D === NaN which results in black pixels\n\tfloat metalness = surf.metalness;\n\tfloat ior = surf.ior;\n\tbool frontFace = surf.frontFace;\n\tfloat filteredRoughness = surf.filteredRoughness;\n\n\tvec3 halfVector = getHalfVector( wo, wi );\n\tfloat iorRatio = frontFace ? 1.0 / ior : ior;\n\tfloat G = ggxShadowMaskG2( wi, wo, filteredRoughness );\n\tfloat D = ggxDistribution( halfVector, filteredRoughness );\n\n\tfloat F = schlickFresnelFromIor( dot( wi, halfVector ), iorRatio );\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tbool cannotRefract = iorRatio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\tF = 1.0;\n\n\t}\n\n\tvec3 color = mix( vec3( 1.0 ), surf.color, metalness );\n\tcolor = mix( color, vec3( 1.0 ), F );\n\tcolor *= G * D / ( 4.0 * abs( wi.z * wo.z ) );\n\tcolor *= mix( F, 1.0, metalness );\n\tcolor *= wi.z; // scale the light by the direction the light is coming in from\n\n\treturn color;\n\n}\n\n/*\n// transmission\nfunction transmissionPDF( wo, wi, material, surf ) {\n\n\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? ior : 1 / ior;\n\tconst minRoughness = Math.max( roughness, MIN_ROUGHNESS );\n\n\thalfVector.set( 0, 0, 0 ).addScaledVector( wi, ratio ).addScaledVector( wo, 1.0 ).normalize().multiplyScalar( - 1 );\n\n\tconst denom = Math.pow( ratio * halfVector.dot( wi ) + 1.0 * halfVector.dot( wo ), 2.0 );\n\treturn ggxPDF( wo, halfVector, minRoughness ) / denom;\n\n}\n\nfunction transmissionDirection( wo, hit, material, lightDirection ) {\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? 1 / ior : ior;\n\tconst minRoughness = Math.max( roughness, MIN_ROUGHNESS );\n\n\t// sample ggx vndf distribution which gives a new normal\n\tggxDirection(\n\t\two,\n\t\tminRoughness,\n\t\tminRoughness,\n\t\tMath.random(),\n\t\tMath.random(),\n\t\thalfVector,\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\ttempDir.copy( wo ).multiplyScalar( - 1 );\n\trefract( tempDir, halfVector, ratio, lightDirection );\n\n}\n\nfunction transmissionColor( wo, wi, material, hit, colorTarget ) {\n\n\tconst { metalness, transmission } = material;\n\tcolorTarget\n\t\t.copy( material.color )\n\t\t.multiplyScalar( ( 1.0 - metalness ) * wo.z )\n\t\t.multiplyScalar( transmission );\n\n}\n*/\n\n// TODO: This is just using a basic cosine-weighted specular distribution with an\n// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\nfloat transmissionPDF( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\tfloat ior = surf.ior;\n\tbool frontFace = surf.frontFace;\n\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tfloat reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tbool cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treturn 0.0;\n\n\t}\n\n\treturn 1.0 / ( 1.0 - reflectance );\n\n}\n\nvec3 transmissionDirection( vec3 wo, SurfaceRec surf ) {\n\n\tfloat roughness = surf.roughness;\n\tfloat ior = surf.ior;\n\tbool frontFace = surf.frontFace;\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\n\n\tvec3 lightDirection = refract( - wo, vec3( 0.0, 0.0, 1.0 ), ratio );\n\tlightDirection += randDirection() * roughness;\n\treturn normalize( lightDirection );\n\n}\n\nvec3 transmissionColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\tfloat metalness = surf.metalness;\n\tfloat transmission = surf.transmission;\n\n\tvec3 color = surf.color;\n\tcolor *= ( 1.0 - metalness );\n\tcolor *= transmission;\n\n\treturn color;\n\n}\n\nfloat bsdfPdf( vec3 wo, vec3 wi, SurfaceRec surf, out float specularPdf ) {\n\n\tfloat ior = surf.ior;\n\tfloat metalness = surf.metalness;\n\tfloat transmission = surf.transmission;\n\tbool frontFace = surf.frontFace;\n\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tfloat reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tbool cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treflectance = 1.0;\n\n\t}\n\n\tfloat spdf = 0.0;\n\tfloat dpdf = 0.0;\n\tfloat tpdf = 0.0;\n\n\tif ( wi.z < 0.0 ) {\n\n\t\ttpdf = transmissionPDF( wo, wi, surf );\n\n\t} else {\n\n\t\tspdf = specularPDF( wo, wi, surf );\n\t\tdpdf = diffusePDF( wo, wi, surf );\n\n\t}\n\n\tfloat transSpecularProb = mix( reflectance, 1.0, metalness );\n\tfloat diffSpecularProb = 0.5 + 0.5 * metalness;\n\tfloat pdf =\n\t\tspdf * transmission * transSpecularProb\n\t\t+ tpdf * transmission * ( 1.0 - transSpecularProb )\n\t\t+ spdf * ( 1.0 - transmission ) * diffSpecularProb\n\t\t+ dpdf * ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb );\n\n\t// retrieve specular rays for the shadows flag\n\tspecularPdf = spdf * transmission * transSpecularProb + spdf * ( 1.0 - transmission ) * diffSpecularProb;\n\n\treturn pdf;\n\n}\n\nvec3 bsdfColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\tvec3 color = vec3( 0.0 );\n\tif ( wi.z < 0.0 ) {\n\n\t\tcolor = transmissionColor( wo, wi, surf );\n\n\t} else {\n\n\t\tcolor = diffuseColor( wo, wi, surf );\n\t\tcolor *= 1.0 - surf.transmission;\n\n\t\tcolor += specularColor( wo, wi, surf );\n\n\t}\n\n\treturn color;\n\n}\n\nfloat bsdfResult( vec3 wo, vec3 wi, SurfaceRec surf, out vec3 color ) {\n\n\tfloat specularPdf;\n\tcolor = bsdfColor( wo, wi, surf );\n\treturn bsdfPdf( wo, wi, surf, specularPdf );\n\n}\n\nSampleRec bsdfSample( vec3 wo, SurfaceRec surf ) {\n\n\tfloat ior = surf.ior;\n\tfloat metalness = surf.metalness;\n\tfloat transmission = surf.transmission;\n\tbool frontFace = surf.frontFace;\n\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tfloat reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tbool cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treflectance = 1.0;\n\n\t}\n\n\tSampleRec result;\n\tif ( rand() < transmission ) {\n\n\t\tfloat specularProb = mix( reflectance, 1.0, metalness );\n\t\tif ( rand() < specularProb ) {\n\n\t\t\tresult.direction = specularDirection( wo, surf );\n\n\t\t} else {\n\n\t\t\tresult.direction = transmissionDirection( wo, surf );\n\n\t\t}\n\n\t} else {\n\n\t\tfloat specularProb = 0.5 + 0.5 * metalness;\n\t\tif ( rand() < specularProb ) {\n\n\t\t\tresult.direction = specularDirection( wo, surf );\n\n\t\t} else {\n\n\t\t\tresult.direction = diffuseDirection( wo, surf );\n\n\t\t}\n\n\t}\n\n\tresult.pdf = bsdfPdf( wo, result.direction, surf, result.specularPdf );\n\tresult.color = bsdfColor( wo, result.direction, surf );\n\treturn result;\n\n}\n`;\n","export const shaderEnvMapSampling = /* glsl */`\n\nvec3 sampleEquirectEnvMapColor( vec3 direction, sampler2D map ) {\n\n\treturn texture2D( map, equirectDirectionToUv( direction ) ).rgb;\n\n}\n\nfloat envMapDirectionPdf( vec3 direction ) {\n\n\tvec2 uv = equirectDirectionToUv( direction );\n\tfloat theta = uv.y * PI;\n\tfloat sinTheta = sin( theta );\n\tif ( sinTheta == 0.0 ) {\n\n\t\treturn 0.0;\n\n\t}\n\n\treturn 1.0 / ( 2.0 * PI * PI * sinTheta );\n\n}\n\nfloat envMapSample( vec3 direction, EquirectHdrInfo info, out vec3 color ) {\n\n\tvec2 uv = equirectDirectionToUv( direction );\n\tcolor = texture2D( info.map, uv ).rgb;\n\n\tfloat totalSum = texture2D( info.totalSum, vec2( 0.0 ) ).r;\n\tfloat lum = colorToLuminance( color );\n\tivec2 resolution = textureSize( info.map, 0 );\n\tfloat pdf = lum / totalSum;\n\n\treturn float( resolution.x * resolution.y ) * pdf * envMapDirectionPdf( direction );\n\n}\n\nfloat randomEnvMapSample( EquirectHdrInfo info, out vec3 color, out vec3 direction ) {\n\n\t// sample env map cdf\n\tvec2 r = rand2();\n\tfloat v = texture2D( info.marginalWeights, vec2( r.x, 0.0 ) ).x;\n\tfloat u = texture2D( info.conditionalWeights, vec2( r.y, v ) ).x;\n\tvec2 uv = vec2( u, v );\n\n\tvec3 derivedDirection = equirectUvToDirection( uv );\n\tdirection = derivedDirection;\n\tcolor = texture2D( info.map, uv ).rgb;\n\n\tfloat totalSum = texture2D( info.totalSum, vec2( 0.0 ) ).r;\n\tfloat lum = colorToLuminance( color );\n\tivec2 resolution = textureSize( info.map, 0 );\n\tfloat pdf = lum / totalSum;\n\n\treturn float( resolution.x * resolution.y ) * pdf * envMapDirectionPdf( direction );\n\n}\n\nfloat misHeuristic( float a, float b ) {\n\n\tfloat aa = a * a;\n\tfloat bb = a * b;\n\treturn aa / ( bb + aa );\n\n}\n\n`;\n","import { Matrix4, Matrix3, Color, Vector2 } from 'three';\nimport { MaterialBase } from './MaterialBase.js';\nimport {\n\tMeshBVHUniformStruct, FloatVertexAttributeTexture, UIntVertexAttributeTexture,\n\tshaderStructs, shaderIntersectFunction,\n} from 'three-mesh-bvh';\nimport { shaderMaterialStructs } from '../shader/shaderStructs.js';\nimport { MaterialsTexture } from '../uniforms/MaterialsTexture.js';\nimport { RenderTarget2DArray } from '../uniforms/RenderTarget2DArray.js';\nimport { shaderMaterialSampling } from '../shader/shaderMaterialSampling.js';\nimport { shaderEnvMapSampling } from '../shader/shaderEnvMapSampling.js';\nimport { shaderUtils } from '../shader/shaderUtils.js';\nimport { PhysicalCameraUniform } from '../uniforms/PhysicalCameraUniform.js';\nimport { EquirectHdrInfoUniform } from '../uniforms/EquirectHdrInfoUniform.js';\n\nexport class PhysicalPathTracingMaterial extends MaterialBase {\n\n\tonBeforeRender() {\n\n\t\tthis.setDefine( 'FEATURE_DOF', this.physicalCamera.bokehSize === 0 ? 0 : 1 );\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\ttransparent: true,\n\t\t\tdepthWrite: false,\n\n\t\t\tdefines: {\n\t\t\t\tFEATURE_MIS: 1,\n\t\t\t\tFEATURE_DOF: 1,\n\t\t\t\tFEATURE_GRADIENT_BG: 0,\n\t\t\t\tTRANSPARENT_TRAVERSALS: 5,\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\tresolution: { value: new Vector2() },\n\n\t\t\t\tbounces: { value: 3 },\n\t\t\t\tphysicalCamera: { value: new PhysicalCameraUniform() },\n\n\t\t\t\tbvh: { value: new MeshBVHUniformStruct() },\n\t\t\t\tnormalAttribute: { value: new FloatVertexAttributeTexture() },\n\t\t\t\ttangentAttribute: { value: new FloatVertexAttributeTexture() },\n\t\t\t\tuvAttribute: { value: new FloatVertexAttributeTexture() },\n\t\t\t\tmaterialIndexAttribute: { value: new UIntVertexAttributeTexture() },\n\t\t\t\tmaterials: { value: new MaterialsTexture() },\n\t\t\t\ttextures: { value: new RenderTarget2DArray().texture },\n\t\t\t\tcameraWorldMatrix: { value: new Matrix4() },\n\t\t\t\tinvProjectionMatrix: { value: new Matrix4() },\n\t\t\t\tbackgroundBlur: { value: 0.0 },\n\t\t\t\tenvironmentIntensity: { value: 2.0 },\n\t\t\t\tenvironmentRotation: { value: new Matrix3() },\n\t\t\t\tenvMapInfo: { value: new EquirectHdrInfoUniform() },\n\n\t\t\t\tseed: { value: 0 },\n\t\t\t\topacity: { value: 1 },\n\t\t\t\tfilterGlossyFactor: { value: 0.0 },\n\n\t\t\t\tbgGradientTop: { value: new Color( 0x111111 ) },\n\t\t\t\tbgGradientBottom: { value: new Color( 0x000000 ) },\n\t\t\t\tbackgroundAlpha: { value: 1.0 },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 mvPosition = vec4( position, 1.0 );\n\t\t\t\t\tmvPosition = modelViewMatrix * mvPosition;\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\tvUv = uv;\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\t#define RAY_OFFSET 1e-4\n\n\t\t\t\tprecision highp isampler2D;\n\t\t\t\tprecision highp usampler2D;\n\t\t\t\tprecision highp sampler2DArray;\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\t\t\t\t#include <common>\n\n\t\t\t\t${ shaderStructs }\n\t\t\t\t${ shaderIntersectFunction }\n\t\t\t\t${ shaderMaterialStructs }\n\n\t\t\t\t${ shaderUtils }\n\t\t\t\t${ shaderMaterialSampling }\n\t\t\t\t${ shaderEnvMapSampling }\n\n\t\t\t\tuniform mat3 environmentRotation;\n\t\t\t\tuniform float backgroundBlur;\n\t\t\t\tuniform float backgroundAlpha;\n\n\t\t\t\t#if FEATURE_GRADIENT_BG\n\n\t\t\t\tuniform vec3 bgGradientTop;\n\t\t\t\tuniform vec3 bgGradientBottom;\n\n\t\t\t\t#endif\n\n\t\t\t\t#if FEATURE_DOF\n\n\t\t\t\tuniform PhysicalCamera physicalCamera;\n\n\t\t\t\t#endif\n\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tuniform int bounces;\n\t\t\t\tuniform mat4 cameraWorldMatrix;\n\t\t\t\tuniform mat4 invProjectionMatrix;\n\t\t\t\tuniform sampler2D normalAttribute;\n\t\t\t\tuniform sampler2D tangentAttribute;\n\t\t\t\tuniform sampler2D uvAttribute;\n\t\t\t\tuniform usampler2D materialIndexAttribute;\n\t\t\t\tuniform BVH bvh;\n\t\t\t\tuniform float environmentIntensity;\n\t\t\t\tuniform float filterGlossyFactor;\n\t\t\t\tuniform int seed;\n\t\t\t\tuniform float opacity;\n\t\t\t\tuniform sampler2D materials;\n\n\t\t\t\tuniform EquirectHdrInfo envMapInfo;\n\n\t\t\t\tuniform sampler2DArray textures;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvec3 sampleBackground( vec3 direction ) {\n\n\t\t\t\t\t#if FEATURE_GRADIENT_BG\n\n\t\t\t\t\tdirection = normalize( direction + randDirection() * 0.05 );\n\n\t\t\t\t\tfloat value = ( direction.y + 1.0 ) / 2.0;\n\t\t\t\t\tvalue = pow( value, 2.0 );\n\n\t\t\t\t\treturn mix( bgGradientBottom, bgGradientTop, value );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\tvec3 sampleDir = normalize( direction + getHemisphereSample( direction, rand2() ) * 0.5 * backgroundBlur );\n\t\t\t\t\treturn environmentIntensity * sampleEquirectEnvMapColor( sampleDir, envMapInfo.map );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\n\t\t\t\t// step through multiple surface hits and accumulate color attenuation based on transmissive surfaces\n\t\t\t\tbool attenuateHit( BVH bvh, vec3 rayOrigin, vec3 rayDirection, int traversals, bool isShadowRay, out vec3 color ) {\n\n\t\t\t\t\t// hit results\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\tfloat dist = 0.0;\n\n\t\t\t\t\tcolor = vec3( 1.0 );\n\n\t\t\t\t\tfor ( int i = 0; i < traversals; i ++ ) {\n\n\t\t\t\t\t\tif ( bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist ) ) {\n\n\t\t\t\t\t\t\t// TODO: attenuate the contribution based on the PDF of the resulting ray including refraction values\n\t\t\t\t\t\t\t// Should be able to work using the material BSDF functions which will take into account specularity, etc.\n\t\t\t\t\t\t\t// TODO: should we account for emissive surfaces here?\n\n\t\t\t\t\t\t\tvec2 uv = textureSampleBarycoord( uvAttribute, barycoord, faceIndices.xyz ).xy;\n\t\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\t\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\n\n\t\t\t\t\t\t\t// adjust the ray to the new surface\n\t\t\t\t\t\t\tbool isBelowSurface = dot( rayDirection, faceNormal ) < 0.0;\n\t\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\t\tvec3 absPoint = abs( point );\n\t\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\t\t\t\t\t\trayOrigin = point + faceNormal * ( maxPoint + 1.0 ) * ( isBelowSurface ? - RAY_OFFSET : RAY_OFFSET );\n\n\t\t\t\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\n\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Opacity Test\n\n\t\t\t\t\t\t\t// albedo\n\t\t\t\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\t\t\t\t\t\tif ( material.map != - 1 ) {\n\n\t\t\t\t\t\t\t\talbedo *= texture2D( textures, vec3( material.matTranform * uv, material.map ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// transmission\n\t\t\t\t\t\t\tfloat transmission = material.transmission;\n\t\t\t\t\t\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\t\t\t\t\t\ttransmission *= texture2D( textures, vec3( uv, material.transmissionMap ) ).r;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// metalness\n\t\t\t\t\t\t\tfloat metalness = material.metalness;\n\t\t\t\t\t\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\t\t\t\t\t\tmetalness *= texture2D( textures, vec3( uv, material.metalnessMap ) ).b;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfloat alphaTest = material.alphaTest;\n\t\t\t\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\t\t\t\t\t\tfloat transmissionFactor = ( 1.0 - metalness ) * transmission;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\ttransmissionFactor < rand() && ! (\n\t\t\t\t\t\t\t\t\t// material sidedness\n\t\t\t\t\t\t\t\t\tmaterial.side != 0.0 && side == material.side\n\n\t\t\t\t\t\t\t\t\t// alpha test\n\t\t\t\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t\t\t\t\t\t\t// opacity\n\t\t\t\t\t\t\t\t\t|| ! useAlphaTest && albedo.a < rand()\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// only attenuate on the way in\n\t\t\t\t\t\t\tif ( isBelowSurface ) {\n\n\t\t\t\t\t\t\t\tcolor *= albedo.rgb;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\t// returns whether the ray hit anything, not just the first surface. Could be optimized to not check the full hierarchy.\n\t\t\t\tbool anyHit( BVH bvh, vec3 rayOrigin, vec3 rayDirection ) {\n\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\tfloat dist = 0.0;\n\t\t\t\t\treturn bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n\n\t\t\t\t}\n\n\t\t\t\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\n\t\t\t\t// erichlof/THREE.js-PathTracing-Renderer/\n\t\t\t\tfloat tentFilter( float x ) {\n\n\t\t\t\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\n\n\t\t\t\t\t// get [-1, 1] normalized device coordinates\n\t\t\t\t\tvec2 ndc = 2.0 * vUv - vec2( 1.0 );\n\t\t\t\t\tvec3 rayOrigin, rayDirection;\n\t\t\t\t\tndcToCameraRay( ndc, cameraWorldMatrix, invProjectionMatrix, rayOrigin, rayDirection );\n\n\t\t\t\t\t// Jitter the camera ray by finding a new subpixel point to point to from the camera origin\n\t\t\t\t\t// This is better than just jittering the camera position since it actually results in divergent\n\t\t\t\t\t// rays providing better coverage for the pixel\n\t\t\t\t\t{\n\n\t\t\t\t\t\t// TODO: the complexity here could be improved\n\t\t\t\t\t\tvec3 cameraOrigin = ( cameraWorldMatrix * vec4( 0.0, 0.0, 0.0, 1.0 ) ).xyz;\n\t\t\t\t\t\tvec3 ss00, ss01, ss10, temp;\n\t\t\t\t\t\tndcToCameraRay( vec2( - 1.0, - 1.0 ), cameraWorldMatrix, invProjectionMatrix, ss00, temp );\n\t\t\t\t\t\tndcToCameraRay( vec2( - 1.0, 1.0 ), cameraWorldMatrix, invProjectionMatrix, ss01, temp );\n\t\t\t\t\t\tndcToCameraRay( vec2( 1.0, - 1.0 ), cameraWorldMatrix, invProjectionMatrix, ss10, temp );\n\n\t\t\t\t\t\tvec3 ssdX = ( ss10 - ss00 ) / resolution.x;\n\t\t\t\t\t\tvec3 ssdY = ( ss01 - ss00 ) / resolution.y;\n\t\t\t\t\t\trayOrigin += tentFilter( rand() ) * ssdX + tentFilter( rand() ) * ssdY;\n\t\t\t\t\t\trayDirection = normalize( rayOrigin - cameraOrigin );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t#if FEATURE_DOF\n\t\t\t\t\t{\n\n\t\t\t\t\t\t// depth of field\n\t\t\t\t\t\tvec3 focalPoint = rayOrigin + normalize( rayDirection ) * physicalCamera.focusDistance;\n\n\t\t\t\t\t\t// get the aperture sample\n\t\t\t\t\t\tvec2 apertureSample = sampleAperture( physicalCamera.apertureBlades ) * physicalCamera.bokehSize * 0.5 * 1e-3;\n\n\t\t\t\t\t\t// rotate the aperture shape\n\t\t\t\t\t\tfloat ac = cos( physicalCamera.apertureRotation );\n\t\t\t\t\t\tfloat as = sin( physicalCamera.apertureRotation );\n\t\t\t\t\t\tapertureSample = vec2(\n\t\t\t\t\t\t\tapertureSample.x * ac - apertureSample.y * as,\n\t\t\t\t\t\t\tapertureSample.x * as + apertureSample.y * ac\n\t\t\t\t\t\t);\n\t\t\t\t\t\tapertureSample.x *= saturate( physicalCamera.anamorphicRatio );\n\t\t\t\t\t\tapertureSample.y *= saturate( 1.0 / physicalCamera.anamorphicRatio );\n\n\t\t\t\t\t\t// create the new ray\n\t\t\t\t\t\trayOrigin += ( cameraWorldMatrix * vec4( apertureSample, 0.0, 0.0 ) ).xyz;\n\t\t\t\t\t\trayDirection = focalPoint - rayOrigin;\n\n\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t\trayDirection = normalize( rayDirection );\n\n\t\t\t\t\t// inverse environment rotation\n\t\t\t\t\tmat3 invEnvironmentRotation = inverse( environmentRotation );\n\n\t\t\t\t\t// final color\n\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t// hit results\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\tfloat dist = 0.0;\n\n\t\t\t\t\t// path tracing state\n\t\t\t\t\tfloat accumulatedRoughness = 0.0;\n\t\t\t\t\tbool transmissiveRay = true;\n\t\t\t\t\tint transparentTraversals = TRANSPARENT_TRAVERSALS;\n\t\t\t\t\tvec3 throughputColor = vec3( 1.0 );\n\t\t\t\t\tSampleRec sampleRec;\n\t\t\t\t\tint i;\n\t\t\t\t\tbool isShadowRay = false;\n\n\t\t\t\t\tfor ( i = 0; i < bounces; i ++ ) {\n\n\t\t\t\t\t\tif ( ! bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist ) ) {\n\n\t\t\t\t\t\t\tif ( i == 0 || transmissiveRay ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += sampleBackground( environmentRotation * rayDirection ) * throughputColor;\n\t\t\t\t\t\t\t\tgl_FragColor.a = backgroundAlpha;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t\t\t// get the PDF of the hit envmap point\n\t\t\t\t\t\t\t\tvec3 envColor;\n\t\t\t\t\t\t\t\tfloat envPdf = envMapSample( environmentRotation * rayDirection, envMapInfo, envColor );\n\n\t\t\t\t\t\t\t\t// and weight the contribution\n\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( sampleRec.pdf, envPdf );\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += environmentIntensity * envColor * throughputColor * misWeight;\n\n\t\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb +=\n\t\t\t\t\t\t\t\t\tenvironmentIntensity *\n\t\t\t\t\t\t\t\t\tsampleEquirectEnvMapColor( environmentRotation * rayDirection, envMapInfo.map ) *\n\t\t\t\t\t\t\t\t\tthroughputColor;\n\n\t\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\n\n\t\t\t\t\t\tif ( material.matte && i == 0 ) {\n\n\t\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we've determined that this is a shadow ray and we've hit an item with no shadow casting\n\t\t\t\t\t\t// then skip it\n\t\t\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\n\n\t\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\t\tvec3 absPoint = abs( point );\n\t\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\t\t\t\t\t\trayOrigin = point - ( maxPoint + 1.0 ) * faceNormal * RAY_OFFSET;\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvec2 uv = textureSampleBarycoord( uvAttribute, barycoord, faceIndices.xyz ).xy;\n\n\t\t\t\t\t\t// albedo\n\t\t\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\t\t\t\t\tif ( material.map != - 1 ) {\n\n\t\t\t\t\t\t\talbedo *= texture2D( textures, vec3( uv, material.map ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// possibly skip this sample if it's transparent, alpha test is enabled, or we hit the wrong material side\n\t\t\t\t\t\t// and it's single sided.\n\t\t\t\t\t\t// - alpha test is disabled when it === 0\n\t\t\t\t\t\t// - the material sidedness test is complicated because we want light to pass through the back side but still\n\t\t\t\t\t\t// be able to see the front side. This boolean checks if the side we hit is the front side on the first ray\n\t\t\t\t\t\t// and we're rendering the other then we skip it. Do the opposite on subsequent bounces to get incoming light.\n\t\t\t\t\t\tfloat alphaTest = material.alphaTest;\n\t\t\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\t\t\t\t\tbool isFirstHit = i == 0;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t// material sidedness\n\t\t\t\t\t\t\tmaterial.side != 0.0 && ( side != material.side ) == isFirstHit\n\n\t\t\t\t\t\t\t// alpha test\n\t\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t\t\t\t\t// opacity\n\t\t\t\t\t\t\t|| ! useAlphaTest && albedo.a < rand()\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\t\tvec3 absPoint = abs( point );\n\t\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\t\t\t\t\t\trayOrigin = point - ( maxPoint + 1.0 ) * faceNormal * RAY_OFFSET;\n\n\t\t\t\t\t\t\t// only allow a limited number of transparency discards otherwise we could\n\t\t\t\t\t\t\t// crash the context with too long a loop.\n\t\t\t\t\t\t\ti -= sign( transparentTraversals );\n\t\t\t\t\t\t\ttransparentTraversals -= sign( transparentTraversals );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// fetch the interpolated smooth normal\n\t\t\t\t\t\tvec3 normal = normalize( textureSampleBarycoord(\n\t\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t).xyz );\n\n\t\t\t\t\t\t// roughness\n\t\t\t\t\t\tfloat roughness = material.roughness;\n\t\t\t\t\t\tif ( material.roughnessMap != - 1 ) {\n\n\t\t\t\t\t\t\troughness *= texture2D( textures, vec3( uv, material.roughnessMap ) ).g;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// metalness\n\t\t\t\t\t\tfloat metalness = material.metalness;\n\t\t\t\t\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\t\t\t\t\tmetalness *= texture2D( textures, vec3( uv, material.metalnessMap ) ).b;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// emission\n\t\t\t\t\t\tvec3 emission = material.emissiveIntensity * material.emissive;\n\t\t\t\t\t\tif ( material.emissiveMap != - 1 ) {\n\n\t\t\t\t\t\t\temission *= texture2D( textures, vec3( uv, material.emissiveMap ) ).xyz;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// transmission\n\t\t\t\t\t\tfloat transmission = material.transmission;\n\t\t\t\t\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\t\t\t\t\ttransmission *= texture2D( textures, vec3( uv, material.transmissionMap ) ).r;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// normal\n\t\t\t\t\t\tif ( material.normalMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\t\t\t\t\ttangentAttribute,\n\t\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t\t\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\t\t\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\t\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\t\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );\n\t\t\t\t\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t\t\t\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uv, material.normalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\t\t\t\t\ttexNormal.xy *= material.normalScale;\n\t\t\t\t\t\t\t\tnormal = vTBN * texNormal;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnormal *= side;\n\n\t\t\t\t\t\tSurfaceRec surfaceRec;\n\t\t\t\t\t\tsurfaceRec.normal = normal;\n\t\t\t\t\t\tsurfaceRec.faceNormal = faceNormal;\n\t\t\t\t\t\tsurfaceRec.transmission = transmission;\n\t\t\t\t\t\tsurfaceRec.ior = material.ior;\n\t\t\t\t\t\tsurfaceRec.emission = emission;\n\t\t\t\t\t\tsurfaceRec.metalness = metalness;\n\t\t\t\t\t\tsurfaceRec.color = albedo.rgb;\n\t\t\t\t\t\tsurfaceRec.roughness = roughness;\n\n\t\t\t\t\t\t// frontFace is used to determine transmissive properties and PDF. If no transmission is used\n\t\t\t\t\t\t// then we can just always assume this is a front face.\n\t\t\t\t\t\tsurfaceRec.frontFace = side == 1.0 || transmission == 0.0;\n\n\t\t\t\t\t\t// Compute the filtered roughness value to use during specular reflection computations. A minimum\n\t\t\t\t\t\t// value of 1e-6 is needed because the GGX functions do not work with a roughness value of 0 and\n\t\t\t\t\t\t// the accumulated roughness value is scaled by a user setting and a \"magic value\" of 5.0.\n\t\t\t\t\t\t// If we're exiting something transmissive then scale the factor down significantly so we can retain\n\t\t\t\t\t\t// sharp internal reflections\n\t\t\t\t\t\tsurfaceRec.filteredRoughness = clamp(\n\t\t\t\t\t\t\tmax( surfaceRec.roughness, accumulatedRoughness * filterGlossyFactor * 5.0 ),\n\t\t\t\t\t\t\t1e-3,\n\t\t\t\t\t\t\t1.0\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tmat3 normalBasis = getBasisFromNormal( surfaceRec.normal );\n\t\t\t\t\t\tmat3 invBasis = inverse( normalBasis );\n\n\t\t\t\t\t\tvec3 outgoing = - normalize( invBasis * rayDirection );\n\t\t\t\t\t\tsampleRec = bsdfSample( outgoing, surfaceRec );\n\n\t\t\t\t\t\tfloat specRayPdf = specularPDF( outgoing, sampleRec.direction, surfaceRec );\n\t\t\t\t\t\tisShadowRay = sampleRec.specularPdf < rand();\n\n\t\t\t\t\t\t// adjust the hit point by the surface normal by a factor of some offset and the\n\t\t\t\t\t\t// maximum component-wise value of the current point to accommodate floating point\n\t\t\t\t\t\t// error as values increase.\n\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\tvec3 absPoint = abs( point );\n\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\t\t\t\t\trayDirection = normalize( normalBasis * sampleRec.direction );\n\n\t\t\t\t\t\tbool isBelowSurface = dot( rayDirection, faceNormal ) < 0.0;\n\t\t\t\t\t\trayOrigin = point + faceNormal * ( maxPoint + 1.0 ) * ( isBelowSurface ? - RAY_OFFSET : RAY_OFFSET );\n\n\t\t\t\t\t\t// direct env map sampling\n\t\t\t\t\t\t#if FEATURE_MIS\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t// find a sample in the environment map to include in the contribution\n\t\t\t\t\t\t\tvec3 envColor, envDirection;\n\t\t\t\t\t\t\tfloat envPdf = randomEnvMapSample( envMapInfo, envColor, envDirection );\n\t\t\t\t\t\t\tenvDirection = invEnvironmentRotation * envDirection;\n\n\t\t\t\t\t\t\t// this env sampling is not set up for transmissive sampling and yields overly bright\n\t\t\t\t\t\t\t// results so we ignore the sample in this case.\n\t\t\t\t\t\t\t// TODO: this should be improved but how? The env samples could traverse a few layers?\n\t\t\t\t\t\t\tbool isSampleBelowSurface = dot( faceNormal, envDirection ) < 0.0;\n\t\t\t\t\t\t\tif ( isSampleBelowSurface ) {\n\n\t\t\t\t\t\t\t\tenvPdf = 0.0;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// check if a ray could even reach the surface\n\t\t\t\t\t\t\tvec3 attenuatedColor;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tenvPdf > 0.0 &&\n\t\t\t\t\t\t\t\tisDirectionValid( envDirection, normal, faceNormal ) &&\n\t\t\t\t\t\t\t\t! attenuateHit( bvh, rayOrigin, envDirection, bounces - i, isShadowRay, attenuatedColor )\n\t\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t\t// get the material pdf\n\t\t\t\t\t\t\t\tvec3 sampleColor;\n\t\t\t\t\t\t\t\tfloat envMaterialPdf = bsdfResult( outgoing, normalize( invBasis * envDirection ), surfaceRec, sampleColor );\n\t\t\t\t\t\t\t\tif ( envMaterialPdf > 0.0 ) {\n\n\t\t\t\t\t\t\t\t\t// weight the direct light contribution\n\t\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( envPdf, envMaterialPdf );\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += attenuatedColor * environmentIntensity * envColor * throughputColor * sampleColor * misWeight / envPdf;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// accumulate a roughness value to offset diffuse, specular, diffuse rays that have high contribution\n\t\t\t\t\t\t// to a single pixel resulting in fireflies\n\t\t\t\t\t\tif ( ! isBelowSurface ) {\n\n\t\t\t\t\t\t\t// determine if this is a rough normal or not by checking how far off straight up it is\n\t\t\t\t\t\t\tvec3 halfVector = normalize( outgoing + sampleRec.direction );\n\t\t\t\t\t\t\taccumulatedRoughness += sin( acos( halfVector.z ) );\n\t\t\t\t\t\t\ttransmissiveRay = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// accumulate color\n\t\t\t\t\t\tgl_FragColor.rgb += ( emission * throughputColor );\n\n\t\t\t\t\t\t// skip the sample if our PDF or ray is impossible\n\t\t\t\t\t\tif ( sampleRec.pdf <= 0.0 || ! isDirectionValid( rayDirection, normal, faceNormal) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthroughputColor *= sampleRec.color / sampleRec.pdf;\n\n\t\t\t\t\t\t// discard the sample if there are any NaNs\n\t\t\t\t\t\tif ( any( isnan( throughputColor ) ) || any( isinf( throughputColor ) ) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl_FragColor.a *= opacity;\n\n\t\t\t\t}\n\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n","// core\nexport * from './core/PathTracingRenderer.js';\nexport * from './core/PathTracingSceneGenerator.js';\nexport * from './core/DynamicPathTracingSceneGenerator.js';\nexport * from './core/MaterialReducer.js';\nexport * from './core/PhysicalCamera.js';\n\n// uniforms\nexport * from './uniforms/MaterialsTexture.js';\nexport * from './uniforms/RenderTarget2DArray.js';\nexport * from './uniforms/EquirectHdrInfoUniform.js';\nexport * from './uniforms/PhysicalCameraUniform.js';\n\n// utils\nexport * from './utils/GeometryPreparationUtils.js';\nexport * from './utils/BlurredEnvMapGenerator.js';\n\n// materials\nexport * from './materials/MaterialBase.js';\nexport * from './materials/PhysicalPathTracingMaterial.js';\n\n// shaders\nexport * from './shader/shaderMaterialSampling.js';\nexport * from './shader/shaderUtils.js';\nexport * from './shader/shaderStructs.js';\n"],"names":[],"mappings":"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,MAAM,CAAC,SAAS,CAAC;AACrC,GAAG,IAAI,CAAC,cAAc,GAAG,MAAM,CAAC,cAAc,CAAC;AAC/C,GAAG,IAAI,CAAC,gBAAgB,GAAG,MAAM,CAAC,gBAAgB,CAAC;AACnD,GAAG,IAAI,CAAC,aAAa,GAAG,MAAM,CAAC,aAAa,CAAC;AAC7C,GAAG,IAAI,CAAC,eAAe,GAAG,MAAM,CAAC,eAAe,CAAC;AACjD;AACA,GAAG,MAAM;AACT;AACA,GAAG,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;AACtB,GAAG,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;AAC7B,GAAG,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC;AAC3B,GAAG,IAAI,CAAC,aAAa,GAAG,EAAE,CAAC;AAC3B,GAAG,IAAI,CAAC,eAAe,GAAG,CAAC,CAAC;AAC5B;AACA,GAAG;AACH;AACA,EAAE;AACF;AACA;;ACnCY,MAAC,WAAW,aAAa,CAAC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9NA,MAAM,iBAAiB,SAAS,YAAY,CAAC;AAC7C;AACA,CAAC,WAAW,GAAG;AACf;AACA,EAAE,KAAK,EAAE;AACT;AACA,GAAG,QAAQ,EAAE;AACb;AACA,IAAI,MAAM,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE;AAC3B,IAAI,IAAI,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE;AACtB;AACA,IAAI;AACJ;AACA,GAAG,YAAY,YAAY,CAAC;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,CAAC;AACJ;AACA,GAAG,cAAc,YAAY,CAAC;AAC9B;AACA;AACA;AACA;AACA,IAAI,GAAG,WAAW,EAAE;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,CAAC;AACJ;AACA,GAAG,EAAE,CAAC;AACN;AACA,EAAE;AACF;AACA,CAAC;AACD;AACO,MAAM,sBAAsB,CAAC;AACpC;AACA,CAAC,WAAW,EAAE,QAAQ,GAAG;AACzB;AACA,EAAE,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AAC3B,EAAE,IAAI,CAAC,cAAc,GAAG,IAAI,cAAc,EAAE,QAAQ,EAAE,CAAC;AACvD,EAAE,IAAI,CAAC,QAAQ,GAAG,IAAI,cAAc,EAAE,IAAI,iBAAiB,EAAE,EAAE,CAAC;AAChE,EAAE,IAAI,CAAC,YAAY,GAAG,IAAI,iBAAiB,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,IAAI,EAAE,SAAS,EAAE,MAAM,EAAE,UAAU,EAAE,EAAE,CAAC;AAC7F;AACA,EAAE;AACF;AACA,CAAC,OAAO,GAAG;AACX;AACA,EAAE,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,CAAC;AAChC,EAAE,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC;AAC1B,EAAE,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC;AAC9B;AACA,EAAE;AACF;AACA,CAAC,QAAQ,EAAE,OAAO,EAAE,IAAI,GAAG;AAC3B;AACA,EAAE,MAAM,EAAE,cAAc,EAAE,YAAY,EAAE,QAAQ,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;AACpE;AACA;AACA,EAAE,MAAM,WAAW,GAAG,cAAc,CAAC,mBAAmB,EAAE,OAAO,EAAE,CAAC;AACpE;AACA;AACA,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,OAAO,CAAC,KAAK,CAAC;AAC1C,EAAE,YAAY,CAAC,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,CAAC;AACxC,EAAE,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC;AACjD,EAAE,QAAQ,CAAC,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC;AAChC;AACA;AACA,EAAE,MAAM,gBAAgB,GAAG,QAAQ,CAAC,eAAe,EAAE,CAAC;AACtD,EAAE,MAAM,SAAS,GAAG,QAAQ,CAAC,SAAS,CAAC;AACvC;AACA,EAAE,QAAQ,CAAC,eAAe,EAAE,YAAY,EAAE,CAAC;AAC3C,EAAE,QAAQ,CAAC,SAAS,GAAG,IAAI,CAAC;AAC5B,EAAE,QAAQ,CAAC,MAAM,EAAE,QAAQ,EAAE,CAAC;AAC9B;AACA,EAAE,QAAQ,CAAC,eAAe,EAAE,gBAAgB,EAAE,CAAC;AAC/C,EAAE,QAAQ,CAAC,SAAS,GAAG,SAAS,CAAC;AACjC;AACA;AACA,EAAE,MAAM,MAAM,GAAG,IAAI,YAAY,EAAE,KAAK,GAAG,MAAM,GAAG,CAAC,EAAE,CAAC;AACxD,EAAE,QAAQ,CAAC,sBAAsB,EAAE,YAAY,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC;AAC/E;AACA,EAAE,MAAM,MAAM,GAAG,IAAI,WAAW,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,UAAU,EAAE,SAAS,EAAE,CAAC;AACjF,EAAE,MAAM,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;AACvC,EAAE,MAAM,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;AACvC,EAAE,MAAM,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;AAC/B,EAAE,MAAM,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;AAC/B,EAAE,MAAM,CAAC,OAAO,GAAG,gCAAgC,CAAC;AACpD,EAAE,MAAM,CAAC,WAAW,GAAG,IAAI,CAAC;AAC5B;AACA,EAAE,OAAO,MAAM,CAAC;AAChB;AACA,EAAE;AACF;AACA;;AChHY,MAAC,qBAAqB,cAAc,CAAC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGO,MAAM,kBAAkB,aAAa,CAAC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;ACxGW,MAAC,sBAAsB,aAAa,CAAC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,kBAAkB,EAAE;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxVO,MAAM,oBAAoB,aAAa,CAAC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,CAAC;AACJ;AACA,GAAG,EAAE,CAAC;AACN;AACA,EAAE,IAAI,CAAC,SAAS,EAAE,UAAU,EAAE,CAAC;AAC/B;AACA,EAAE;AACF;AACA;;AC9oBA;;;;"}